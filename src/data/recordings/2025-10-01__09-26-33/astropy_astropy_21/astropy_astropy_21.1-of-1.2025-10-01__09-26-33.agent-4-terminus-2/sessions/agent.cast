{"version": 2, "width": 160, "height": 40, "timestamp": 1762942234, "env": {"SHELL": "/bin/bash", "TERM": "screen"}}
[0.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[0.002, "i", "asciinema rec --stdin /logs/agent.cast\r"]
[0.004, "o", "asciinema rec --stdin /logs/agent.cast\r\n"]
[0.006, "o", "\u001b[?2004l\r\n\u001b[0;31masciinema: /logs/agent.cast already exists, aborting\u001b[0m\r\n\u001b[0;31masciinema: use --overwrite option if you want to overwrite existing recording\u001b[0m\r\n\u001b[0;31masciinema: use --append option if you want to append to existing recording\u001b[0m\r\n"]
[5.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[5.002, "i", "clear\r"]
[5.004, "o", "clear\r\n"]
[5.006, "o", "\u001b[?2004l\r\n\u001b[H\u001b[J\r\n"]
[10.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[10.002, "i", "ls -la\r"]
[10.004, "o", "ls -la\r\n"]
[10.006, "o", "\u001b[?2004l\r\ntotal 884\r\ndrwxr-xr-x 1 root root   4096 Oct  1 11:48 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root   4096 Sep 15 17:24 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root      0 Sep 13 19:37 .astropy-root\r\ndrwxr-xr-x 1 root root   4096 Sep 13 19:38 \u001b[01;34m.circleci\u001b[0m\r\ndrwxr-xr-x 1 root root   4096 Sep 13 19:38 \u001b[01;34m.devcontainer\u001b[0m\r\n-rw-r--r-- 1 root root   1125 Sep 13 19:37 .flake8\r\ndrwxr-xr-x 1 root root   4096 Sep 15 17:25 \u001b[01;34m.git\u001b[0m\r\n-rw-r--r-- 1 root root   1771 Sep 13 19:37 .git-blame-ignore-revs\r\n-rw-r--r-- 1 root root     74 Sep 13 19:37 .gitattributes\r\ndrwxr-xr-x 1 root root   4096 Sep 13 19:38 \u001b[01;34m.github\u001b[0m\r\n-rw-r--r-- 1 root root   1318 Sep 13 19:38 .gitignore\r\n-rw-r--r-- 1 root root  23173 Sep 13 19:38 .mailmap\r\n-rw-r--r-- 1 root root   4394 Sep 13 19:38 .pre-commit-config.yaml\r\n-rw-r--r-- 1 root root     76 Sep 13 19:37 .pycodestyle\r\ndrwxr-xr-x 1 root root   4096 Sep 13 19:38 \u001b[01;34m.pyinstaller\u001b[0m\r\n-rw-r--r-- 1 root root    597 Sep 13 19:37 .readthedocs.yaml\r\n-rw-r--r-- 1 root root  11870 Sep 13 19:38 .ruff.toml\r\n-rw-r--r-- 1 root root 611692 Sep 13 19:38 CHANGES.rst\r\n-rw-r--r-- 1 root root     66 Sep 13 19:37 CITATION\r\n-rw-r--r-- 1 root root  69267 Sep 13 19:37 CITATION.cff\r\n-rw-r--r-- 1 root root    139 Sep 13 19:37 CODE_OF_CONDUCT.md\r\n-rw-r--r-- 1 root root   9843 Sep 13 19:38 CONTRIBUTING.md\r\n-rw-r--r-- 1 root root    129 Sep 13 19:37 GOVERNANCE.md\r\n-rw-r--r-- 1 root root   1496 Sep 13 19:37 LICENSE.rst\r\n-rw-r--r-- 1 root root    178 Sep 13 19:37 MANIFEST.in\r\n-rw-r--r-- 1 root root   5324 Sep 13 19:38 README.rst\r\n-rw-r--r-- 1 root root   1154 Sep 13 19:38 SECURITY.md\r\ndrwxr-xr-x 1 root root   4096 Sep 15 14:29 \u001b[01;34mastropy\u001b[0m\r\ndrwxr-xr-x 5 root root   4096 Sep 13 19:40 \u001b[01;34mastropy-benchmarks\u001b[0m\r\ndrwxr-xr-x 2 root root   4096 Sep 15 14:27 \u001b[01;34mastropy.egg-info\u001b[0m\r\n-rw-r--r-- 1 root root    382 Sep 13 19:38 asv.ci.conf.json\r\ndrwxr-xr-x 1 root root   4096 Sep 13 19:38 \u001b[01;34mcextern\u001b[0m\r\n-rw-r--r-- 1 root root    244 Sep 13 19:37 codecov.yml\r\n-rw-r--r-- 1 root root   2671 Sep 13 19:38 conftest.py\r\ndrwxr-xr-x 1 root root   4096 Sep 13 19:38 \u001b[01;34mdocs\u001b[0m\r\ndrwxr-xr-x 4 root root   4096 Sep 13 19:38 \u001b[01;34mexamples\u001b[0m\r\ndrwxr-xr-x 1 root root   4096 Sep 13 19:38 \u001b[01;34mlicenses\u001b[0m\r\n-rw-r--r-- 1 root root  18581 Sep 13 19:38 pyproject.toml\r\n-rwxr-xr-x 1 root root   1895 Sep 13 19:38 \u001b[01;32msetup.py\u001b[0m\r\n-rw-r--r-- 1 root root   6841 Sep 13 19:38 tox.ini\r\n"]
[15.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[15.002, "i", "ls -la .asv\r"]
[15.004, "o", "ls -la .asv\r\n"]
[15.006, "o", "\u001b[?2004l\r\nls: cannot access '.asv': No such file or directory\r\n"]
[20.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[20.002, "i", "ls -la benchmarks\r"]
[20.004, "o", "ls -la benchmarks\r\n"]
[20.006, "o", "\u001b[?2004l\r\nls: cannot access 'benchmarks': No such file or directory\r\n"]
[25.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[25.002, "i", "ls -la asv.conf.json\r"]
[25.004, "o", "ls -la asv.conf.json\r\n"]
[25.006, "o", "\u001b[?2004l\r\nls: cannot access 'asv.conf.json': No such file or directory\r\n"]
[30.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[30.002, "i", "cat asv.conf.json\r"]
[30.004, "o", "cat asv.conf.json\r\n"]
[30.006, "o", "\u001b[?2004l\r\ncat: asv.conf.json: No such file or directory\r\n"]
[35.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[35.002, "i", "grep -R \"class units\" -n benchmarks || true\r"]
[35.004, "o", "grep -R \"class units\" -n benchmarks || true\r\n"]
[35.006, "o", "\u001b[?2004l\r\ngrep: benchmarks: No such file or directory\r\n"]
[40.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[40.002, "i", "grep -R \"TimeQuantity\" -n benchmarks || true\r"]
[40.004, "o", "grep -R \"TimeQuantity\" -n benchmarks || true\r\n"]
[40.006, "o", "\u001b[?2004l\r\ngrep: benchmarks: No such file or directory\r\n"]
[45.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[45.002, "i", "asv run --python=same --bench=\"units.time_quantity_init_small_list.*|units.time_quantity_creation_nocopy.*\" --quick\r"]
[45.004, "o", "asv run --python=same --bench=\"units.time_quantity_init_small_list.*|units.time_quantity_creation_nocopy.*\" --quick\r\n"]
[45.006, "o", "k\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;31mNo `asv.conf` file found for valid extensions: ['.json', '.jsonc'].\u001b[0m\r\n"]
[50.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[50.002, "i", "asv run --python=same --bench=\"units.time_quantity_times_unit.*|units.TimeQuantityOpLargeArraySameUnit.*\" --quick\r"]
[50.004, "o", "asv run --python=same --bench=\"units.time_quantity_times_unit.*|units.TimeQuantityOpLargeArraySameUnit.*\" --quick\r\n"]
[50.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;31mNo `asv.conf` file found for valid extensions: ['.json', '.jsonc'].\u001b[0m\r\n"]
[55.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[55.002, "i", "asv profile --python=same units.time_quantity_times_unit\r"]
[55.004, "o", "asv profile --python=same units.time_quantity_times_unit\r\n"]
[55.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;31mNo `asv.conf` file found for valid extensions: ['.json', '.jsonc'].\u001b[0m\r\n"]
[60.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[60.002, "i", "grep -R \"def .*quantity\" -n . || true\r"]
[60.004, "o", "grep -R \"def .*quantity\" -n . || true\r\n"]
[60.006, "o", "\u001b[?2004l\r\n\u001b[35m\u001b[K./astropy/stats/tests/test_funcs.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K130\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_median_absolute_deviation_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/constants/constant.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K180\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __quantity\u001b[m\u001b[K_subclass__(self, unit):\r\n\u001b[35m\u001b[K./astropy/uncertainty/tests/test_distribution.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K36\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_init(self):\r\n\u001b[35m\u001b[K./astropy/uncertainty/tests/test_distribution.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K45\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_init_T(self):\r\n\u001b[35m\u001b[K./astropy/uncertainty/tests/test_distribution.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K50\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_init_with_distribution(self):\r\n\u001b[35m\u001b[K./astropy/uncertainty/tests/test_distribution.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K205\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_add_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/uncertainty/tests/test_distribution.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K329\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_index_assignment_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/uncertainty/tests/test_distribution.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K425\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_distr_angle_view_as_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/uncertainty/tests/test_distribution.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K503\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_scalar_quantity\u001b[m\u001b[K_distribution():\r\n\u001b[35m\u001b[K./astropy/units/quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K694\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef _result_as_quantity\u001b[m\u001b[K(self, result, unit, out):\r\n\u001b[35m\u001b[K./astropy/units/quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K746\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __quantity\u001b[m\u001b[K_subclass__(self, unit):\r\n\u001b[35m\u001b[K./astropy/units/quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1285\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K_iter():\r\n\u001b[35m\u001b[K./astropy/units/quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2149\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __quantity\u001b[m\u001b[K_subclass__(self, unit):\r\n\u001b[35m\u001b[K./astropy/units/function/core.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K95\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef _quantity\u001b[m\u001b[K_class(self):\r\n\u001b[35m\u001b[K./astropy/units/function/core.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K631\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __quantity\u001b[m\u001b[K_subclass__(self, unit):\r\n\u001b[35m\u001b[K./astropy/units/function/logarithmic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K57\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef _quantity\u001b[m\u001b[K_class(self):\r\n\u001b[35m\u001b[K./astropy/units/function/logarithmic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K155\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef _quantity\u001b[m\u001b[K_class(self):\r\n\u001b[35m\u001b[K./astropy/units/function/logarithmic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K180\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef _quantity\u001b[m\u001b[K_class(self):\r\n\u001b[35m\u001b[K./astropy/units/function/logarithmic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K214\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef _quantity\u001b[m\u001b[K_class(self):\r\n\u001b[35m\u001b[K./astropy/units/utils.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K351\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K_asanyarray(a: Sequence[int]) -> NDArray[int]: ...\r\n\u001b[35m\u001b[K./astropy/units/utils.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K353\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K_asanyarray(a: Sequence[int], dtype: DType) -> NDArray[DType]: ...\r\n\u001b[35m\u001b[K./astropy/units/utils.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K355\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K_asanyarray(a: Sequence[Quantity]) -> Quantity: ...\r\n\u001b[35m\u001b[K./astropy/units/utils.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K356\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K_asanyarray(\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K245\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_non_quantity\u001b[m\u001b[K_with_unit(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K476\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_as_power(self, exponent_type):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K722\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_conversion():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K737\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_ilshift():  # in-place conversion\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K763\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_value_views():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K784\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_conversion_with_equiv():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K805\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_conversion_equivalency_passed_on():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K809\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kdef __quantity\u001b[m\u001b[K_view__(self, obj, unit):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K812\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kdef __quantity\u001b[m\u001b[K_instance__(self, *args, **kwargs):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K868\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_equality(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K881\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_equality_array(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K911\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_comparison(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K947\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_dimensionless_quantity\u001b[m\u001b[K_repr(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K954\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_dimensionless_quantity\u001b[m\u001b[K_str(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K961\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_dimensionless_quantity\u001b[m\u001b[K_format(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K966\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_scalar_quantity\u001b[m\u001b[K_str(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K970\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_scalar_quantity\u001b[m\u001b[K_repr(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K974\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_array_quantity\u001b[m\u001b[K_str(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K977\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_array_quantity\u001b[m\u001b[K_repr(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K980\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_scalar_quantity\u001b[m\u001b[K_format(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1554\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_inverse_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1573\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_mutability():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1583\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity_initialized_with_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1599\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_string_unit():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1608\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_invalid_unit_string():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1642\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_iterability():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1704\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_pickelability():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1718\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_initialisation_from_string():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1778\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_to_view():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1785\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_tuple_power():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1790\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_fraction_power():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1799\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_from_table():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1843\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_assign_slice_with_quantity\u001b[m\u001b[K_like():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1900\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_repr_array_of_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2038\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_masked_quantity\u001b[m\u001b[K_str_repr():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_array_methods.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K521\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_slice_to_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_typing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K14\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_typing(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_typing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K69\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_subclass_typing(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_logarithmic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K603\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_using_quantity\u001b[m\u001b[K_class(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_logarithmic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K630\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_decomposition():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_logarithmic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K658\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_view(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_ufuncs.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1061\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_ndarray_inplace_op_with_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_ufuncs.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1082\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_exception_with_where_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_ufuncs.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1144\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_clip_quantity\u001b[m\u001b[K_inplace(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_ufuncs.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1440\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kdef test_basic(self, ufunc, duck_quantity\u001b[m\u001b[K):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_ufuncs.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1453\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kdef test_full(self, ufunc, duck_quantity\u001b[m\u001b[K, out):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_ufuncs.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1473\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kdef test_basic(self, ufunc, quantity, duck_quantity\u001b[m\u001b[K):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_ufuncs.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1493\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kdef test_full(self, ufunc, quantity, duck_quantity\u001b[m\u001b[K, out):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_structured.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K706\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_initialization(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_structured.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K715\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_si(self):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_decorator.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K65\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_args_nonquantity\u001b[m\u001b[K(x_input):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_decorator.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K110\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_not_quantity\u001b[m\u001b[K(x_input, y_input):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_decorator.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K128\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_not_quantity\u001b[m\u001b[K_annotated(x_input, y_input):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_decorator.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K200\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_kwarg_not_quantity\u001b[m\u001b[K(x_input, y_input):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_decorator.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K466\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_annotated_not_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_physical.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K190\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_physical_type_cannot_become_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_annotations.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K136\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_args_nonquantity\u001b[m\u001b[K3(solarx_unit):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_annotations.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K187\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_not_quantity\u001b[m\u001b[K3(solarx_unit, solary_unit):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_quantity_annotations.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K290\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_kwarg_not_quantity\u001b[m\u001b[K3(solarx_unit, solary_unit):\r\n\u001b[35m\u001b[K./astropy/units/tests/test_utils.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K15\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_asanyarray():\r\n\u001b[35m\u001b[K./astropy/units/quantity_helper/function_helpers.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K341\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef _as_quantity\u001b[m\u001b[K(a):\r\n\u001b[35m\u001b[K./astropy/nddata/nduncertainty.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K211\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/nddata/tests/test_nduncertainty.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K117\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_init_fake_with_quantity\u001b[m\u001b[K(UncertClass):\r\n\u001b[35m\u001b[K./astropy/nddata/tests/test_nduncertainty.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K284\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K(UncertClass):\r\n\u001b[35m\u001b[K./astropy/nddata/tests/test_nddata.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K181\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_nddata_init_data_quantity\u001b[m\u001b[K(data):\r\n\u001b[35m\u001b[K./astropy/nddata/tests/test_nddata.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K204\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_nddata_init_data_masked_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/coordinates/spectral_coordinate.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K400\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/coordinates/spectral_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K75\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __quantity\u001b[m\u001b[K_subclass__(self, unit):\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_distance.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K161\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_distance_is_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_distance.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K302\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_distance_to_quantity\u001b[m\u001b[K_when_not_units_of_length():\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_angles.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K559\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_angle_to_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_angles.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K567\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_to_angle():\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_angles.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K967\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_mixed_string_and_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_spectral_coordinate.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K268\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_init_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_spectral_coordinate.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K278\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_init_spectral_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_spectral_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K18\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_init_quantity\u001b[m\u001b[K(self, unit):\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_spectral_quantity.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K22\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_init_spectralquantity\u001b[m\u001b[K(self, unit):\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_representation.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K140\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_init_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_representation.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K530\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_init_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_representation.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K705\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_init_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_representation.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K996\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_init_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_representation.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1263\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_init_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_frames.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1112\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_attributes():\r\n\u001b[35m\u001b[K./astropy/coordinates/tests/test_frames.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1125\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_attribute_default():\r\n\u001b[35m\u001b[K./astropy/table/column.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1088\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_column.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K151\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_init(self, Column):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_column.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K160\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_with_info_init(self, Column):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_column.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K173\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_comparison(self, Column):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_column.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K216\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_to_quantity\u001b[m\u001b[K(self, Column):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_column.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K266\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_to_funcunit_quantity\u001b[m\u001b[K(self, Column):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_mixin.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K126\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_votable_quantity\u001b[m\u001b[K_write(tmp_path):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_mixin.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K746\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_representation():\r\n\u001b[35m\u001b[K./astropy/table/tests/test_init_table.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K608\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_init_Table_from_list_of_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/table/tests/test_masked.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K600\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_masked_quantity\u001b[m\u001b[K_in_table():\r\n\u001b[35m\u001b[K./astropy/table/tests/test_operations.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K805\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_join_with_join_distance_1d_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_operations.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2348\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_join_mixins_time_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/table/tests/test_table.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K153\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_set_new_col_new_table_quantity\u001b[m\u001b[K(self, table_types):\r\n\u001b[35m\u001b[K./astropy/table/tests/test_table.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K943\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_inserting_quantity\u001b[m\u001b[K_row_in_empty_table(\r\n\u001b[35m\u001b[K./astropy/time/utils.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K79\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K_day_frac(val1, val2=None):\r\n\u001b[35m\u001b[K./astropy/time/formats.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K639\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef _check_val_type_not_quantity\u001b[m\u001b[K(format_name, val1, val2):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_basic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1519\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_decimalyear_no_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_basic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2869\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_timedelta_empty_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_comparisons.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K153\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_isclose_timedelta(swap, time_delta, other_quantity\u001b[m\u001b[K):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_comparisons.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K167\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef isclose_other_quantity\u001b[m\u001b[K(t1, t2, **kwargs):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K103\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_time_delta_comp_num_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K117\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_time_delta_comp_nan_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K751\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_basic(sign, in_str, out_val, dt_sec):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K760\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_precision():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K796\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_invalid(in_str):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K812\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_out_subfmt():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K818\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_out_subfmt_precision():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K823\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_out_subfmt_to_value_subfmt():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K829\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity_str_out_subfmt_from_non_quantity\u001b[m\u001b[K_str():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K835\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_internal_precision():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K849\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_val_type_error():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K854\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_zero_value():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_delta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K860\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_str_multi_comps_overflow():\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K19\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_valid_quantity\u001b[m\u001b[K_input(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K51\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_invalid_quantity\u001b[m\u001b[K_input(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K72\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_no_quantity\u001b[m\u001b[K_input_allowed(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K79\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_valid_quantity\u001b[m\u001b[K_operations(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K95\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_invalid_quantity\u001b[m\u001b[K_operations(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K107\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_valid_quantity\u001b[m\u001b[K_input(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K117\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_invalid_quantity\u001b[m\u001b[K_input(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K127\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_output(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K139\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_output_errors(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K160\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_valid_quantity\u001b[m\u001b[K_operations1(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K182\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_valid_quantity\u001b[m\u001b[K_operations2(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K220\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_valid_quantity\u001b[m\u001b[K_operations3(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K267\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_invalid_quantity\u001b[m\u001b[K_operations(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K272\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_invalid_quantity\u001b[m\u001b[K_operations2(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K280\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_invalid_quantity\u001b[m\u001b[K_broadcast(self):\r\n\u001b[35m\u001b[K./astropy/time/tests/test_quantity_interaction.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K326\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_conversion_rounding(q1, q2):\r\n\u001b[35m\u001b[K./astropy/io/misc/yaml.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K166\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef _quantity\u001b[m\u001b[K_representer(tag):\r\n\u001b[35m\u001b[K./astropy/io/misc/yaml.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K174\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef _quantity\u001b[m\u001b[K_constructor(cls):\r\n\u001b[35m\u001b[K./astropy/modeling/core.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K896\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef uses_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/modeling/parameters.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K441\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/modeling/parameters.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K450\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef quantity(self, quantity\u001b[m\u001b[K):\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_model.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K41\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_call():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_model.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K57\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_no_quantity\u001b[m\u001b[K_call():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_model.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K74\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_uses_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_model.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K91\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_uses_quantity\u001b[m\u001b[K_compound():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_model.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K108\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_uses_quantity\u001b[m\u001b[K_no_param():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_parameters.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K32\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_parameter_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_parameters.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K46\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_parameter_set_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_parameters.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K162\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_parameter_quantity\u001b[m\u001b[K_property():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_parameters.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K253\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_parameter_quantity\u001b[m\u001b[K_arithmetic():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_quantities_parameters.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K288\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_parameter_quantity\u001b[m\u001b[K_comparison():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_rotations.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K99\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_Rotation2D_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_parameters.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K505\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K(self):\r\n\u001b[35m\u001b[K./astropy/modeling/tests/test_core.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K338\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kdef model2(x, y, n_outputs=2, uses_quantity\u001b[m\u001b[K=True):\r\n\u001b[35m\u001b[K./astropy/convolution/tests/test_convolve_kernels.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K155\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_gaussian_2d_kernel_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy/convolution/tests/test_convolve_fft.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K98\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K(self, boundary, nan_treatment, normalize_kernel, dealias):\r\n\u001b[35m\u001b[K./astropy/convolution/tests/test_convolve.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K69\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K(\r\n\u001b[35m\u001b[K./astropy/tests/helper.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K192\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef assert_quantity\u001b[m\u001b[K_allclose(actual, desired, rtol=1.0e-7, atol=None, **kwargs):\r\n\u001b[35m\u001b[K./astropy/tests/tests/test_quantity_helpers.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K7\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_assert_quantity\u001b[m\u001b[K_allclose():\r\n\u001b[35m\u001b[K./astropy/visualization/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K9\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef quantity\u001b[m\u001b[K_support(format=\"latex_inline\"):\r\n\u001b[35m\u001b[K./astropy/visualization/tests/test_units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K71\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef test_quantity\u001b[m\u001b[K_subclass():\r\n\u001b[35m\u001b[K./astropy/utils/masked/tests/test_masked.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K314\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_masked_quantity\u001b[m\u001b[K_getting(self):\r\n\u001b[35m\u001b[K./astropy/utils/masked/tests/test_masked.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K326\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_masked_quantity\u001b[m\u001b[K_class_init(self):\r\n\u001b[35m\u001b[K./astropy/utils/masked/tests/test_masked.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K351\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_initialization_with_list_of_masked_quantity\u001b[m\u001b[K_scalars(self):\r\n\u001b[35m\u001b[K./astropy/utils/masked/tests/test_masked.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K357\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_initialization_with_list_of_masked_quantity\u001b[m\u001b[K_arrays(self):\r\n\u001b[35m\u001b[K./astropy/utils/masked/tests/test_functions.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K344\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef test_ufunc_inplace_quantity\u001b[m\u001b[K_initial(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/coordinates.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K197\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_init_quantity\u001b[m\u001b[K_scalar_positional(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/coordinates.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K200\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_init_quantity\u001b[m\u001b[K_array_positional(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/coordinates.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K203\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_init_quantity\u001b[m\u001b[K_scalar_positional_fk5_kwarg(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/coordinates.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K206\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_init_quantity\u001b[m\u001b[K_scalar_positional_fk5_frame(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/coordinates.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K209\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_init_quantity\u001b[m\u001b[K_scalar_positional_fk5_frame_extra_kwargs(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/coordinates.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K212\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_init_quantity\u001b[m\u001b[K_scalar_keyword(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/coordinates.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K215\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_init_quantity\u001b[m\u001b[K_array_keyword(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K54\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_creation():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K58\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_creation_nocopy():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K62\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_view():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K66\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_init_scalar():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K70\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_init_array():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K74\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_init_small_list():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K82\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_init_small_array():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K90\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_scalar_conversion():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K94\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_array_conversion():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K98\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_times_unit():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K102\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity_times_quantity\u001b[m\u001b[K():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K106\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_ufunc_sin():\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K122\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_square(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K125\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_square(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K128\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_square_out(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K131\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_sqrt(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K134\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_sqrt(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K137\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_sqrt_out(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K166\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_equal(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K170\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_equal(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K173\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_truediv(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K178\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_truediv(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K181\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_mul(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K185\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_multiply(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K188\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_sub(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K192\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_subtract(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K195\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_add(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K199\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef time_quantity\u001b[m\u001b[K_np_add(self):\r\n\u001b[35m\u001b[K./astropy-benchmarks/benchmarks/imports.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K173\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kdef timeraw_import_astropy_units_quantity\u001b[m\u001b[K():\r\n"]
[65.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[65.002, "i", "grep -R \"units\" -n src tests || true\r"]
[65.004, "o", "grep -R \"units\" -n src tests || true\r\n"]
[65.006, "o", "\u001b[?2004l\r\ngrep: src: No such file or directory\r\ngrep: tests: No such file or directory\r\n"]
[70.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[70.002, "i", "cat asv.ci.conf.json\r"]
[70.004, "o", "cat asv.ci.conf.json\r\n"]
[70.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[75.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[75.002, "i", "asv run -c asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list.*|units.time_quantity_creati\r"]
[75.004, "o", "asv run -c asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list.*|units.time_quantity_creati\r\n"]
[75.006, "o", "ion_nocopy.*|units.time_quantity_init_small_array.*|units.time_quantity_times_unit.*|units.time_quantity_array_conversion.*|units.time_quantity_view.*\" --quick\r\n\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[80.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[80.002, "i", "asv profile --python=same -c asv.ci.conf.json units.time_quantity_times_unit\r"]
[80.004, "o", "asv profile --python=same -c asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[80.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[85.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[85.002, "i", "sed -n '1,260p' astropy/units/quantity.py\r"]
[85.004, "o", "sed -n '1,260p' astropy/units/quantity.py\r\n"]
[85.006, "o", "\u001b[?2004l\r\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\r\n\"\"\"\r\nThis module defines the `Quantity` object, which represents a number with some\r\nassociated units. `Quantity` objects support operations like ordinary numbers,\r\nbut will deal with unit conversions internally.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport builtins\r\nimport numbers\r\nimport operator\r\nimport re\r\nimport warnings\r\nfrom fractions import Fraction\r\nfrom typing import TYPE_CHECKING\r\n\r\nimport numpy as np\r\n\r\nfrom astropy import config as _config\r\nfrom astropy.utils.compat.numpycompat import COPY_IF_NEEDED, NUMPY_LT_2_0\r\nfrom astropy.utils.data_info import ParentDtypeInfo\r\nfrom astropy.utils.exceptions import AstropyWarning\r\n\r\nfrom .core import (\r\n    Unit,\r\n    UnitBase,\r\n    UnitConversionError,\r\n    UnitsError,\r\n    UnitTypeError,\r\n    dimensionless_unscaled,\r\n    get_current_unit_registry,\r\n)\r\nfrom .format import Base, Latex\r\nfrom .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\r\nfrom .quantity_helper.function_helpers import (\r\n    DISPATCHED_FUNCTIONS,\r\n    FUNCTION_HELPERS,\r\n    SUBCLASS_SAFE_FUNCTIONS,\r\n    UNSUPPORTED_FUNCTIONS,\r\n)\r\nfrom .structured import StructuredUnit, _structured_unit_like_dtype\r\nfrom .utils import is_effectively_unity\r\n\r\nif TYPE_CHECKING:\r\n    from typing_extensions import Self\r\n\r\n    from .typing import QuantityLike\r\n\r\n__all__ = [\r\n    \"Quantity\",\r\n    \"SpecificTypeQuantity\",\r\n    \"QuantityInfoBase\",\r\n    \"QuantityInfo\",\r\n    \"allclose\",\r\n    \"isclose\",\r\n]\r\n\r\n\r\n# We don't want to run doctests in the docstrings we inherit from Numpy\r\n__doctest_skip__ = [\"Quantity.*\"]\r\n\r\n_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\r\n_UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\r\n\r\n\r\nclass Conf(_config.ConfigNamespace):\r\n    \"\"\"\r\n    Configuration parameters for Quantity.\r\n    \"\"\"\r\n\r\n    latex_array_threshold = _config.ConfigItem(\r\n        100,\r\n        \"The maximum size an array Quantity can be before its LaTeX \"\r\n        'representation for IPython gets \"summarized\" (meaning only the first '\r\n        'and last few elements are shown with \"...\" between). Setting this to a '\r\n        \"negative number means that the value will instead be whatever numpy \"\r\n        \"gets from get_printoptions.\",\r\n    )\r\n\r\n\r\nconf = Conf()\r\n\r\n\r\nclass QuantityIterator:\r\n    \"\"\"\r\n    Flat iterator object to iterate over Quantities.\r\n\r\n    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\r\n    ``q``.  It allows iterating over the array as if it were a 1-D array,\r\n    either in a for-loop or by calling its `next` method.\r\n\r\n    Iteration is done in C-contiguous style, with the last index varying the\r\n    fastest. The iterator can also be indexed using basic slicing or\r\n    advanced indexing.\r\n\r\n    See Also\r\n    --------\r\n    Quantity.flatten : Returns a flattened copy of an array.\r\n\r\n    Notes\r\n    -----\r\n    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\r\n    is not exported by the `~astropy.units` module.  Instead of\r\n    instantiating a `QuantityIterator` directly, use `Quantity.flat`.\r\n    \"\"\"\r\n\r\n    def __init__(self, q):\r\n        self._quantity = q\r\n        self._dataiter = q.view(np.ndarray).flat\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __getitem__(self, indx):\r\n        out = self._dataiter.__getitem__(indx)\r\n        # For single elements, ndarray.flat.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if isinstance(out, type(self._quantity)):\r\n            return out\r\n        else:\r\n            return self._quantity._new_view(out)\r\n\r\n    def __setitem__(self, index, value):\r\n        self._dataiter[index] = self._quantity._to_own_unit(value)\r\n\r\n    def __next__(self):\r\n        \"\"\"\r\n        Return the next value, or raise StopIteration.\r\n        \"\"\"\r\n        out = next(self._dataiter)\r\n        # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\r\n        return self._quantity._new_view(out)\r\n\r\n    next = __next__\r\n\r\n    def __len__(self):\r\n        return len(self._dataiter)\r\n\r\n    # Properties and methods to match `numpy.ndarray.flatiter`\r\n\r\n    @property\r\n    def base(self):\r\n        \"\"\"A reference to the array that is iterated over.\"\"\"\r\n        return self._quantity\r\n\r\n    @property\r\n    def coords(self):\r\n        \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\r\n        return self._dataiter.coords\r\n\r\n    @property\r\n    def index(self):\r\n        \"\"\"Current flat index into the array.\"\"\"\r\n        return self._dataiter.index\r\n\r\n    def copy(self):\r\n        \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\r\n        return self._quantity.flatten()\r\n\r\n\r\nclass QuantityInfoBase(ParentDtypeInfo):\r\n    # This is on a base class rather than QuantityInfo directly, so that\r\n    # it can be used for EarthLocationInfo yet make clear that that class\r\n    # should not be considered a typical Quantity subclass by Table.\r\n    attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\r\n    _supports_indexing = True\r\n\r\n    @staticmethod\r\n    def default_format(val):\r\n        return f\"{val.value}\"\r\n\r\n    @staticmethod\r\n    def possible_string_format_functions(format_):\r\n        \"\"\"Iterate through possible string-derived format functions.\r\n\r\n        A string can either be a format specifier for the format built-in,\r\n        a new-style format string, or an old-style format string.\r\n\r\n        This method is overridden in order to suppress printing the unit\r\n        in each row since it is already at the top in the column header.\r\n        \"\"\"\r\n        yield lambda format_, val: format(val.value, format_)\r\n        yield lambda format_, val: format_.format(val.value)\r\n        yield lambda format_, val: format_ % val.value\r\n\r\n\r\nclass QuantityInfo(QuantityInfoBase):\r\n    \"\"\"\r\n    Container for meta information like name, description, format.  This is\r\n    required when the object is used as a mixin column within a table, but can\r\n    be used as a general way to store meta information.\r\n    \"\"\"\r\n\r\n    _represent_as_dict_attrs = (\"value\", \"unit\")\r\n    _construct_from_dict_args = [\"value\"]\r\n    _represent_as_dict_primary_data = \"value\"\r\n\r\n    def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\r\n        \"\"\"\r\n        Return a new Quantity instance which is consistent with the\r\n        input ``cols`` and has ``length`` rows.\r\n\r\n        This is intended for creating an empty column object whose elements can\r\n        be set in-place for table operations like join or vstack.\r\n\r\n        Parameters\r\n        ----------\r\n        cols : list\r\n            List of input columns\r\n        length : int\r\n            Length of the output column object\r\n        metadata_conflicts : str ('warn'|'error'|'silent')\r\n            How to handle metadata conflicts\r\n        name : str\r\n            Output column name\r\n\r\n        Returns\r\n        -------\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n            Empty instance of this class consistent with ``cols``\r\n\r\n        \"\"\"\r\n        # Get merged info attributes like shape, dtype, format, description, etc.\r\n        attrs = self.merge_cols_attributes(\r\n            cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\r\n        )\r\n\r\n        # Make an empty quantity using the unit of the last one.\r\n        shape = (length,) + attrs.pop(\"shape\")\r\n        dtype = attrs.pop(\"dtype\")\r\n        # Use zeros so we do not get problems for Quantity subclasses such\r\n        # as Longitude and Latitude, which cannot take arbitrary values.\r\n        data = np.zeros(shape=shape, dtype=dtype)\r\n        # Get arguments needed to reconstruct class\r\n        map = {\r\n            key: (data if key == \"value\" else getattr(cols[-1], key))\r\n            for key in self._represent_as_dict_attrs\r\n        }\r\n        map[\"copy\"] = COPY_IF_NEEDED\r\n        out = self._construct_from_dict(map)\r\n\r\n        # Set remaining info attributes\r\n        for attr, value in attrs.items():\r\n            setattr(out.info, attr, value)\r\n\r\n        return out\r\n\r\n    def get_sortable_arrays(self):\r\n        \"\"\"\r\n        Return a list of arrays which can be lexically sorted to represent\r\n        the order of the parent column.\r\n\r\n        For Quantity this is just the quantity itself.\r\n\r\n\r\n        Returns\r\n        -------\r\n        arrays : list of ndarray\r\n        \"\"\"\r\n"]
[90.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[90.002, "i", "sed -n '260,800p' astropy/units/quantity.py\r"]
[90.004, "o", "sed -n '260,800p' astropy/units/quantity.py\r\n"]
[90.006, "o", "\u001b[?2004l\r\n        \"\"\"\r\n        return [self._parent]\r\n\r\n\r\nclass Quantity(np.ndarray):\r\n    \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\r\n\r\n    See also: https://docs.astropy.org/en/stable/units/quantity.html\r\n\r\n    Parameters\r\n    ----------\r\n    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\r\n        The numerical value of this quantity in the units given by unit.  If a\r\n        `Quantity` or sequence of them (or any other valid object with a\r\n        ``unit`` attribute), creates a new `Quantity` object, converting to\r\n        `unit` units as needed.  If a string, it is converted to a number or\r\n        `Quantity`, depending on whether a unit is present.\r\n\r\n    unit : unit-like\r\n        An object that represents the unit associated with the input value.\r\n        Must be an `~astropy.units.UnitBase` object or a string parseable by\r\n        the :mod:`~astropy.units` package.\r\n\r\n    dtype : ~numpy.dtype, optional\r\n        The dtype of the resulting Numpy array or scalar that will\r\n        hold the value.  If not provided, it is determined from the input,\r\n        except that any integer and (non-Quantity) object inputs are converted\r\n        to float by default.\r\n        If `None`, the normal `numpy.dtype` introspection is used, e.g.\r\n        preventing upcasting of integers.\r\n\r\n    copy : bool, optional\r\n        If `True` (default), then the value is copied.  Otherwise, a copy will\r\n        only be made if ``__array__`` returns a copy, if value is a nested\r\n        sequence, or if a copy is needed to satisfy an explicitly given\r\n        ``dtype``.  (The `False` option is intended mostly for internal use,\r\n        to speed up initialization where a copy is known to have been made.\r\n        Use with care.)\r\n\r\n    order : {'C', 'F', 'A'}, optional\r\n        Specify the order of the array.  As in `~numpy.array`.  This parameter\r\n        is ignored if the input is a `Quantity` and ``copy=False``.\r\n\r\n    subok : bool, optional\r\n        If `False` (default), the returned array will be forced to be a\r\n        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\r\n        or a subclass appropriate for the unit will be used (such as\r\n        `~astropy.units.Dex` for ``u.dex(u.AA)``).\r\n\r\n    ndmin : int, optional\r\n        Specifies the minimum number of dimensions that the resulting array\r\n        should have.  Ones will be prepended to the shape as needed to meet\r\n        this requirement.  This parameter is ignored if the input is a\r\n        `Quantity` and ``copy=False``.\r\n\r\n    Raises\r\n    ------\r\n    TypeError\r\n        If the value provided is not a Python numeric type.\r\n    TypeError\r\n        If the unit provided is not either a :class:`~astropy.units.Unit`\r\n        object or a parseable string unit.\r\n\r\n    Notes\r\n    -----\r\n    Quantities can also be created by multiplying a number or array with a\r\n    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\r\n\r\n    Unless the ``dtype`` argument is explicitly specified, integer\r\n    or (non-Quantity) object inputs are converted to `float` by default.\r\n    \"\"\"\r\n\r\n    # Need to set a class-level default for _equivalencies, or\r\n    # Constants can not initialize properly\r\n    _equivalencies = []\r\n\r\n    # Default unit for initialization; can be overridden by subclasses,\r\n    # possibly to `None` to indicate there is no default unit.\r\n    _default_unit = dimensionless_unscaled\r\n\r\n    # Ensures views have an undefined unit.\r\n    _unit = None\r\n\r\n    __array_priority__ = 10000\r\n\r\n    def __class_getitem__(cls, unit_shape_dtype):\r\n        \"\"\"Quantity Type Hints.\r\n\r\n        Unit-aware type hints are ``Annotated`` objects that encode the class,\r\n        the unit, and possibly shape and dtype information, depending on the\r\n        python and :mod:`numpy` versions.\r\n\r\n        Schematically, ``Annotated[cls[shape, dtype], unit]``\r\n\r\n        As a classmethod, the type is the class, ie ``Quantity``\r\n        produces an ``Annotated[Quantity, ...]`` while a subclass\r\n        like :class:`~astropy.coordinates.Angle` returns\r\n        ``Annotated[Angle, ...]``.\r\n\r\n        Parameters\r\n        ----------\r\n        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\r\n            Unit specification, can be the physical type (ie str or class).\r\n            If tuple, then the first element is the unit specification\r\n            and all other elements are for `numpy.ndarray` type annotations.\r\n            Whether they are included depends on the python and :mod:`numpy`\r\n            versions.\r\n\r\n        Returns\r\n        -------\r\n        `typing.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\r\n            Return type in this preference order:\r\n            * `typing.Annotated`\r\n            * `astropy.units.Unit` or `astropy.units.PhysicalType`\r\n\r\n        Raises\r\n        ------\r\n        TypeError\r\n            If the unit/physical_type annotation is not Unit-like or\r\n            PhysicalType-like.\r\n\r\n        Examples\r\n        --------\r\n        Create a unit-aware Quantity type annotation\r\n\r\n            >>> Quantity[Unit(\"s\")]\r\n            Annotated[Quantity, Unit(\"s\")]\r\n\r\n        See Also\r\n        --------\r\n        `~astropy.units.quantity_input`\r\n            Use annotations for unit checks on function arguments and results.\r\n\r\n        Notes\r\n        -----\r\n        |Quantity| types are also static-type compatible.\r\n        \"\"\"\r\n        from typing import Annotated\r\n\r\n        # process whether [unit] or [unit, shape, ptype]\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n            target = unit_shape_dtype[0]\r\n            shape_dtype = unit_shape_dtype[1:]\r\n        else:  # just unit\r\n            target = unit_shape_dtype\r\n            shape_dtype = ()\r\n\r\n        # Allowed unit/physical types. Errors if neither.\r\n        try:\r\n            unit = Unit(target)\r\n        except (TypeError, ValueError):\r\n            from astropy.units.physical import get_physical_type\r\n\r\n            try:\r\n                unit = get_physical_type(target)\r\n            except (TypeError, ValueError, KeyError):  # KeyError for Enum\r\n                raise TypeError(\r\n                    \"unit annotation is not a Unit or PhysicalType\"\r\n                ) from None\r\n\r\n        # Quantity does not (yet) properly extend the NumPy generics types,\r\n        # introduced in numpy v1.22+, instead just including the unit info as\r\n        # metadata using Annotated.\r\n        # TODO: ensure we do interact with NDArray.__class_getitem__.\r\n        return Annotated[cls, unit]\r\n\r\n    def __new__(\r\n        cls: type[Self],\r\n        value: QuantityLike,\r\n        unit=None,\r\n        dtype=np.inexact,\r\n        copy=True,\r\n        order=None,\r\n        subok=False,\r\n        ndmin=0,\r\n    ) -> Self:\r\n        if unit is not None:\r\n            # convert unit first, to avoid multiple string->unit conversions\r\n            unit = Unit(unit)\r\n\r\n        # inexact -> upcast to float dtype\r\n        float_default = dtype is np.inexact\r\n        if float_default:\r\n            dtype = None\r\n\r\n        # optimize speed for Quantity with no dtype given, copy=COPY_IF_NEEDED\r\n        if isinstance(value, Quantity):\r\n            if unit is not None and unit is not value.unit:\r\n                value = value.to(unit)\r\n                # the above already makes a copy (with float dtype)\r\n                copy = COPY_IF_NEEDED\r\n\r\n            if type(value) is not cls and not (subok and isinstance(value, cls)):\r\n                value = value.view(cls)\r\n\r\n            if float_default and value.dtype.kind in \"iu\":\r\n                dtype = float\r\n\r\n            return np.array(\r\n                value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n            )\r\n\r\n        # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\r\n        # To ensure array remains fast, we short-circuit it.\r\n        value_unit = None\r\n        if not isinstance(value, np.ndarray):\r\n            if isinstance(value, str):\r\n                # The first part of the regex string matches any integer/float;\r\n                # the second parts adds possible trailing .+-, which will break\r\n                # the float function below and ensure things like 1.2.3deg\r\n                # will not work.\r\n                pattern = (\r\n                    r\"\\s*[+-]?\"\r\n                    r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\r\n                    r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\r\n                    r\"([eE][+-]?\\d+)?\"\r\n                    r\"[.+-]?\"\r\n                )\r\n\r\n                v = re.match(pattern, value)\r\n                unit_string = None\r\n                try:\r\n                    value = float(v.group())\r\n\r\n                except Exception:\r\n                    raise TypeError(\r\n                        f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\r\n                        \"start with a number.\"\r\n                    )\r\n\r\n                unit_string = v.string[v.end() :].strip()\r\n                if unit_string:\r\n                    value_unit = Unit(unit_string)\r\n                    if unit is None:\r\n                        unit = value_unit  # signal no conversion needed below.\r\n\r\n            elif isinstance(value, (list, tuple)) and len(value) > 0:\r\n                if all(isinstance(v, Quantity) for v in value):\r\n                    # If a list/tuple contains only quantities, stack them,\r\n                    # which also converts them to the same unit.\r\n                    value = np.stack(value)\r\n                    copy = False\r\n\r\n                elif (\r\n                    dtype is None\r\n                    and not hasattr(value, \"dtype\")\r\n                    and isinstance(unit, StructuredUnit)\r\n                ):\r\n                    # Special case for list/tuple of values and a structured unit:\r\n                    # ``np.array(value, dtype=None)`` would treat tuples as lower\r\n                    # levels of the array, rather than as elements of a structured\r\n                    # array, so we use the structure of the unit to help infer the\r\n                    # structured dtype of the value.\r\n                    dtype = unit._recursively_get_dtype(value)\r\n\r\n        using_default_unit = False\r\n        if value_unit is None:\r\n            # If the value has a `unit` attribute and if not None\r\n            # (for Columns with uninitialized unit), treat it like a quantity.\r\n            value_unit = getattr(value, \"unit\", None)\r\n            if value_unit is None:\r\n                # Default to dimensionless for no (initialized) unit attribute.\r\n                if unit is None:\r\n                    using_default_unit = True\r\n                    unit = cls._default_unit\r\n                value_unit = unit  # signal below that no conversion is needed\r\n            else:\r\n                try:\r\n                    value_unit = Unit(value_unit)\r\n                except Exception as exc:\r\n                    raise TypeError(\r\n                        f\"The unit attribute {value.unit!r} of the input could \"\r\n                        \"not be parsed as an astropy Unit.\"\r\n                    ) from exc\r\n\r\n                if unit is None:\r\n                    unit = value_unit\r\n                elif unit is not value_unit:\r\n                    copy = COPY_IF_NEEDED  # copy will be made in conversion at end\r\n\r\n        value = np.array(\r\n            value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n        )\r\n\r\n        # For no-user-input unit, make sure the constructed unit matches the\r\n        # structure of the data.\r\n        if using_default_unit and value.dtype.names is not None:\r\n            unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\r\n\r\n        # check that array contains numbers or long int objects\r\n        if value.dtype.kind in \"OSU\" and not (\r\n            value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\r\n        ):\r\n            raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\r\n\r\n        # by default, cast any integer, boolean, etc., to float\r\n        if float_default and value.dtype.kind in \"iuO\":\r\n            value = value.astype(float)\r\n\r\n        # if we allow subclasses, allow a class from the unit.\r\n        if subok:\r\n            qcls = getattr(unit, \"_quantity_class\", cls)\r\n            if issubclass(qcls, cls):\r\n                cls = qcls\r\n\r\n        value = value.view(cls)\r\n        value._set_unit(value_unit)\r\n        if unit is value_unit:\r\n            return value\r\n        else:\r\n            # here we had non-Quantity input that had a \"unit\" attribute\r\n            # with a unit different from the desired one.  So, convert.\r\n            return value.to(unit)\r\n\r\n    def __array_finalize__(self, obj):\r\n        # Check whether super().__array_finalize should be called\r\n        # (sadly, ndarray.__array_finalize__ is None; we cannot be sure\r\n        # what is above us).\r\n        super_array_finalize = super().__array_finalize__\r\n        if super_array_finalize is not None:\r\n            super_array_finalize(obj)\r\n\r\n        # If we're a new object or viewing an ndarray, nothing has to be done.\r\n        if obj is None or obj.__class__ is np.ndarray:\r\n            return\r\n\r\n        # Copy over the unit and possibly info.  Note that the only way the\r\n        # unit can already be set is if one enters via _new_view(), where the\r\n        # unit is often different from that of self, and where propagation of\r\n        # info is not always desirable.\r\n        if self._unit is None:\r\n            unit = getattr(obj, \"_unit\", None)\r\n            if unit is not None:\r\n                self._set_unit(unit)\r\n\r\n            # Copy info if the original had `info` defined.  Because of the way the\r\n            # DataInfo works, `'info' in obj.__dict__` is False until the\r\n            # `info` attribute is accessed or set.\r\n            if \"info\" in obj.__dict__:\r\n                self.info = obj.info\r\n\r\n    def __array_wrap__(self, obj, context=None, return_scalar=False):\r\n        if context is None:\r\n            # Methods like .squeeze() created a new `ndarray` and then call\r\n            # __array_wrap__ to turn the array into self's subclass.\r\n            return self._new_view(obj)\r\n\r\n        raise NotImplementedError(\r\n            \"__array_wrap__ should not be used with a context any more since all \"\r\n            \"use should go through array_function. Please raise an issue on \"\r\n            \"https://github.com/astropy/astropy\"\r\n        )\r\n\r\n    def __array_ufunc__(self, function, method, *inputs, **kwargs):\r\n        \"\"\"Wrap numpy ufuncs, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            ufunc to wrap.\r\n        method : str\r\n            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\r\n        inputs : tuple\r\n            Input arrays.\r\n        kwargs : keyword arguments\r\n            As passed on, with ``out`` containing possible quantity output.\r\n\r\n        Returns\r\n        -------\r\n        result : `~astropy.units.Quantity` or `NotImplemented`\r\n            Results of the ufunc, with the unit set properly.\r\n        \"\"\"\r\n        # Determine required conversion functions -- to bring the unit of the\r\n        # input to that expected (e.g., radian for np.sin), or to get\r\n        # consistent units between two inputs (e.g., in np.add) --\r\n        # and the unit of the result (or tuple of units for nout > 1).\r\n        try:\r\n            converters, unit = converters_and_unit(function, method, *inputs)\r\n\r\n            out = kwargs.get(\"out\", None)\r\n            # Avoid loop back by turning any Quantity output into array views.\r\n            if out is not None:\r\n                # If pre-allocated output is used, check it is suitable.\r\n                # This also returns array view, to ensure we don't loop back.\r\n                if function.nout == 1:\r\n                    out = out[0]\r\n                out_array = check_output(out, unit, inputs, function=function)\r\n                # Ensure output argument remains a tuple.\r\n                kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\r\n\r\n            if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\r\n                # Special-case for initial argument for reductions like\r\n                # np.add.reduce.  This should be converted to the output unit as\r\n                # well, which is typically the same as the input unit (but can\r\n                # in principle be different: unitless for np.equal, radian\r\n                # for np.arctan2, though those are not necessarily useful!)\r\n                kwargs[\"initial\"] = self._to_own_unit(\r\n                    kwargs[\"initial\"], check_precision=False, unit=unit\r\n                )\r\n\r\n            # Same for inputs, but here also convert if necessary.\r\n            arrays = []\r\n            for input_, converter in zip(inputs, converters):\r\n                input_ = getattr(input_, \"value\", input_)\r\n                arrays.append(converter(input_) if converter else input_)\r\n\r\n            # Call our superclass's __array_ufunc__\r\n            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\r\n            # If unit is None, a plain array is expected (e.g., comparisons), which\r\n            # means we're done.\r\n            # We're also done if the result was None (for method 'at') or\r\n            # NotImplemented, which can happen if other inputs/outputs override\r\n            # __array_ufunc__; hopefully, they can then deal with us.\r\n            if unit is None or result is None or result is NotImplemented:\r\n                return result\r\n\r\n            return self._result_as_quantity(result, unit, out)\r\n\r\n        except (TypeError, ValueError, AttributeError) as e:\r\n            out_normalized = kwargs.get(\"out\", ())\r\n            inputs_and_outputs = inputs + out_normalized\r\n            ignored_ufunc = (\r\n                None,\r\n                np.ndarray.__array_ufunc__,\r\n                type(self).__array_ufunc__,\r\n            )\r\n            if not all(\r\n                getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\r\n                for io in inputs_and_outputs\r\n            ):\r\n                return NotImplemented\r\n            else:\r\n                raise e\r\n\r\n    def _result_as_quantity(self, result, unit, out):\r\n        \"\"\"Turn result into a quantity with the given unit.\r\n\r\n        If no output is given, it will take a view of the array as a quantity,\r\n        and set the unit.  If output is given, those should be quantity views\r\n        of the result arrays, and the function will just set the unit.\r\n\r\n        Parameters\r\n        ----------\r\n        result : ndarray or tuple thereof\r\n            Array(s) which need to be turned into quantity.\r\n        unit : `~astropy.units.Unit`\r\n            Unit for the quantities to be returned (or `None` if the result\r\n            should not be a quantity).  Should be tuple if result is a tuple.\r\n        out : `~astropy.units.Quantity` or None\r\n            Possible output quantity. Should be `None` or a tuple if result\r\n            is a tuple.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n           With units set.\r\n        \"\"\"\r\n        if isinstance(result, (tuple, list)):\r\n            if out is None:\r\n                out = (None,) * len(result)\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n"]
[95.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[95.002, "i", "sed -n '800,1600p' astropy/units/quantity.py\r"]
[95.004, "o", "sed -n '800,1600p' astropy/units/quantity.py\r\n"]
[95.006, "o", "\u001b[?2004l\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n        # ``obj.__class is np.ndarray``. So, not worth special-casing.\r\n        if obj is None:\r\n            obj = self.view(np.ndarray)\r\n        else:\r\n            obj = np.array(obj, copy=COPY_IF_NEEDED, subok=True)\r\n\r\n        # Take the view, set the unit, and update possible other properties\r\n        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\r\n        view = obj.view(quantity_subclass)\r\n        view._set_unit(unit)\r\n        view.__array_finalize__(self)\r\n        if propagate_info and \"info\" in self.__dict__:\r\n            view.info = self.info\r\n        return view\r\n\r\n    def _set_unit(self, unit):\r\n        \"\"\"Set the unit.\r\n\r\n        This is used anywhere the unit is set or modified, i.e., in the\r\n        initializer, in ``__imul__`` and ``__itruediv__`` for in-place\r\n        multiplication and division by another unit, as well as in\r\n        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\r\n        sets the unit, but subclasses can override it to check that, e.g.,\r\n        a unit is consistent.\r\n        \"\"\"\r\n        if not isinstance(unit, UnitBase):\r\n            if isinstance(self._unit, StructuredUnit) or isinstance(\r\n                unit, StructuredUnit\r\n            ):\r\n                unit = StructuredUnit(unit, self.dtype)\r\n            else:\r\n                # Trying to go through a string ensures that, e.g., Magnitudes with\r\n                # dimensionless physical unit become Quantity with units of mag.\r\n                unit = Unit(str(unit), parse_strict=\"silent\")\r\n                if not isinstance(unit, (UnitBase, StructuredUnit)):\r\n                    raise UnitTypeError(\r\n                        f\"{self.__class__.__name__} instances require normal units, \"\r\n                        f\"not {unit.__class__} instances.\"\r\n                    )\r\n\r\n        self._unit = unit\r\n\r\n    def __deepcopy__(self, memo):\r\n        # If we don't define this, ``copy.deepcopy(quantity)`` will\r\n        # return a bare Numpy array.\r\n        return self.copy()\r\n\r\n    def __reduce__(self):\r\n        # patch to pickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        object_state = list(super().__reduce__())\r\n        object_state[2] = (object_state[2], self.__dict__)\r\n        return tuple(object_state)\r\n\r\n    def __setstate__(self, state):\r\n        # patch to unpickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        nd_state, own_state = state\r\n        super().__setstate__(nd_state)\r\n        self.__dict__.update(own_state)\r\n\r\n    info = QuantityInfo()\r\n\r\n    def _to_value(self, unit, equivalencies=[]):\r\n        \"\"\"Helper method for to and to_value.\"\"\"\r\n        if equivalencies == []:\r\n            equivalencies = self._equivalencies\r\n        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\r\n            # Standard path, let unit to do work.\r\n            return self.unit.to(\r\n                unit, self.view(np.ndarray), equivalencies=equivalencies\r\n            )\r\n\r\n        else:\r\n            # The .to() method of a simple unit cannot convert a structured\r\n            # dtype, so we work around it, by recursing.\r\n            # TODO: deprecate this?\r\n            # Convert simple to Structured on initialization?\r\n            result = np.empty_like(self.view(np.ndarray))\r\n            for name in self.dtype.names:\r\n                result[name] = self[name]._to_value(unit, equivalencies)\r\n            return result\r\n\r\n    def to(self, unit, equivalencies=[], copy=True):\r\n        \"\"\"\r\n        Return a new `~astropy.units.Quantity` object with the specified unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like\r\n            An object that represents the unit to convert to. Must be\r\n            an `~astropy.units.UnitBase` object or a string parseable\r\n            by the `~astropy.units` package.\r\n\r\n        equivalencies : list of tuple\r\n            A list of equivalence pairs to try if the units are not\r\n            directly convertible.  See :ref:`astropy:unit_equivalencies`.\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n            (none for `~astropy.units.Quantity`, but may be set for subclasses)\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        copy : bool, optional\r\n            If `True` (default), then the value is copied.  Otherwise, a copy\r\n            will only be made if necessary.\r\n\r\n        See Also\r\n        --------\r\n        to_value : get the numerical value in a given unit.\r\n        \"\"\"\r\n        # We don't use `to_value` below since we always want to make a copy\r\n        # and don't want to slow down this method (esp. the scalar case).\r\n        unit = Unit(unit)\r\n        if copy:\r\n            # Avoid using to_value to ensure that we make a copy. We also\r\n            # don't want to slow down this method (esp. the scalar case).\r\n            value = self._to_value(unit, equivalencies)\r\n        else:\r\n            # to_value only copies if necessary\r\n            value = self.to_value(unit, equivalencies)\r\n        return self._new_view(value, unit)\r\n\r\n    def to_value(self, unit=None, equivalencies=[]):\r\n        \"\"\"\r\n        The numerical value, possibly in a different unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            The unit in which the value should be given. If not given or `None`,\r\n            use the current unit.\r\n\r\n        equivalencies : list of tuple, optional\r\n            A list of equivalence pairs to try if the units are not directly\r\n            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\r\n            or ``[]``, class default equivalencies will be used (none for\r\n            `~astropy.units.Quantity`, but may be set for subclasses).\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        Returns\r\n        -------\r\n        value : ndarray or scalar\r\n            The value in the units specified. For arrays, this will be a view\r\n            of the data if no unit conversion was necessary.\r\n\r\n        See Also\r\n        --------\r\n        to : Get a new instance in a different unit.\r\n        \"\"\"\r\n        if unit is None or unit is self.unit:\r\n            value = self.view(np.ndarray)\r\n        elif not self.dtype.names:\r\n            # For non-structured, we attempt a short-cut, where we just get\r\n            # the scale.  If that is 1, we do not have to do anything.\r\n            unit = Unit(unit)\r\n            # We want a view if the unit does not change.  One could check\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n            # TODO: would be better for `unit.to` to have an in-place flag.\r\n            try:\r\n                scale = self.unit._to(unit)\r\n            except Exception:\r\n                # Short-cut failed; try default (maybe equivalencies help).\r\n                value = self._to_value(unit, equivalencies)\r\n            else:\r\n                value = self.view(np.ndarray)\r\n                if not is_effectively_unity(scale):\r\n                    # not in-place!\r\n                    value = value * scale\r\n        else:\r\n            # For structured arrays, we go the default route.\r\n            value = self._to_value(unit, equivalencies)\r\n\r\n        # Index with empty tuple to decay array scalars in to numpy scalars.\r\n        return value if value.shape else value[()]\r\n\r\n    value = property(\r\n        to_value,\r\n        doc=\"\"\"The numerical value of this instance.\r\n\r\n    See also\r\n    --------\r\n    to_value : Get the numerical value in a given unit.\r\n    \"\"\",\r\n    )\r\n\r\n    @property\r\n    def unit(self):\r\n        \"\"\"\r\n        A `~astropy.units.UnitBase` object representing the unit of this\r\n        quantity.\r\n        \"\"\"\r\n        return self._unit\r\n\r\n    @property\r\n    def equivalencies(self):\r\n        \"\"\"\r\n        A list of equivalencies that will be applied by default during\r\n        unit conversions.\r\n        \"\"\"\r\n        return self._equivalencies\r\n\r\n    def _recursively_apply(self, func):\r\n        \"\"\"Apply function recursively to every field.\r\n\r\n        Returns a copy with the result.\r\n        \"\"\"\r\n        result = np.empty_like(self)\r\n        result_value = result.view(np.ndarray)\r\n        result_unit = ()\r\n        for name in self.dtype.names:\r\n            part = func(self[name])\r\n            result_value[name] = part.value\r\n            result_unit += (part.unit,)\r\n\r\n        result._set_unit(result_unit)\r\n        return result\r\n\r\n    @property\r\n    def si(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with SI units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"si\"))\r\n        si_unit = self.unit.si\r\n        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\r\n\r\n    @property\r\n    def cgs(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with CGS units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"cgs\"))\r\n        cgs_unit = self.unit.cgs\r\n        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\r\n\r\n    @property\r\n    def isscalar(self):\r\n        \"\"\"\r\n        True if the `value` of this quantity is a scalar, or False if it\r\n        is an array-like object.\r\n\r\n        .. note::\r\n            This is subtly different from `numpy.isscalar` in that\r\n            `numpy.isscalar` returns False for a zero-dimensional array\r\n            (e.g. ``np.array(1)``), while this is True for quantities,\r\n            since quantities cannot represent true numpy scalars.\r\n        \"\"\"\r\n        return not self.shape\r\n\r\n    # This flag controls whether convenience conversion members, such\r\n    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\r\n    # not turned on on Quantity itself, but is on some subclasses of\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n    _include_easy_conversion_members = False\r\n\r\n    def __dir__(self):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.  This function is implemented in\r\n        order to make autocompletion still work correctly in IPython.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            return super().__dir__()\r\n\r\n        dir_values = set(super().__dir__())\r\n        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\r\n        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\r\n            dir_values.update(equivalent.names)\r\n        return sorted(dir_values)\r\n\r\n    def __getattr__(self, attr):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            raise AttributeError(\r\n                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\r\n            )\r\n\r\n        def get_virtual_unit_attribute():\r\n            registry = get_current_unit_registry().registry\r\n            to_unit = registry.get(attr, None)\r\n            if to_unit is None:\r\n                return None\r\n\r\n            try:\r\n                return self.unit.to(\r\n                    to_unit, self.value, equivalencies=self.equivalencies\r\n                )\r\n            except UnitsError:\r\n                return None\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n            # so they should raise a TypeError rather than an IndexError.\r\n            if self.isscalar:\r\n                raise TypeError(\r\n                    f\"'{self.__class__.__name__}' object with a scalar value \"\r\n                    \"does not support indexing\"\r\n                )\r\n            else:\r\n                raise\r\n        # For single elements, ndarray.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if not isinstance(out, np.ndarray):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def __setitem__(self, i, value):\r\n        if isinstance(i, str):\r\n            # Indexing will cause a different unit, so by doing this in\r\n            # two steps we effectively try with the right unit.\r\n            self[i][...] = value\r\n            return\r\n\r\n        # update indices in info if the info property has been accessed\r\n        # (in which case 'info' in self.__dict__ is True; this is guaranteed\r\n        # to be the case if we're part of a table).\r\n        if not self.isscalar and \"info\" in self.__dict__:\r\n            self.info.adjust_indices(i, value, len(self))\r\n        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\r\n\r\n    # __contains__ is OK\r\n\r\n    def __bool__(self):\r\n        \"\"\"This method raises ValueError, since truthiness of quantities is ambiguous,\r\n        especially for logarithmic units and temperatures. Use explicit comparisons.\r\n        \"\"\"\r\n        raise ValueError(\r\n            f\"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units\"\r\n            \" and temperatures. Use explicit comparisons.\"\r\n        )\r\n\r\n    def __len__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\r\n            )\r\n        else:\r\n            return len(self.value)\r\n\r\n    # Numerical types\r\n    def __float__(self):\r\n        try:\r\n            return float(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __int__(self):\r\n        try:\r\n            return int(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __index__(self):\r\n        # for indices, we do not want to mess around with scaling at all,\r\n        # so unlike for float, int, we insist here on unscaled dimensionless\r\n        try:\r\n            assert self.unit.is_unity()\r\n            return self.value.__index__()\r\n        except Exception:\r\n            raise TypeError(\r\n                \"only integer dimensionless scalar quantities \"\r\n                \"can be converted to a Python index\"\r\n            )\r\n\r\n    # TODO: we may want to add a hook for dimensionless quantities?\r\n    @property\r\n    def _unitstr(self):\r\n        if self.unit is None:\r\n            unitstr = _UNIT_NOT_INITIALISED\r\n        else:\r\n            unitstr = str(self.unit)\r\n\r\n        if unitstr:\r\n            unitstr = \" \" + unitstr\r\n\r\n        return unitstr\r\n\r\n    def to_string(\r\n        self, unit=None, precision=None, format=None, subfmt=None, *, formatter=None\r\n    ):\r\n        \"\"\"\r\n        Generate a string representation of the quantity and its unit.\r\n\r\n        The behavior of this function can be altered via the\r\n        `numpy.set_printoptions` function and its various keywords.  The\r\n        exception to this is the ``threshold`` keyword, which is controlled via\r\n        the ``[units.quantity]`` configuration item ``latex_array_threshold``.\r\n        This is treated separately because the numpy default of 1000 is too big\r\n        for most browsers to handle.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            Specifies the unit.  If not provided,\r\n            the unit used to initialize the quantity will be used.\r\n\r\n        precision : number, optional\r\n            The level of decimal precision. If `None`, or not provided,\r\n            it will be determined from NumPy print options.\r\n\r\n        format : str, optional\r\n            The format of the result. If not provided, an unadorned\r\n            string is returned. Supported values are:\r\n\r\n            - 'latex': Return a LaTeX-formatted string\r\n\r\n            - 'latex_inline': Return a LaTeX-formatted string that uses\r\n              negative exponents instead of fractions\r\n\r\n        formatter : str, callable, dict, optional\r\n            The formatter to use for the value. If a string, it should be a\r\n            valid format specifier using Python's mini-language. If a callable,\r\n            it will be treated as the default formatter for all values and will\r\n            overwrite default Latex formatting for exponential notation and complex\r\n            numbers. If a dict, it should map a specific type to a callable to be\r\n            directly passed into `numpy.array2string`. If not provided, the default\r\n            formatter will be used.\r\n\r\n        subfmt : str, optional\r\n            Subformat of the result. For the moment, only used for\r\n            ``format='latex'`` and ``format='latex_inline'``. Supported\r\n            values are:\r\n\r\n            - 'inline': Use ``$ ... $`` as delimiters.\r\n\r\n            - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\r\n\r\n        Returns\r\n        -------\r\n        str\r\n            A string with the contents of this Quantity\r\n        \"\"\"\r\n        if unit is not None and unit != self.unit:\r\n            return self.to(unit).to_string(\r\n                unit=None,\r\n                precision=precision,\r\n                format=format,\r\n                subfmt=subfmt,\r\n                formatter=formatter,\r\n            )\r\n\r\n        if format is None and formatter is None and precision is None:\r\n            # Use default formatting settings\r\n            return f\"{self.value}{self._unitstr:s}\"\r\n\r\n        formats = {\r\n            None: None,\r\n            \"latex\": {\r\n                None: (\"$\", \"$\"),\r\n                \"inline\": (\"$\", \"$\"),\r\n                \"display\": (r\"$\\displaystyle \", r\"$\"),\r\n            },\r\n        }\r\n        formats[\"latex_inline\"] = formats[\"latex\"]\r\n\r\n        if format not in formats:\r\n            raise ValueError(f\"Unknown format '{format}'\")\r\n\r\n        format_spec = formatter if isinstance(formatter, str) else None\r\n\r\n        if format is None:\r\n            if format_spec is not None:\r\n\r\n                def formatter(value):\r\n                    return builtins.format(value, format_spec)\r\n\r\n            if callable(formatter):\r\n                formatter = {\"all\": formatter}\r\n\r\n            return (\r\n                np.array2string(\r\n                    self.value,\r\n                    precision=precision,\r\n                    floatmode=\"fixed\",\r\n                    formatter=formatter,\r\n                )\r\n                + self._unitstr\r\n            )\r\n\r\n        # else, for the moment we assume format=\"latex\" or \"latex_inline\".\r\n\r\n        # Set the precision if set, otherwise use numpy default\r\n        pops = np.get_printoptions()\r\n        if format_spec is None:\r\n            format_spec = (\r\n                f\".{precision if precision is not None else pops['precision']}g\"\r\n            )\r\n\r\n        # Use default formatters\r\n        if formatter is None or isinstance(formatter, str):\r\n            # Filter width and alignment operations for latex\r\n            # [[fill]align][sign][\"z\"][\"#\"][\"0\"][width][grouping_option][\".\" precision][type]\r\n            format_spec = re.sub(\r\n                r\"(.*?)([+\\- ]?)(\\d+)?(,)?(\\.\\d+)?([a-zA-Z%]+)?$\",\r\n                r\"\\2\\5\\6\",\r\n                format_spec,\r\n            )\r\n\r\n            if self.dtype.kind == \"c\":  # Complex default latex formatter\r\n                # Disallow sign operations for the imaginary part\r\n                imag_format_spec = re.sub(r\"[+\\- ]\", \"\", format_spec)\r\n\r\n                def formatter(value):\r\n                    return \"({}{}i)\".format(\r\n                        Latex.format_exponential_notation(\r\n                            value.real, format_spec=format_spec\r\n                        ),\r\n                        Latex.format_exponential_notation(\r\n                            value.imag, format_spec=\"+\" + imag_format_spec\r\n                        ),\r\n                    )\r\n\r\n            else:  # Float default latex formatter\r\n\r\n                def formatter(value):\r\n                    return Latex.format_exponential_notation(\r\n                        value, format_spec=format_spec\r\n                    )\r\n\r\n        if callable(formatter):\r\n            formatter = {\"all\": formatter}\r\n\r\n        # The view is needed for the scalar case - self.value might be float.\r\n        latex_value = np.array2string(\r\n            self.view(np.ndarray),\r\n            threshold=(\r\n                conf.latex_array_threshold\r\n                if conf.latex_array_threshold > -1\r\n                else pops[\"threshold\"]\r\n            ),\r\n            formatter=formatter,\r\n            max_line_width=np.inf,\r\n            separator=\",~\",\r\n        )\r\n\r\n        latex_value = latex_value.replace(\"...\", r\"\\dots\")\r\n\r\n        # Format unit\r\n        # [1:-1] strips the '$' on either side needed for math mode\r\n        if self.unit is None:\r\n            latex_unit = _UNIT_NOT_INITIALISED\r\n        elif format == \"latex\":\r\n            latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\r\n        elif format == \"latex_inline\":\r\n            latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\r\n\r\n        delimiter_left, delimiter_right = formats[format][subfmt]\r\n\r\n        # Add a space in front except for super-script units like degrees.\r\n        if not latex_unit.removeprefix(\"\\\\mathrm{\").startswith(\"{}^\"):\r\n            latex_unit = rf\" \\; {latex_unit}\"\r\n\r\n        return rf\"{delimiter_left}{latex_value}{latex_unit}{delimiter_right}\"\r\n\r\n    def __str__(self):\r\n        return self.to_string()\r\n\r\n    def __repr__(self):\r\n        prefixstr = \"<\" + self.__class__.__name__ + \" \"\r\n        arrstr = np.array2string(\r\n            self.view(np.ndarray), separator=\", \", prefix=prefixstr\r\n        )\r\n        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\r\n\r\n    def _repr_latex_(self):\r\n        \"\"\"\r\n        Generate a latex representation of the quantity and its unit.\r\n\r\n        Returns\r\n        -------\r\n        lstr\r\n            A LaTeX string with the contents of this Quantity\r\n        \"\"\"\r\n        # NOTE: This should change to display format in a future release\r\n        return self.to_string(format=\"latex\", subfmt=\"inline\")\r\n\r\n    def __format__(self, format_spec):\r\n        try:\r\n            return self.to_string(format=format_spec)\r\n        except ValueError:\r\n            # We might have a unit format not implemented in `to_string()`.\r\n            if format_spec in Base.registry:\r\n                if self.unit is dimensionless_unscaled:\r\n                    return f\"{self.value}\"\r\n                else:\r\n                    return f\"{self.value} {format(self.unit, format_spec)}\"\r\n"]
[100.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[100.002, "i", "sed -n '1600,2400p' astropy/units/quantity.py\r"]
[100.004, "o", "sed -n '1600,2400p' astropy/units/quantity.py\r\n"]
[100.006, "o", "\u001b[?2004l\r\n                    return f\"{self.value} {format(self.unit, format_spec)}\"\r\n            # Can the value be formatted on its own?\r\n            try:\r\n                return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\r\n            except ValueError:\r\n                # Format the whole thing as a single string.\r\n                return format(f\"{self.value}{self._unitstr:s}\", format_spec)\r\n\r\n    def decompose(self, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units\r\n        decomposed. Decomposed units have only irreducible units in\r\n        them (see `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        bases : sequence of `~astropy.units.UnitBase`, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n        \"\"\"\r\n        return self._decompose(False, bases=bases)\r\n\r\n    def _decompose(self, allowscaledunits=False, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units decomposed. Decomposed\r\n        units have only irreducible units in them (see\r\n        `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        allowscaledunits : bool\r\n            If True, the resulting `Quantity` may have a scale factor\r\n            associated with it.  If False, any scaling in the unit will\r\n            be subsumed into the value of the resulting `Quantity`\r\n\r\n        bases : sequence of UnitBase, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n\r\n        \"\"\"\r\n        new_unit = self.unit.decompose(bases=bases)\r\n\r\n        # Be careful here because self.value usually is a view of self;\r\n        # be sure that the original value is not being modified.\r\n        if not allowscaledunits and hasattr(new_unit, \"scale\"):\r\n            new_value = self.value * new_unit.scale\r\n            new_unit = new_unit / new_unit.scale\r\n            return self._new_view(new_value, new_unit)\r\n        else:\r\n            return self._new_view(self.copy(), new_unit)\r\n\r\n    # These functions need to be overridden to take into account the units\r\n    # Array conversion\r\n    # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\r\n\r\n    def item(self, *args):\r\n        \"\"\"Copy an element of an array to a scalar Quantity and return it.\r\n\r\n        Like :meth:`~numpy.ndarray.item` except that it always\r\n        returns a `Quantity`, not a Python scalar.\r\n\r\n        \"\"\"\r\n        return self._new_view(super().item(*args))\r\n\r\n    def tolist(self):\r\n        raise NotImplementedError(\r\n            \"cannot make a list of Quantities. Get list of values with\"\r\n            \" q.value.tolist().\"\r\n        )\r\n\r\n    def _to_own_unit(self, value, check_precision=True, *, unit=None):\r\n        \"\"\"Convert value to one's own unit (or that given).\r\n\r\n        Here, non-quantities are treated as dimensionless, and care is taken\r\n        for values of 0, infinity or nan, which are allowed to have any unit.\r\n\r\n        Parameters\r\n        ----------\r\n        value : anything convertible to `~astropy.units.Quantity`\r\n            The value to be converted to the requested unit.\r\n        check_precision : bool\r\n            Whether to forbid conversion of float to integer if that changes\r\n            the input number.  Default: `True`.\r\n        unit : `~astropy.units.Unit` or None\r\n            The unit to convert to.  By default, the unit of ``self``.\r\n\r\n        Returns\r\n        -------\r\n        value : number or `~numpy.ndarray`\r\n            In the requested units.\r\n\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        try:\r\n            _value = value.to_value(unit)\r\n        except AttributeError:\r\n            # We're not a Quantity.\r\n            # First remove two special cases (with a fast test):\r\n            # 1) Maybe masked printing? MaskedArray with quantities does not\r\n            # work very well, but no reason to break even repr and str.\r\n            # 2) np.ma.masked? useful if we're a MaskedQuantity.\r\n            if value is np.ma.masked or (\r\n                value is np.ma.masked_print_option and self.dtype.kind == \"O\"\r\n            ):\r\n                return value\r\n            # Now, let's try a more general conversion.\r\n            # Plain arrays will be converted to dimensionless in the process,\r\n            # but anything with a unit attribute will use that.\r\n            try:\r\n                as_quantity = Quantity(value)\r\n                _value = as_quantity.to_value(unit)\r\n            except UnitsError:\r\n                # last chance: if this was not something with a unit\r\n                # and is all 0, inf, or nan, we treat it as arbitrary unit.\r\n                if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\r\n                    as_quantity.value\r\n                ):\r\n                    _value = as_quantity.value\r\n                else:\r\n                    raise\r\n\r\n        if self.dtype.kind == \"i\" and check_precision:\r\n            # If, e.g., we are casting float to int, we want to fail if\r\n            # precision is lost, but let things pass if it works.\r\n            _value = np.array(_value, copy=COPY_IF_NEEDED, subok=True)\r\n            if not np.can_cast(_value.dtype, self.dtype):\r\n                self_dtype_array = np.array(_value, self.dtype, subok=True)\r\n                if not np.all((self_dtype_array == _value) | np.isnan(_value)):\r\n                    raise TypeError(\r\n                        \"cannot convert value type to array type without precision loss\"\r\n                    )\r\n\r\n        # Setting names to ensure things like equality work (note that\r\n        # above will have failed already if units did not match).\r\n        # TODO: is this the best place to do this?\r\n        if _value.dtype.names is not None:\r\n            _value = _value.astype(self.dtype, copy=False)\r\n        return _value\r\n\r\n    if NUMPY_LT_2_0:\r\n\r\n        def itemset(self, *args):\r\n            if len(args) == 0:\r\n                raise ValueError(\"itemset must have at least one argument\")\r\n\r\n            self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\r\n\r\n    def tostring(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tostring()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to string.  Write array with\"\r\n            \" q.value.tostring(...).\"\r\n        )\r\n\r\n    def tobytes(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tobytes()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\r\n        )\r\n\r\n    def tofile(self, fid, sep=\"\", format=\"%s\"):\r\n        \"\"\"Not implemented, use ``.value.tofile()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\r\n        )\r\n\r\n    def dump(self, file):\r\n        \"\"\"Not implemented, use ``.value.dump()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to file.  Write array with q.value.dump()\"\r\n        )\r\n\r\n    def dumps(self):\r\n        \"\"\"Not implemented, use ``.value.dumps()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\r\n        )\r\n\r\n    # astype, byteswap, copy, view, getfield, setflags OK as is\r\n\r\n    def fill(self, value):\r\n        self.view(np.ndarray).fill(self._to_own_unit(value))\r\n\r\n    # Shape manipulation: resize cannot be done (does not own data), but\r\n    # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\r\n    # the flat iterator needs to be overwritten, otherwise single items are\r\n    # returned as numbers.\r\n    @property\r\n    def flat(self):\r\n        \"\"\"A 1-D iterator over the Quantity array.\r\n\r\n        This returns a ``QuantityIterator`` instance, which behaves the same\r\n        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\r\n        and is similar to, but not a subclass of, Python's built-in iterator\r\n        object.\r\n        \"\"\"\r\n        return QuantityIterator(self)\r\n\r\n    @flat.setter\r\n    def flat(self, value):\r\n        y = self.ravel()\r\n        y[:] = value\r\n\r\n    # Item selection and manipulation\r\n    # repeat, sort, compress, diagonal OK\r\n    def take(self, indices, axis=None, out=None, mode=\"raise\"):\r\n        out = super().take(indices, axis=axis, out=out, mode=mode)\r\n        # For single elements, ndarray.take returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if type(out) is not type(self):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def put(self, indices, values, mode=\"raise\"):\r\n        self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\r\n\r\n    def choose(self, choices, out=None, mode=\"raise\"):\r\n        raise NotImplementedError(\r\n            \"cannot choose based on quantity.  Choose using array with\"\r\n            \" q.value.choose(...)\"\r\n        )\r\n\r\n    # ensure we do not return indices as quantities\r\n    if NUMPY_LT_2_0:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None):\r\n            return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\r\n\r\n    else:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None, *, stable=None):\r\n            return self.view(np.ndarray).argsort(\r\n                axis=axis, kind=kind, order=order, stable=stable\r\n            )\r\n\r\n    def searchsorted(self, v, *args, **kwargs):\r\n        return np.searchsorted(\r\n            np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\r\n        )  # avoid numpy 1.6 problem\r\n\r\n    def argmax(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def argmin(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def __array_function__(self, function, types, args, kwargs):\r\n        \"\"\"Wrap numpy functions, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap\r\n        types : iterable of classes\r\n            Classes that provide an ``__array_function__`` override. Can\r\n            in principle be used to interact with other classes. Below,\r\n            mostly passed on to `~numpy.ndarray`, which can only interact\r\n            with subclasses.\r\n        args : tuple\r\n            Positional arguments provided in the function call.\r\n        kwargs : dict\r\n            Keyword arguments provided in the function call.\r\n\r\n        Returns\r\n        -------\r\n        result: `~astropy.units.Quantity`, `~numpy.ndarray`\r\n            As appropriate for the function.  If the function is not\r\n            supported, `NotImplemented` is returned, which will lead to\r\n            a `TypeError` unless another argument overrode the function.\r\n\r\n        Raises\r\n        ------\r\n        ~astropy.units.UnitsError\r\n            If operands have incompatible units.\r\n        \"\"\"\r\n        # A function should be in one of the following sets or dicts:\r\n        # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\r\n        #    supports Quantity; we pass on to ndarray.__array_function__.\r\n        # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\r\n        #    after converting quantities to arrays with suitable units,\r\n        #    and possibly setting units on the result.\r\n        # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\r\n        #    requires a Quantity-specific implementation.\r\n        # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\r\n        # For now, since we may not yet have complete coverage, if a\r\n        # function is in none of the above, we simply call the numpy\r\n        # implementation.\r\n        if function in SUBCLASS_SAFE_FUNCTIONS:\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        elif function in FUNCTION_HELPERS:\r\n            function_helper = FUNCTION_HELPERS[function]\r\n            try:\r\n                args, kwargs, unit, out = function_helper(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            result = super().__array_function__(function, types, args, kwargs)\r\n            # Fall through to return section\r\n\r\n        elif function in DISPATCHED_FUNCTIONS:\r\n            dispatched_function = DISPATCHED_FUNCTIONS[function]\r\n            try:\r\n                result, unit, out = dispatched_function(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            # Fall through to return section\r\n\r\n        elif function in UNSUPPORTED_FUNCTIONS:\r\n            return NotImplemented\r\n\r\n        else:\r\n            warnings.warn(\r\n                f\"function '{function.__name__}' is not known to astropy's Quantity.\"\r\n                \" Will run it anyway, hoping it will treat ndarray subclasses\"\r\n                \" correctly. Please raise an issue at\"\r\n                \" https://github.com/astropy/astropy/issues.\",\r\n                AstropyWarning,\r\n            )\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        # If unit is None, a plain array is expected (e.g., boolean), which\r\n        # means we're done.\r\n        # We're also done if the result was NotImplemented, which can happen\r\n        # if other inputs/outputs override __array_function__;\r\n        # hopefully, they can then deal with us.\r\n        if unit is None or result is NotImplemented:\r\n            return result\r\n\r\n        return self._result_as_quantity(result, unit, out=out)\r\n\r\n    def _not_implemented_or_raise(self, function, types):\r\n        # Our function helper or dispatcher found that the function does not\r\n        # work with Quantity.  In principle, there may be another class that\r\n        # knows what to do with us, for which we should return NotImplemented.\r\n        # But if there is ndarray (or a non-Quantity subclass of it) around,\r\n        # it quite likely coerces, so we should just break.\r\n        if any(\r\n            issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\r\n        ):\r\n            raise TypeError(\r\n                f\"the Quantity implementation cannot handle {function} \"\r\n                \"with the given arguments.\"\r\n            ) from None\r\n        else:\r\n            return NotImplemented\r\n\r\n    # Calculation -- override ndarray methods to take into account units.\r\n    # We use the corresponding numpy functions to evaluate the results, since\r\n    # the methods do not always allow calling with keyword arguments.\r\n    # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\r\n    # TypeError: 'a_max' is an invalid keyword argument for this function.\r\n    def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\r\n        \"\"\"Wrap a numpy function that processes self, returning a Quantity.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap.\r\n        args : positional arguments\r\n            Any positional arguments to the function beyond the first argument\r\n            (which will be set to ``self``).\r\n        kwargs : keyword arguments\r\n            Keyword arguments to the function.\r\n\r\n        If present, the following arguments are treated specially:\r\n\r\n        unit : `~astropy.units.Unit`\r\n            Unit of the output result.  If not given, the unit of ``self``.\r\n        out : `~astropy.units.Quantity`\r\n            A Quantity instance in which to store the output.\r\n\r\n        Notes\r\n        -----\r\n        Output should always be assigned via a keyword argument, otherwise\r\n        no proper account of the unit is taken.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            Result of the function call, with the unit set properly.\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        # Ensure we don't loop back by turning any Quantity into array views.\r\n        args = (self.value,) + tuple(\r\n            (arg.value if isinstance(arg, Quantity) else arg) for arg in args\r\n        )\r\n        if out is not None:\r\n            # If pre-allocated output is used, check it is suitable.\r\n            # This also returns array view, to ensure we don't loop back.\r\n            arrays = tuple(arg for arg in args if isinstance(arg, np.ndarray))\r\n            kwargs[\"out\"] = check_output(out, unit, arrays, function=function)\r\n        # Apply the function and turn it back into a Quantity.\r\n        result = function(*args, **kwargs)\r\n        return self._result_as_quantity(result, unit, out)\r\n\r\n    def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):\r\n        return self._wrap_function(np.trace, offset, axis1, axis2, dtype, out=out)\r\n\r\n    def var(\r\n        self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True\r\n    ):\r\n        return self._wrap_function(\r\n            np.var,\r\n            axis,\r\n            dtype,\r\n            out=out,\r\n            ddof=ddof,\r\n            keepdims=keepdims,\r\n            where=where,\r\n            unit=self.unit**2,\r\n        )\r\n\r\n    def std(\r\n        self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True\r\n    ):\r\n        return self._wrap_function(\r\n            np.std, axis, dtype, out=out, ddof=ddof, keepdims=keepdims, where=where\r\n        )\r\n\r\n    def mean(self, axis=None, dtype=None, out=None, keepdims=False, *, where=True):\r\n        return self._wrap_function(\r\n            np.mean, axis, dtype, out=out, keepdims=keepdims, where=where\r\n        )\r\n\r\n    def round(self, decimals=0, out=None):\r\n        return self._wrap_function(np.round, decimals, out=out)\r\n\r\n    def dot(self, b, out=None):\r\n        result_unit = self.unit * getattr(b, \"unit\", dimensionless_unscaled)\r\n        return self._wrap_function(np.dot, b, out=out, unit=result_unit)\r\n\r\n    # Calculation: override methods that do not make sense.\r\n\r\n    def all(self, axis=None, out=None):\r\n        raise TypeError(\r\n            \"cannot evaluate truth value of quantities. \"\r\n            \"Evaluate array with q.value.all(...)\"\r\n        )\r\n\r\n    def any(self, axis=None, out=None):\r\n        raise TypeError(\r\n            \"cannot evaluate truth value of quantities. \"\r\n            \"Evaluate array with q.value.any(...)\"\r\n        )\r\n\r\n    # Calculation: numpy functions that can be overridden with methods.\r\n\r\n    def diff(self, n=1, axis=-1):\r\n        return self._wrap_function(np.diff, n, axis)\r\n\r\n    def ediff1d(self, to_end=None, to_begin=None):\r\n        return self._wrap_function(np.ediff1d, to_end, to_begin)\r\n\r\n    def insert(self, obj, values, axis=None):\r\n        \"\"\"\r\n        Insert values along the given axis before the given indices and return\r\n        a new `~astropy.units.Quantity` object.\r\n\r\n        This is a thin wrapper around the `numpy.insert` function.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : int, slice or sequence of int\r\n            Object that defines the index or indices before which ``values`` is\r\n            inserted.\r\n        values : array-like\r\n            Values to insert.  If the type of ``values`` is different\r\n            from that of quantity, ``values`` is converted to the matching type.\r\n            ``values`` should be shaped so that it can be broadcast appropriately\r\n            The unit of ``values`` must be consistent with this quantity.\r\n        axis : int, optional\r\n            Axis along which to insert ``values``.  If ``axis`` is None then\r\n            the quantity array is flattened before insertion.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            A copy of quantity with ``values`` inserted.  Note that the\r\n            insertion does not occur in-place: a new quantity array is returned.\r\n\r\n        Examples\r\n        --------\r\n        >>> import astropy.units as u\r\n        >>> q = [1, 2] * u.m\r\n        >>> q.insert(0, 50 * u.cm)\r\n        <Quantity [ 0.5,  1.,  2.] m>\r\n\r\n        >>> q = [[1, 2], [3, 4]] * u.m\r\n        >>> q.insert(1, [10, 20] * u.m, axis=0)\r\n        <Quantity [[  1.,  2.],\r\n                   [ 10., 20.],\r\n                   [  3.,  4.]] m>\r\n\r\n        >>> q.insert(1, 10 * u.m, axis=1)\r\n        <Quantity [[  1., 10.,  2.],\r\n                   [  3., 10.,  4.]] m>\r\n\r\n        \"\"\"\r\n        out_array = np.insert(self.value, obj, self._to_own_unit(values), axis)\r\n        return self._new_view(out_array)\r\n\r\n\r\nclass SpecificTypeQuantity(Quantity):\r\n    \"\"\"Superclass for Quantities of specific physical type.\r\n\r\n    Subclasses of these work just like :class:`~astropy.units.Quantity`, except\r\n    that they are for specific physical types (and may have methods that are\r\n    only appropriate for that type).  Astropy examples are\r\n    :class:`~astropy.coordinates.Angle` and\r\n    :class:`~astropy.coordinates.Distance`\r\n\r\n    At a minimum, subclasses should set ``_equivalent_unit`` to the unit\r\n    associated with the physical type.\r\n    \"\"\"\r\n\r\n    # The unit for the specific physical type.  Instances can only be created\r\n    # with units that are equivalent to this.\r\n    _equivalent_unit = None\r\n\r\n    # The default unit used for views.  Even with `None`, views of arrays\r\n    # without units are possible, but will have an uninitialized unit.\r\n    _unit = None\r\n\r\n    # Default unit for initialization through the constructor.\r\n    _default_unit = None\r\n\r\n    # ensure that we get precedence over our superclass.\r\n    __array_priority__ = Quantity.__array_priority__ + 10\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        if unit.is_equivalent(self._equivalent_unit):\r\n            return type(self), True\r\n        else:\r\n            return super().__quantity_subclass__(unit)[0], False\r\n\r\n    def _set_unit(self, unit):\r\n        if unit is None or not unit.is_equivalent(self._equivalent_unit):\r\n            raise UnitTypeError(\r\n                (\r\n                    f\"{type(self).__name__} instances require units equivalent to \"\r\n                    f\"'{self._equivalent_unit}'\"\r\n                )\r\n                + (\r\n                    \", but no unit was given.\"\r\n                    if unit is None\r\n                    else f\", so cannot set it to '{unit}'.\"\r\n                )\r\n            )\r\n\r\n        super()._set_unit(unit)\r\n\r\n\r\ndef isclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False):\r\n    \"\"\"\r\n    Return a boolean array where two arrays are element-wise equal\r\n    within a tolerance.\r\n\r\n    Parameters\r\n    ----------\r\n    a, b : array-like or `~astropy.units.Quantity`\r\n        Input values or arrays to compare\r\n    rtol : array-like or `~astropy.units.Quantity`\r\n        The relative tolerance for the comparison, which defaults to\r\n        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,\r\n        then it must be dimensionless.\r\n    atol : number or `~astropy.units.Quantity`\r\n        The absolute tolerance for the comparison.  The units (or lack\r\n        thereof) of ``a``, ``b``, and ``atol`` must be consistent with\r\n        each other.  If `None`, ``atol`` defaults to zero in the\r\n        appropriate units.\r\n    equal_nan : `bool`\r\n        Whether to compare NaN\u2019s as equal. If `True`, NaNs in ``a`` will\r\n        be considered equal to NaN\u2019s in ``b``.\r\n\r\n    Notes\r\n    -----\r\n    This is a :class:`~astropy.units.Quantity`-aware version of\r\n    :func:`numpy.isclose`. However, this differs from the `numpy` function in\r\n    that the default for the absolute tolerance here is zero instead of\r\n    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default\r\n    *absolute* tolerance given two inputs that may have differently scaled\r\n    units.\r\n\r\n    Raises\r\n    ------\r\n    `~astropy.units.UnitsError`\r\n        If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,\r\n        or if ``rtol`` is not dimensionless.\r\n\r\n    See Also\r\n    --------\r\n    allclose\r\n    \"\"\"\r\n    return np.isclose(*_unquantify_allclose_arguments(a, b, rtol, atol), equal_nan)\r\n\r\n\r\ndef allclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False) -> bool:\r\n    \"\"\"\r\n    Whether two arrays are element-wise equal within a tolerance.\r\n\r\n    Parameters\r\n    ----------\r\n    a, b : array-like or `~astropy.units.Quantity`\r\n        Input values or arrays to compare\r\n    rtol : array-like or `~astropy.units.Quantity`\r\n        The relative tolerance for the comparison, which defaults to\r\n        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,\r\n        then it must be dimensionless.\r\n    atol : number or `~astropy.units.Quantity`\r\n        The absolute tolerance for the comparison.  The units (or lack\r\n        thereof) of ``a``, ``b``, and ``atol`` must be consistent with\r\n        each other.  If `None`, ``atol`` defaults to zero in the\r\n        appropriate units.\r\n    equal_nan : `bool`\r\n        Whether to compare NaN\u2019s as equal. If `True`, NaNs in ``a`` will\r\n        be considered equal to NaN\u2019s in ``b``.\r\n\r\n    Notes\r\n    -----\r\n    This is a :class:`~astropy.units.Quantity`-aware version of\r\n    :func:`numpy.allclose`. However, this differs from the `numpy` function in\r\n    that the default for the absolute tolerance here is zero instead of\r\n    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default\r\n    *absolute* tolerance given two inputs that may have differently scaled\r\n    units.\r\n\r\n    Raises\r\n    ------\r\n    `~astropy.units.UnitsError`\r\n        If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,\r\n        or if ``rtol`` is not dimensionless.\r\n\r\n    See Also\r\n    --------\r\n    isclose\r\n    \"\"\"\r\n    return np.allclose(*_unquantify_allclose_arguments(a, b, rtol, atol), equal_nan)\r\n\r\n\r\ndef _unquantify_allclose_arguments(actual, desired, rtol, atol):\r\n    actual = Quantity(actual, subok=True, copy=COPY_IF_NEEDED)\r\n\r\n    desired = Quantity(desired, subok=True, copy=COPY_IF_NEEDED)\r\n    try:\r\n        desired = desired.to(actual.unit)\r\n    except UnitsError:\r\n        raise UnitsError(\r\n            f\"Units for 'desired' ({desired.unit}) and 'actual' \"\r\n            f\"({actual.unit}) are not convertible\"\r\n        )\r\n\r\n    if atol is None:\r\n        # By default, we assume an absolute tolerance of zero in the\r\n        # appropriate units.  The default value of None for atol is\r\n        # needed because the units of atol must be consistent with the\r\n        # units for a and b.\r\n        atol = Quantity(0)\r\n    else:\r\n        atol = Quantity(atol, subok=True, copy=COPY_IF_NEEDED)\r\n        try:\r\n            atol = atol.to(actual.unit)\r\n        except UnitsError:\r\n            raise UnitsError(\r\n                f\"Units for 'atol' ({atol.unit}) and 'actual' \"\r\n                f\"({actual.unit}) are not convertible\"\r\n            )\r\n\r\n    rtol = Quantity(rtol, subok=True, copy=COPY_IF_NEEDED)\r\n    try:\r\n        rtol = rtol.to(dimensionless_unscaled)\r\n    except Exception:\r\n        raise UnitsError(\"'rtol' should be dimensionless\")\r\n\r\n    return actual.value, desired.value, rtol.value, atol.value\r\n"]
[105.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[105.002, "i", "sed -n '2400,3200p' astropy/units/quantity.py\r"]
[105.004, "o", "sed -n '2400,3200p' astropy/units/quantity.py\r\n"]
[105.006, "o", "\u001b[?2004l\r\n"]
[110.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[110.002, "i", "cat asv.ci.conf.json\r"]
[110.004, "o", "cat asv.ci.conf.json\r\n"]
[110.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[115.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[115.002, "i", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r"]
[115.004, "o", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r\n"]
[115.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[120.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[120.002, "i", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r"]
[120.004, "o", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r\n"]
[120.006, "o", "_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\"\r\n\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: argument {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages}: invalid choice: 'dev' (choose from 'help', 'quickstart', 'machine', 'setup', 'run', 'continuous', 'find', 'rm', 'publish', 'preview', 'profile', 'update', 'show', 'compare', 'check', 'gh-pages')\r\n"]
[125.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[125.002, "i", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r"]
[125.004, "o", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[125.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[130.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[130.002, "i", "sed -n '1,400p' astropy/units/quantity.py\r"]
[130.004, "o", "sed -n '1,400p' astropy/units/quantity.py\r\n"]
[130.006, "o", "\u001b[?2004l\r\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\r\n\"\"\"\r\nThis module defines the `Quantity` object, which represents a number with some\r\nassociated units. `Quantity` objects support operations like ordinary numbers,\r\nbut will deal with unit conversions internally.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport builtins\r\nimport numbers\r\nimport operator\r\nimport re\r\nimport warnings\r\nfrom fractions import Fraction\r\nfrom typing import TYPE_CHECKING\r\n\r\nimport numpy as np\r\n\r\nfrom astropy import config as _config\r\nfrom astropy.utils.compat.numpycompat import COPY_IF_NEEDED, NUMPY_LT_2_0\r\nfrom astropy.utils.data_info import ParentDtypeInfo\r\nfrom astropy.utils.exceptions import AstropyWarning\r\n\r\nfrom .core import (\r\n    Unit,\r\n    UnitBase,\r\n    UnitConversionError,\r\n    UnitsError,\r\n    UnitTypeError,\r\n    dimensionless_unscaled,\r\n    get_current_unit_registry,\r\n)\r\nfrom .format import Base, Latex\r\nfrom .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\r\nfrom .quantity_helper.function_helpers import (\r\n    DISPATCHED_FUNCTIONS,\r\n    FUNCTION_HELPERS,\r\n    SUBCLASS_SAFE_FUNCTIONS,\r\n    UNSUPPORTED_FUNCTIONS,\r\n)\r\nfrom .structured import StructuredUnit, _structured_unit_like_dtype\r\nfrom .utils import is_effectively_unity\r\n\r\nif TYPE_CHECKING:\r\n    from typing_extensions import Self\r\n\r\n    from .typing import QuantityLike\r\n\r\n__all__ = [\r\n    \"Quantity\",\r\n    \"SpecificTypeQuantity\",\r\n    \"QuantityInfoBase\",\r\n    \"QuantityInfo\",\r\n    \"allclose\",\r\n    \"isclose\",\r\n]\r\n\r\n\r\n# We don't want to run doctests in the docstrings we inherit from Numpy\r\n__doctest_skip__ = [\"Quantity.*\"]\r\n\r\n_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\r\n_UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\r\n\r\n\r\nclass Conf(_config.ConfigNamespace):\r\n    \"\"\"\r\n    Configuration parameters for Quantity.\r\n    \"\"\"\r\n\r\n    latex_array_threshold = _config.ConfigItem(\r\n        100,\r\n        \"The maximum size an array Quantity can be before its LaTeX \"\r\n        'representation for IPython gets \"summarized\" (meaning only the first '\r\n        'and last few elements are shown with \"...\" between). Setting this to a '\r\n        \"negative number means that the value will instead be whatever numpy \"\r\n        \"gets from get_printoptions.\",\r\n    )\r\n\r\n\r\nconf = Conf()\r\n\r\n\r\nclass QuantityIterator:\r\n    \"\"\"\r\n    Flat iterator object to iterate over Quantities.\r\n\r\n    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\r\n    ``q``.  It allows iterating over the array as if it were a 1-D array,\r\n    either in a for-loop or by calling its `next` method.\r\n\r\n    Iteration is done in C-contiguous style, with the last index varying the\r\n    fastest. The iterator can also be indexed using basic slicing or\r\n    advanced indexing.\r\n\r\n    See Also\r\n    --------\r\n    Quantity.flatten : Returns a flattened copy of an array.\r\n\r\n    Notes\r\n    -----\r\n    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\r\n    is not exported by the `~astropy.units` module.  Instead of\r\n    instantiating a `QuantityIterator` directly, use `Quantity.flat`.\r\n    \"\"\"\r\n\r\n    def __init__(self, q):\r\n        self._quantity = q\r\n        self._dataiter = q.view(np.ndarray).flat\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __getitem__(self, indx):\r\n        out = self._dataiter.__getitem__(indx)\r\n        # For single elements, ndarray.flat.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if isinstance(out, type(self._quantity)):\r\n            return out\r\n        else:\r\n            return self._quantity._new_view(out)\r\n\r\n    def __setitem__(self, index, value):\r\n        self._dataiter[index] = self._quantity._to_own_unit(value)\r\n\r\n    def __next__(self):\r\n        \"\"\"\r\n        Return the next value, or raise StopIteration.\r\n        \"\"\"\r\n        out = next(self._dataiter)\r\n        # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\r\n        return self._quantity._new_view(out)\r\n\r\n    next = __next__\r\n\r\n    def __len__(self):\r\n        return len(self._dataiter)\r\n\r\n    # Properties and methods to match `numpy.ndarray.flatiter`\r\n\r\n    @property\r\n    def base(self):\r\n        \"\"\"A reference to the array that is iterated over.\"\"\"\r\n        return self._quantity\r\n\r\n    @property\r\n    def coords(self):\r\n        \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\r\n        return self._dataiter.coords\r\n\r\n    @property\r\n    def index(self):\r\n        \"\"\"Current flat index into the array.\"\"\"\r\n        return self._dataiter.index\r\n\r\n    def copy(self):\r\n        \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\r\n        return self._quantity.flatten()\r\n\r\n\r\nclass QuantityInfoBase(ParentDtypeInfo):\r\n    # This is on a base class rather than QuantityInfo directly, so that\r\n    # it can be used for EarthLocationInfo yet make clear that that class\r\n    # should not be considered a typical Quantity subclass by Table.\r\n    attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\r\n    _supports_indexing = True\r\n\r\n    @staticmethod\r\n    def default_format(val):\r\n        return f\"{val.value}\"\r\n\r\n    @staticmethod\r\n    def possible_string_format_functions(format_):\r\n        \"\"\"Iterate through possible string-derived format functions.\r\n\r\n        A string can either be a format specifier for the format built-in,\r\n        a new-style format string, or an old-style format string.\r\n\r\n        This method is overridden in order to suppress printing the unit\r\n        in each row since it is already at the top in the column header.\r\n        \"\"\"\r\n        yield lambda format_, val: format(val.value, format_)\r\n        yield lambda format_, val: format_.format(val.value)\r\n        yield lambda format_, val: format_ % val.value\r\n\r\n\r\nclass QuantityInfo(QuantityInfoBase):\r\n    \"\"\"\r\n    Container for meta information like name, description, format.  This is\r\n    required when the object is used as a mixin column within a table, but can\r\n    be used as a general way to store meta information.\r\n    \"\"\"\r\n\r\n    _represent_as_dict_attrs = (\"value\", \"unit\")\r\n    _construct_from_dict_args = [\"value\"]\r\n    _represent_as_dict_primary_data = \"value\"\r\n\r\n    def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\r\n        \"\"\"\r\n        Return a new Quantity instance which is consistent with the\r\n        input ``cols`` and has ``length`` rows.\r\n\r\n        This is intended for creating an empty column object whose elements can\r\n        be set in-place for table operations like join or vstack.\r\n\r\n        Parameters\r\n        ----------\r\n        cols : list\r\n            List of input columns\r\n        length : int\r\n            Length of the output column object\r\n        metadata_conflicts : str ('warn'|'error'|'silent')\r\n            How to handle metadata conflicts\r\n        name : str\r\n            Output column name\r\n\r\n        Returns\r\n        -------\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n            Empty instance of this class consistent with ``cols``\r\n\r\n        \"\"\"\r\n        # Get merged info attributes like shape, dtype, format, description, etc.\r\n        attrs = self.merge_cols_attributes(\r\n            cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\r\n        )\r\n\r\n        # Make an empty quantity using the unit of the last one.\r\n        shape = (length,) + attrs.pop(\"shape\")\r\n        dtype = attrs.pop(\"dtype\")\r\n        # Use zeros so we do not get problems for Quantity subclasses such\r\n        # as Longitude and Latitude, which cannot take arbitrary values.\r\n        data = np.zeros(shape=shape, dtype=dtype)\r\n        # Get arguments needed to reconstruct class\r\n        map = {\r\n            key: (data if key == \"value\" else getattr(cols[-1], key))\r\n            for key in self._represent_as_dict_attrs\r\n        }\r\n        map[\"copy\"] = COPY_IF_NEEDED\r\n        out = self._construct_from_dict(map)\r\n\r\n        # Set remaining info attributes\r\n        for attr, value in attrs.items():\r\n            setattr(out.info, attr, value)\r\n\r\n        return out\r\n\r\n    def get_sortable_arrays(self):\r\n        \"\"\"\r\n        Return a list of arrays which can be lexically sorted to represent\r\n        the order of the parent column.\r\n\r\n        For Quantity this is just the quantity itself.\r\n\r\n\r\n        Returns\r\n        -------\r\n        arrays : list of ndarray\r\n        \"\"\"\r\n        return [self._parent]\r\n\r\n\r\nclass Quantity(np.ndarray):\r\n    \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\r\n\r\n    See also: https://docs.astropy.org/en/stable/units/quantity.html\r\n\r\n    Parameters\r\n    ----------\r\n    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\r\n        The numerical value of this quantity in the units given by unit.  If a\r\n        `Quantity` or sequence of them (or any other valid object with a\r\n        ``unit`` attribute), creates a new `Quantity` object, converting to\r\n        `unit` units as needed.  If a string, it is converted to a number or\r\n        `Quantity`, depending on whether a unit is present.\r\n\r\n    unit : unit-like\r\n        An object that represents the unit associated with the input value.\r\n        Must be an `~astropy.units.UnitBase` object or a string parseable by\r\n        the :mod:`~astropy.units` package.\r\n\r\n    dtype : ~numpy.dtype, optional\r\n        The dtype of the resulting Numpy array or scalar that will\r\n        hold the value.  If not provided, it is determined from the input,\r\n        except that any integer and (non-Quantity) object inputs are converted\r\n        to float by default.\r\n        If `None`, the normal `numpy.dtype` introspection is used, e.g.\r\n        preventing upcasting of integers.\r\n\r\n    copy : bool, optional\r\n        If `True` (default), then the value is copied.  Otherwise, a copy will\r\n        only be made if ``__array__`` returns a copy, if value is a nested\r\n        sequence, or if a copy is needed to satisfy an explicitly given\r\n        ``dtype``.  (The `False` option is intended mostly for internal use,\r\n        to speed up initialization where a copy is known to have been made.\r\n        Use with care.)\r\n\r\n    order : {'C', 'F', 'A'}, optional\r\n        Specify the order of the array.  As in `~numpy.array`.  This parameter\r\n        is ignored if the input is a `Quantity` and ``copy=False``.\r\n\r\n    subok : bool, optional\r\n        If `False` (default), the returned array will be forced to be a\r\n        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\r\n        or a subclass appropriate for the unit will be used (such as\r\n        `~astropy.units.Dex` for ``u.dex(u.AA)``).\r\n\r\n    ndmin : int, optional\r\n        Specifies the minimum number of dimensions that the resulting array\r\n        should have.  Ones will be prepended to the shape as needed to meet\r\n        this requirement.  This parameter is ignored if the input is a\r\n        `Quantity` and ``copy=False``.\r\n\r\n    Raises\r\n    ------\r\n    TypeError\r\n        If the value provided is not a Python numeric type.\r\n    TypeError\r\n        If the unit provided is not either a :class:`~astropy.units.Unit`\r\n        object or a parseable string unit.\r\n\r\n    Notes\r\n    -----\r\n    Quantities can also be created by multiplying a number or array with a\r\n    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\r\n\r\n    Unless the ``dtype`` argument is explicitly specified, integer\r\n    or (non-Quantity) object inputs are converted to `float` by default.\r\n    \"\"\"\r\n\r\n    # Need to set a class-level default for _equivalencies, or\r\n    # Constants can not initialize properly\r\n    _equivalencies = []\r\n\r\n    # Default unit for initialization; can be overridden by subclasses,\r\n    # possibly to `None` to indicate there is no default unit.\r\n    _default_unit = dimensionless_unscaled\r\n\r\n    # Ensures views have an undefined unit.\r\n    _unit = None\r\n\r\n    __array_priority__ = 10000\r\n\r\n    def __class_getitem__(cls, unit_shape_dtype):\r\n        \"\"\"Quantity Type Hints.\r\n\r\n        Unit-aware type hints are ``Annotated`` objects that encode the class,\r\n        the unit, and possibly shape and dtype information, depending on the\r\n        python and :mod:`numpy` versions.\r\n\r\n        Schematically, ``Annotated[cls[shape, dtype], unit]``\r\n\r\n        As a classmethod, the type is the class, ie ``Quantity``\r\n        produces an ``Annotated[Quantity, ...]`` while a subclass\r\n        like :class:`~astropy.coordinates.Angle` returns\r\n        ``Annotated[Angle, ...]``.\r\n\r\n        Parameters\r\n        ----------\r\n        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\r\n            Unit specification, can be the physical type (ie str or class).\r\n            If tuple, then the first element is the unit specification\r\n            and all other elements are for `numpy.ndarray` type annotations.\r\n            Whether they are included depends on the python and :mod:`numpy`\r\n            versions.\r\n\r\n        Returns\r\n        -------\r\n        `typing.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\r\n            Return type in this preference order:\r\n            * `typing.Annotated`\r\n            * `astropy.units.Unit` or `astropy.units.PhysicalType`\r\n\r\n        Raises\r\n        ------\r\n        TypeError\r\n            If the unit/physical_type annotation is not Unit-like or\r\n            PhysicalType-like.\r\n\r\n        Examples\r\n        --------\r\n        Create a unit-aware Quantity type annotation\r\n\r\n            >>> Quantity[Unit(\"s\")]\r\n            Annotated[Quantity, Unit(\"s\")]\r\n\r\n        See Also\r\n        --------\r\n        `~astropy.units.quantity_input`\r\n            Use annotations for unit checks on function arguments and results.\r\n\r\n        Notes\r\n        -----\r\n        |Quantity| types are also static-type compatible.\r\n        \"\"\"\r\n        from typing import Annotated\r\n\r\n        # process whether [unit] or [unit, shape, ptype]\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n"]
[135.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[135.002, "i", "sed -n '400,1200p' astropy/units/quantity.py\r"]
[135.004, "o", "sed -n '400,1200p' astropy/units/quantity.py\r\n"]
[135.006, "o", "\u001b[?2004l\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n            target = unit_shape_dtype[0]\r\n            shape_dtype = unit_shape_dtype[1:]\r\n        else:  # just unit\r\n            target = unit_shape_dtype\r\n            shape_dtype = ()\r\n\r\n        # Allowed unit/physical types. Errors if neither.\r\n        try:\r\n            unit = Unit(target)\r\n        except (TypeError, ValueError):\r\n            from astropy.units.physical import get_physical_type\r\n\r\n            try:\r\n                unit = get_physical_type(target)\r\n            except (TypeError, ValueError, KeyError):  # KeyError for Enum\r\n                raise TypeError(\r\n                    \"unit annotation is not a Unit or PhysicalType\"\r\n                ) from None\r\n\r\n        # Quantity does not (yet) properly extend the NumPy generics types,\r\n        # introduced in numpy v1.22+, instead just including the unit info as\r\n        # metadata using Annotated.\r\n        # TODO: ensure we do interact with NDArray.__class_getitem__.\r\n        return Annotated[cls, unit]\r\n\r\n    def __new__(\r\n        cls: type[Self],\r\n        value: QuantityLike,\r\n        unit=None,\r\n        dtype=np.inexact,\r\n        copy=True,\r\n        order=None,\r\n        subok=False,\r\n        ndmin=0,\r\n    ) -> Self:\r\n        if unit is not None:\r\n            # convert unit first, to avoid multiple string->unit conversions\r\n            unit = Unit(unit)\r\n\r\n        # inexact -> upcast to float dtype\r\n        float_default = dtype is np.inexact\r\n        if float_default:\r\n            dtype = None\r\n\r\n        # optimize speed for Quantity with no dtype given, copy=COPY_IF_NEEDED\r\n        if isinstance(value, Quantity):\r\n            if unit is not None and unit is not value.unit:\r\n                value = value.to(unit)\r\n                # the above already makes a copy (with float dtype)\r\n                copy = COPY_IF_NEEDED\r\n\r\n            if type(value) is not cls and not (subok and isinstance(value, cls)):\r\n                value = value.view(cls)\r\n\r\n            if float_default and value.dtype.kind in \"iu\":\r\n                dtype = float\r\n\r\n            return np.array(\r\n                value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n            )\r\n\r\n        # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\r\n        # To ensure array remains fast, we short-circuit it.\r\n        value_unit = None\r\n        if not isinstance(value, np.ndarray):\r\n            if isinstance(value, str):\r\n                # The first part of the regex string matches any integer/float;\r\n                # the second parts adds possible trailing .+-, which will break\r\n                # the float function below and ensure things like 1.2.3deg\r\n                # will not work.\r\n                pattern = (\r\n                    r\"\\s*[+-]?\"\r\n                    r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\r\n                    r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\r\n                    r\"([eE][+-]?\\d+)?\"\r\n                    r\"[.+-]?\"\r\n                )\r\n\r\n                v = re.match(pattern, value)\r\n                unit_string = None\r\n                try:\r\n                    value = float(v.group())\r\n\r\n                except Exception:\r\n                    raise TypeError(\r\n                        f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\r\n                        \"start with a number.\"\r\n                    )\r\n\r\n                unit_string = v.string[v.end() :].strip()\r\n                if unit_string:\r\n                    value_unit = Unit(unit_string)\r\n                    if unit is None:\r\n                        unit = value_unit  # signal no conversion needed below.\r\n\r\n            elif isinstance(value, (list, tuple)) and len(value) > 0:\r\n                if all(isinstance(v, Quantity) for v in value):\r\n                    # If a list/tuple contains only quantities, stack them,\r\n                    # which also converts them to the same unit.\r\n                    value = np.stack(value)\r\n                    copy = False\r\n\r\n                elif (\r\n                    dtype is None\r\n                    and not hasattr(value, \"dtype\")\r\n                    and isinstance(unit, StructuredUnit)\r\n                ):\r\n                    # Special case for list/tuple of values and a structured unit:\r\n                    # ``np.array(value, dtype=None)`` would treat tuples as lower\r\n                    # levels of the array, rather than as elements of a structured\r\n                    # array, so we use the structure of the unit to help infer the\r\n                    # structured dtype of the value.\r\n                    dtype = unit._recursively_get_dtype(value)\r\n\r\n        using_default_unit = False\r\n        if value_unit is None:\r\n            # If the value has a `unit` attribute and if not None\r\n            # (for Columns with uninitialized unit), treat it like a quantity.\r\n            value_unit = getattr(value, \"unit\", None)\r\n            if value_unit is None:\r\n                # Default to dimensionless for no (initialized) unit attribute.\r\n                if unit is None:\r\n                    using_default_unit = True\r\n                    unit = cls._default_unit\r\n                value_unit = unit  # signal below that no conversion is needed\r\n            else:\r\n                try:\r\n                    value_unit = Unit(value_unit)\r\n                except Exception as exc:\r\n                    raise TypeError(\r\n                        f\"The unit attribute {value.unit!r} of the input could \"\r\n                        \"not be parsed as an astropy Unit.\"\r\n                    ) from exc\r\n\r\n                if unit is None:\r\n                    unit = value_unit\r\n                elif unit is not value_unit:\r\n                    copy = COPY_IF_NEEDED  # copy will be made in conversion at end\r\n\r\n        value = np.array(\r\n            value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n        )\r\n\r\n        # For no-user-input unit, make sure the constructed unit matches the\r\n        # structure of the data.\r\n        if using_default_unit and value.dtype.names is not None:\r\n            unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\r\n\r\n        # check that array contains numbers or long int objects\r\n        if value.dtype.kind in \"OSU\" and not (\r\n            value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\r\n        ):\r\n            raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\r\n\r\n        # by default, cast any integer, boolean, etc., to float\r\n        if float_default and value.dtype.kind in \"iuO\":\r\n            value = value.astype(float)\r\n\r\n        # if we allow subclasses, allow a class from the unit.\r\n        if subok:\r\n            qcls = getattr(unit, \"_quantity_class\", cls)\r\n            if issubclass(qcls, cls):\r\n                cls = qcls\r\n\r\n        value = value.view(cls)\r\n        value._set_unit(value_unit)\r\n        if unit is value_unit:\r\n            return value\r\n        else:\r\n            # here we had non-Quantity input that had a \"unit\" attribute\r\n            # with a unit different from the desired one.  So, convert.\r\n            return value.to(unit)\r\n\r\n    def __array_finalize__(self, obj):\r\n        # Check whether super().__array_finalize should be called\r\n        # (sadly, ndarray.__array_finalize__ is None; we cannot be sure\r\n        # what is above us).\r\n        super_array_finalize = super().__array_finalize__\r\n        if super_array_finalize is not None:\r\n            super_array_finalize(obj)\r\n\r\n        # If we're a new object or viewing an ndarray, nothing has to be done.\r\n        if obj is None or obj.__class__ is np.ndarray:\r\n            return\r\n\r\n        # Copy over the unit and possibly info.  Note that the only way the\r\n        # unit can already be set is if one enters via _new_view(), where the\r\n        # unit is often different from that of self, and where propagation of\r\n        # info is not always desirable.\r\n        if self._unit is None:\r\n            unit = getattr(obj, \"_unit\", None)\r\n            if unit is not None:\r\n                self._set_unit(unit)\r\n\r\n            # Copy info if the original had `info` defined.  Because of the way the\r\n            # DataInfo works, `'info' in obj.__dict__` is False until the\r\n            # `info` attribute is accessed or set.\r\n            if \"info\" in obj.__dict__:\r\n                self.info = obj.info\r\n\r\n    def __array_wrap__(self, obj, context=None, return_scalar=False):\r\n        if context is None:\r\n            # Methods like .squeeze() created a new `ndarray` and then call\r\n            # __array_wrap__ to turn the array into self's subclass.\r\n            return self._new_view(obj)\r\n\r\n        raise NotImplementedError(\r\n            \"__array_wrap__ should not be used with a context any more since all \"\r\n            \"use should go through array_function. Please raise an issue on \"\r\n            \"https://github.com/astropy/astropy\"\r\n        )\r\n\r\n    def __array_ufunc__(self, function, method, *inputs, **kwargs):\r\n        \"\"\"Wrap numpy ufuncs, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            ufunc to wrap.\r\n        method : str\r\n            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\r\n        inputs : tuple\r\n            Input arrays.\r\n        kwargs : keyword arguments\r\n            As passed on, with ``out`` containing possible quantity output.\r\n\r\n        Returns\r\n        -------\r\n        result : `~astropy.units.Quantity` or `NotImplemented`\r\n            Results of the ufunc, with the unit set properly.\r\n        \"\"\"\r\n        # Determine required conversion functions -- to bring the unit of the\r\n        # input to that expected (e.g., radian for np.sin), or to get\r\n        # consistent units between two inputs (e.g., in np.add) --\r\n        # and the unit of the result (or tuple of units for nout > 1).\r\n        try:\r\n            converters, unit = converters_and_unit(function, method, *inputs)\r\n\r\n            out = kwargs.get(\"out\", None)\r\n            # Avoid loop back by turning any Quantity output into array views.\r\n            if out is not None:\r\n                # If pre-allocated output is used, check it is suitable.\r\n                # This also returns array view, to ensure we don't loop back.\r\n                if function.nout == 1:\r\n                    out = out[0]\r\n                out_array = check_output(out, unit, inputs, function=function)\r\n                # Ensure output argument remains a tuple.\r\n                kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\r\n\r\n            if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\r\n                # Special-case for initial argument for reductions like\r\n                # np.add.reduce.  This should be converted to the output unit as\r\n                # well, which is typically the same as the input unit (but can\r\n                # in principle be different: unitless for np.equal, radian\r\n                # for np.arctan2, though those are not necessarily useful!)\r\n                kwargs[\"initial\"] = self._to_own_unit(\r\n                    kwargs[\"initial\"], check_precision=False, unit=unit\r\n                )\r\n\r\n            # Same for inputs, but here also convert if necessary.\r\n            arrays = []\r\n            for input_, converter in zip(inputs, converters):\r\n                input_ = getattr(input_, \"value\", input_)\r\n                arrays.append(converter(input_) if converter else input_)\r\n\r\n            # Call our superclass's __array_ufunc__\r\n            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\r\n            # If unit is None, a plain array is expected (e.g., comparisons), which\r\n            # means we're done.\r\n            # We're also done if the result was None (for method 'at') or\r\n            # NotImplemented, which can happen if other inputs/outputs override\r\n            # __array_ufunc__; hopefully, they can then deal with us.\r\n            if unit is None or result is None or result is NotImplemented:\r\n                return result\r\n\r\n            return self._result_as_quantity(result, unit, out)\r\n\r\n        except (TypeError, ValueError, AttributeError) as e:\r\n            out_normalized = kwargs.get(\"out\", ())\r\n            inputs_and_outputs = inputs + out_normalized\r\n            ignored_ufunc = (\r\n                None,\r\n                np.ndarray.__array_ufunc__,\r\n                type(self).__array_ufunc__,\r\n            )\r\n            if not all(\r\n                getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\r\n                for io in inputs_and_outputs\r\n            ):\r\n                return NotImplemented\r\n            else:\r\n                raise e\r\n\r\n    def _result_as_quantity(self, result, unit, out):\r\n        \"\"\"Turn result into a quantity with the given unit.\r\n\r\n        If no output is given, it will take a view of the array as a quantity,\r\n        and set the unit.  If output is given, those should be quantity views\r\n        of the result arrays, and the function will just set the unit.\r\n\r\n        Parameters\r\n        ----------\r\n        result : ndarray or tuple thereof\r\n            Array(s) which need to be turned into quantity.\r\n        unit : `~astropy.units.Unit`\r\n            Unit for the quantities to be returned (or `None` if the result\r\n            should not be a quantity).  Should be tuple if result is a tuple.\r\n        out : `~astropy.units.Quantity` or None\r\n            Possible output quantity. Should be `None` or a tuple if result\r\n            is a tuple.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n           With units set.\r\n        \"\"\"\r\n        if isinstance(result, (tuple, list)):\r\n            if out is None:\r\n                out = (None,) * len(result)\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n        # ``obj.__class is np.ndarray``. So, not worth special-casing.\r\n        if obj is None:\r\n            obj = self.view(np.ndarray)\r\n        else:\r\n            obj = np.array(obj, copy=COPY_IF_NEEDED, subok=True)\r\n\r\n        # Take the view, set the unit, and update possible other properties\r\n        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\r\n        view = obj.view(quantity_subclass)\r\n        view._set_unit(unit)\r\n        view.__array_finalize__(self)\r\n        if propagate_info and \"info\" in self.__dict__:\r\n            view.info = self.info\r\n        return view\r\n\r\n    def _set_unit(self, unit):\r\n        \"\"\"Set the unit.\r\n\r\n        This is used anywhere the unit is set or modified, i.e., in the\r\n        initializer, in ``__imul__`` and ``__itruediv__`` for in-place\r\n        multiplication and division by another unit, as well as in\r\n        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\r\n        sets the unit, but subclasses can override it to check that, e.g.,\r\n        a unit is consistent.\r\n        \"\"\"\r\n        if not isinstance(unit, UnitBase):\r\n            if isinstance(self._unit, StructuredUnit) or isinstance(\r\n                unit, StructuredUnit\r\n            ):\r\n                unit = StructuredUnit(unit, self.dtype)\r\n            else:\r\n                # Trying to go through a string ensures that, e.g., Magnitudes with\r\n                # dimensionless physical unit become Quantity with units of mag.\r\n                unit = Unit(str(unit), parse_strict=\"silent\")\r\n                if not isinstance(unit, (UnitBase, StructuredUnit)):\r\n                    raise UnitTypeError(\r\n                        f\"{self.__class__.__name__} instances require normal units, \"\r\n                        f\"not {unit.__class__} instances.\"\r\n                    )\r\n\r\n        self._unit = unit\r\n\r\n    def __deepcopy__(self, memo):\r\n        # If we don't define this, ``copy.deepcopy(quantity)`` will\r\n        # return a bare Numpy array.\r\n        return self.copy()\r\n\r\n    def __reduce__(self):\r\n        # patch to pickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        object_state = list(super().__reduce__())\r\n        object_state[2] = (object_state[2], self.__dict__)\r\n        return tuple(object_state)\r\n\r\n    def __setstate__(self, state):\r\n        # patch to unpickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        nd_state, own_state = state\r\n        super().__setstate__(nd_state)\r\n        self.__dict__.update(own_state)\r\n\r\n    info = QuantityInfo()\r\n\r\n    def _to_value(self, unit, equivalencies=[]):\r\n        \"\"\"Helper method for to and to_value.\"\"\"\r\n        if equivalencies == []:\r\n            equivalencies = self._equivalencies\r\n        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\r\n            # Standard path, let unit to do work.\r\n            return self.unit.to(\r\n                unit, self.view(np.ndarray), equivalencies=equivalencies\r\n            )\r\n\r\n        else:\r\n            # The .to() method of a simple unit cannot convert a structured\r\n            # dtype, so we work around it, by recursing.\r\n            # TODO: deprecate this?\r\n            # Convert simple to Structured on initialization?\r\n            result = np.empty_like(self.view(np.ndarray))\r\n            for name in self.dtype.names:\r\n                result[name] = self[name]._to_value(unit, equivalencies)\r\n            return result\r\n\r\n    def to(self, unit, equivalencies=[], copy=True):\r\n        \"\"\"\r\n        Return a new `~astropy.units.Quantity` object with the specified unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like\r\n            An object that represents the unit to convert to. Must be\r\n            an `~astropy.units.UnitBase` object or a string parseable\r\n            by the `~astropy.units` package.\r\n\r\n        equivalencies : list of tuple\r\n            A list of equivalence pairs to try if the units are not\r\n            directly convertible.  See :ref:`astropy:unit_equivalencies`.\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n            (none for `~astropy.units.Quantity`, but may be set for subclasses)\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        copy : bool, optional\r\n            If `True` (default), then the value is copied.  Otherwise, a copy\r\n            will only be made if necessary.\r\n\r\n        See Also\r\n        --------\r\n        to_value : get the numerical value in a given unit.\r\n        \"\"\"\r\n        # We don't use `to_value` below since we always want to make a copy\r\n        # and don't want to slow down this method (esp. the scalar case).\r\n        unit = Unit(unit)\r\n        if copy:\r\n            # Avoid using to_value to ensure that we make a copy. We also\r\n            # don't want to slow down this method (esp. the scalar case).\r\n            value = self._to_value(unit, equivalencies)\r\n        else:\r\n            # to_value only copies if necessary\r\n            value = self.to_value(unit, equivalencies)\r\n        return self._new_view(value, unit)\r\n\r\n    def to_value(self, unit=None, equivalencies=[]):\r\n        \"\"\"\r\n        The numerical value, possibly in a different unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            The unit in which the value should be given. If not given or `None`,\r\n            use the current unit.\r\n\r\n        equivalencies : list of tuple, optional\r\n            A list of equivalence pairs to try if the units are not directly\r\n            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\r\n            or ``[]``, class default equivalencies will be used (none for\r\n            `~astropy.units.Quantity`, but may be set for subclasses).\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        Returns\r\n        -------\r\n        value : ndarray or scalar\r\n            The value in the units specified. For arrays, this will be a view\r\n            of the data if no unit conversion was necessary.\r\n\r\n        See Also\r\n        --------\r\n        to : Get a new instance in a different unit.\r\n        \"\"\"\r\n        if unit is None or unit is self.unit:\r\n            value = self.view(np.ndarray)\r\n        elif not self.dtype.names:\r\n            # For non-structured, we attempt a short-cut, where we just get\r\n            # the scale.  If that is 1, we do not have to do anything.\r\n            unit = Unit(unit)\r\n            # We want a view if the unit does not change.  One could check\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n            # TODO: would be better for `unit.to` to have an in-place flag.\r\n            try:\r\n                scale = self.unit._to(unit)\r\n            except Exception:\r\n                # Short-cut failed; try default (maybe equivalencies help).\r\n                value = self._to_value(unit, equivalencies)\r\n            else:\r\n                value = self.view(np.ndarray)\r\n                if not is_effectively_unity(scale):\r\n                    # not in-place!\r\n                    value = value * scale\r\n        else:\r\n            # For structured arrays, we go the default route.\r\n            value = self._to_value(unit, equivalencies)\r\n\r\n        # Index with empty tuple to decay array scalars in to numpy scalars.\r\n        return value if value.shape else value[()]\r\n\r\n    value = property(\r\n        to_value,\r\n        doc=\"\"\"The numerical value of this instance.\r\n\r\n    See also\r\n    --------\r\n    to_value : Get the numerical value in a given unit.\r\n    \"\"\",\r\n    )\r\n\r\n    @property\r\n    def unit(self):\r\n        \"\"\"\r\n        A `~astropy.units.UnitBase` object representing the unit of this\r\n        quantity.\r\n        \"\"\"\r\n        return self._unit\r\n\r\n    @property\r\n    def equivalencies(self):\r\n        \"\"\"\r\n        A list of equivalencies that will be applied by default during\r\n        unit conversions.\r\n        \"\"\"\r\n        return self._equivalencies\r\n\r\n    def _recursively_apply(self, func):\r\n        \"\"\"Apply function recursively to every field.\r\n\r\n        Returns a copy with the result.\r\n        \"\"\"\r\n        result = np.empty_like(self)\r\n        result_value = result.view(np.ndarray)\r\n        result_unit = ()\r\n        for name in self.dtype.names:\r\n            part = func(self[name])\r\n            result_value[name] = part.value\r\n            result_unit += (part.unit,)\r\n\r\n        result._set_unit(result_unit)\r\n        return result\r\n\r\n    @property\r\n    def si(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with SI units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"si\"))\r\n        si_unit = self.unit.si\r\n        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\r\n\r\n    @property\r\n    def cgs(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with CGS units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"cgs\"))\r\n        cgs_unit = self.unit.cgs\r\n        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\r\n\r\n    @property\r\n    def isscalar(self):\r\n        \"\"\"\r\n        True if the `value` of this quantity is a scalar, or False if it\r\n        is an array-like object.\r\n\r\n        .. note::\r\n            This is subtly different from `numpy.isscalar` in that\r\n            `numpy.isscalar` returns False for a zero-dimensional array\r\n            (e.g. ``np.array(1)``), while this is True for quantities,\r\n            since quantities cannot represent true numpy scalars.\r\n        \"\"\"\r\n        return not self.shape\r\n\r\n    # This flag controls whether convenience conversion members, such\r\n    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\r\n    # not turned on on Quantity itself, but is on some subclasses of\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n    _include_easy_conversion_members = False\r\n\r\n    def __dir__(self):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.  This function is implemented in\r\n        order to make autocompletion still work correctly in IPython.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            return super().__dir__()\r\n\r\n        dir_values = set(super().__dir__())\r\n        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\r\n        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\r\n            dir_values.update(equivalent.names)\r\n        return sorted(dir_values)\r\n\r\n    def __getattr__(self, attr):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            raise AttributeError(\r\n                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\r\n            )\r\n\r\n        def get_virtual_unit_attribute():\r\n            registry = get_current_unit_registry().registry\r\n            to_unit = registry.get(attr, None)\r\n            if to_unit is None:\r\n                return None\r\n\r\n            try:\r\n                return self.unit.to(\r\n                    to_unit, self.value, equivalencies=self.equivalencies\r\n                )\r\n            except UnitsError:\r\n                return None\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n"]
[140.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[140.002, "i", "sed -n '1200,2000p' astropy/units/quantity.py\r"]
[140.004, "o", "sed -n '1200,2000p' astropy/units/quantity.py\r\n"]
[140.006, "o", "\u001b[?2004l\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n            # so they should raise a TypeError rather than an IndexError.\r\n            if self.isscalar:\r\n                raise TypeError(\r\n                    f\"'{self.__class__.__name__}' object with a scalar value \"\r\n                    \"does not support indexing\"\r\n                )\r\n            else:\r\n                raise\r\n        # For single elements, ndarray.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if not isinstance(out, np.ndarray):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def __setitem__(self, i, value):\r\n        if isinstance(i, str):\r\n            # Indexing will cause a different unit, so by doing this in\r\n            # two steps we effectively try with the right unit.\r\n            self[i][...] = value\r\n            return\r\n\r\n        # update indices in info if the info property has been accessed\r\n        # (in which case 'info' in self.__dict__ is True; this is guaranteed\r\n        # to be the case if we're part of a table).\r\n        if not self.isscalar and \"info\" in self.__dict__:\r\n            self.info.adjust_indices(i, value, len(self))\r\n        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\r\n\r\n    # __contains__ is OK\r\n\r\n    def __bool__(self):\r\n        \"\"\"This method raises ValueError, since truthiness of quantities is ambiguous,\r\n        especially for logarithmic units and temperatures. Use explicit comparisons.\r\n        \"\"\"\r\n        raise ValueError(\r\n            f\"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units\"\r\n            \" and temperatures. Use explicit comparisons.\"\r\n        )\r\n\r\n    def __len__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\r\n            )\r\n        else:\r\n            return len(self.value)\r\n\r\n    # Numerical types\r\n    def __float__(self):\r\n        try:\r\n            return float(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __int__(self):\r\n        try:\r\n            return int(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __index__(self):\r\n        # for indices, we do not want to mess around with scaling at all,\r\n        # so unlike for float, int, we insist here on unscaled dimensionless\r\n        try:\r\n            assert self.unit.is_unity()\r\n            return self.value.__index__()\r\n        except Exception:\r\n            raise TypeError(\r\n                \"only integer dimensionless scalar quantities \"\r\n                \"can be converted to a Python index\"\r\n            )\r\n\r\n    # TODO: we may want to add a hook for dimensionless quantities?\r\n    @property\r\n    def _unitstr(self):\r\n        if self.unit is None:\r\n            unitstr = _UNIT_NOT_INITIALISED\r\n        else:\r\n            unitstr = str(self.unit)\r\n\r\n        if unitstr:\r\n            unitstr = \" \" + unitstr\r\n\r\n        return unitstr\r\n\r\n    def to_string(\r\n        self, unit=None, precision=None, format=None, subfmt=None, *, formatter=None\r\n    ):\r\n        \"\"\"\r\n        Generate a string representation of the quantity and its unit.\r\n\r\n        The behavior of this function can be altered via the\r\n        `numpy.set_printoptions` function and its various keywords.  The\r\n        exception to this is the ``threshold`` keyword, which is controlled via\r\n        the ``[units.quantity]`` configuration item ``latex_array_threshold``.\r\n        This is treated separately because the numpy default of 1000 is too big\r\n        for most browsers to handle.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            Specifies the unit.  If not provided,\r\n            the unit used to initialize the quantity will be used.\r\n\r\n        precision : number, optional\r\n            The level of decimal precision. If `None`, or not provided,\r\n            it will be determined from NumPy print options.\r\n\r\n        format : str, optional\r\n            The format of the result. If not provided, an unadorned\r\n            string is returned. Supported values are:\r\n\r\n            - 'latex': Return a LaTeX-formatted string\r\n\r\n            - 'latex_inline': Return a LaTeX-formatted string that uses\r\n              negative exponents instead of fractions\r\n\r\n        formatter : str, callable, dict, optional\r\n            The formatter to use for the value. If a string, it should be a\r\n            valid format specifier using Python's mini-language. If a callable,\r\n            it will be treated as the default formatter for all values and will\r\n            overwrite default Latex formatting for exponential notation and complex\r\n            numbers. If a dict, it should map a specific type to a callable to be\r\n            directly passed into `numpy.array2string`. If not provided, the default\r\n            formatter will be used.\r\n\r\n        subfmt : str, optional\r\n            Subformat of the result. For the moment, only used for\r\n            ``format='latex'`` and ``format='latex_inline'``. Supported\r\n            values are:\r\n\r\n            - 'inline': Use ``$ ... $`` as delimiters.\r\n\r\n            - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\r\n\r\n        Returns\r\n        -------\r\n        str\r\n            A string with the contents of this Quantity\r\n        \"\"\"\r\n        if unit is not None and unit != self.unit:\r\n            return self.to(unit).to_string(\r\n                unit=None,\r\n                precision=precision,\r\n                format=format,\r\n                subfmt=subfmt,\r\n                formatter=formatter,\r\n            )\r\n\r\n        if format is None and formatter is None and precision is None:\r\n            # Use default formatting settings\r\n            return f\"{self.value}{self._unitstr:s}\"\r\n\r\n        formats = {\r\n            None: None,\r\n            \"latex\": {\r\n                None: (\"$\", \"$\"),\r\n                \"inline\": (\"$\", \"$\"),\r\n                \"display\": (r\"$\\displaystyle \", r\"$\"),\r\n            },\r\n        }\r\n        formats[\"latex_inline\"] = formats[\"latex\"]\r\n\r\n        if format not in formats:\r\n            raise ValueError(f\"Unknown format '{format}'\")\r\n\r\n        format_spec = formatter if isinstance(formatter, str) else None\r\n\r\n        if format is None:\r\n            if format_spec is not None:\r\n\r\n                def formatter(value):\r\n                    return builtins.format(value, format_spec)\r\n\r\n            if callable(formatter):\r\n                formatter = {\"all\": formatter}\r\n\r\n            return (\r\n                np.array2string(\r\n                    self.value,\r\n                    precision=precision,\r\n                    floatmode=\"fixed\",\r\n                    formatter=formatter,\r\n                )\r\n                + self._unitstr\r\n            )\r\n\r\n        # else, for the moment we assume format=\"latex\" or \"latex_inline\".\r\n\r\n        # Set the precision if set, otherwise use numpy default\r\n        pops = np.get_printoptions()\r\n        if format_spec is None:\r\n            format_spec = (\r\n                f\".{precision if precision is not None else pops['precision']}g\"\r\n            )\r\n\r\n        # Use default formatters\r\n        if formatter is None or isinstance(formatter, str):\r\n            # Filter width and alignment operations for latex\r\n            # [[fill]align][sign][\"z\"][\"#\"][\"0\"][width][grouping_option][\".\" precision][type]\r\n            format_spec = re.sub(\r\n                r\"(.*?)([+\\- ]?)(\\d+)?(,)?(\\.\\d+)?([a-zA-Z%]+)?$\",\r\n                r\"\\2\\5\\6\",\r\n                format_spec,\r\n            )\r\n\r\n            if self.dtype.kind == \"c\":  # Complex default latex formatter\r\n                # Disallow sign operations for the imaginary part\r\n                imag_format_spec = re.sub(r\"[+\\- ]\", \"\", format_spec)\r\n\r\n                def formatter(value):\r\n                    return \"({}{}i)\".format(\r\n                        Latex.format_exponential_notation(\r\n                            value.real, format_spec=format_spec\r\n                        ),\r\n                        Latex.format_exponential_notation(\r\n                            value.imag, format_spec=\"+\" + imag_format_spec\r\n                        ),\r\n                    )\r\n\r\n            else:  # Float default latex formatter\r\n\r\n                def formatter(value):\r\n                    return Latex.format_exponential_notation(\r\n                        value, format_spec=format_spec\r\n                    )\r\n\r\n        if callable(formatter):\r\n            formatter = {\"all\": formatter}\r\n\r\n        # The view is needed for the scalar case - self.value might be float.\r\n        latex_value = np.array2string(\r\n            self.view(np.ndarray),\r\n            threshold=(\r\n                conf.latex_array_threshold\r\n                if conf.latex_array_threshold > -1\r\n                else pops[\"threshold\"]\r\n            ),\r\n            formatter=formatter,\r\n            max_line_width=np.inf,\r\n            separator=\",~\",\r\n        )\r\n\r\n        latex_value = latex_value.replace(\"...\", r\"\\dots\")\r\n\r\n        # Format unit\r\n        # [1:-1] strips the '$' on either side needed for math mode\r\n        if self.unit is None:\r\n            latex_unit = _UNIT_NOT_INITIALISED\r\n        elif format == \"latex\":\r\n            latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\r\n        elif format == \"latex_inline\":\r\n            latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\r\n\r\n        delimiter_left, delimiter_right = formats[format][subfmt]\r\n\r\n        # Add a space in front except for super-script units like degrees.\r\n        if not latex_unit.removeprefix(\"\\\\mathrm{\").startswith(\"{}^\"):\r\n            latex_unit = rf\" \\; {latex_unit}\"\r\n\r\n        return rf\"{delimiter_left}{latex_value}{latex_unit}{delimiter_right}\"\r\n\r\n    def __str__(self):\r\n        return self.to_string()\r\n\r\n    def __repr__(self):\r\n        prefixstr = \"<\" + self.__class__.__name__ + \" \"\r\n        arrstr = np.array2string(\r\n            self.view(np.ndarray), separator=\", \", prefix=prefixstr\r\n        )\r\n        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\r\n\r\n    def _repr_latex_(self):\r\n        \"\"\"\r\n        Generate a latex representation of the quantity and its unit.\r\n\r\n        Returns\r\n        -------\r\n        lstr\r\n            A LaTeX string with the contents of this Quantity\r\n        \"\"\"\r\n        # NOTE: This should change to display format in a future release\r\n        return self.to_string(format=\"latex\", subfmt=\"inline\")\r\n\r\n    def __format__(self, format_spec):\r\n        try:\r\n            return self.to_string(format=format_spec)\r\n        except ValueError:\r\n            # We might have a unit format not implemented in `to_string()`.\r\n            if format_spec in Base.registry:\r\n                if self.unit is dimensionless_unscaled:\r\n                    return f\"{self.value}\"\r\n                else:\r\n                    return f\"{self.value} {format(self.unit, format_spec)}\"\r\n            # Can the value be formatted on its own?\r\n            try:\r\n                return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\r\n            except ValueError:\r\n                # Format the whole thing as a single string.\r\n                return format(f\"{self.value}{self._unitstr:s}\", format_spec)\r\n\r\n    def decompose(self, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units\r\n        decomposed. Decomposed units have only irreducible units in\r\n        them (see `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        bases : sequence of `~astropy.units.UnitBase`, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n        \"\"\"\r\n        return self._decompose(False, bases=bases)\r\n\r\n    def _decompose(self, allowscaledunits=False, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units decomposed. Decomposed\r\n        units have only irreducible units in them (see\r\n        `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        allowscaledunits : bool\r\n            If True, the resulting `Quantity` may have a scale factor\r\n            associated with it.  If False, any scaling in the unit will\r\n            be subsumed into the value of the resulting `Quantity`\r\n\r\n        bases : sequence of UnitBase, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n\r\n        \"\"\"\r\n        new_unit = self.unit.decompose(bases=bases)\r\n\r\n        # Be careful here because self.value usually is a view of self;\r\n        # be sure that the original value is not being modified.\r\n        if not allowscaledunits and hasattr(new_unit, \"scale\"):\r\n            new_value = self.value * new_unit.scale\r\n            new_unit = new_unit / new_unit.scale\r\n            return self._new_view(new_value, new_unit)\r\n        else:\r\n            return self._new_view(self.copy(), new_unit)\r\n\r\n    # These functions need to be overridden to take into account the units\r\n    # Array conversion\r\n    # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\r\n\r\n    def item(self, *args):\r\n        \"\"\"Copy an element of an array to a scalar Quantity and return it.\r\n\r\n        Like :meth:`~numpy.ndarray.item` except that it always\r\n        returns a `Quantity`, not a Python scalar.\r\n\r\n        \"\"\"\r\n        return self._new_view(super().item(*args))\r\n\r\n    def tolist(self):\r\n        raise NotImplementedError(\r\n            \"cannot make a list of Quantities. Get list of values with\"\r\n            \" q.value.tolist().\"\r\n        )\r\n\r\n    def _to_own_unit(self, value, check_precision=True, *, unit=None):\r\n        \"\"\"Convert value to one's own unit (or that given).\r\n\r\n        Here, non-quantities are treated as dimensionless, and care is taken\r\n        for values of 0, infinity or nan, which are allowed to have any unit.\r\n\r\n        Parameters\r\n        ----------\r\n        value : anything convertible to `~astropy.units.Quantity`\r\n            The value to be converted to the requested unit.\r\n        check_precision : bool\r\n            Whether to forbid conversion of float to integer if that changes\r\n            the input number.  Default: `True`.\r\n        unit : `~astropy.units.Unit` or None\r\n            The unit to convert to.  By default, the unit of ``self``.\r\n\r\n        Returns\r\n        -------\r\n        value : number or `~numpy.ndarray`\r\n            In the requested units.\r\n\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        try:\r\n            _value = value.to_value(unit)\r\n        except AttributeError:\r\n            # We're not a Quantity.\r\n            # First remove two special cases (with a fast test):\r\n            # 1) Maybe masked printing? MaskedArray with quantities does not\r\n            # work very well, but no reason to break even repr and str.\r\n            # 2) np.ma.masked? useful if we're a MaskedQuantity.\r\n            if value is np.ma.masked or (\r\n                value is np.ma.masked_print_option and self.dtype.kind == \"O\"\r\n            ):\r\n                return value\r\n            # Now, let's try a more general conversion.\r\n            # Plain arrays will be converted to dimensionless in the process,\r\n            # but anything with a unit attribute will use that.\r\n            try:\r\n                as_quantity = Quantity(value)\r\n                _value = as_quantity.to_value(unit)\r\n            except UnitsError:\r\n                # last chance: if this was not something with a unit\r\n                # and is all 0, inf, or nan, we treat it as arbitrary unit.\r\n                if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\r\n                    as_quantity.value\r\n                ):\r\n                    _value = as_quantity.value\r\n                else:\r\n                    raise\r\n\r\n        if self.dtype.kind == \"i\" and check_precision:\r\n            # If, e.g., we are casting float to int, we want to fail if\r\n            # precision is lost, but let things pass if it works.\r\n            _value = np.array(_value, copy=COPY_IF_NEEDED, subok=True)\r\n            if not np.can_cast(_value.dtype, self.dtype):\r\n                self_dtype_array = np.array(_value, self.dtype, subok=True)\r\n                if not np.all((self_dtype_array == _value) | np.isnan(_value)):\r\n                    raise TypeError(\r\n                        \"cannot convert value type to array type without precision loss\"\r\n                    )\r\n\r\n        # Setting names to ensure things like equality work (note that\r\n        # above will have failed already if units did not match).\r\n        # TODO: is this the best place to do this?\r\n        if _value.dtype.names is not None:\r\n            _value = _value.astype(self.dtype, copy=False)\r\n        return _value\r\n\r\n    if NUMPY_LT_2_0:\r\n\r\n        def itemset(self, *args):\r\n            if len(args) == 0:\r\n                raise ValueError(\"itemset must have at least one argument\")\r\n\r\n            self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\r\n\r\n    def tostring(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tostring()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to string.  Write array with\"\r\n            \" q.value.tostring(...).\"\r\n        )\r\n\r\n    def tobytes(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tobytes()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\r\n        )\r\n\r\n    def tofile(self, fid, sep=\"\", format=\"%s\"):\r\n        \"\"\"Not implemented, use ``.value.tofile()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\r\n        )\r\n\r\n    def dump(self, file):\r\n        \"\"\"Not implemented, use ``.value.dump()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to file.  Write array with q.value.dump()\"\r\n        )\r\n\r\n    def dumps(self):\r\n        \"\"\"Not implemented, use ``.value.dumps()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\r\n        )\r\n\r\n    # astype, byteswap, copy, view, getfield, setflags OK as is\r\n\r\n    def fill(self, value):\r\n        self.view(np.ndarray).fill(self._to_own_unit(value))\r\n\r\n    # Shape manipulation: resize cannot be done (does not own data), but\r\n    # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\r\n    # the flat iterator needs to be overwritten, otherwise single items are\r\n    # returned as numbers.\r\n    @property\r\n    def flat(self):\r\n        \"\"\"A 1-D iterator over the Quantity array.\r\n\r\n        This returns a ``QuantityIterator`` instance, which behaves the same\r\n        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\r\n        and is similar to, but not a subclass of, Python's built-in iterator\r\n        object.\r\n        \"\"\"\r\n        return QuantityIterator(self)\r\n\r\n    @flat.setter\r\n    def flat(self, value):\r\n        y = self.ravel()\r\n        y[:] = value\r\n\r\n    # Item selection and manipulation\r\n    # repeat, sort, compress, diagonal OK\r\n    def take(self, indices, axis=None, out=None, mode=\"raise\"):\r\n        out = super().take(indices, axis=axis, out=out, mode=mode)\r\n        # For single elements, ndarray.take returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if type(out) is not type(self):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def put(self, indices, values, mode=\"raise\"):\r\n        self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\r\n\r\n    def choose(self, choices, out=None, mode=\"raise\"):\r\n        raise NotImplementedError(\r\n            \"cannot choose based on quantity.  Choose using array with\"\r\n            \" q.value.choose(...)\"\r\n        )\r\n\r\n    # ensure we do not return indices as quantities\r\n    if NUMPY_LT_2_0:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None):\r\n            return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\r\n\r\n    else:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None, *, stable=None):\r\n            return self.view(np.ndarray).argsort(\r\n                axis=axis, kind=kind, order=order, stable=stable\r\n            )\r\n\r\n    def searchsorted(self, v, *args, **kwargs):\r\n        return np.searchsorted(\r\n            np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\r\n        )  # avoid numpy 1.6 problem\r\n\r\n    def argmax(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def argmin(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def __array_function__(self, function, types, args, kwargs):\r\n        \"\"\"Wrap numpy functions, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap\r\n        types : iterable of classes\r\n            Classes that provide an ``__array_function__`` override. Can\r\n            in principle be used to interact with other classes. Below,\r\n            mostly passed on to `~numpy.ndarray`, which can only interact\r\n            with subclasses.\r\n        args : tuple\r\n            Positional arguments provided in the function call.\r\n        kwargs : dict\r\n            Keyword arguments provided in the function call.\r\n\r\n        Returns\r\n        -------\r\n        result: `~astropy.units.Quantity`, `~numpy.ndarray`\r\n            As appropriate for the function.  If the function is not\r\n            supported, `NotImplemented` is returned, which will lead to\r\n            a `TypeError` unless another argument overrode the function.\r\n\r\n        Raises\r\n        ------\r\n        ~astropy.units.UnitsError\r\n            If operands have incompatible units.\r\n        \"\"\"\r\n        # A function should be in one of the following sets or dicts:\r\n        # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\r\n        #    supports Quantity; we pass on to ndarray.__array_function__.\r\n        # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\r\n        #    after converting quantities to arrays with suitable units,\r\n        #    and possibly setting units on the result.\r\n        # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\r\n        #    requires a Quantity-specific implementation.\r\n        # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\r\n        # For now, since we may not yet have complete coverage, if a\r\n        # function is in none of the above, we simply call the numpy\r\n        # implementation.\r\n        if function in SUBCLASS_SAFE_FUNCTIONS:\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        elif function in FUNCTION_HELPERS:\r\n            function_helper = FUNCTION_HELPERS[function]\r\n            try:\r\n                args, kwargs, unit, out = function_helper(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            result = super().__array_function__(function, types, args, kwargs)\r\n            # Fall through to return section\r\n\r\n        elif function in DISPATCHED_FUNCTIONS:\r\n            dispatched_function = DISPATCHED_FUNCTIONS[function]\r\n            try:\r\n                result, unit, out = dispatched_function(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            # Fall through to return section\r\n\r\n        elif function in UNSUPPORTED_FUNCTIONS:\r\n            return NotImplemented\r\n\r\n        else:\r\n            warnings.warn(\r\n                f\"function '{function.__name__}' is not known to astropy's Quantity.\"\r\n                \" Will run it anyway, hoping it will treat ndarray subclasses\"\r\n                \" correctly. Please raise an issue at\"\r\n                \" https://github.com/astropy/astropy/issues.\",\r\n                AstropyWarning,\r\n            )\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        # If unit is None, a plain array is expected (e.g., boolean), which\r\n        # means we're done.\r\n        # We're also done if the result was NotImplemented, which can happen\r\n        # if other inputs/outputs override __array_function__;\r\n        # hopefully, they can then deal with us.\r\n        if unit is None or result is NotImplemented:\r\n            return result\r\n\r\n        return self._result_as_quantity(result, unit, out=out)\r\n\r\n    def _not_implemented_or_raise(self, function, types):\r\n        # Our function helper or dispatcher found that the function does not\r\n        # work with Quantity.  In principle, there may be another class that\r\n        # knows what to do with us, for which we should return NotImplemented.\r\n        # But if there is ndarray (or a non-Quantity subclass of it) around,\r\n        # it quite likely coerces, so we should just break.\r\n        if any(\r\n            issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\r\n        ):\r\n            raise TypeError(\r\n                f\"the Quantity implementation cannot handle {function} \"\r\n                \"with the given arguments.\"\r\n            ) from None\r\n        else:\r\n            return NotImplemented\r\n\r\n    # Calculation -- override ndarray methods to take into account units.\r\n    # We use the corresponding numpy functions to evaluate the results, since\r\n    # the methods do not always allow calling with keyword arguments.\r\n    # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\r\n    # TypeError: 'a_max' is an invalid keyword argument for this function.\r\n    def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\r\n        \"\"\"Wrap a numpy function that processes self, returning a Quantity.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap.\r\n        args : positional arguments\r\n            Any positional arguments to the function beyond the first argument\r\n            (which will be set to ``self``).\r\n        kwargs : keyword arguments\r\n            Keyword arguments to the function.\r\n\r\n        If present, the following arguments are treated specially:\r\n\r\n        unit : `~astropy.units.Unit`\r\n            Unit of the output result.  If not given, the unit of ``self``.\r\n        out : `~astropy.units.Quantity`\r\n            A Quantity instance in which to store the output.\r\n\r\n        Notes\r\n        -----\r\n        Output should always be assigned via a keyword argument, otherwise\r\n        no proper account of the unit is taken.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            Result of the function call, with the unit set properly.\r\n        \"\"\"\r\n        if unit is None:\r\n"]
[145.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[145.002, "i", "cat asv.ci.conf.json\r"]
[145.004, "o", "cat asv.ci.conf.json\r\n"]
[145.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[150.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[150.002, "i", "sed -n '1,240p' astropy-benchmarks/benchmarks/units.py\r"]
[150.004, "o", "sed -n '1,240p' astropy-benchmarks/benchmarks/units.py\r\n"]
[150.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[155.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[155.002, "i", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r"]
[155.004, "o", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r\n"]
[155.006, "o", "_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\"\r\n\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: argument {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages}: invalid choice: 'dev' (choose from 'help', 'quickstart', 'machine', 'setup', 'run', 'continuous', 'find', 'rm', 'publish', 'preview', 'profile', 'update', 'show', 'compare', 'check', 'gh-pages')\r\n"]
[160.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[160.002, "i", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r"]
[160.004, "o", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[160.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[165.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[165.002, "i", "sed -n '1,400p' astropy/units/quantity.py\r"]
[165.004, "o", "sed -n '1,400p' astropy/units/quantity.py\r\n"]
[165.006, "o", "\u001b[?2004l\r\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\r\n\"\"\"\r\nThis module defines the `Quantity` object, which represents a number with some\r\nassociated units. `Quantity` objects support operations like ordinary numbers,\r\nbut will deal with unit conversions internally.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport builtins\r\nimport numbers\r\nimport operator\r\nimport re\r\nimport warnings\r\nfrom fractions import Fraction\r\nfrom typing import TYPE_CHECKING\r\n\r\nimport numpy as np\r\n\r\nfrom astropy import config as _config\r\nfrom astropy.utils.compat.numpycompat import COPY_IF_NEEDED, NUMPY_LT_2_0\r\nfrom astropy.utils.data_info import ParentDtypeInfo\r\nfrom astropy.utils.exceptions import AstropyWarning\r\n\r\nfrom .core import (\r\n    Unit,\r\n    UnitBase,\r\n    UnitConversionError,\r\n    UnitsError,\r\n    UnitTypeError,\r\n    dimensionless_unscaled,\r\n    get_current_unit_registry,\r\n)\r\nfrom .format import Base, Latex\r\nfrom .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\r\nfrom .quantity_helper.function_helpers import (\r\n    DISPATCHED_FUNCTIONS,\r\n    FUNCTION_HELPERS,\r\n    SUBCLASS_SAFE_FUNCTIONS,\r\n    UNSUPPORTED_FUNCTIONS,\r\n)\r\nfrom .structured import StructuredUnit, _structured_unit_like_dtype\r\nfrom .utils import is_effectively_unity\r\n\r\nif TYPE_CHECKING:\r\n    from typing_extensions import Self\r\n\r\n    from .typing import QuantityLike\r\n\r\n__all__ = [\r\n    \"Quantity\",\r\n    \"SpecificTypeQuantity\",\r\n    \"QuantityInfoBase\",\r\n    \"QuantityInfo\",\r\n    \"allclose\",\r\n    \"isclose\",\r\n]\r\n\r\n\r\n# We don't want to run doctests in the docstrings we inherit from Numpy\r\n__doctest_skip__ = [\"Quantity.*\"]\r\n\r\n_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\r\n_UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\r\n\r\n\r\nclass Conf(_config.ConfigNamespace):\r\n    \"\"\"\r\n    Configuration parameters for Quantity.\r\n    \"\"\"\r\n\r\n    latex_array_threshold = _config.ConfigItem(\r\n        100,\r\n        \"The maximum size an array Quantity can be before its LaTeX \"\r\n        'representation for IPython gets \"summarized\" (meaning only the first '\r\n        'and last few elements are shown with \"...\" between). Setting this to a '\r\n        \"negative number means that the value will instead be whatever numpy \"\r\n        \"gets from get_printoptions.\",\r\n    )\r\n\r\n\r\nconf = Conf()\r\n\r\n\r\nclass QuantityIterator:\r\n    \"\"\"\r\n    Flat iterator object to iterate over Quantities.\r\n\r\n    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\r\n    ``q``.  It allows iterating over the array as if it were a 1-D array,\r\n    either in a for-loop or by calling its `next` method.\r\n\r\n    Iteration is done in C-contiguous style, with the last index varying the\r\n    fastest. The iterator can also be indexed using basic slicing or\r\n    advanced indexing.\r\n\r\n    See Also\r\n    --------\r\n    Quantity.flatten : Returns a flattened copy of an array.\r\n\r\n    Notes\r\n    -----\r\n    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\r\n    is not exported by the `~astropy.units` module.  Instead of\r\n    instantiating a `QuantityIterator` directly, use `Quantity.flat`.\r\n    \"\"\"\r\n\r\n    def __init__(self, q):\r\n        self._quantity = q\r\n        self._dataiter = q.view(np.ndarray).flat\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __getitem__(self, indx):\r\n        out = self._dataiter.__getitem__(indx)\r\n        # For single elements, ndarray.flat.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if isinstance(out, type(self._quantity)):\r\n            return out\r\n        else:\r\n            return self._quantity._new_view(out)\r\n\r\n    def __setitem__(self, index, value):\r\n        self._dataiter[index] = self._quantity._to_own_unit(value)\r\n\r\n    def __next__(self):\r\n        \"\"\"\r\n        Return the next value, or raise StopIteration.\r\n        \"\"\"\r\n        out = next(self._dataiter)\r\n        # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\r\n        return self._quantity._new_view(out)\r\n\r\n    next = __next__\r\n\r\n    def __len__(self):\r\n        return len(self._dataiter)\r\n\r\n    # Properties and methods to match `numpy.ndarray.flatiter`\r\n\r\n    @property\r\n    def base(self):\r\n        \"\"\"A reference to the array that is iterated over.\"\"\"\r\n        return self._quantity\r\n\r\n    @property\r\n    def coords(self):\r\n        \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\r\n        return self._dataiter.coords\r\n\r\n    @property\r\n    def index(self):\r\n        \"\"\"Current flat index into the array.\"\"\"\r\n        return self._dataiter.index\r\n\r\n    def copy(self):\r\n        \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\r\n        return self._quantity.flatten()\r\n\r\n\r\nclass QuantityInfoBase(ParentDtypeInfo):\r\n    # This is on a base class rather than QuantityInfo directly, so that\r\n    # it can be used for EarthLocationInfo yet make clear that that class\r\n    # should not be considered a typical Quantity subclass by Table.\r\n    attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\r\n    _supports_indexing = True\r\n\r\n    @staticmethod\r\n    def default_format(val):\r\n        return f\"{val.value}\"\r\n\r\n    @staticmethod\r\n    def possible_string_format_functions(format_):\r\n        \"\"\"Iterate through possible string-derived format functions.\r\n\r\n        A string can either be a format specifier for the format built-in,\r\n        a new-style format string, or an old-style format string.\r\n\r\n        This method is overridden in order to suppress printing the unit\r\n        in each row since it is already at the top in the column header.\r\n        \"\"\"\r\n        yield lambda format_, val: format(val.value, format_)\r\n        yield lambda format_, val: format_.format(val.value)\r\n        yield lambda format_, val: format_ % val.value\r\n\r\n\r\nclass QuantityInfo(QuantityInfoBase):\r\n    \"\"\"\r\n    Container for meta information like name, description, format.  This is\r\n    required when the object is used as a mixin column within a table, but can\r\n    be used as a general way to store meta information.\r\n    \"\"\"\r\n\r\n    _represent_as_dict_attrs = (\"value\", \"unit\")\r\n    _construct_from_dict_args = [\"value\"]\r\n    _represent_as_dict_primary_data = \"value\"\r\n\r\n    def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\r\n        \"\"\"\r\n        Return a new Quantity instance which is consistent with the\r\n        input ``cols`` and has ``length`` rows.\r\n\r\n        This is intended for creating an empty column object whose elements can\r\n        be set in-place for table operations like join or vstack.\r\n\r\n        Parameters\r\n        ----------\r\n        cols : list\r\n            List of input columns\r\n        length : int\r\n            Length of the output column object\r\n        metadata_conflicts : str ('warn'|'error'|'silent')\r\n            How to handle metadata conflicts\r\n        name : str\r\n            Output column name\r\n\r\n        Returns\r\n        -------\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n            Empty instance of this class consistent with ``cols``\r\n\r\n        \"\"\"\r\n        # Get merged info attributes like shape, dtype, format, description, etc.\r\n        attrs = self.merge_cols_attributes(\r\n            cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\r\n        )\r\n\r\n        # Make an empty quantity using the unit of the last one.\r\n        shape = (length,) + attrs.pop(\"shape\")\r\n        dtype = attrs.pop(\"dtype\")\r\n        # Use zeros so we do not get problems for Quantity subclasses such\r\n        # as Longitude and Latitude, which cannot take arbitrary values.\r\n        data = np.zeros(shape=shape, dtype=dtype)\r\n        # Get arguments needed to reconstruct class\r\n        map = {\r\n            key: (data if key == \"value\" else getattr(cols[-1], key))\r\n            for key in self._represent_as_dict_attrs\r\n        }\r\n        map[\"copy\"] = COPY_IF_NEEDED\r\n        out = self._construct_from_dict(map)\r\n\r\n        # Set remaining info attributes\r\n        for attr, value in attrs.items():\r\n            setattr(out.info, attr, value)\r\n\r\n        return out\r\n\r\n    def get_sortable_arrays(self):\r\n        \"\"\"\r\n        Return a list of arrays which can be lexically sorted to represent\r\n        the order of the parent column.\r\n\r\n        For Quantity this is just the quantity itself.\r\n\r\n\r\n        Returns\r\n        -------\r\n        arrays : list of ndarray\r\n        \"\"\"\r\n        return [self._parent]\r\n\r\n\r\nclass Quantity(np.ndarray):\r\n    \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\r\n\r\n    See also: https://docs.astropy.org/en/stable/units/quantity.html\r\n\r\n    Parameters\r\n    ----------\r\n    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\r\n        The numerical value of this quantity in the units given by unit.  If a\r\n        `Quantity` or sequence of them (or any other valid object with a\r\n        ``unit`` attribute), creates a new `Quantity` object, converting to\r\n        `unit` units as needed.  If a string, it is converted to a number or\r\n        `Quantity`, depending on whether a unit is present.\r\n\r\n    unit : unit-like\r\n        An object that represents the unit associated with the input value.\r\n        Must be an `~astropy.units.UnitBase` object or a string parseable by\r\n        the :mod:`~astropy.units` package.\r\n\r\n    dtype : ~numpy.dtype, optional\r\n        The dtype of the resulting Numpy array or scalar that will\r\n        hold the value.  If not provided, it is determined from the input,\r\n        except that any integer and (non-Quantity) object inputs are converted\r\n        to float by default.\r\n        If `None`, the normal `numpy.dtype` introspection is used, e.g.\r\n        preventing upcasting of integers.\r\n\r\n    copy : bool, optional\r\n        If `True` (default), then the value is copied.  Otherwise, a copy will\r\n        only be made if ``__array__`` returns a copy, if value is a nested\r\n        sequence, or if a copy is needed to satisfy an explicitly given\r\n        ``dtype``.  (The `False` option is intended mostly for internal use,\r\n        to speed up initialization where a copy is known to have been made.\r\n        Use with care.)\r\n\r\n    order : {'C', 'F', 'A'}, optional\r\n        Specify the order of the array.  As in `~numpy.array`.  This parameter\r\n        is ignored if the input is a `Quantity` and ``copy=False``.\r\n\r\n    subok : bool, optional\r\n        If `False` (default), the returned array will be forced to be a\r\n        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\r\n        or a subclass appropriate for the unit will be used (such as\r\n        `~astropy.units.Dex` for ``u.dex(u.AA)``).\r\n\r\n    ndmin : int, optional\r\n        Specifies the minimum number of dimensions that the resulting array\r\n        should have.  Ones will be prepended to the shape as needed to meet\r\n        this requirement.  This parameter is ignored if the input is a\r\n        `Quantity` and ``copy=False``.\r\n\r\n    Raises\r\n    ------\r\n    TypeError\r\n        If the value provided is not a Python numeric type.\r\n    TypeError\r\n        If the unit provided is not either a :class:`~astropy.units.Unit`\r\n        object or a parseable string unit.\r\n\r\n    Notes\r\n    -----\r\n    Quantities can also be created by multiplying a number or array with a\r\n    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\r\n\r\n    Unless the ``dtype`` argument is explicitly specified, integer\r\n    or (non-Quantity) object inputs are converted to `float` by default.\r\n    \"\"\"\r\n\r\n    # Need to set a class-level default for _equivalencies, or\r\n    # Constants can not initialize properly\r\n    _equivalencies = []\r\n\r\n    # Default unit for initialization; can be overridden by subclasses,\r\n    # possibly to `None` to indicate there is no default unit.\r\n    _default_unit = dimensionless_unscaled\r\n\r\n    # Ensures views have an undefined unit.\r\n    _unit = None\r\n\r\n    __array_priority__ = 10000\r\n\r\n    def __class_getitem__(cls, unit_shape_dtype):\r\n        \"\"\"Quantity Type Hints.\r\n\r\n        Unit-aware type hints are ``Annotated`` objects that encode the class,\r\n        the unit, and possibly shape and dtype information, depending on the\r\n        python and :mod:`numpy` versions.\r\n\r\n        Schematically, ``Annotated[cls[shape, dtype], unit]``\r\n\r\n        As a classmethod, the type is the class, ie ``Quantity``\r\n        produces an ``Annotated[Quantity, ...]`` while a subclass\r\n        like :class:`~astropy.coordinates.Angle` returns\r\n        ``Annotated[Angle, ...]``.\r\n\r\n        Parameters\r\n        ----------\r\n        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\r\n            Unit specification, can be the physical type (ie str or class).\r\n            If tuple, then the first element is the unit specification\r\n            and all other elements are for `numpy.ndarray` type annotations.\r\n            Whether they are included depends on the python and :mod:`numpy`\r\n            versions.\r\n\r\n        Returns\r\n        -------\r\n        `typing.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\r\n            Return type in this preference order:\r\n            * `typing.Annotated`\r\n            * `astropy.units.Unit` or `astropy.units.PhysicalType`\r\n\r\n        Raises\r\n        ------\r\n        TypeError\r\n            If the unit/physical_type annotation is not Unit-like or\r\n            PhysicalType-like.\r\n\r\n        Examples\r\n        --------\r\n        Create a unit-aware Quantity type annotation\r\n\r\n            >>> Quantity[Unit(\"s\")]\r\n            Annotated[Quantity, Unit(\"s\")]\r\n\r\n        See Also\r\n        --------\r\n        `~astropy.units.quantity_input`\r\n            Use annotations for unit checks on function arguments and results.\r\n\r\n        Notes\r\n        -----\r\n        |Quantity| types are also static-type compatible.\r\n        \"\"\"\r\n        from typing import Annotated\r\n\r\n        # process whether [unit] or [unit, shape, ptype]\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n"]
[170.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[170.002, "i", "sed -n '400,1200p' astropy/units/quantity.py\r"]
[170.004, "o", "sed -n '400,1200p' astropy/units/quantity.py\r\n"]
[170.006, "o", "\u001b[?2004l\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n            target = unit_shape_dtype[0]\r\n            shape_dtype = unit_shape_dtype[1:]\r\n        else:  # just unit\r\n            target = unit_shape_dtype\r\n            shape_dtype = ()\r\n\r\n        # Allowed unit/physical types. Errors if neither.\r\n        try:\r\n            unit = Unit(target)\r\n        except (TypeError, ValueError):\r\n            from astropy.units.physical import get_physical_type\r\n\r\n            try:\r\n                unit = get_physical_type(target)\r\n            except (TypeError, ValueError, KeyError):  # KeyError for Enum\r\n                raise TypeError(\r\n                    \"unit annotation is not a Unit or PhysicalType\"\r\n                ) from None\r\n\r\n        # Quantity does not (yet) properly extend the NumPy generics types,\r\n        # introduced in numpy v1.22+, instead just including the unit info as\r\n        # metadata using Annotated.\r\n        # TODO: ensure we do interact with NDArray.__class_getitem__.\r\n        return Annotated[cls, unit]\r\n\r\n    def __new__(\r\n        cls: type[Self],\r\n        value: QuantityLike,\r\n        unit=None,\r\n        dtype=np.inexact,\r\n        copy=True,\r\n        order=None,\r\n        subok=False,\r\n        ndmin=0,\r\n    ) -> Self:\r\n        if unit is not None:\r\n            # convert unit first, to avoid multiple string->unit conversions\r\n            unit = Unit(unit)\r\n\r\n        # inexact -> upcast to float dtype\r\n        float_default = dtype is np.inexact\r\n        if float_default:\r\n            dtype = None\r\n\r\n        # optimize speed for Quantity with no dtype given, copy=COPY_IF_NEEDED\r\n        if isinstance(value, Quantity):\r\n            if unit is not None and unit is not value.unit:\r\n                value = value.to(unit)\r\n                # the above already makes a copy (with float dtype)\r\n                copy = COPY_IF_NEEDED\r\n\r\n            if type(value) is not cls and not (subok and isinstance(value, cls)):\r\n                value = value.view(cls)\r\n\r\n            if float_default and value.dtype.kind in \"iu\":\r\n                dtype = float\r\n\r\n            return np.array(\r\n                value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n            )\r\n\r\n        # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\r\n        # To ensure array remains fast, we short-circuit it.\r\n        value_unit = None\r\n        if not isinstance(value, np.ndarray):\r\n            if isinstance(value, str):\r\n                # The first part of the regex string matches any integer/float;\r\n                # the second parts adds possible trailing .+-, which will break\r\n                # the float function below and ensure things like 1.2.3deg\r\n                # will not work.\r\n                pattern = (\r\n                    r\"\\s*[+-]?\"\r\n                    r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\r\n                    r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\r\n                    r\"([eE][+-]?\\d+)?\"\r\n                    r\"[.+-]?\"\r\n                )\r\n\r\n                v = re.match(pattern, value)\r\n                unit_string = None\r\n                try:\r\n                    value = float(v.group())\r\n\r\n                except Exception:\r\n                    raise TypeError(\r\n                        f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\r\n                        \"start with a number.\"\r\n                    )\r\n\r\n                unit_string = v.string[v.end() :].strip()\r\n                if unit_string:\r\n                    value_unit = Unit(unit_string)\r\n                    if unit is None:\r\n                        unit = value_unit  # signal no conversion needed below.\r\n\r\n            elif isinstance(value, (list, tuple)) and len(value) > 0:\r\n                if all(isinstance(v, Quantity) for v in value):\r\n                    # If a list/tuple contains only quantities, stack them,\r\n                    # which also converts them to the same unit.\r\n                    value = np.stack(value)\r\n                    copy = False\r\n\r\n                elif (\r\n                    dtype is None\r\n                    and not hasattr(value, \"dtype\")\r\n                    and isinstance(unit, StructuredUnit)\r\n                ):\r\n                    # Special case for list/tuple of values and a structured unit:\r\n                    # ``np.array(value, dtype=None)`` would treat tuples as lower\r\n                    # levels of the array, rather than as elements of a structured\r\n                    # array, so we use the structure of the unit to help infer the\r\n                    # structured dtype of the value.\r\n                    dtype = unit._recursively_get_dtype(value)\r\n\r\n        using_default_unit = False\r\n        if value_unit is None:\r\n            # If the value has a `unit` attribute and if not None\r\n            # (for Columns with uninitialized unit), treat it like a quantity.\r\n            value_unit = getattr(value, \"unit\", None)\r\n            if value_unit is None:\r\n                # Default to dimensionless for no (initialized) unit attribute.\r\n                if unit is None:\r\n                    using_default_unit = True\r\n                    unit = cls._default_unit\r\n                value_unit = unit  # signal below that no conversion is needed\r\n            else:\r\n                try:\r\n                    value_unit = Unit(value_unit)\r\n                except Exception as exc:\r\n                    raise TypeError(\r\n                        f\"The unit attribute {value.unit!r} of the input could \"\r\n                        \"not be parsed as an astropy Unit.\"\r\n                    ) from exc\r\n\r\n                if unit is None:\r\n                    unit = value_unit\r\n                elif unit is not value_unit:\r\n                    copy = COPY_IF_NEEDED  # copy will be made in conversion at end\r\n\r\n        value = np.array(\r\n            value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n        )\r\n\r\n        # For no-user-input unit, make sure the constructed unit matches the\r\n        # structure of the data.\r\n        if using_default_unit and value.dtype.names is not None:\r\n            unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\r\n\r\n        # check that array contains numbers or long int objects\r\n        if value.dtype.kind in \"OSU\" and not (\r\n            value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\r\n        ):\r\n            raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\r\n\r\n        # by default, cast any integer, boolean, etc., to float\r\n        if float_default and value.dtype.kind in \"iuO\":\r\n            value = value.astype(float)\r\n\r\n        # if we allow subclasses, allow a class from the unit.\r\n        if subok:\r\n            qcls = getattr(unit, \"_quantity_class\", cls)\r\n            if issubclass(qcls, cls):\r\n                cls = qcls\r\n\r\n        value = value.view(cls)\r\n        value._set_unit(value_unit)\r\n        if unit is value_unit:\r\n            return value\r\n        else:\r\n            # here we had non-Quantity input that had a \"unit\" attribute\r\n            # with a unit different from the desired one.  So, convert.\r\n            return value.to(unit)\r\n\r\n    def __array_finalize__(self, obj):\r\n        # Check whether super().__array_finalize should be called\r\n        # (sadly, ndarray.__array_finalize__ is None; we cannot be sure\r\n        # what is above us).\r\n        super_array_finalize = super().__array_finalize__\r\n        if super_array_finalize is not None:\r\n            super_array_finalize(obj)\r\n\r\n        # If we're a new object or viewing an ndarray, nothing has to be done.\r\n        if obj is None or obj.__class__ is np.ndarray:\r\n            return\r\n\r\n        # Copy over the unit and possibly info.  Note that the only way the\r\n        # unit can already be set is if one enters via _new_view(), where the\r\n        # unit is often different from that of self, and where propagation of\r\n        # info is not always desirable.\r\n        if self._unit is None:\r\n            unit = getattr(obj, \"_unit\", None)\r\n            if unit is not None:\r\n                self._set_unit(unit)\r\n\r\n            # Copy info if the original had `info` defined.  Because of the way the\r\n            # DataInfo works, `'info' in obj.__dict__` is False until the\r\n            # `info` attribute is accessed or set.\r\n            if \"info\" in obj.__dict__:\r\n                self.info = obj.info\r\n\r\n    def __array_wrap__(self, obj, context=None, return_scalar=False):\r\n        if context is None:\r\n            # Methods like .squeeze() created a new `ndarray` and then call\r\n            # __array_wrap__ to turn the array into self's subclass.\r\n            return self._new_view(obj)\r\n\r\n        raise NotImplementedError(\r\n            \"__array_wrap__ should not be used with a context any more since all \"\r\n            \"use should go through array_function. Please raise an issue on \"\r\n            \"https://github.com/astropy/astropy\"\r\n        )\r\n\r\n    def __array_ufunc__(self, function, method, *inputs, **kwargs):\r\n        \"\"\"Wrap numpy ufuncs, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            ufunc to wrap.\r\n        method : str\r\n            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\r\n        inputs : tuple\r\n            Input arrays.\r\n        kwargs : keyword arguments\r\n            As passed on, with ``out`` containing possible quantity output.\r\n\r\n        Returns\r\n        -------\r\n        result : `~astropy.units.Quantity` or `NotImplemented`\r\n            Results of the ufunc, with the unit set properly.\r\n        \"\"\"\r\n        # Determine required conversion functions -- to bring the unit of the\r\n        # input to that expected (e.g., radian for np.sin), or to get\r\n        # consistent units between two inputs (e.g., in np.add) --\r\n        # and the unit of the result (or tuple of units for nout > 1).\r\n        try:\r\n            converters, unit = converters_and_unit(function, method, *inputs)\r\n\r\n            out = kwargs.get(\"out\", None)\r\n            # Avoid loop back by turning any Quantity output into array views.\r\n            if out is not None:\r\n                # If pre-allocated output is used, check it is suitable.\r\n                # This also returns array view, to ensure we don't loop back.\r\n                if function.nout == 1:\r\n                    out = out[0]\r\n                out_array = check_output(out, unit, inputs, function=function)\r\n                # Ensure output argument remains a tuple.\r\n                kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\r\n\r\n            if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\r\n                # Special-case for initial argument for reductions like\r\n                # np.add.reduce.  This should be converted to the output unit as\r\n                # well, which is typically the same as the input unit (but can\r\n                # in principle be different: unitless for np.equal, radian\r\n                # for np.arctan2, though those are not necessarily useful!)\r\n                kwargs[\"initial\"] = self._to_own_unit(\r\n                    kwargs[\"initial\"], check_precision=False, unit=unit\r\n                )\r\n\r\n            # Same for inputs, but here also convert if necessary.\r\n            arrays = []\r\n            for input_, converter in zip(inputs, converters):\r\n                input_ = getattr(input_, \"value\", input_)\r\n                arrays.append(converter(input_) if converter else input_)\r\n\r\n            # Call our superclass's __array_ufunc__\r\n            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\r\n            # If unit is None, a plain array is expected (e.g., comparisons), which\r\n            # means we're done.\r\n            # We're also done if the result was None (for method 'at') or\r\n            # NotImplemented, which can happen if other inputs/outputs override\r\n            # __array_ufunc__; hopefully, they can then deal with us.\r\n            if unit is None or result is None or result is NotImplemented:\r\n                return result\r\n\r\n            return self._result_as_quantity(result, unit, out)\r\n\r\n        except (TypeError, ValueError, AttributeError) as e:\r\n            out_normalized = kwargs.get(\"out\", ())\r\n            inputs_and_outputs = inputs + out_normalized\r\n            ignored_ufunc = (\r\n                None,\r\n                np.ndarray.__array_ufunc__,\r\n                type(self).__array_ufunc__,\r\n            )\r\n            if not all(\r\n                getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\r\n                for io in inputs_and_outputs\r\n            ):\r\n                return NotImplemented\r\n            else:\r\n                raise e\r\n\r\n    def _result_as_quantity(self, result, unit, out):\r\n        \"\"\"Turn result into a quantity with the given unit.\r\n\r\n        If no output is given, it will take a view of the array as a quantity,\r\n        and set the unit.  If output is given, those should be quantity views\r\n        of the result arrays, and the function will just set the unit.\r\n\r\n        Parameters\r\n        ----------\r\n        result : ndarray or tuple thereof\r\n            Array(s) which need to be turned into quantity.\r\n        unit : `~astropy.units.Unit`\r\n            Unit for the quantities to be returned (or `None` if the result\r\n            should not be a quantity).  Should be tuple if result is a tuple.\r\n        out : `~astropy.units.Quantity` or None\r\n            Possible output quantity. Should be `None` or a tuple if result\r\n            is a tuple.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n           With units set.\r\n        \"\"\"\r\n        if isinstance(result, (tuple, list)):\r\n            if out is None:\r\n                out = (None,) * len(result)\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n        # ``obj.__class is np.ndarray``. So, not worth special-casing.\r\n        if obj is None:\r\n            obj = self.view(np.ndarray)\r\n        else:\r\n            obj = np.array(obj, copy=COPY_IF_NEEDED, subok=True)\r\n\r\n        # Take the view, set the unit, and update possible other properties\r\n        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\r\n        view = obj.view(quantity_subclass)\r\n        view._set_unit(unit)\r\n        view.__array_finalize__(self)\r\n        if propagate_info and \"info\" in self.__dict__:\r\n            view.info = self.info\r\n        return view\r\n\r\n    def _set_unit(self, unit):\r\n        \"\"\"Set the unit.\r\n\r\n        This is used anywhere the unit is set or modified, i.e., in the\r\n        initializer, in ``__imul__`` and ``__itruediv__`` for in-place\r\n        multiplication and division by another unit, as well as in\r\n        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\r\n        sets the unit, but subclasses can override it to check that, e.g.,\r\n        a unit is consistent.\r\n        \"\"\"\r\n        if not isinstance(unit, UnitBase):\r\n            if isinstance(self._unit, StructuredUnit) or isinstance(\r\n                unit, StructuredUnit\r\n            ):\r\n                unit = StructuredUnit(unit, self.dtype)\r\n            else:\r\n                # Trying to go through a string ensures that, e.g., Magnitudes with\r\n                # dimensionless physical unit become Quantity with units of mag.\r\n                unit = Unit(str(unit), parse_strict=\"silent\")\r\n                if not isinstance(unit, (UnitBase, StructuredUnit)):\r\n                    raise UnitTypeError(\r\n                        f\"{self.__class__.__name__} instances require normal units, \"\r\n                        f\"not {unit.__class__} instances.\"\r\n                    )\r\n\r\n        self._unit = unit\r\n\r\n    def __deepcopy__(self, memo):\r\n        # If we don't define this, ``copy.deepcopy(quantity)`` will\r\n        # return a bare Numpy array.\r\n        return self.copy()\r\n\r\n    def __reduce__(self):\r\n        # patch to pickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        object_state = list(super().__reduce__())\r\n        object_state[2] = (object_state[2], self.__dict__)\r\n        return tuple(object_state)\r\n\r\n    def __setstate__(self, state):\r\n        # patch to unpickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        nd_state, own_state = state\r\n        super().__setstate__(nd_state)\r\n        self.__dict__.update(own_state)\r\n\r\n    info = QuantityInfo()\r\n\r\n    def _to_value(self, unit, equivalencies=[]):\r\n        \"\"\"Helper method for to and to_value.\"\"\"\r\n        if equivalencies == []:\r\n            equivalencies = self._equivalencies\r\n        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\r\n            # Standard path, let unit to do work.\r\n            return self.unit.to(\r\n                unit, self.view(np.ndarray), equivalencies=equivalencies\r\n            )\r\n\r\n        else:\r\n            # The .to() method of a simple unit cannot convert a structured\r\n            # dtype, so we work around it, by recursing.\r\n            # TODO: deprecate this?\r\n            # Convert simple to Structured on initialization?\r\n            result = np.empty_like(self.view(np.ndarray))\r\n            for name in self.dtype.names:\r\n                result[name] = self[name]._to_value(unit, equivalencies)\r\n            return result\r\n\r\n    def to(self, unit, equivalencies=[], copy=True):\r\n        \"\"\"\r\n        Return a new `~astropy.units.Quantity` object with the specified unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like\r\n            An object that represents the unit to convert to. Must be\r\n            an `~astropy.units.UnitBase` object or a string parseable\r\n            by the `~astropy.units` package.\r\n\r\n        equivalencies : list of tuple\r\n            A list of equivalence pairs to try if the units are not\r\n            directly convertible.  See :ref:`astropy:unit_equivalencies`.\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n            (none for `~astropy.units.Quantity`, but may be set for subclasses)\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        copy : bool, optional\r\n            If `True` (default), then the value is copied.  Otherwise, a copy\r\n            will only be made if necessary.\r\n\r\n        See Also\r\n        --------\r\n        to_value : get the numerical value in a given unit.\r\n        \"\"\"\r\n        # We don't use `to_value` below since we always want to make a copy\r\n        # and don't want to slow down this method (esp. the scalar case).\r\n        unit = Unit(unit)\r\n        if copy:\r\n            # Avoid using to_value to ensure that we make a copy. We also\r\n            # don't want to slow down this method (esp. the scalar case).\r\n            value = self._to_value(unit, equivalencies)\r\n        else:\r\n            # to_value only copies if necessary\r\n            value = self.to_value(unit, equivalencies)\r\n        return self._new_view(value, unit)\r\n\r\n    def to_value(self, unit=None, equivalencies=[]):\r\n        \"\"\"\r\n        The numerical value, possibly in a different unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            The unit in which the value should be given. If not given or `None`,\r\n            use the current unit.\r\n\r\n        equivalencies : list of tuple, optional\r\n            A list of equivalence pairs to try if the units are not directly\r\n            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\r\n            or ``[]``, class default equivalencies will be used (none for\r\n            `~astropy.units.Quantity`, but may be set for subclasses).\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        Returns\r\n        -------\r\n        value : ndarray or scalar\r\n            The value in the units specified. For arrays, this will be a view\r\n            of the data if no unit conversion was necessary.\r\n\r\n        See Also\r\n        --------\r\n        to : Get a new instance in a different unit.\r\n        \"\"\"\r\n        if unit is None or unit is self.unit:\r\n            value = self.view(np.ndarray)\r\n        elif not self.dtype.names:\r\n            # For non-structured, we attempt a short-cut, where we just get\r\n            # the scale.  If that is 1, we do not have to do anything.\r\n            unit = Unit(unit)\r\n            # We want a view if the unit does not change.  One could check\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n            # TODO: would be better for `unit.to` to have an in-place flag.\r\n            try:\r\n                scale = self.unit._to(unit)\r\n            except Exception:\r\n                # Short-cut failed; try default (maybe equivalencies help).\r\n                value = self._to_value(unit, equivalencies)\r\n            else:\r\n                value = self.view(np.ndarray)\r\n                if not is_effectively_unity(scale):\r\n                    # not in-place!\r\n                    value = value * scale\r\n        else:\r\n            # For structured arrays, we go the default route.\r\n            value = self._to_value(unit, equivalencies)\r\n\r\n        # Index with empty tuple to decay array scalars in to numpy scalars.\r\n        return value if value.shape else value[()]\r\n\r\n    value = property(\r\n        to_value,\r\n        doc=\"\"\"The numerical value of this instance.\r\n\r\n    See also\r\n    --------\r\n    to_value : Get the numerical value in a given unit.\r\n    \"\"\",\r\n    )\r\n\r\n    @property\r\n    def unit(self):\r\n        \"\"\"\r\n        A `~astropy.units.UnitBase` object representing the unit of this\r\n        quantity.\r\n        \"\"\"\r\n        return self._unit\r\n\r\n    @property\r\n    def equivalencies(self):\r\n        \"\"\"\r\n        A list of equivalencies that will be applied by default during\r\n        unit conversions.\r\n        \"\"\"\r\n        return self._equivalencies\r\n\r\n    def _recursively_apply(self, func):\r\n        \"\"\"Apply function recursively to every field.\r\n\r\n        Returns a copy with the result.\r\n        \"\"\"\r\n        result = np.empty_like(self)\r\n        result_value = result.view(np.ndarray)\r\n        result_unit = ()\r\n        for name in self.dtype.names:\r\n            part = func(self[name])\r\n            result_value[name] = part.value\r\n            result_unit += (part.unit,)\r\n\r\n        result._set_unit(result_unit)\r\n        return result\r\n\r\n    @property\r\n    def si(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with SI units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"si\"))\r\n        si_unit = self.unit.si\r\n        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\r\n\r\n    @property\r\n    def cgs(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with CGS units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"cgs\"))\r\n        cgs_unit = self.unit.cgs\r\n        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\r\n\r\n    @property\r\n    def isscalar(self):\r\n        \"\"\"\r\n        True if the `value` of this quantity is a scalar, or False if it\r\n        is an array-like object.\r\n\r\n        .. note::\r\n            This is subtly different from `numpy.isscalar` in that\r\n            `numpy.isscalar` returns False for a zero-dimensional array\r\n            (e.g. ``np.array(1)``), while this is True for quantities,\r\n            since quantities cannot represent true numpy scalars.\r\n        \"\"\"\r\n        return not self.shape\r\n\r\n    # This flag controls whether convenience conversion members, such\r\n    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\r\n    # not turned on on Quantity itself, but is on some subclasses of\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n    _include_easy_conversion_members = False\r\n\r\n    def __dir__(self):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.  This function is implemented in\r\n        order to make autocompletion still work correctly in IPython.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            return super().__dir__()\r\n\r\n        dir_values = set(super().__dir__())\r\n        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\r\n        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\r\n            dir_values.update(equivalent.names)\r\n        return sorted(dir_values)\r\n\r\n    def __getattr__(self, attr):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            raise AttributeError(\r\n                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\r\n            )\r\n\r\n        def get_virtual_unit_attribute():\r\n            registry = get_current_unit_registry().registry\r\n            to_unit = registry.get(attr, None)\r\n            if to_unit is None:\r\n                return None\r\n\r\n            try:\r\n                return self.unit.to(\r\n                    to_unit, self.value, equivalencies=self.equivalencies\r\n                )\r\n            except UnitsError:\r\n                return None\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n"]
[175.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[175.002, "i", "sed -n '1200,2000p' astropy/units/quantity.py\r"]
[175.004, "o", "sed -n '1200,2000p' astropy/units/quantity.py\r\n"]
[175.006, "o", "\u001b[?2004l\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n            # so they should raise a TypeError rather than an IndexError.\r\n            if self.isscalar:\r\n                raise TypeError(\r\n                    f\"'{self.__class__.__name__}' object with a scalar value \"\r\n                    \"does not support indexing\"\r\n                )\r\n            else:\r\n                raise\r\n        # For single elements, ndarray.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if not isinstance(out, np.ndarray):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def __setitem__(self, i, value):\r\n        if isinstance(i, str):\r\n            # Indexing will cause a different unit, so by doing this in\r\n            # two steps we effectively try with the right unit.\r\n            self[i][...] = value\r\n            return\r\n\r\n        # update indices in info if the info property has been accessed\r\n        # (in which case 'info' in self.__dict__ is True; this is guaranteed\r\n        # to be the case if we're part of a table).\r\n        if not self.isscalar and \"info\" in self.__dict__:\r\n            self.info.adjust_indices(i, value, len(self))\r\n        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\r\n\r\n    # __contains__ is OK\r\n\r\n    def __bool__(self):\r\n        \"\"\"This method raises ValueError, since truthiness of quantities is ambiguous,\r\n        especially for logarithmic units and temperatures. Use explicit comparisons.\r\n        \"\"\"\r\n        raise ValueError(\r\n            f\"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units\"\r\n            \" and temperatures. Use explicit comparisons.\"\r\n        )\r\n\r\n    def __len__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\r\n            )\r\n        else:\r\n            return len(self.value)\r\n\r\n    # Numerical types\r\n    def __float__(self):\r\n        try:\r\n            return float(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __int__(self):\r\n        try:\r\n            return int(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __index__(self):\r\n        # for indices, we do not want to mess around with scaling at all,\r\n        # so unlike for float, int, we insist here on unscaled dimensionless\r\n        try:\r\n            assert self.unit.is_unity()\r\n            return self.value.__index__()\r\n        except Exception:\r\n            raise TypeError(\r\n                \"only integer dimensionless scalar quantities \"\r\n                \"can be converted to a Python index\"\r\n            )\r\n\r\n    # TODO: we may want to add a hook for dimensionless quantities?\r\n    @property\r\n    def _unitstr(self):\r\n        if self.unit is None:\r\n            unitstr = _UNIT_NOT_INITIALISED\r\n        else:\r\n            unitstr = str(self.unit)\r\n\r\n        if unitstr:\r\n            unitstr = \" \" + unitstr\r\n\r\n        return unitstr\r\n\r\n    def to_string(\r\n        self, unit=None, precision=None, format=None, subfmt=None, *, formatter=None\r\n    ):\r\n        \"\"\"\r\n        Generate a string representation of the quantity and its unit.\r\n\r\n        The behavior of this function can be altered via the\r\n        `numpy.set_printoptions` function and its various keywords.  The\r\n        exception to this is the ``threshold`` keyword, which is controlled via\r\n        the ``[units.quantity]`` configuration item ``latex_array_threshold``.\r\n        This is treated separately because the numpy default of 1000 is too big\r\n        for most browsers to handle.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            Specifies the unit.  If not provided,\r\n            the unit used to initialize the quantity will be used.\r\n\r\n        precision : number, optional\r\n            The level of decimal precision. If `None`, or not provided,\r\n            it will be determined from NumPy print options.\r\n\r\n        format : str, optional\r\n            The format of the result. If not provided, an unadorned\r\n            string is returned. Supported values are:\r\n\r\n            - 'latex': Return a LaTeX-formatted string\r\n\r\n            - 'latex_inline': Return a LaTeX-formatted string that uses\r\n              negative exponents instead of fractions\r\n\r\n        formatter : str, callable, dict, optional\r\n            The formatter to use for the value. If a string, it should be a\r\n            valid format specifier using Python's mini-language. If a callable,\r\n            it will be treated as the default formatter for all values and will\r\n            overwrite default Latex formatting for exponential notation and complex\r\n            numbers. If a dict, it should map a specific type to a callable to be\r\n            directly passed into `numpy.array2string`. If not provided, the default\r\n            formatter will be used.\r\n\r\n        subfmt : str, optional\r\n            Subformat of the result. For the moment, only used for\r\n            ``format='latex'`` and ``format='latex_inline'``. Supported\r\n            values are:\r\n\r\n            - 'inline': Use ``$ ... $`` as delimiters.\r\n\r\n            - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\r\n\r\n        Returns\r\n        -------\r\n        str\r\n            A string with the contents of this Quantity\r\n        \"\"\"\r\n        if unit is not None and unit != self.unit:\r\n            return self.to(unit).to_string(\r\n                unit=None,\r\n                precision=precision,\r\n                format=format,\r\n                subfmt=subfmt,\r\n                formatter=formatter,\r\n            )\r\n\r\n        if format is None and formatter is None and precision is None:\r\n            # Use default formatting settings\r\n            return f\"{self.value}{self._unitstr:s}\"\r\n\r\n        formats = {\r\n            None: None,\r\n            \"latex\": {\r\n                None: (\"$\", \"$\"),\r\n                \"inline\": (\"$\", \"$\"),\r\n                \"display\": (r\"$\\displaystyle \", r\"$\"),\r\n            },\r\n        }\r\n        formats[\"latex_inline\"] = formats[\"latex\"]\r\n\r\n        if format not in formats:\r\n            raise ValueError(f\"Unknown format '{format}'\")\r\n\r\n        format_spec = formatter if isinstance(formatter, str) else None\r\n\r\n        if format is None:\r\n            if format_spec is not None:\r\n\r\n                def formatter(value):\r\n                    return builtins.format(value, format_spec)\r\n\r\n            if callable(formatter):\r\n                formatter = {\"all\": formatter}\r\n\r\n            return (\r\n                np.array2string(\r\n                    self.value,\r\n                    precision=precision,\r\n                    floatmode=\"fixed\",\r\n                    formatter=formatter,\r\n                )\r\n                + self._unitstr\r\n            )\r\n\r\n        # else, for the moment we assume format=\"latex\" or \"latex_inline\".\r\n\r\n        # Set the precision if set, otherwise use numpy default\r\n        pops = np.get_printoptions()\r\n        if format_spec is None:\r\n            format_spec = (\r\n                f\".{precision if precision is not None else pops['precision']}g\"\r\n            )\r\n\r\n        # Use default formatters\r\n        if formatter is None or isinstance(formatter, str):\r\n            # Filter width and alignment operations for latex\r\n            # [[fill]align][sign][\"z\"][\"#\"][\"0\"][width][grouping_option][\".\" precision][type]\r\n            format_spec = re.sub(\r\n                r\"(.*?)([+\\- ]?)(\\d+)?(,)?(\\.\\d+)?([a-zA-Z%]+)?$\",\r\n                r\"\\2\\5\\6\",\r\n                format_spec,\r\n            )\r\n\r\n            if self.dtype.kind == \"c\":  # Complex default latex formatter\r\n                # Disallow sign operations for the imaginary part\r\n                imag_format_spec = re.sub(r\"[+\\- ]\", \"\", format_spec)\r\n\r\n                def formatter(value):\r\n                    return \"({}{}i)\".format(\r\n                        Latex.format_exponential_notation(\r\n                            value.real, format_spec=format_spec\r\n                        ),\r\n                        Latex.format_exponential_notation(\r\n                            value.imag, format_spec=\"+\" + imag_format_spec\r\n                        ),\r\n                    )\r\n\r\n            else:  # Float default latex formatter\r\n\r\n                def formatter(value):\r\n                    return Latex.format_exponential_notation(\r\n                        value, format_spec=format_spec\r\n                    )\r\n\r\n        if callable(formatter):\r\n            formatter = {\"all\": formatter}\r\n\r\n        # The view is needed for the scalar case - self.value might be float.\r\n        latex_value = np.array2string(\r\n            self.view(np.ndarray),\r\n            threshold=(\r\n                conf.latex_array_threshold\r\n                if conf.latex_array_threshold > -1\r\n                else pops[\"threshold\"]\r\n            ),\r\n            formatter=formatter,\r\n            max_line_width=np.inf,\r\n            separator=\",~\",\r\n        )\r\n\r\n        latex_value = latex_value.replace(\"...\", r\"\\dots\")\r\n\r\n        # Format unit\r\n        # [1:-1] strips the '$' on either side needed for math mode\r\n        if self.unit is None:\r\n            latex_unit = _UNIT_NOT_INITIALISED\r\n        elif format == \"latex\":\r\n            latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\r\n        elif format == \"latex_inline\":\r\n            latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\r\n\r\n        delimiter_left, delimiter_right = formats[format][subfmt]\r\n\r\n        # Add a space in front except for super-script units like degrees.\r\n        if not latex_unit.removeprefix(\"\\\\mathrm{\").startswith(\"{}^\"):\r\n            latex_unit = rf\" \\; {latex_unit}\"\r\n\r\n        return rf\"{delimiter_left}{latex_value}{latex_unit}{delimiter_right}\"\r\n\r\n    def __str__(self):\r\n        return self.to_string()\r\n\r\n    def __repr__(self):\r\n        prefixstr = \"<\" + self.__class__.__name__ + \" \"\r\n        arrstr = np.array2string(\r\n            self.view(np.ndarray), separator=\", \", prefix=prefixstr\r\n        )\r\n        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\r\n\r\n    def _repr_latex_(self):\r\n        \"\"\"\r\n        Generate a latex representation of the quantity and its unit.\r\n\r\n        Returns\r\n        -------\r\n        lstr\r\n            A LaTeX string with the contents of this Quantity\r\n        \"\"\"\r\n        # NOTE: This should change to display format in a future release\r\n        return self.to_string(format=\"latex\", subfmt=\"inline\")\r\n\r\n    def __format__(self, format_spec):\r\n        try:\r\n            return self.to_string(format=format_spec)\r\n        except ValueError:\r\n            # We might have a unit format not implemented in `to_string()`.\r\n            if format_spec in Base.registry:\r\n                if self.unit is dimensionless_unscaled:\r\n                    return f\"{self.value}\"\r\n                else:\r\n                    return f\"{self.value} {format(self.unit, format_spec)}\"\r\n            # Can the value be formatted on its own?\r\n            try:\r\n                return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\r\n            except ValueError:\r\n                # Format the whole thing as a single string.\r\n                return format(f\"{self.value}{self._unitstr:s}\", format_spec)\r\n\r\n    def decompose(self, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units\r\n        decomposed. Decomposed units have only irreducible units in\r\n        them (see `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        bases : sequence of `~astropy.units.UnitBase`, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n        \"\"\"\r\n        return self._decompose(False, bases=bases)\r\n\r\n    def _decompose(self, allowscaledunits=False, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units decomposed. Decomposed\r\n        units have only irreducible units in them (see\r\n        `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        allowscaledunits : bool\r\n            If True, the resulting `Quantity` may have a scale factor\r\n            associated with it.  If False, any scaling in the unit will\r\n            be subsumed into the value of the resulting `Quantity`\r\n\r\n        bases : sequence of UnitBase, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n\r\n        \"\"\"\r\n        new_unit = self.unit.decompose(bases=bases)\r\n\r\n        # Be careful here because self.value usually is a view of self;\r\n        # be sure that the original value is not being modified.\r\n        if not allowscaledunits and hasattr(new_unit, \"scale\"):\r\n            new_value = self.value * new_unit.scale\r\n            new_unit = new_unit / new_unit.scale\r\n            return self._new_view(new_value, new_unit)\r\n        else:\r\n            return self._new_view(self.copy(), new_unit)\r\n\r\n    # These functions need to be overridden to take into account the units\r\n    # Array conversion\r\n    # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\r\n\r\n    def item(self, *args):\r\n        \"\"\"Copy an element of an array to a scalar Quantity and return it.\r\n\r\n        Like :meth:`~numpy.ndarray.item` except that it always\r\n        returns a `Quantity`, not a Python scalar.\r\n\r\n        \"\"\"\r\n        return self._new_view(super().item(*args))\r\n\r\n    def tolist(self):\r\n        raise NotImplementedError(\r\n            \"cannot make a list of Quantities. Get list of values with\"\r\n            \" q.value.tolist().\"\r\n        )\r\n\r\n    def _to_own_unit(self, value, check_precision=True, *, unit=None):\r\n        \"\"\"Convert value to one's own unit (or that given).\r\n\r\n        Here, non-quantities are treated as dimensionless, and care is taken\r\n        for values of 0, infinity or nan, which are allowed to have any unit.\r\n\r\n        Parameters\r\n        ----------\r\n        value : anything convertible to `~astropy.units.Quantity`\r\n            The value to be converted to the requested unit.\r\n        check_precision : bool\r\n            Whether to forbid conversion of float to integer if that changes\r\n            the input number.  Default: `True`.\r\n        unit : `~astropy.units.Unit` or None\r\n            The unit to convert to.  By default, the unit of ``self``.\r\n\r\n        Returns\r\n        -------\r\n        value : number or `~numpy.ndarray`\r\n            In the requested units.\r\n\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        try:\r\n            _value = value.to_value(unit)\r\n        except AttributeError:\r\n            # We're not a Quantity.\r\n            # First remove two special cases (with a fast test):\r\n            # 1) Maybe masked printing? MaskedArray with quantities does not\r\n            # work very well, but no reason to break even repr and str.\r\n            # 2) np.ma.masked? useful if we're a MaskedQuantity.\r\n            if value is np.ma.masked or (\r\n                value is np.ma.masked_print_option and self.dtype.kind == \"O\"\r\n            ):\r\n                return value\r\n            # Now, let's try a more general conversion.\r\n            # Plain arrays will be converted to dimensionless in the process,\r\n            # but anything with a unit attribute will use that.\r\n            try:\r\n                as_quantity = Quantity(value)\r\n                _value = as_quantity.to_value(unit)\r\n            except UnitsError:\r\n                # last chance: if this was not something with a unit\r\n                # and is all 0, inf, or nan, we treat it as arbitrary unit.\r\n                if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\r\n                    as_quantity.value\r\n                ):\r\n                    _value = as_quantity.value\r\n                else:\r\n                    raise\r\n\r\n        if self.dtype.kind == \"i\" and check_precision:\r\n            # If, e.g., we are casting float to int, we want to fail if\r\n            # precision is lost, but let things pass if it works.\r\n            _value = np.array(_value, copy=COPY_IF_NEEDED, subok=True)\r\n            if not np.can_cast(_value.dtype, self.dtype):\r\n                self_dtype_array = np.array(_value, self.dtype, subok=True)\r\n                if not np.all((self_dtype_array == _value) | np.isnan(_value)):\r\n                    raise TypeError(\r\n                        \"cannot convert value type to array type without precision loss\"\r\n                    )\r\n\r\n        # Setting names to ensure things like equality work (note that\r\n        # above will have failed already if units did not match).\r\n        # TODO: is this the best place to do this?\r\n        if _value.dtype.names is not None:\r\n            _value = _value.astype(self.dtype, copy=False)\r\n        return _value\r\n\r\n    if NUMPY_LT_2_0:\r\n\r\n        def itemset(self, *args):\r\n            if len(args) == 0:\r\n                raise ValueError(\"itemset must have at least one argument\")\r\n\r\n            self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\r\n\r\n    def tostring(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tostring()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to string.  Write array with\"\r\n            \" q.value.tostring(...).\"\r\n        )\r\n\r\n    def tobytes(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tobytes()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\r\n        )\r\n\r\n    def tofile(self, fid, sep=\"\", format=\"%s\"):\r\n        \"\"\"Not implemented, use ``.value.tofile()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\r\n        )\r\n\r\n    def dump(self, file):\r\n        \"\"\"Not implemented, use ``.value.dump()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to file.  Write array with q.value.dump()\"\r\n        )\r\n\r\n    def dumps(self):\r\n        \"\"\"Not implemented, use ``.value.dumps()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\r\n        )\r\n\r\n    # astype, byteswap, copy, view, getfield, setflags OK as is\r\n\r\n    def fill(self, value):\r\n        self.view(np.ndarray).fill(self._to_own_unit(value))\r\n\r\n    # Shape manipulation: resize cannot be done (does not own data), but\r\n    # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\r\n    # the flat iterator needs to be overwritten, otherwise single items are\r\n    # returned as numbers.\r\n    @property\r\n    def flat(self):\r\n        \"\"\"A 1-D iterator over the Quantity array.\r\n\r\n        This returns a ``QuantityIterator`` instance, which behaves the same\r\n        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\r\n        and is similar to, but not a subclass of, Python's built-in iterator\r\n        object.\r\n        \"\"\"\r\n        return QuantityIterator(self)\r\n\r\n    @flat.setter\r\n    def flat(self, value):\r\n        y = self.ravel()\r\n        y[:] = value\r\n\r\n    # Item selection and manipulation\r\n    # repeat, sort, compress, diagonal OK\r\n    def take(self, indices, axis=None, out=None, mode=\"raise\"):\r\n        out = super().take(indices, axis=axis, out=out, mode=mode)\r\n        # For single elements, ndarray.take returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if type(out) is not type(self):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def put(self, indices, values, mode=\"raise\"):\r\n        self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\r\n\r\n    def choose(self, choices, out=None, mode=\"raise\"):\r\n        raise NotImplementedError(\r\n            \"cannot choose based on quantity.  Choose using array with\"\r\n            \" q.value.choose(...)\"\r\n        )\r\n\r\n    # ensure we do not return indices as quantities\r\n    if NUMPY_LT_2_0:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None):\r\n            return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\r\n\r\n    else:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None, *, stable=None):\r\n            return self.view(np.ndarray).argsort(\r\n                axis=axis, kind=kind, order=order, stable=stable\r\n            )\r\n\r\n    def searchsorted(self, v, *args, **kwargs):\r\n        return np.searchsorted(\r\n            np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\r\n        )  # avoid numpy 1.6 problem\r\n\r\n    def argmax(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def argmin(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def __array_function__(self, function, types, args, kwargs):\r\n        \"\"\"Wrap numpy functions, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap\r\n        types : iterable of classes\r\n            Classes that provide an ``__array_function__`` override. Can\r\n            in principle be used to interact with other classes. Below,\r\n            mostly passed on to `~numpy.ndarray`, which can only interact\r\n            with subclasses.\r\n        args : tuple\r\n            Positional arguments provided in the function call.\r\n        kwargs : dict\r\n            Keyword arguments provided in the function call.\r\n\r\n        Returns\r\n        -------\r\n        result: `~astropy.units.Quantity`, `~numpy.ndarray`\r\n            As appropriate for the function.  If the function is not\r\n            supported, `NotImplemented` is returned, which will lead to\r\n            a `TypeError` unless another argument overrode the function.\r\n\r\n        Raises\r\n        ------\r\n        ~astropy.units.UnitsError\r\n            If operands have incompatible units.\r\n        \"\"\"\r\n        # A function should be in one of the following sets or dicts:\r\n        # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\r\n        #    supports Quantity; we pass on to ndarray.__array_function__.\r\n        # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\r\n        #    after converting quantities to arrays with suitable units,\r\n        #    and possibly setting units on the result.\r\n        # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\r\n        #    requires a Quantity-specific implementation.\r\n        # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\r\n        # For now, since we may not yet have complete coverage, if a\r\n        # function is in none of the above, we simply call the numpy\r\n        # implementation.\r\n        if function in SUBCLASS_SAFE_FUNCTIONS:\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        elif function in FUNCTION_HELPERS:\r\n            function_helper = FUNCTION_HELPERS[function]\r\n            try:\r\n                args, kwargs, unit, out = function_helper(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            result = super().__array_function__(function, types, args, kwargs)\r\n            # Fall through to return section\r\n\r\n        elif function in DISPATCHED_FUNCTIONS:\r\n            dispatched_function = DISPATCHED_FUNCTIONS[function]\r\n            try:\r\n                result, unit, out = dispatched_function(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            # Fall through to return section\r\n\r\n        elif function in UNSUPPORTED_FUNCTIONS:\r\n            return NotImplemented\r\n\r\n        else:\r\n            warnings.warn(\r\n                f\"function '{function.__name__}' is not known to astropy's Quantity.\"\r\n                \" Will run it anyway, hoping it will treat ndarray subclasses\"\r\n                \" correctly. Please raise an issue at\"\r\n                \" https://github.com/astropy/astropy/issues.\",\r\n                AstropyWarning,\r\n            )\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        # If unit is None, a plain array is expected (e.g., boolean), which\r\n        # means we're done.\r\n        # We're also done if the result was NotImplemented, which can happen\r\n        # if other inputs/outputs override __array_function__;\r\n        # hopefully, they can then deal with us.\r\n        if unit is None or result is NotImplemented:\r\n            return result\r\n\r\n        return self._result_as_quantity(result, unit, out=out)\r\n\r\n    def _not_implemented_or_raise(self, function, types):\r\n        # Our function helper or dispatcher found that the function does not\r\n        # work with Quantity.  In principle, there may be another class that\r\n        # knows what to do with us, for which we should return NotImplemented.\r\n        # But if there is ndarray (or a non-Quantity subclass of it) around,\r\n        # it quite likely coerces, so we should just break.\r\n        if any(\r\n            issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\r\n        ):\r\n            raise TypeError(\r\n                f\"the Quantity implementation cannot handle {function} \"\r\n                \"with the given arguments.\"\r\n            ) from None\r\n        else:\r\n            return NotImplemented\r\n\r\n    # Calculation -- override ndarray methods to take into account units.\r\n    # We use the corresponding numpy functions to evaluate the results, since\r\n    # the methods do not always allow calling with keyword arguments.\r\n    # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\r\n    # TypeError: 'a_max' is an invalid keyword argument for this function.\r\n    def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\r\n        \"\"\"Wrap a numpy function that processes self, returning a Quantity.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap.\r\n        args : positional arguments\r\n            Any positional arguments to the function beyond the first argument\r\n            (which will be set to ``self``).\r\n        kwargs : keyword arguments\r\n            Keyword arguments to the function.\r\n\r\n        If present, the following arguments are treated specially:\r\n\r\n        unit : `~astropy.units.Unit`\r\n            Unit of the output result.  If not given, the unit of ``self``.\r\n        out : `~astropy.units.Quantity`\r\n            A Quantity instance in which to store the output.\r\n\r\n        Notes\r\n        -----\r\n        Output should always be assigned via a keyword argument, otherwise\r\n        no proper account of the unit is taken.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            Result of the function call, with the unit set properly.\r\n        \"\"\"\r\n        if unit is None:\r\n"]
[180.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[180.002, "i", "cat asv.ci.conf.json\r"]
[180.004, "o", "cat asv.ci.conf.json\r\n"]
[180.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[185.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[185.002, "i", "sed -n '1,220p' astropy-benchmarks/benchmarks/units.py\r"]
[185.004, "o", "sed -n '1,220p' astropy-benchmarks/benchmarks/units.py\r\n"]
[185.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n"]
[190.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[190.002, "i", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r"]
[190.004, "o", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r\n"]
[190.006, "o", "_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\"\r\n\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: argument {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages}: invalid choice: 'dev' (choose from 'help', 'quickstart', 'machine', 'setup', 'run', 'continuous', 'find', 'rm', 'publish', 'preview', 'profile', 'update', 'show', 'compare', 'check', 'gh-pages')\r\n"]
[195.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[195.002, "i", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r"]
[195.004, "o", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[195.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[200.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[200.002, "i", "sed -n '1,400p' astropy/units/quantity.py\r"]
[200.004, "o", "sed -n '1,400p' astropy/units/quantity.py\r\n"]
[200.006, "o", "\u001b[?2004l\r\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\r\n\"\"\"\r\nThis module defines the `Quantity` object, which represents a number with some\r\nassociated units. `Quantity` objects support operations like ordinary numbers,\r\nbut will deal with unit conversions internally.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport builtins\r\nimport numbers\r\nimport operator\r\nimport re\r\nimport warnings\r\nfrom fractions import Fraction\r\nfrom typing import TYPE_CHECKING\r\n\r\nimport numpy as np\r\n\r\nfrom astropy import config as _config\r\nfrom astropy.utils.compat.numpycompat import COPY_IF_NEEDED, NUMPY_LT_2_0\r\nfrom astropy.utils.data_info import ParentDtypeInfo\r\nfrom astropy.utils.exceptions import AstropyWarning\r\n\r\nfrom .core import (\r\n    Unit,\r\n    UnitBase,\r\n    UnitConversionError,\r\n    UnitsError,\r\n    UnitTypeError,\r\n    dimensionless_unscaled,\r\n    get_current_unit_registry,\r\n)\r\nfrom .format import Base, Latex\r\nfrom .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\r\nfrom .quantity_helper.function_helpers import (\r\n    DISPATCHED_FUNCTIONS,\r\n    FUNCTION_HELPERS,\r\n    SUBCLASS_SAFE_FUNCTIONS,\r\n    UNSUPPORTED_FUNCTIONS,\r\n)\r\nfrom .structured import StructuredUnit, _structured_unit_like_dtype\r\nfrom .utils import is_effectively_unity\r\n\r\nif TYPE_CHECKING:\r\n    from typing_extensions import Self\r\n\r\n    from .typing import QuantityLike\r\n\r\n__all__ = [\r\n    \"Quantity\",\r\n    \"SpecificTypeQuantity\",\r\n    \"QuantityInfoBase\",\r\n    \"QuantityInfo\",\r\n    \"allclose\",\r\n    \"isclose\",\r\n]\r\n\r\n\r\n# We don't want to run doctests in the docstrings we inherit from Numpy\r\n__doctest_skip__ = [\"Quantity.*\"]\r\n\r\n_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\r\n_UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\r\n\r\n\r\nclass Conf(_config.ConfigNamespace):\r\n    \"\"\"\r\n    Configuration parameters for Quantity.\r\n    \"\"\"\r\n\r\n    latex_array_threshold = _config.ConfigItem(\r\n        100,\r\n        \"The maximum size an array Quantity can be before its LaTeX \"\r\n        'representation for IPython gets \"summarized\" (meaning only the first '\r\n        'and last few elements are shown with \"...\" between). Setting this to a '\r\n        \"negative number means that the value will instead be whatever numpy \"\r\n        \"gets from get_printoptions.\",\r\n    )\r\n\r\n\r\nconf = Conf()\r\n\r\n\r\nclass QuantityIterator:\r\n    \"\"\"\r\n    Flat iterator object to iterate over Quantities.\r\n\r\n    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\r\n    ``q``.  It allows iterating over the array as if it were a 1-D array,\r\n    either in a for-loop or by calling its `next` method.\r\n\r\n    Iteration is done in C-contiguous style, with the last index varying the\r\n    fastest. The iterator can also be indexed using basic slicing or\r\n    advanced indexing.\r\n\r\n    See Also\r\n    --------\r\n    Quantity.flatten : Returns a flattened copy of an array.\r\n\r\n    Notes\r\n    -----\r\n    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\r\n    is not exported by the `~astropy.units` module.  Instead of\r\n    instantiating a `QuantityIterator` directly, use `Quantity.flat`.\r\n    \"\"\"\r\n\r\n    def __init__(self, q):\r\n        self._quantity = q\r\n        self._dataiter = q.view(np.ndarray).flat\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __getitem__(self, indx):\r\n        out = self._dataiter.__getitem__(indx)\r\n        # For single elements, ndarray.flat.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if isinstance(out, type(self._quantity)):\r\n            return out\r\n        else:\r\n            return self._quantity._new_view(out)\r\n\r\n    def __setitem__(self, index, value):\r\n        self._dataiter[index] = self._quantity._to_own_unit(value)\r\n\r\n    def __next__(self):\r\n        \"\"\"\r\n        Return the next value, or raise StopIteration.\r\n        \"\"\"\r\n        out = next(self._dataiter)\r\n        # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\r\n        return self._quantity._new_view(out)\r\n\r\n    next = __next__\r\n\r\n    def __len__(self):\r\n        return len(self._dataiter)\r\n\r\n    # Properties and methods to match `numpy.ndarray.flatiter`\r\n\r\n    @property\r\n    def base(self):\r\n        \"\"\"A reference to the array that is iterated over.\"\"\"\r\n        return self._quantity\r\n\r\n    @property\r\n    def coords(self):\r\n        \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\r\n        return self._dataiter.coords\r\n\r\n    @property\r\n    def index(self):\r\n        \"\"\"Current flat index into the array.\"\"\"\r\n        return self._dataiter.index\r\n\r\n    def copy(self):\r\n        \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\r\n        return self._quantity.flatten()\r\n\r\n\r\nclass QuantityInfoBase(ParentDtypeInfo):\r\n    # This is on a base class rather than QuantityInfo directly, so that\r\n    # it can be used for EarthLocationInfo yet make clear that that class\r\n    # should not be considered a typical Quantity subclass by Table.\r\n    attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\r\n    _supports_indexing = True\r\n\r\n    @staticmethod\r\n    def default_format(val):\r\n        return f\"{val.value}\"\r\n\r\n    @staticmethod\r\n    def possible_string_format_functions(format_):\r\n        \"\"\"Iterate through possible string-derived format functions.\r\n\r\n        A string can either be a format specifier for the format built-in,\r\n        a new-style format string, or an old-style format string.\r\n\r\n        This method is overridden in order to suppress printing the unit\r\n        in each row since it is already at the top in the column header.\r\n        \"\"\"\r\n        yield lambda format_, val: format(val.value, format_)\r\n        yield lambda format_, val: format_.format(val.value)\r\n        yield lambda format_, val: format_ % val.value\r\n\r\n\r\nclass QuantityInfo(QuantityInfoBase):\r\n    \"\"\"\r\n    Container for meta information like name, description, format.  This is\r\n    required when the object is used as a mixin column within a table, but can\r\n    be used as a general way to store meta information.\r\n    \"\"\"\r\n\r\n    _represent_as_dict_attrs = (\"value\", \"unit\")\r\n    _construct_from_dict_args = [\"value\"]\r\n    _represent_as_dict_primary_data = \"value\"\r\n\r\n    def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\r\n        \"\"\"\r\n        Return a new Quantity instance which is consistent with the\r\n        input ``cols`` and has ``length`` rows.\r\n\r\n        This is intended for creating an empty column object whose elements can\r\n        be set in-place for table operations like join or vstack.\r\n\r\n        Parameters\r\n        ----------\r\n        cols : list\r\n            List of input columns\r\n        length : int\r\n            Length of the output column object\r\n        metadata_conflicts : str ('warn'|'error'|'silent')\r\n            How to handle metadata conflicts\r\n        name : str\r\n            Output column name\r\n\r\n        Returns\r\n        -------\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n            Empty instance of this class consistent with ``cols``\r\n\r\n        \"\"\"\r\n        # Get merged info attributes like shape, dtype, format, description, etc.\r\n        attrs = self.merge_cols_attributes(\r\n            cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\r\n        )\r\n\r\n        # Make an empty quantity using the unit of the last one.\r\n        shape = (length,) + attrs.pop(\"shape\")\r\n        dtype = attrs.pop(\"dtype\")\r\n        # Use zeros so we do not get problems for Quantity subclasses such\r\n        # as Longitude and Latitude, which cannot take arbitrary values.\r\n        data = np.zeros(shape=shape, dtype=dtype)\r\n        # Get arguments needed to reconstruct class\r\n        map = {\r\n            key: (data if key == \"value\" else getattr(cols[-1], key))\r\n            for key in self._represent_as_dict_attrs\r\n        }\r\n        map[\"copy\"] = COPY_IF_NEEDED\r\n        out = self._construct_from_dict(map)\r\n\r\n        # Set remaining info attributes\r\n        for attr, value in attrs.items():\r\n            setattr(out.info, attr, value)\r\n\r\n        return out\r\n\r\n    def get_sortable_arrays(self):\r\n        \"\"\"\r\n        Return a list of arrays which can be lexically sorted to represent\r\n        the order of the parent column.\r\n\r\n        For Quantity this is just the quantity itself.\r\n\r\n\r\n        Returns\r\n        -------\r\n        arrays : list of ndarray\r\n        \"\"\"\r\n        return [self._parent]\r\n\r\n\r\nclass Quantity(np.ndarray):\r\n    \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\r\n\r\n    See also: https://docs.astropy.org/en/stable/units/quantity.html\r\n\r\n    Parameters\r\n    ----------\r\n    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\r\n        The numerical value of this quantity in the units given by unit.  If a\r\n        `Quantity` or sequence of them (or any other valid object with a\r\n        ``unit`` attribute), creates a new `Quantity` object, converting to\r\n        `unit` units as needed.  If a string, it is converted to a number or\r\n        `Quantity`, depending on whether a unit is present.\r\n\r\n    unit : unit-like\r\n        An object that represents the unit associated with the input value.\r\n        Must be an `~astropy.units.UnitBase` object or a string parseable by\r\n        the :mod:`~astropy.units` package.\r\n\r\n    dtype : ~numpy.dtype, optional\r\n        The dtype of the resulting Numpy array or scalar that will\r\n        hold the value.  If not provided, it is determined from the input,\r\n        except that any integer and (non-Quantity) object inputs are converted\r\n        to float by default.\r\n        If `None`, the normal `numpy.dtype` introspection is used, e.g.\r\n        preventing upcasting of integers.\r\n\r\n    copy : bool, optional\r\n        If `True` (default), then the value is copied.  Otherwise, a copy will\r\n        only be made if ``__array__`` returns a copy, if value is a nested\r\n        sequence, or if a copy is needed to satisfy an explicitly given\r\n        ``dtype``.  (The `False` option is intended mostly for internal use,\r\n        to speed up initialization where a copy is known to have been made.\r\n        Use with care.)\r\n\r\n    order : {'C', 'F', 'A'}, optional\r\n        Specify the order of the array.  As in `~numpy.array`.  This parameter\r\n        is ignored if the input is a `Quantity` and ``copy=False``.\r\n\r\n    subok : bool, optional\r\n        If `False` (default), the returned array will be forced to be a\r\n        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\r\n        or a subclass appropriate for the unit will be used (such as\r\n        `~astropy.units.Dex` for ``u.dex(u.AA)``).\r\n\r\n    ndmin : int, optional\r\n        Specifies the minimum number of dimensions that the resulting array\r\n        should have.  Ones will be prepended to the shape as needed to meet\r\n        this requirement.  This parameter is ignored if the input is a\r\n        `Quantity` and ``copy=False``.\r\n\r\n    Raises\r\n    ------\r\n    TypeError\r\n        If the value provided is not a Python numeric type.\r\n    TypeError\r\n        If the unit provided is not either a :class:`~astropy.units.Unit`\r\n        object or a parseable string unit.\r\n\r\n    Notes\r\n    -----\r\n    Quantities can also be created by multiplying a number or array with a\r\n    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\r\n\r\n    Unless the ``dtype`` argument is explicitly specified, integer\r\n    or (non-Quantity) object inputs are converted to `float` by default.\r\n    \"\"\"\r\n\r\n    # Need to set a class-level default for _equivalencies, or\r\n    # Constants can not initialize properly\r\n    _equivalencies = []\r\n\r\n    # Default unit for initialization; can be overridden by subclasses,\r\n    # possibly to `None` to indicate there is no default unit.\r\n    _default_unit = dimensionless_unscaled\r\n\r\n    # Ensures views have an undefined unit.\r\n    _unit = None\r\n\r\n    __array_priority__ = 10000\r\n\r\n    def __class_getitem__(cls, unit_shape_dtype):\r\n        \"\"\"Quantity Type Hints.\r\n\r\n        Unit-aware type hints are ``Annotated`` objects that encode the class,\r\n        the unit, and possibly shape and dtype information, depending on the\r\n        python and :mod:`numpy` versions.\r\n\r\n        Schematically, ``Annotated[cls[shape, dtype], unit]``\r\n\r\n        As a classmethod, the type is the class, ie ``Quantity``\r\n        produces an ``Annotated[Quantity, ...]`` while a subclass\r\n        like :class:`~astropy.coordinates.Angle` returns\r\n        ``Annotated[Angle, ...]``.\r\n\r\n        Parameters\r\n        ----------\r\n        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\r\n            Unit specification, can be the physical type (ie str or class).\r\n            If tuple, then the first element is the unit specification\r\n            and all other elements are for `numpy.ndarray` type annotations.\r\n            Whether they are included depends on the python and :mod:`numpy`\r\n            versions.\r\n\r\n        Returns\r\n        -------\r\n        `typing.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\r\n            Return type in this preference order:\r\n            * `typing.Annotated`\r\n            * `astropy.units.Unit` or `astropy.units.PhysicalType`\r\n\r\n        Raises\r\n        ------\r\n        TypeError\r\n            If the unit/physical_type annotation is not Unit-like or\r\n            PhysicalType-like.\r\n\r\n        Examples\r\n        --------\r\n        Create a unit-aware Quantity type annotation\r\n\r\n            >>> Quantity[Unit(\"s\")]\r\n            Annotated[Quantity, Unit(\"s\")]\r\n\r\n        See Also\r\n        --------\r\n        `~astropy.units.quantity_input`\r\n            Use annotations for unit checks on function arguments and results.\r\n\r\n        Notes\r\n        -----\r\n        |Quantity| types are also static-type compatible.\r\n        \"\"\"\r\n        from typing import Annotated\r\n\r\n        # process whether [unit] or [unit, shape, ptype]\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n"]
[205.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[205.002, "i", "sed -n '400,1200p' astropy/units/quantity.py\r"]
[205.004, "o", "sed -n '400,1200p' astropy/units/quantity.py\r\n"]
[205.006, "o", "\u001b[?2004l\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n            target = unit_shape_dtype[0]\r\n            shape_dtype = unit_shape_dtype[1:]\r\n        else:  # just unit\r\n            target = unit_shape_dtype\r\n            shape_dtype = ()\r\n\r\n        # Allowed unit/physical types. Errors if neither.\r\n        try:\r\n            unit = Unit(target)\r\n        except (TypeError, ValueError):\r\n            from astropy.units.physical import get_physical_type\r\n\r\n            try:\r\n                unit = get_physical_type(target)\r\n            except (TypeError, ValueError, KeyError):  # KeyError for Enum\r\n                raise TypeError(\r\n                    \"unit annotation is not a Unit or PhysicalType\"\r\n                ) from None\r\n\r\n        # Quantity does not (yet) properly extend the NumPy generics types,\r\n        # introduced in numpy v1.22+, instead just including the unit info as\r\n        # metadata using Annotated.\r\n        # TODO: ensure we do interact with NDArray.__class_getitem__.\r\n        return Annotated[cls, unit]\r\n\r\n    def __new__(\r\n        cls: type[Self],\r\n        value: QuantityLike,\r\n        unit=None,\r\n        dtype=np.inexact,\r\n        copy=True,\r\n        order=None,\r\n        subok=False,\r\n        ndmin=0,\r\n    ) -> Self:\r\n        if unit is not None:\r\n            # convert unit first, to avoid multiple string->unit conversions\r\n            unit = Unit(unit)\r\n\r\n        # inexact -> upcast to float dtype\r\n        float_default = dtype is np.inexact\r\n        if float_default:\r\n            dtype = None\r\n\r\n        # optimize speed for Quantity with no dtype given, copy=COPY_IF_NEEDED\r\n        if isinstance(value, Quantity):\r\n            if unit is not None and unit is not value.unit:\r\n                value = value.to(unit)\r\n                # the above already makes a copy (with float dtype)\r\n                copy = COPY_IF_NEEDED\r\n\r\n            if type(value) is not cls and not (subok and isinstance(value, cls)):\r\n                value = value.view(cls)\r\n\r\n            if float_default and value.dtype.kind in \"iu\":\r\n                dtype = float\r\n\r\n            return np.array(\r\n                value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n            )\r\n\r\n        # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\r\n        # To ensure array remains fast, we short-circuit it.\r\n        value_unit = None\r\n        if not isinstance(value, np.ndarray):\r\n            if isinstance(value, str):\r\n                # The first part of the regex string matches any integer/float;\r\n                # the second parts adds possible trailing .+-, which will break\r\n                # the float function below and ensure things like 1.2.3deg\r\n                # will not work.\r\n                pattern = (\r\n                    r\"\\s*[+-]?\"\r\n                    r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\r\n                    r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\r\n                    r\"([eE][+-]?\\d+)?\"\r\n                    r\"[.+-]?\"\r\n                )\r\n\r\n                v = re.match(pattern, value)\r\n                unit_string = None\r\n                try:\r\n                    value = float(v.group())\r\n\r\n                except Exception:\r\n                    raise TypeError(\r\n                        f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\r\n                        \"start with a number.\"\r\n                    )\r\n\r\n                unit_string = v.string[v.end() :].strip()\r\n                if unit_string:\r\n                    value_unit = Unit(unit_string)\r\n                    if unit is None:\r\n                        unit = value_unit  # signal no conversion needed below.\r\n\r\n            elif isinstance(value, (list, tuple)) and len(value) > 0:\r\n                if all(isinstance(v, Quantity) for v in value):\r\n                    # If a list/tuple contains only quantities, stack them,\r\n                    # which also converts them to the same unit.\r\n                    value = np.stack(value)\r\n                    copy = False\r\n\r\n                elif (\r\n                    dtype is None\r\n                    and not hasattr(value, \"dtype\")\r\n                    and isinstance(unit, StructuredUnit)\r\n                ):\r\n                    # Special case for list/tuple of values and a structured unit:\r\n                    # ``np.array(value, dtype=None)`` would treat tuples as lower\r\n                    # levels of the array, rather than as elements of a structured\r\n                    # array, so we use the structure of the unit to help infer the\r\n                    # structured dtype of the value.\r\n                    dtype = unit._recursively_get_dtype(value)\r\n\r\n        using_default_unit = False\r\n        if value_unit is None:\r\n            # If the value has a `unit` attribute and if not None\r\n            # (for Columns with uninitialized unit), treat it like a quantity.\r\n            value_unit = getattr(value, \"unit\", None)\r\n            if value_unit is None:\r\n                # Default to dimensionless for no (initialized) unit attribute.\r\n                if unit is None:\r\n                    using_default_unit = True\r\n                    unit = cls._default_unit\r\n                value_unit = unit  # signal below that no conversion is needed\r\n            else:\r\n                try:\r\n                    value_unit = Unit(value_unit)\r\n                except Exception as exc:\r\n                    raise TypeError(\r\n                        f\"The unit attribute {value.unit!r} of the input could \"\r\n                        \"not be parsed as an astropy Unit.\"\r\n                    ) from exc\r\n\r\n                if unit is None:\r\n                    unit = value_unit\r\n                elif unit is not value_unit:\r\n                    copy = COPY_IF_NEEDED  # copy will be made in conversion at end\r\n\r\n        value = np.array(\r\n            value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n        )\r\n\r\n        # For no-user-input unit, make sure the constructed unit matches the\r\n        # structure of the data.\r\n        if using_default_unit and value.dtype.names is not None:\r\n            unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\r\n\r\n        # check that array contains numbers or long int objects\r\n        if value.dtype.kind in \"OSU\" and not (\r\n            value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\r\n        ):\r\n            raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\r\n\r\n        # by default, cast any integer, boolean, etc., to float\r\n        if float_default and value.dtype.kind in \"iuO\":\r\n            value = value.astype(float)\r\n\r\n        # if we allow subclasses, allow a class from the unit.\r\n        if subok:\r\n            qcls = getattr(unit, \"_quantity_class\", cls)\r\n            if issubclass(qcls, cls):\r\n                cls = qcls\r\n\r\n        value = value.view(cls)\r\n        value._set_unit(value_unit)\r\n        if unit is value_unit:\r\n            return value\r\n        else:\r\n            # here we had non-Quantity input that had a \"unit\" attribute\r\n            # with a unit different from the desired one.  So, convert.\r\n            return value.to(unit)\r\n\r\n    def __array_finalize__(self, obj):\r\n        # Check whether super().__array_finalize should be called\r\n        # (sadly, ndarray.__array_finalize__ is None; we cannot be sure\r\n        # what is above us).\r\n        super_array_finalize = super().__array_finalize__\r\n        if super_array_finalize is not None:\r\n            super_array_finalize(obj)\r\n\r\n        # If we're a new object or viewing an ndarray, nothing has to be done.\r\n        if obj is None or obj.__class__ is np.ndarray:\r\n            return\r\n\r\n        # Copy over the unit and possibly info.  Note that the only way the\r\n        # unit can already be set is if one enters via _new_view(), where the\r\n        # unit is often different from that of self, and where propagation of\r\n        # info is not always desirable.\r\n        if self._unit is None:\r\n            unit = getattr(obj, \"_unit\", None)\r\n            if unit is not None:\r\n                self._set_unit(unit)\r\n\r\n            # Copy info if the original had `info` defined.  Because of the way the\r\n            # DataInfo works, `'info' in obj.__dict__` is False until the\r\n            # `info` attribute is accessed or set.\r\n            if \"info\" in obj.__dict__:\r\n                self.info = obj.info\r\n\r\n    def __array_wrap__(self, obj, context=None, return_scalar=False):\r\n        if context is None:\r\n            # Methods like .squeeze() created a new `ndarray` and then call\r\n            # __array_wrap__ to turn the array into self's subclass.\r\n            return self._new_view(obj)\r\n\r\n        raise NotImplementedError(\r\n            \"__array_wrap__ should not be used with a context any more since all \"\r\n            \"use should go through array_function. Please raise an issue on \"\r\n            \"https://github.com/astropy/astropy\"\r\n        )\r\n\r\n    def __array_ufunc__(self, function, method, *inputs, **kwargs):\r\n        \"\"\"Wrap numpy ufuncs, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            ufunc to wrap.\r\n        method : str\r\n            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\r\n        inputs : tuple\r\n            Input arrays.\r\n        kwargs : keyword arguments\r\n            As passed on, with ``out`` containing possible quantity output.\r\n\r\n        Returns\r\n        -------\r\n        result : `~astropy.units.Quantity` or `NotImplemented`\r\n            Results of the ufunc, with the unit set properly.\r\n        \"\"\"\r\n        # Determine required conversion functions -- to bring the unit of the\r\n        # input to that expected (e.g., radian for np.sin), or to get\r\n        # consistent units between two inputs (e.g., in np.add) --\r\n        # and the unit of the result (or tuple of units for nout > 1).\r\n        try:\r\n            converters, unit = converters_and_unit(function, method, *inputs)\r\n\r\n            out = kwargs.get(\"out\", None)\r\n            # Avoid loop back by turning any Quantity output into array views.\r\n            if out is not None:\r\n                # If pre-allocated output is used, check it is suitable.\r\n                # This also returns array view, to ensure we don't loop back.\r\n                if function.nout == 1:\r\n                    out = out[0]\r\n                out_array = check_output(out, unit, inputs, function=function)\r\n                # Ensure output argument remains a tuple.\r\n                kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\r\n\r\n            if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\r\n                # Special-case for initial argument for reductions like\r\n                # np.add.reduce.  This should be converted to the output unit as\r\n                # well, which is typically the same as the input unit (but can\r\n                # in principle be different: unitless for np.equal, radian\r\n                # for np.arctan2, though those are not necessarily useful!)\r\n                kwargs[\"initial\"] = self._to_own_unit(\r\n                    kwargs[\"initial\"], check_precision=False, unit=unit\r\n                )\r\n\r\n            # Same for inputs, but here also convert if necessary.\r\n            arrays = []\r\n            for input_, converter in zip(inputs, converters):\r\n                input_ = getattr(input_, \"value\", input_)\r\n                arrays.append(converter(input_) if converter else input_)\r\n\r\n            # Call our superclass's __array_ufunc__\r\n            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\r\n            # If unit is None, a plain array is expected (e.g., comparisons), which\r\n            # means we're done.\r\n            # We're also done if the result was None (for method 'at') or\r\n            # NotImplemented, which can happen if other inputs/outputs override\r\n            # __array_ufunc__; hopefully, they can then deal with us.\r\n            if unit is None or result is None or result is NotImplemented:\r\n                return result\r\n\r\n            return self._result_as_quantity(result, unit, out)\r\n\r\n        except (TypeError, ValueError, AttributeError) as e:\r\n            out_normalized = kwargs.get(\"out\", ())\r\n            inputs_and_outputs = inputs + out_normalized\r\n            ignored_ufunc = (\r\n                None,\r\n                np.ndarray.__array_ufunc__,\r\n                type(self).__array_ufunc__,\r\n            )\r\n            if not all(\r\n                getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\r\n                for io in inputs_and_outputs\r\n            ):\r\n                return NotImplemented\r\n            else:\r\n                raise e\r\n\r\n    def _result_as_quantity(self, result, unit, out):\r\n        \"\"\"Turn result into a quantity with the given unit.\r\n\r\n        If no output is given, it will take a view of the array as a quantity,\r\n        and set the unit.  If output is given, those should be quantity views\r\n        of the result arrays, and the function will just set the unit.\r\n\r\n        Parameters\r\n        ----------\r\n        result : ndarray or tuple thereof\r\n            Array(s) which need to be turned into quantity.\r\n        unit : `~astropy.units.Unit`\r\n            Unit for the quantities to be returned (or `None` if the result\r\n            should not be a quantity).  Should be tuple if result is a tuple.\r\n        out : `~astropy.units.Quantity` or None\r\n            Possible output quantity. Should be `None` or a tuple if result\r\n            is a tuple.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n           With units set.\r\n        \"\"\"\r\n        if isinstance(result, (tuple, list)):\r\n            if out is None:\r\n                out = (None,) * len(result)\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n        # ``obj.__class is np.ndarray``. So, not worth special-casing.\r\n        if obj is None:\r\n            obj = self.view(np.ndarray)\r\n        else:\r\n            obj = np.array(obj, copy=COPY_IF_NEEDED, subok=True)\r\n\r\n        # Take the view, set the unit, and update possible other properties\r\n        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\r\n        view = obj.view(quantity_subclass)\r\n        view._set_unit(unit)\r\n        view.__array_finalize__(self)\r\n        if propagate_info and \"info\" in self.__dict__:\r\n            view.info = self.info\r\n        return view\r\n\r\n    def _set_unit(self, unit):\r\n        \"\"\"Set the unit.\r\n\r\n        This is used anywhere the unit is set or modified, i.e., in the\r\n        initializer, in ``__imul__`` and ``__itruediv__`` for in-place\r\n        multiplication and division by another unit, as well as in\r\n        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\r\n        sets the unit, but subclasses can override it to check that, e.g.,\r\n        a unit is consistent.\r\n        \"\"\"\r\n        if not isinstance(unit, UnitBase):\r\n            if isinstance(self._unit, StructuredUnit) or isinstance(\r\n                unit, StructuredUnit\r\n            ):\r\n                unit = StructuredUnit(unit, self.dtype)\r\n            else:\r\n                # Trying to go through a string ensures that, e.g., Magnitudes with\r\n                # dimensionless physical unit become Quantity with units of mag.\r\n                unit = Unit(str(unit), parse_strict=\"silent\")\r\n                if not isinstance(unit, (UnitBase, StructuredUnit)):\r\n                    raise UnitTypeError(\r\n                        f\"{self.__class__.__name__} instances require normal units, \"\r\n                        f\"not {unit.__class__} instances.\"\r\n                    )\r\n\r\n        self._unit = unit\r\n\r\n    def __deepcopy__(self, memo):\r\n        # If we don't define this, ``copy.deepcopy(quantity)`` will\r\n        # return a bare Numpy array.\r\n        return self.copy()\r\n\r\n    def __reduce__(self):\r\n        # patch to pickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        object_state = list(super().__reduce__())\r\n        object_state[2] = (object_state[2], self.__dict__)\r\n        return tuple(object_state)\r\n\r\n    def __setstate__(self, state):\r\n        # patch to unpickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        nd_state, own_state = state\r\n        super().__setstate__(nd_state)\r\n        self.__dict__.update(own_state)\r\n\r\n    info = QuantityInfo()\r\n\r\n    def _to_value(self, unit, equivalencies=[]):\r\n        \"\"\"Helper method for to and to_value.\"\"\"\r\n        if equivalencies == []:\r\n            equivalencies = self._equivalencies\r\n        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\r\n            # Standard path, let unit to do work.\r\n            return self.unit.to(\r\n                unit, self.view(np.ndarray), equivalencies=equivalencies\r\n            )\r\n\r\n        else:\r\n            # The .to() method of a simple unit cannot convert a structured\r\n            # dtype, so we work around it, by recursing.\r\n            # TODO: deprecate this?\r\n            # Convert simple to Structured on initialization?\r\n            result = np.empty_like(self.view(np.ndarray))\r\n            for name in self.dtype.names:\r\n                result[name] = self[name]._to_value(unit, equivalencies)\r\n            return result\r\n\r\n    def to(self, unit, equivalencies=[], copy=True):\r\n        \"\"\"\r\n        Return a new `~astropy.units.Quantity` object with the specified unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like\r\n            An object that represents the unit to convert to. Must be\r\n            an `~astropy.units.UnitBase` object or a string parseable\r\n            by the `~astropy.units` package.\r\n\r\n        equivalencies : list of tuple\r\n            A list of equivalence pairs to try if the units are not\r\n            directly convertible.  See :ref:`astropy:unit_equivalencies`.\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n            (none for `~astropy.units.Quantity`, but may be set for subclasses)\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        copy : bool, optional\r\n            If `True` (default), then the value is copied.  Otherwise, a copy\r\n            will only be made if necessary.\r\n\r\n        See Also\r\n        --------\r\n        to_value : get the numerical value in a given unit.\r\n        \"\"\"\r\n        # We don't use `to_value` below since we always want to make a copy\r\n        # and don't want to slow down this method (esp. the scalar case).\r\n        unit = Unit(unit)\r\n        if copy:\r\n            # Avoid using to_value to ensure that we make a copy. We also\r\n            # don't want to slow down this method (esp. the scalar case).\r\n            value = self._to_value(unit, equivalencies)\r\n        else:\r\n            # to_value only copies if necessary\r\n            value = self.to_value(unit, equivalencies)\r\n        return self._new_view(value, unit)\r\n\r\n    def to_value(self, unit=None, equivalencies=[]):\r\n        \"\"\"\r\n        The numerical value, possibly in a different unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            The unit in which the value should be given. If not given or `None`,\r\n            use the current unit.\r\n\r\n        equivalencies : list of tuple, optional\r\n            A list of equivalence pairs to try if the units are not directly\r\n            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\r\n            or ``[]``, class default equivalencies will be used (none for\r\n            `~astropy.units.Quantity`, but may be set for subclasses).\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        Returns\r\n        -------\r\n        value : ndarray or scalar\r\n            The value in the units specified. For arrays, this will be a view\r\n            of the data if no unit conversion was necessary.\r\n\r\n        See Also\r\n        --------\r\n        to : Get a new instance in a different unit.\r\n        \"\"\"\r\n        if unit is None or unit is self.unit:\r\n            value = self.view(np.ndarray)\r\n        elif not self.dtype.names:\r\n            # For non-structured, we attempt a short-cut, where we just get\r\n            # the scale.  If that is 1, we do not have to do anything.\r\n            unit = Unit(unit)\r\n            # We want a view if the unit does not change.  One could check\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n            # TODO: would be better for `unit.to` to have an in-place flag.\r\n            try:\r\n                scale = self.unit._to(unit)\r\n            except Exception:\r\n                # Short-cut failed; try default (maybe equivalencies help).\r\n                value = self._to_value(unit, equivalencies)\r\n            else:\r\n                value = self.view(np.ndarray)\r\n                if not is_effectively_unity(scale):\r\n                    # not in-place!\r\n                    value = value * scale\r\n        else:\r\n            # For structured arrays, we go the default route.\r\n            value = self._to_value(unit, equivalencies)\r\n\r\n        # Index with empty tuple to decay array scalars in to numpy scalars.\r\n        return value if value.shape else value[()]\r\n\r\n    value = property(\r\n        to_value,\r\n        doc=\"\"\"The numerical value of this instance.\r\n\r\n    See also\r\n    --------\r\n    to_value : Get the numerical value in a given unit.\r\n    \"\"\",\r\n    )\r\n\r\n    @property\r\n    def unit(self):\r\n        \"\"\"\r\n        A `~astropy.units.UnitBase` object representing the unit of this\r\n        quantity.\r\n        \"\"\"\r\n        return self._unit\r\n\r\n    @property\r\n    def equivalencies(self):\r\n        \"\"\"\r\n        A list of equivalencies that will be applied by default during\r\n        unit conversions.\r\n        \"\"\"\r\n        return self._equivalencies\r\n\r\n    def _recursively_apply(self, func):\r\n        \"\"\"Apply function recursively to every field.\r\n\r\n        Returns a copy with the result.\r\n        \"\"\"\r\n        result = np.empty_like(self)\r\n        result_value = result.view(np.ndarray)\r\n        result_unit = ()\r\n        for name in self.dtype.names:\r\n            part = func(self[name])\r\n            result_value[name] = part.value\r\n            result_unit += (part.unit,)\r\n\r\n        result._set_unit(result_unit)\r\n        return result\r\n\r\n    @property\r\n    def si(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with SI units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"si\"))\r\n        si_unit = self.unit.si\r\n        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\r\n\r\n    @property\r\n    def cgs(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with CGS units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"cgs\"))\r\n        cgs_unit = self.unit.cgs\r\n        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\r\n\r\n    @property\r\n    def isscalar(self):\r\n        \"\"\"\r\n        True if the `value` of this quantity is a scalar, or False if it\r\n        is an array-like object.\r\n\r\n        .. note::\r\n            This is subtly different from `numpy.isscalar` in that\r\n            `numpy.isscalar` returns False for a zero-dimensional array\r\n            (e.g. ``np.array(1)``), while this is True for quantities,\r\n            since quantities cannot represent true numpy scalars.\r\n        \"\"\"\r\n        return not self.shape\r\n\r\n    # This flag controls whether convenience conversion members, such\r\n    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\r\n    # not turned on on Quantity itself, but is on some subclasses of\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n    _include_easy_conversion_members = False\r\n\r\n    def __dir__(self):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.  This function is implemented in\r\n        order to make autocompletion still work correctly in IPython.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            return super().__dir__()\r\n\r\n        dir_values = set(super().__dir__())\r\n        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\r\n        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\r\n            dir_values.update(equivalent.names)\r\n        return sorted(dir_values)\r\n\r\n    def __getattr__(self, attr):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            raise AttributeError(\r\n                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\r\n            )\r\n\r\n        def get_virtual_unit_attribute():\r\n            registry = get_current_unit_registry().registry\r\n            to_unit = registry.get(attr, None)\r\n            if to_unit is None:\r\n                return None\r\n\r\n            try:\r\n                return self.unit.to(\r\n                    to_unit, self.value, equivalencies=self.equivalencies\r\n                )\r\n            except UnitsError:\r\n                return None\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n"]
[210.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[210.002, "i", "sed -n '1200,2000p' astropy/units/quantity.py\r"]
[210.004, "o", "sed -n '1200,2000p' astropy/units/quantity.py\r\n"]
[210.006, "o", "\u001b[?2004l\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n            # so they should raise a TypeError rather than an IndexError.\r\n            if self.isscalar:\r\n                raise TypeError(\r\n                    f\"'{self.__class__.__name__}' object with a scalar value \"\r\n                    \"does not support indexing\"\r\n                )\r\n            else:\r\n                raise\r\n        # For single elements, ndarray.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if not isinstance(out, np.ndarray):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def __setitem__(self, i, value):\r\n        if isinstance(i, str):\r\n            # Indexing will cause a different unit, so by doing this in\r\n            # two steps we effectively try with the right unit.\r\n            self[i][...] = value\r\n            return\r\n\r\n        # update indices in info if the info property has been accessed\r\n        # (in which case 'info' in self.__dict__ is True; this is guaranteed\r\n        # to be the case if we're part of a table).\r\n        if not self.isscalar and \"info\" in self.__dict__:\r\n            self.info.adjust_indices(i, value, len(self))\r\n        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\r\n\r\n    # __contains__ is OK\r\n\r\n    def __bool__(self):\r\n        \"\"\"This method raises ValueError, since truthiness of quantities is ambiguous,\r\n        especially for logarithmic units and temperatures. Use explicit comparisons.\r\n        \"\"\"\r\n        raise ValueError(\r\n            f\"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units\"\r\n            \" and temperatures. Use explicit comparisons.\"\r\n        )\r\n\r\n    def __len__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\r\n            )\r\n        else:\r\n            return len(self.value)\r\n\r\n    # Numerical types\r\n    def __float__(self):\r\n        try:\r\n            return float(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __int__(self):\r\n        try:\r\n            return int(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __index__(self):\r\n        # for indices, we do not want to mess around with scaling at all,\r\n        # so unlike for float, int, we insist here on unscaled dimensionless\r\n        try:\r\n            assert self.unit.is_unity()\r\n            return self.value.__index__()\r\n        except Exception:\r\n            raise TypeError(\r\n                \"only integer dimensionless scalar quantities \"\r\n                \"can be converted to a Python index\"\r\n            )\r\n\r\n    # TODO: we may want to add a hook for dimensionless quantities?\r\n    @property\r\n    def _unitstr(self):\r\n        if self.unit is None:\r\n            unitstr = _UNIT_NOT_INITIALISED\r\n        else:\r\n            unitstr = str(self.unit)\r\n\r\n        if unitstr:\r\n            unitstr = \" \" + unitstr\r\n\r\n        return unitstr\r\n\r\n    def to_string(\r\n        self, unit=None, precision=None, format=None, subfmt=None, *, formatter=None\r\n    ):\r\n        \"\"\"\r\n        Generate a string representation of the quantity and its unit.\r\n\r\n        The behavior of this function can be altered via the\r\n        `numpy.set_printoptions` function and its various keywords.  The\r\n        exception to this is the ``threshold`` keyword, which is controlled via\r\n        the ``[units.quantity]`` configuration item ``latex_array_threshold``.\r\n        This is treated separately because the numpy default of 1000 is too big\r\n        for most browsers to handle.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            Specifies the unit.  If not provided,\r\n            the unit used to initialize the quantity will be used.\r\n\r\n        precision : number, optional\r\n            The level of decimal precision. If `None`, or not provided,\r\n            it will be determined from NumPy print options.\r\n\r\n        format : str, optional\r\n            The format of the result. If not provided, an unadorned\r\n            string is returned. Supported values are:\r\n\r\n            - 'latex': Return a LaTeX-formatted string\r\n\r\n            - 'latex_inline': Return a LaTeX-formatted string that uses\r\n              negative exponents instead of fractions\r\n\r\n        formatter : str, callable, dict, optional\r\n            The formatter to use for the value. If a string, it should be a\r\n            valid format specifier using Python's mini-language. If a callable,\r\n            it will be treated as the default formatter for all values and will\r\n            overwrite default Latex formatting for exponential notation and complex\r\n            numbers. If a dict, it should map a specific type to a callable to be\r\n            directly passed into `numpy.array2string`. If not provided, the default\r\n            formatter will be used.\r\n\r\n        subfmt : str, optional\r\n            Subformat of the result. For the moment, only used for\r\n            ``format='latex'`` and ``format='latex_inline'``. Supported\r\n            values are:\r\n\r\n            - 'inline': Use ``$ ... $`` as delimiters.\r\n\r\n            - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\r\n\r\n        Returns\r\n        -------\r\n        str\r\n            A string with the contents of this Quantity\r\n        \"\"\"\r\n        if unit is not None and unit != self.unit:\r\n            return self.to(unit).to_string(\r\n                unit=None,\r\n                precision=precision,\r\n                format=format,\r\n                subfmt=subfmt,\r\n                formatter=formatter,\r\n            )\r\n\r\n        if format is None and formatter is None and precision is None:\r\n            # Use default formatting settings\r\n            return f\"{self.value}{self._unitstr:s}\"\r\n\r\n        formats = {\r\n            None: None,\r\n            \"latex\": {\r\n                None: (\"$\", \"$\"),\r\n                \"inline\": (\"$\", \"$\"),\r\n                \"display\": (r\"$\\displaystyle \", r\"$\"),\r\n            },\r\n        }\r\n        formats[\"latex_inline\"] = formats[\"latex\"]\r\n\r\n        if format not in formats:\r\n            raise ValueError(f\"Unknown format '{format}'\")\r\n\r\n        format_spec = formatter if isinstance(formatter, str) else None\r\n\r\n        if format is None:\r\n            if format_spec is not None:\r\n\r\n                def formatter(value):\r\n                    return builtins.format(value, format_spec)\r\n\r\n            if callable(formatter):\r\n                formatter = {\"all\": formatter}\r\n\r\n            return (\r\n                np.array2string(\r\n                    self.value,\r\n                    precision=precision,\r\n                    floatmode=\"fixed\",\r\n                    formatter=formatter,\r\n                )\r\n                + self._unitstr\r\n            )\r\n\r\n        # else, for the moment we assume format=\"latex\" or \"latex_inline\".\r\n\r\n        # Set the precision if set, otherwise use numpy default\r\n        pops = np.get_printoptions()\r\n        if format_spec is None:\r\n            format_spec = (\r\n                f\".{precision if precision is not None else pops['precision']}g\"\r\n            )\r\n\r\n        # Use default formatters\r\n        if formatter is None or isinstance(formatter, str):\r\n            # Filter width and alignment operations for latex\r\n            # [[fill]align][sign][\"z\"][\"#\"][\"0\"][width][grouping_option][\".\" precision][type]\r\n            format_spec = re.sub(\r\n                r\"(.*?)([+\\- ]?)(\\d+)?(,)?(\\.\\d+)?([a-zA-Z%]+)?$\",\r\n                r\"\\2\\5\\6\",\r\n                format_spec,\r\n            )\r\n\r\n            if self.dtype.kind == \"c\":  # Complex default latex formatter\r\n                # Disallow sign operations for the imaginary part\r\n                imag_format_spec = re.sub(r\"[+\\- ]\", \"\", format_spec)\r\n\r\n                def formatter(value):\r\n                    return \"({}{}i)\".format(\r\n                        Latex.format_exponential_notation(\r\n                            value.real, format_spec=format_spec\r\n                        ),\r\n                        Latex.format_exponential_notation(\r\n                            value.imag, format_spec=\"+\" + imag_format_spec\r\n                        ),\r\n                    )\r\n\r\n            else:  # Float default latex formatter\r\n\r\n                def formatter(value):\r\n                    return Latex.format_exponential_notation(\r\n                        value, format_spec=format_spec\r\n                    )\r\n\r\n        if callable(formatter):\r\n            formatter = {\"all\": formatter}\r\n\r\n        # The view is needed for the scalar case - self.value might be float.\r\n        latex_value = np.array2string(\r\n            self.view(np.ndarray),\r\n            threshold=(\r\n                conf.latex_array_threshold\r\n                if conf.latex_array_threshold > -1\r\n                else pops[\"threshold\"]\r\n            ),\r\n            formatter=formatter,\r\n            max_line_width=np.inf,\r\n            separator=\",~\",\r\n        )\r\n\r\n        latex_value = latex_value.replace(\"...\", r\"\\dots\")\r\n\r\n        # Format unit\r\n        # [1:-1] strips the '$' on either side needed for math mode\r\n        if self.unit is None:\r\n            latex_unit = _UNIT_NOT_INITIALISED\r\n        elif format == \"latex\":\r\n            latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\r\n        elif format == \"latex_inline\":\r\n            latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\r\n\r\n        delimiter_left, delimiter_right = formats[format][subfmt]\r\n\r\n        # Add a space in front except for super-script units like degrees.\r\n        if not latex_unit.removeprefix(\"\\\\mathrm{\").startswith(\"{}^\"):\r\n            latex_unit = rf\" \\; {latex_unit}\"\r\n\r\n        return rf\"{delimiter_left}{latex_value}{latex_unit}{delimiter_right}\"\r\n\r\n    def __str__(self):\r\n        return self.to_string()\r\n\r\n    def __repr__(self):\r\n        prefixstr = \"<\" + self.__class__.__name__ + \" \"\r\n        arrstr = np.array2string(\r\n            self.view(np.ndarray), separator=\", \", prefix=prefixstr\r\n        )\r\n        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\r\n\r\n    def _repr_latex_(self):\r\n        \"\"\"\r\n        Generate a latex representation of the quantity and its unit.\r\n\r\n        Returns\r\n        -------\r\n        lstr\r\n            A LaTeX string with the contents of this Quantity\r\n        \"\"\"\r\n        # NOTE: This should change to display format in a future release\r\n        return self.to_string(format=\"latex\", subfmt=\"inline\")\r\n\r\n    def __format__(self, format_spec):\r\n        try:\r\n            return self.to_string(format=format_spec)\r\n        except ValueError:\r\n            # We might have a unit format not implemented in `to_string()`.\r\n            if format_spec in Base.registry:\r\n                if self.unit is dimensionless_unscaled:\r\n                    return f\"{self.value}\"\r\n                else:\r\n                    return f\"{self.value} {format(self.unit, format_spec)}\"\r\n            # Can the value be formatted on its own?\r\n            try:\r\n                return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\r\n            except ValueError:\r\n                # Format the whole thing as a single string.\r\n                return format(f\"{self.value}{self._unitstr:s}\", format_spec)\r\n\r\n    def decompose(self, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units\r\n        decomposed. Decomposed units have only irreducible units in\r\n        them (see `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        bases : sequence of `~astropy.units.UnitBase`, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n        \"\"\"\r\n        return self._decompose(False, bases=bases)\r\n\r\n    def _decompose(self, allowscaledunits=False, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units decomposed. Decomposed\r\n        units have only irreducible units in them (see\r\n        `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        allowscaledunits : bool\r\n            If True, the resulting `Quantity` may have a scale factor\r\n            associated with it.  If False, any scaling in the unit will\r\n            be subsumed into the value of the resulting `Quantity`\r\n\r\n        bases : sequence of UnitBase, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n\r\n        \"\"\"\r\n        new_unit = self.unit.decompose(bases=bases)\r\n\r\n        # Be careful here because self.value usually is a view of self;\r\n        # be sure that the original value is not being modified.\r\n        if not allowscaledunits and hasattr(new_unit, \"scale\"):\r\n            new_value = self.value * new_unit.scale\r\n            new_unit = new_unit / new_unit.scale\r\n            return self._new_view(new_value, new_unit)\r\n        else:\r\n            return self._new_view(self.copy(), new_unit)\r\n\r\n    # These functions need to be overridden to take into account the units\r\n    # Array conversion\r\n    # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\r\n\r\n    def item(self, *args):\r\n        \"\"\"Copy an element of an array to a scalar Quantity and return it.\r\n\r\n        Like :meth:`~numpy.ndarray.item` except that it always\r\n        returns a `Quantity`, not a Python scalar.\r\n\r\n        \"\"\"\r\n        return self._new_view(super().item(*args))\r\n\r\n    def tolist(self):\r\n        raise NotImplementedError(\r\n            \"cannot make a list of Quantities. Get list of values with\"\r\n            \" q.value.tolist().\"\r\n        )\r\n\r\n    def _to_own_unit(self, value, check_precision=True, *, unit=None):\r\n        \"\"\"Convert value to one's own unit (or that given).\r\n\r\n        Here, non-quantities are treated as dimensionless, and care is taken\r\n        for values of 0, infinity or nan, which are allowed to have any unit.\r\n\r\n        Parameters\r\n        ----------\r\n        value : anything convertible to `~astropy.units.Quantity`\r\n            The value to be converted to the requested unit.\r\n        check_precision : bool\r\n            Whether to forbid conversion of float to integer if that changes\r\n            the input number.  Default: `True`.\r\n        unit : `~astropy.units.Unit` or None\r\n            The unit to convert to.  By default, the unit of ``self``.\r\n\r\n        Returns\r\n        -------\r\n        value : number or `~numpy.ndarray`\r\n            In the requested units.\r\n\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        try:\r\n            _value = value.to_value(unit)\r\n        except AttributeError:\r\n            # We're not a Quantity.\r\n            # First remove two special cases (with a fast test):\r\n            # 1) Maybe masked printing? MaskedArray with quantities does not\r\n            # work very well, but no reason to break even repr and str.\r\n            # 2) np.ma.masked? useful if we're a MaskedQuantity.\r\n            if value is np.ma.masked or (\r\n                value is np.ma.masked_print_option and self.dtype.kind == \"O\"\r\n            ):\r\n                return value\r\n            # Now, let's try a more general conversion.\r\n            # Plain arrays will be converted to dimensionless in the process,\r\n            # but anything with a unit attribute will use that.\r\n            try:\r\n                as_quantity = Quantity(value)\r\n                _value = as_quantity.to_value(unit)\r\n            except UnitsError:\r\n                # last chance: if this was not something with a unit\r\n                # and is all 0, inf, or nan, we treat it as arbitrary unit.\r\n                if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\r\n                    as_quantity.value\r\n                ):\r\n                    _value = as_quantity.value\r\n                else:\r\n                    raise\r\n\r\n        if self.dtype.kind == \"i\" and check_precision:\r\n            # If, e.g., we are casting float to int, we want to fail if\r\n            # precision is lost, but let things pass if it works.\r\n            _value = np.array(_value, copy=COPY_IF_NEEDED, subok=True)\r\n            if not np.can_cast(_value.dtype, self.dtype):\r\n                self_dtype_array = np.array(_value, self.dtype, subok=True)\r\n                if not np.all((self_dtype_array == _value) | np.isnan(_value)):\r\n                    raise TypeError(\r\n                        \"cannot convert value type to array type without precision loss\"\r\n                    )\r\n\r\n        # Setting names to ensure things like equality work (note that\r\n        # above will have failed already if units did not match).\r\n        # TODO: is this the best place to do this?\r\n        if _value.dtype.names is not None:\r\n            _value = _value.astype(self.dtype, copy=False)\r\n        return _value\r\n\r\n    if NUMPY_LT_2_0:\r\n\r\n        def itemset(self, *args):\r\n            if len(args) == 0:\r\n                raise ValueError(\"itemset must have at least one argument\")\r\n\r\n            self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\r\n\r\n    def tostring(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tostring()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to string.  Write array with\"\r\n            \" q.value.tostring(...).\"\r\n        )\r\n\r\n    def tobytes(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tobytes()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\r\n        )\r\n\r\n    def tofile(self, fid, sep=\"\", format=\"%s\"):\r\n        \"\"\"Not implemented, use ``.value.tofile()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\r\n        )\r\n\r\n    def dump(self, file):\r\n        \"\"\"Not implemented, use ``.value.dump()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to file.  Write array with q.value.dump()\"\r\n        )\r\n\r\n    def dumps(self):\r\n        \"\"\"Not implemented, use ``.value.dumps()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\r\n        )\r\n\r\n    # astype, byteswap, copy, view, getfield, setflags OK as is\r\n\r\n    def fill(self, value):\r\n        self.view(np.ndarray).fill(self._to_own_unit(value))\r\n\r\n    # Shape manipulation: resize cannot be done (does not own data), but\r\n    # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\r\n    # the flat iterator needs to be overwritten, otherwise single items are\r\n    # returned as numbers.\r\n    @property\r\n    def flat(self):\r\n        \"\"\"A 1-D iterator over the Quantity array.\r\n\r\n        This returns a ``QuantityIterator`` instance, which behaves the same\r\n        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\r\n        and is similar to, but not a subclass of, Python's built-in iterator\r\n        object.\r\n        \"\"\"\r\n        return QuantityIterator(self)\r\n\r\n    @flat.setter\r\n    def flat(self, value):\r\n        y = self.ravel()\r\n        y[:] = value\r\n\r\n    # Item selection and manipulation\r\n    # repeat, sort, compress, diagonal OK\r\n    def take(self, indices, axis=None, out=None, mode=\"raise\"):\r\n        out = super().take(indices, axis=axis, out=out, mode=mode)\r\n        # For single elements, ndarray.take returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if type(out) is not type(self):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def put(self, indices, values, mode=\"raise\"):\r\n        self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\r\n\r\n    def choose(self, choices, out=None, mode=\"raise\"):\r\n        raise NotImplementedError(\r\n            \"cannot choose based on quantity.  Choose using array with\"\r\n            \" q.value.choose(...)\"\r\n        )\r\n\r\n    # ensure we do not return indices as quantities\r\n    if NUMPY_LT_2_0:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None):\r\n            return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\r\n\r\n    else:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None, *, stable=None):\r\n            return self.view(np.ndarray).argsort(\r\n                axis=axis, kind=kind, order=order, stable=stable\r\n            )\r\n\r\n    def searchsorted(self, v, *args, **kwargs):\r\n        return np.searchsorted(\r\n            np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\r\n        )  # avoid numpy 1.6 problem\r\n\r\n    def argmax(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def argmin(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def __array_function__(self, function, types, args, kwargs):\r\n        \"\"\"Wrap numpy functions, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap\r\n        types : iterable of classes\r\n            Classes that provide an ``__array_function__`` override. Can\r\n            in principle be used to interact with other classes. Below,\r\n            mostly passed on to `~numpy.ndarray`, which can only interact\r\n            with subclasses.\r\n        args : tuple\r\n            Positional arguments provided in the function call.\r\n        kwargs : dict\r\n            Keyword arguments provided in the function call.\r\n\r\n        Returns\r\n        -------\r\n        result: `~astropy.units.Quantity`, `~numpy.ndarray`\r\n            As appropriate for the function.  If the function is not\r\n            supported, `NotImplemented` is returned, which will lead to\r\n            a `TypeError` unless another argument overrode the function.\r\n\r\n        Raises\r\n        ------\r\n        ~astropy.units.UnitsError\r\n            If operands have incompatible units.\r\n        \"\"\"\r\n        # A function should be in one of the following sets or dicts:\r\n        # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\r\n        #    supports Quantity; we pass on to ndarray.__array_function__.\r\n        # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\r\n        #    after converting quantities to arrays with suitable units,\r\n        #    and possibly setting units on the result.\r\n        # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\r\n        #    requires a Quantity-specific implementation.\r\n        # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\r\n        # For now, since we may not yet have complete coverage, if a\r\n        # function is in none of the above, we simply call the numpy\r\n        # implementation.\r\n        if function in SUBCLASS_SAFE_FUNCTIONS:\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        elif function in FUNCTION_HELPERS:\r\n            function_helper = FUNCTION_HELPERS[function]\r\n            try:\r\n                args, kwargs, unit, out = function_helper(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            result = super().__array_function__(function, types, args, kwargs)\r\n            # Fall through to return section\r\n\r\n        elif function in DISPATCHED_FUNCTIONS:\r\n            dispatched_function = DISPATCHED_FUNCTIONS[function]\r\n            try:\r\n                result, unit, out = dispatched_function(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            # Fall through to return section\r\n\r\n        elif function in UNSUPPORTED_FUNCTIONS:\r\n            return NotImplemented\r\n\r\n        else:\r\n            warnings.warn(\r\n                f\"function '{function.__name__}' is not known to astropy's Quantity.\"\r\n                \" Will run it anyway, hoping it will treat ndarray subclasses\"\r\n                \" correctly. Please raise an issue at\"\r\n                \" https://github.com/astropy/astropy/issues.\",\r\n                AstropyWarning,\r\n            )\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        # If unit is None, a plain array is expected (e.g., boolean), which\r\n        # means we're done.\r\n        # We're also done if the result was NotImplemented, which can happen\r\n        # if other inputs/outputs override __array_function__;\r\n        # hopefully, they can then deal with us.\r\n        if unit is None or result is NotImplemented:\r\n            return result\r\n\r\n        return self._result_as_quantity(result, unit, out=out)\r\n\r\n    def _not_implemented_or_raise(self, function, types):\r\n        # Our function helper or dispatcher found that the function does not\r\n        # work with Quantity.  In principle, there may be another class that\r\n        # knows what to do with us, for which we should return NotImplemented.\r\n        # But if there is ndarray (or a non-Quantity subclass of it) around,\r\n        # it quite likely coerces, so we should just break.\r\n        if any(\r\n            issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\r\n        ):\r\n            raise TypeError(\r\n                f\"the Quantity implementation cannot handle {function} \"\r\n                \"with the given arguments.\"\r\n            ) from None\r\n        else:\r\n            return NotImplemented\r\n\r\n    # Calculation -- override ndarray methods to take into account units.\r\n    # We use the corresponding numpy functions to evaluate the results, since\r\n    # the methods do not always allow calling with keyword arguments.\r\n    # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\r\n    # TypeError: 'a_max' is an invalid keyword argument for this function.\r\n    def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\r\n        \"\"\"Wrap a numpy function that processes self, returning a Quantity.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap.\r\n        args : positional arguments\r\n            Any positional arguments to the function beyond the first argument\r\n            (which will be set to ``self``).\r\n        kwargs : keyword arguments\r\n            Keyword arguments to the function.\r\n\r\n        If present, the following arguments are treated specially:\r\n\r\n        unit : `~astropy.units.Unit`\r\n            Unit of the output result.  If not given, the unit of ``self``.\r\n        out : `~astropy.units.Quantity`\r\n            A Quantity instance in which to store the output.\r\n\r\n        Notes\r\n        -----\r\n        Output should always be assigned via a keyword argument, otherwise\r\n        no proper account of the unit is taken.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            Result of the function call, with the unit set properly.\r\n        \"\"\"\r\n        if unit is None:\r\n"]
[215.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[215.002, "i", "cat asv.ci.conf.json\r"]
[215.004, "o", "cat asv.ci.conf.json\r\n"]
[215.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[220.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[220.002, "i", "sed -n '1,240p' astropy-benchmarks/benchmarks/units.py\r"]
[220.004, "o", "sed -n '1,240p' astropy-benchmarks/benchmarks/units.py\r\n"]
[220.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[225.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[225.002, "i", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r"]
[225.004, "o", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r\n"]
[225.006, "o", "_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\"\r\n\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: argument {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages}: invalid choice: 'dev' (choose from 'help', 'quickstart', 'machine', 'setup', 'run', 'continuous', 'find', 'rm', 'publish', 'preview', 'profile', 'update', 'show', 'compare', 'check', 'gh-pages')\r\n"]
[230.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[230.002, "i", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r"]
[230.004, "o", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[230.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[235.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[235.002, "i", "sed -n '1,400p' astropy/units/quantity.py\r"]
[235.004, "o", "sed -n '1,400p' astropy/units/quantity.py\r\n"]
[235.006, "o", "\u001b[?2004l\r\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\r\n\"\"\"\r\nThis module defines the `Quantity` object, which represents a number with some\r\nassociated units. `Quantity` objects support operations like ordinary numbers,\r\nbut will deal with unit conversions internally.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport builtins\r\nimport numbers\r\nimport operator\r\nimport re\r\nimport warnings\r\nfrom fractions import Fraction\r\nfrom typing import TYPE_CHECKING\r\n\r\nimport numpy as np\r\n\r\nfrom astropy import config as _config\r\nfrom astropy.utils.compat.numpycompat import COPY_IF_NEEDED, NUMPY_LT_2_0\r\nfrom astropy.utils.data_info import ParentDtypeInfo\r\nfrom astropy.utils.exceptions import AstropyWarning\r\n\r\nfrom .core import (\r\n    Unit,\r\n    UnitBase,\r\n    UnitConversionError,\r\n    UnitsError,\r\n    UnitTypeError,\r\n    dimensionless_unscaled,\r\n    get_current_unit_registry,\r\n)\r\nfrom .format import Base, Latex\r\nfrom .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\r\nfrom .quantity_helper.function_helpers import (\r\n    DISPATCHED_FUNCTIONS,\r\n    FUNCTION_HELPERS,\r\n    SUBCLASS_SAFE_FUNCTIONS,\r\n    UNSUPPORTED_FUNCTIONS,\r\n)\r\nfrom .structured import StructuredUnit, _structured_unit_like_dtype\r\nfrom .utils import is_effectively_unity\r\n\r\nif TYPE_CHECKING:\r\n    from typing_extensions import Self\r\n\r\n    from .typing import QuantityLike\r\n\r\n__all__ = [\r\n    \"Quantity\",\r\n    \"SpecificTypeQuantity\",\r\n    \"QuantityInfoBase\",\r\n    \"QuantityInfo\",\r\n    \"allclose\",\r\n    \"isclose\",\r\n]\r\n\r\n\r\n# We don't want to run doctests in the docstrings we inherit from Numpy\r\n__doctest_skip__ = [\"Quantity.*\"]\r\n\r\n_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\r\n_UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\r\n\r\n\r\nclass Conf(_config.ConfigNamespace):\r\n    \"\"\"\r\n    Configuration parameters for Quantity.\r\n    \"\"\"\r\n\r\n    latex_array_threshold = _config.ConfigItem(\r\n        100,\r\n        \"The maximum size an array Quantity can be before its LaTeX \"\r\n        'representation for IPython gets \"summarized\" (meaning only the first '\r\n        'and last few elements are shown with \"...\" between). Setting this to a '\r\n        \"negative number means that the value will instead be whatever numpy \"\r\n        \"gets from get_printoptions.\",\r\n    )\r\n\r\n\r\nconf = Conf()\r\n\r\n\r\nclass QuantityIterator:\r\n    \"\"\"\r\n    Flat iterator object to iterate over Quantities.\r\n\r\n    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\r\n    ``q``.  It allows iterating over the array as if it were a 1-D array,\r\n    either in a for-loop or by calling its `next` method.\r\n\r\n    Iteration is done in C-contiguous style, with the last index varying the\r\n    fastest. The iterator can also be indexed using basic slicing or\r\n    advanced indexing.\r\n\r\n    See Also\r\n    --------\r\n    Quantity.flatten : Returns a flattened copy of an array.\r\n\r\n    Notes\r\n    -----\r\n    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\r\n    is not exported by the `~astropy.units` module.  Instead of\r\n    instantiating a `QuantityIterator` directly, use `Quantity.flat`.\r\n    \"\"\"\r\n\r\n    def __init__(self, q):\r\n        self._quantity = q\r\n        self._dataiter = q.view(np.ndarray).flat\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __getitem__(self, indx):\r\n        out = self._dataiter.__getitem__(indx)\r\n        # For single elements, ndarray.flat.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if isinstance(out, type(self._quantity)):\r\n            return out\r\n        else:\r\n            return self._quantity._new_view(out)\r\n\r\n    def __setitem__(self, index, value):\r\n        self._dataiter[index] = self._quantity._to_own_unit(value)\r\n\r\n    def __next__(self):\r\n        \"\"\"\r\n        Return the next value, or raise StopIteration.\r\n        \"\"\"\r\n        out = next(self._dataiter)\r\n        # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\r\n        return self._quantity._new_view(out)\r\n\r\n    next = __next__\r\n\r\n    def __len__(self):\r\n        return len(self._dataiter)\r\n\r\n    # Properties and methods to match `numpy.ndarray.flatiter`\r\n\r\n    @property\r\n    def base(self):\r\n        \"\"\"A reference to the array that is iterated over.\"\"\"\r\n        return self._quantity\r\n\r\n    @property\r\n    def coords(self):\r\n        \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\r\n        return self._dataiter.coords\r\n\r\n    @property\r\n    def index(self):\r\n        \"\"\"Current flat index into the array.\"\"\"\r\n        return self._dataiter.index\r\n\r\n    def copy(self):\r\n        \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\r\n        return self._quantity.flatten()\r\n\r\n\r\nclass QuantityInfoBase(ParentDtypeInfo):\r\n    # This is on a base class rather than QuantityInfo directly, so that\r\n    # it can be used for EarthLocationInfo yet make clear that that class\r\n    # should not be considered a typical Quantity subclass by Table.\r\n    attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\r\n    _supports_indexing = True\r\n\r\n    @staticmethod\r\n    def default_format(val):\r\n        return f\"{val.value}\"\r\n\r\n    @staticmethod\r\n    def possible_string_format_functions(format_):\r\n        \"\"\"Iterate through possible string-derived format functions.\r\n\r\n        A string can either be a format specifier for the format built-in,\r\n        a new-style format string, or an old-style format string.\r\n\r\n        This method is overridden in order to suppress printing the unit\r\n        in each row since it is already at the top in the column header.\r\n        \"\"\"\r\n        yield lambda format_, val: format(val.value, format_)\r\n        yield lambda format_, val: format_.format(val.value)\r\n        yield lambda format_, val: format_ % val.value\r\n\r\n\r\nclass QuantityInfo(QuantityInfoBase):\r\n    \"\"\"\r\n    Container for meta information like name, description, format.  This is\r\n    required when the object is used as a mixin column within a table, but can\r\n    be used as a general way to store meta information.\r\n    \"\"\"\r\n\r\n    _represent_as_dict_attrs = (\"value\", \"unit\")\r\n    _construct_from_dict_args = [\"value\"]\r\n    _represent_as_dict_primary_data = \"value\"\r\n\r\n    def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\r\n        \"\"\"\r\n        Return a new Quantity instance which is consistent with the\r\n        input ``cols`` and has ``length`` rows.\r\n\r\n        This is intended for creating an empty column object whose elements can\r\n        be set in-place for table operations like join or vstack.\r\n\r\n        Parameters\r\n        ----------\r\n        cols : list\r\n            List of input columns\r\n        length : int\r\n            Length of the output column object\r\n        metadata_conflicts : str ('warn'|'error'|'silent')\r\n            How to handle metadata conflicts\r\n        name : str\r\n            Output column name\r\n\r\n        Returns\r\n        -------\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n            Empty instance of this class consistent with ``cols``\r\n\r\n        \"\"\"\r\n        # Get merged info attributes like shape, dtype, format, description, etc.\r\n        attrs = self.merge_cols_attributes(\r\n            cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\r\n        )\r\n\r\n        # Make an empty quantity using the unit of the last one.\r\n        shape = (length,) + attrs.pop(\"shape\")\r\n        dtype = attrs.pop(\"dtype\")\r\n        # Use zeros so we do not get problems for Quantity subclasses such\r\n        # as Longitude and Latitude, which cannot take arbitrary values.\r\n        data = np.zeros(shape=shape, dtype=dtype)\r\n        # Get arguments needed to reconstruct class\r\n        map = {\r\n            key: (data if key == \"value\" else getattr(cols[-1], key))\r\n            for key in self._represent_as_dict_attrs\r\n        }\r\n        map[\"copy\"] = COPY_IF_NEEDED\r\n        out = self._construct_from_dict(map)\r\n\r\n        # Set remaining info attributes\r\n        for attr, value in attrs.items():\r\n            setattr(out.info, attr, value)\r\n\r\n        return out\r\n\r\n    def get_sortable_arrays(self):\r\n        \"\"\"\r\n        Return a list of arrays which can be lexically sorted to represent\r\n        the order of the parent column.\r\n\r\n        For Quantity this is just the quantity itself.\r\n\r\n\r\n        Returns\r\n        -------\r\n        arrays : list of ndarray\r\n        \"\"\"\r\n        return [self._parent]\r\n\r\n\r\nclass Quantity(np.ndarray):\r\n    \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\r\n\r\n    See also: https://docs.astropy.org/en/stable/units/quantity.html\r\n\r\n    Parameters\r\n    ----------\r\n    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\r\n        The numerical value of this quantity in the units given by unit.  If a\r\n        `Quantity` or sequence of them (or any other valid object with a\r\n        ``unit`` attribute), creates a new `Quantity` object, converting to\r\n        `unit` units as needed.  If a string, it is converted to a number or\r\n        `Quantity`, depending on whether a unit is present.\r\n\r\n    unit : unit-like\r\n        An object that represents the unit associated with the input value.\r\n        Must be an `~astropy.units.UnitBase` object or a string parseable by\r\n        the :mod:`~astropy.units` package.\r\n\r\n    dtype : ~numpy.dtype, optional\r\n        The dtype of the resulting Numpy array or scalar that will\r\n        hold the value.  If not provided, it is determined from the input,\r\n        except that any integer and (non-Quantity) object inputs are converted\r\n        to float by default.\r\n        If `None`, the normal `numpy.dtype` introspection is used, e.g.\r\n        preventing upcasting of integers.\r\n\r\n    copy : bool, optional\r\n        If `True` (default), then the value is copied.  Otherwise, a copy will\r\n        only be made if ``__array__`` returns a copy, if value is a nested\r\n        sequence, or if a copy is needed to satisfy an explicitly given\r\n        ``dtype``.  (The `False` option is intended mostly for internal use,\r\n        to speed up initialization where a copy is known to have been made.\r\n        Use with care.)\r\n\r\n    order : {'C', 'F', 'A'}, optional\r\n        Specify the order of the array.  As in `~numpy.array`.  This parameter\r\n        is ignored if the input is a `Quantity` and ``copy=False``.\r\n\r\n    subok : bool, optional\r\n        If `False` (default), the returned array will be forced to be a\r\n        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\r\n        or a subclass appropriate for the unit will be used (such as\r\n        `~astropy.units.Dex` for ``u.dex(u.AA)``).\r\n\r\n    ndmin : int, optional\r\n        Specifies the minimum number of dimensions that the resulting array\r\n        should have.  Ones will be prepended to the shape as needed to meet\r\n        this requirement.  This parameter is ignored if the input is a\r\n        `Quantity` and ``copy=False``.\r\n\r\n    Raises\r\n    ------\r\n    TypeError\r\n        If the value provided is not a Python numeric type.\r\n    TypeError\r\n        If the unit provided is not either a :class:`~astropy.units.Unit`\r\n        object or a parseable string unit.\r\n\r\n    Notes\r\n    -----\r\n    Quantities can also be created by multiplying a number or array with a\r\n    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\r\n\r\n    Unless the ``dtype`` argument is explicitly specified, integer\r\n    or (non-Quantity) object inputs are converted to `float` by default.\r\n    \"\"\"\r\n\r\n    # Need to set a class-level default for _equivalencies, or\r\n    # Constants can not initialize properly\r\n    _equivalencies = []\r\n\r\n    # Default unit for initialization; can be overridden by subclasses,\r\n    # possibly to `None` to indicate there is no default unit.\r\n    _default_unit = dimensionless_unscaled\r\n\r\n    # Ensures views have an undefined unit.\r\n    _unit = None\r\n\r\n    __array_priority__ = 10000\r\n\r\n    def __class_getitem__(cls, unit_shape_dtype):\r\n        \"\"\"Quantity Type Hints.\r\n\r\n        Unit-aware type hints are ``Annotated`` objects that encode the class,\r\n        the unit, and possibly shape and dtype information, depending on the\r\n        python and :mod:`numpy` versions.\r\n\r\n        Schematically, ``Annotated[cls[shape, dtype], unit]``\r\n\r\n        As a classmethod, the type is the class, ie ``Quantity``\r\n        produces an ``Annotated[Quantity, ...]`` while a subclass\r\n        like :class:`~astropy.coordinates.Angle` returns\r\n        ``Annotated[Angle, ...]``.\r\n\r\n        Parameters\r\n        ----------\r\n        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\r\n            Unit specification, can be the physical type (ie str or class).\r\n            If tuple, then the first element is the unit specification\r\n            and all other elements are for `numpy.ndarray` type annotations.\r\n            Whether they are included depends on the python and :mod:`numpy`\r\n            versions.\r\n\r\n        Returns\r\n        -------\r\n        `typing.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\r\n            Return type in this preference order:\r\n            * `typing.Annotated`\r\n            * `astropy.units.Unit` or `astropy.units.PhysicalType`\r\n\r\n        Raises\r\n        ------\r\n        TypeError\r\n            If the unit/physical_type annotation is not Unit-like or\r\n            PhysicalType-like.\r\n\r\n        Examples\r\n        --------\r\n        Create a unit-aware Quantity type annotation\r\n\r\n            >>> Quantity[Unit(\"s\")]\r\n            Annotated[Quantity, Unit(\"s\")]\r\n\r\n        See Also\r\n        --------\r\n        `~astropy.units.quantity_input`\r\n            Use annotations for unit checks on function arguments and results.\r\n\r\n        Notes\r\n        -----\r\n        |Quantity| types are also static-type compatible.\r\n        \"\"\"\r\n        from typing import Annotated\r\n\r\n        # process whether [unit] or [unit, shape, ptype]\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n"]
[240.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[240.002, "i", "sed -n '400,1200p' astropy/units/quantity.py\r"]
[240.004, "o", "sed -n '400,1200p' astropy/units/quantity.py\r\n"]
[240.006, "o", "\u001b[?2004l\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n            target = unit_shape_dtype[0]\r\n            shape_dtype = unit_shape_dtype[1:]\r\n        else:  # just unit\r\n            target = unit_shape_dtype\r\n            shape_dtype = ()\r\n\r\n        # Allowed unit/physical types. Errors if neither.\r\n        try:\r\n            unit = Unit(target)\r\n        except (TypeError, ValueError):\r\n            from astropy.units.physical import get_physical_type\r\n\r\n            try:\r\n                unit = get_physical_type(target)\r\n            except (TypeError, ValueError, KeyError):  # KeyError for Enum\r\n                raise TypeError(\r\n                    \"unit annotation is not a Unit or PhysicalType\"\r\n                ) from None\r\n\r\n        # Quantity does not (yet) properly extend the NumPy generics types,\r\n        # introduced in numpy v1.22+, instead just including the unit info as\r\n        # metadata using Annotated.\r\n        # TODO: ensure we do interact with NDArray.__class_getitem__.\r\n        return Annotated[cls, unit]\r\n\r\n    def __new__(\r\n        cls: type[Self],\r\n        value: QuantityLike,\r\n        unit=None,\r\n        dtype=np.inexact,\r\n        copy=True,\r\n        order=None,\r\n        subok=False,\r\n        ndmin=0,\r\n    ) -> Self:\r\n        if unit is not None:\r\n            # convert unit first, to avoid multiple string->unit conversions\r\n            unit = Unit(unit)\r\n\r\n        # inexact -> upcast to float dtype\r\n        float_default = dtype is np.inexact\r\n        if float_default:\r\n            dtype = None\r\n\r\n        # optimize speed for Quantity with no dtype given, copy=COPY_IF_NEEDED\r\n        if isinstance(value, Quantity):\r\n            if unit is not None and unit is not value.unit:\r\n                value = value.to(unit)\r\n                # the above already makes a copy (with float dtype)\r\n                copy = COPY_IF_NEEDED\r\n\r\n            if type(value) is not cls and not (subok and isinstance(value, cls)):\r\n                value = value.view(cls)\r\n\r\n            if float_default and value.dtype.kind in \"iu\":\r\n                dtype = float\r\n\r\n            return np.array(\r\n                value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n            )\r\n\r\n        # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\r\n        # To ensure array remains fast, we short-circuit it.\r\n        value_unit = None\r\n        if not isinstance(value, np.ndarray):\r\n            if isinstance(value, str):\r\n                # The first part of the regex string matches any integer/float;\r\n                # the second parts adds possible trailing .+-, which will break\r\n                # the float function below and ensure things like 1.2.3deg\r\n                # will not work.\r\n                pattern = (\r\n                    r\"\\s*[+-]?\"\r\n                    r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\r\n                    r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\r\n                    r\"([eE][+-]?\\d+)?\"\r\n                    r\"[.+-]?\"\r\n                )\r\n\r\n                v = re.match(pattern, value)\r\n                unit_string = None\r\n                try:\r\n                    value = float(v.group())\r\n\r\n                except Exception:\r\n                    raise TypeError(\r\n                        f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\r\n                        \"start with a number.\"\r\n                    )\r\n\r\n                unit_string = v.string[v.end() :].strip()\r\n                if unit_string:\r\n                    value_unit = Unit(unit_string)\r\n                    if unit is None:\r\n                        unit = value_unit  # signal no conversion needed below.\r\n\r\n            elif isinstance(value, (list, tuple)) and len(value) > 0:\r\n                if all(isinstance(v, Quantity) for v in value):\r\n                    # If a list/tuple contains only quantities, stack them,\r\n                    # which also converts them to the same unit.\r\n                    value = np.stack(value)\r\n                    copy = False\r\n\r\n                elif (\r\n                    dtype is None\r\n                    and not hasattr(value, \"dtype\")\r\n                    and isinstance(unit, StructuredUnit)\r\n                ):\r\n                    # Special case for list/tuple of values and a structured unit:\r\n                    # ``np.array(value, dtype=None)`` would treat tuples as lower\r\n                    # levels of the array, rather than as elements of a structured\r\n                    # array, so we use the structure of the unit to help infer the\r\n                    # structured dtype of the value.\r\n                    dtype = unit._recursively_get_dtype(value)\r\n\r\n        using_default_unit = False\r\n        if value_unit is None:\r\n            # If the value has a `unit` attribute and if not None\r\n            # (for Columns with uninitialized unit), treat it like a quantity.\r\n            value_unit = getattr(value, \"unit\", None)\r\n            if value_unit is None:\r\n                # Default to dimensionless for no (initialized) unit attribute.\r\n                if unit is None:\r\n                    using_default_unit = True\r\n                    unit = cls._default_unit\r\n                value_unit = unit  # signal below that no conversion is needed\r\n            else:\r\n                try:\r\n                    value_unit = Unit(value_unit)\r\n                except Exception as exc:\r\n                    raise TypeError(\r\n                        f\"The unit attribute {value.unit!r} of the input could \"\r\n                        \"not be parsed as an astropy Unit.\"\r\n                    ) from exc\r\n\r\n                if unit is None:\r\n                    unit = value_unit\r\n                elif unit is not value_unit:\r\n                    copy = COPY_IF_NEEDED  # copy will be made in conversion at end\r\n\r\n        value = np.array(\r\n            value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n        )\r\n\r\n        # For no-user-input unit, make sure the constructed unit matches the\r\n        # structure of the data.\r\n        if using_default_unit and value.dtype.names is not None:\r\n            unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\r\n\r\n        # check that array contains numbers or long int objects\r\n        if value.dtype.kind in \"OSU\" and not (\r\n            value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\r\n        ):\r\n            raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\r\n\r\n        # by default, cast any integer, boolean, etc., to float\r\n        if float_default and value.dtype.kind in \"iuO\":\r\n            value = value.astype(float)\r\n\r\n        # if we allow subclasses, allow a class from the unit.\r\n        if subok:\r\n            qcls = getattr(unit, \"_quantity_class\", cls)\r\n            if issubclass(qcls, cls):\r\n                cls = qcls\r\n\r\n        value = value.view(cls)\r\n        value._set_unit(value_unit)\r\n        if unit is value_unit:\r\n            return value\r\n        else:\r\n            # here we had non-Quantity input that had a \"unit\" attribute\r\n            # with a unit different from the desired one.  So, convert.\r\n            return value.to(unit)\r\n\r\n    def __array_finalize__(self, obj):\r\n        # Check whether super().__array_finalize should be called\r\n        # (sadly, ndarray.__array_finalize__ is None; we cannot be sure\r\n        # what is above us).\r\n        super_array_finalize = super().__array_finalize__\r\n        if super_array_finalize is not None:\r\n            super_array_finalize(obj)\r\n\r\n        # If we're a new object or viewing an ndarray, nothing has to be done.\r\n        if obj is None or obj.__class__ is np.ndarray:\r\n            return\r\n\r\n        # Copy over the unit and possibly info.  Note that the only way the\r\n        # unit can already be set is if one enters via _new_view(), where the\r\n        # unit is often different from that of self, and where propagation of\r\n        # info is not always desirable.\r\n        if self._unit is None:\r\n            unit = getattr(obj, \"_unit\", None)\r\n            if unit is not None:\r\n                self._set_unit(unit)\r\n\r\n            # Copy info if the original had `info` defined.  Because of the way the\r\n            # DataInfo works, `'info' in obj.__dict__` is False until the\r\n            # `info` attribute is accessed or set.\r\n            if \"info\" in obj.__dict__:\r\n                self.info = obj.info\r\n\r\n    def __array_wrap__(self, obj, context=None, return_scalar=False):\r\n        if context is None:\r\n            # Methods like .squeeze() created a new `ndarray` and then call\r\n            # __array_wrap__ to turn the array into self's subclass.\r\n            return self._new_view(obj)\r\n\r\n        raise NotImplementedError(\r\n            \"__array_wrap__ should not be used with a context any more since all \"\r\n            \"use should go through array_function. Please raise an issue on \"\r\n            \"https://github.com/astropy/astropy\"\r\n        )\r\n\r\n    def __array_ufunc__(self, function, method, *inputs, **kwargs):\r\n        \"\"\"Wrap numpy ufuncs, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            ufunc to wrap.\r\n        method : str\r\n            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\r\n        inputs : tuple\r\n            Input arrays.\r\n        kwargs : keyword arguments\r\n            As passed on, with ``out`` containing possible quantity output.\r\n\r\n        Returns\r\n        -------\r\n        result : `~astropy.units.Quantity` or `NotImplemented`\r\n            Results of the ufunc, with the unit set properly.\r\n        \"\"\"\r\n        # Determine required conversion functions -- to bring the unit of the\r\n        # input to that expected (e.g., radian for np.sin), or to get\r\n        # consistent units between two inputs (e.g., in np.add) --\r\n        # and the unit of the result (or tuple of units for nout > 1).\r\n        try:\r\n            converters, unit = converters_and_unit(function, method, *inputs)\r\n\r\n            out = kwargs.get(\"out\", None)\r\n            # Avoid loop back by turning any Quantity output into array views.\r\n            if out is not None:\r\n                # If pre-allocated output is used, check it is suitable.\r\n                # This also returns array view, to ensure we don't loop back.\r\n                if function.nout == 1:\r\n                    out = out[0]\r\n                out_array = check_output(out, unit, inputs, function=function)\r\n                # Ensure output argument remains a tuple.\r\n                kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\r\n\r\n            if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\r\n                # Special-case for initial argument for reductions like\r\n                # np.add.reduce.  This should be converted to the output unit as\r\n                # well, which is typically the same as the input unit (but can\r\n                # in principle be different: unitless for np.equal, radian\r\n                # for np.arctan2, though those are not necessarily useful!)\r\n                kwargs[\"initial\"] = self._to_own_unit(\r\n                    kwargs[\"initial\"], check_precision=False, unit=unit\r\n                )\r\n\r\n            # Same for inputs, but here also convert if necessary.\r\n            arrays = []\r\n            for input_, converter in zip(inputs, converters):\r\n                input_ = getattr(input_, \"value\", input_)\r\n                arrays.append(converter(input_) if converter else input_)\r\n\r\n            # Call our superclass's __array_ufunc__\r\n            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\r\n            # If unit is None, a plain array is expected (e.g., comparisons), which\r\n            # means we're done.\r\n            # We're also done if the result was None (for method 'at') or\r\n            # NotImplemented, which can happen if other inputs/outputs override\r\n            # __array_ufunc__; hopefully, they can then deal with us.\r\n            if unit is None or result is None or result is NotImplemented:\r\n                return result\r\n\r\n            return self._result_as_quantity(result, unit, out)\r\n\r\n        except (TypeError, ValueError, AttributeError) as e:\r\n            out_normalized = kwargs.get(\"out\", ())\r\n            inputs_and_outputs = inputs + out_normalized\r\n            ignored_ufunc = (\r\n                None,\r\n                np.ndarray.__array_ufunc__,\r\n                type(self).__array_ufunc__,\r\n            )\r\n            if not all(\r\n                getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\r\n                for io in inputs_and_outputs\r\n            ):\r\n                return NotImplemented\r\n            else:\r\n                raise e\r\n\r\n    def _result_as_quantity(self, result, unit, out):\r\n        \"\"\"Turn result into a quantity with the given unit.\r\n\r\n        If no output is given, it will take a view of the array as a quantity,\r\n        and set the unit.  If output is given, those should be quantity views\r\n        of the result arrays, and the function will just set the unit.\r\n\r\n        Parameters\r\n        ----------\r\n        result : ndarray or tuple thereof\r\n            Array(s) which need to be turned into quantity.\r\n        unit : `~astropy.units.Unit`\r\n            Unit for the quantities to be returned (or `None` if the result\r\n            should not be a quantity).  Should be tuple if result is a tuple.\r\n        out : `~astropy.units.Quantity` or None\r\n            Possible output quantity. Should be `None` or a tuple if result\r\n            is a tuple.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n           With units set.\r\n        \"\"\"\r\n        if isinstance(result, (tuple, list)):\r\n            if out is None:\r\n                out = (None,) * len(result)\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n        # ``obj.__class is np.ndarray``. So, not worth special-casing.\r\n        if obj is None:\r\n            obj = self.view(np.ndarray)\r\n        else:\r\n            obj = np.array(obj, copy=COPY_IF_NEEDED, subok=True)\r\n\r\n        # Take the view, set the unit, and update possible other properties\r\n        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\r\n        view = obj.view(quantity_subclass)\r\n        view._set_unit(unit)\r\n        view.__array_finalize__(self)\r\n        if propagate_info and \"info\" in self.__dict__:\r\n            view.info = self.info\r\n        return view\r\n\r\n    def _set_unit(self, unit):\r\n        \"\"\"Set the unit.\r\n\r\n        This is used anywhere the unit is set or modified, i.e., in the\r\n        initializer, in ``__imul__`` and ``__itruediv__`` for in-place\r\n        multiplication and division by another unit, as well as in\r\n        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\r\n        sets the unit, but subclasses can override it to check that, e.g.,\r\n        a unit is consistent.\r\n        \"\"\"\r\n        if not isinstance(unit, UnitBase):\r\n            if isinstance(self._unit, StructuredUnit) or isinstance(\r\n                unit, StructuredUnit\r\n            ):\r\n                unit = StructuredUnit(unit, self.dtype)\r\n            else:\r\n                # Trying to go through a string ensures that, e.g., Magnitudes with\r\n                # dimensionless physical unit become Quantity with units of mag.\r\n                unit = Unit(str(unit), parse_strict=\"silent\")\r\n                if not isinstance(unit, (UnitBase, StructuredUnit)):\r\n                    raise UnitTypeError(\r\n                        f\"{self.__class__.__name__} instances require normal units, \"\r\n                        f\"not {unit.__class__} instances.\"\r\n                    )\r\n\r\n        self._unit = unit\r\n\r\n    def __deepcopy__(self, memo):\r\n        # If we don't define this, ``copy.deepcopy(quantity)`` will\r\n        # return a bare Numpy array.\r\n        return self.copy()\r\n\r\n    def __reduce__(self):\r\n        # patch to pickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        object_state = list(super().__reduce__())\r\n        object_state[2] = (object_state[2], self.__dict__)\r\n        return tuple(object_state)\r\n\r\n    def __setstate__(self, state):\r\n        # patch to unpickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        nd_state, own_state = state\r\n        super().__setstate__(nd_state)\r\n        self.__dict__.update(own_state)\r\n\r\n    info = QuantityInfo()\r\n\r\n    def _to_value(self, unit, equivalencies=[]):\r\n        \"\"\"Helper method for to and to_value.\"\"\"\r\n        if equivalencies == []:\r\n            equivalencies = self._equivalencies\r\n        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\r\n            # Standard path, let unit to do work.\r\n            return self.unit.to(\r\n                unit, self.view(np.ndarray), equivalencies=equivalencies\r\n            )\r\n\r\n        else:\r\n            # The .to() method of a simple unit cannot convert a structured\r\n            # dtype, so we work around it, by recursing.\r\n            # TODO: deprecate this?\r\n            # Convert simple to Structured on initialization?\r\n            result = np.empty_like(self.view(np.ndarray))\r\n            for name in self.dtype.names:\r\n                result[name] = self[name]._to_value(unit, equivalencies)\r\n            return result\r\n\r\n    def to(self, unit, equivalencies=[], copy=True):\r\n        \"\"\"\r\n        Return a new `~astropy.units.Quantity` object with the specified unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like\r\n            An object that represents the unit to convert to. Must be\r\n            an `~astropy.units.UnitBase` object or a string parseable\r\n            by the `~astropy.units` package.\r\n\r\n        equivalencies : list of tuple\r\n            A list of equivalence pairs to try if the units are not\r\n            directly convertible.  See :ref:`astropy:unit_equivalencies`.\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n            (none for `~astropy.units.Quantity`, but may be set for subclasses)\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        copy : bool, optional\r\n            If `True` (default), then the value is copied.  Otherwise, a copy\r\n            will only be made if necessary.\r\n\r\n        See Also\r\n        --------\r\n        to_value : get the numerical value in a given unit.\r\n        \"\"\"\r\n        # We don't use `to_value` below since we always want to make a copy\r\n        # and don't want to slow down this method (esp. the scalar case).\r\n        unit = Unit(unit)\r\n        if copy:\r\n            # Avoid using to_value to ensure that we make a copy. We also\r\n            # don't want to slow down this method (esp. the scalar case).\r\n            value = self._to_value(unit, equivalencies)\r\n        else:\r\n            # to_value only copies if necessary\r\n            value = self.to_value(unit, equivalencies)\r\n        return self._new_view(value, unit)\r\n\r\n    def to_value(self, unit=None, equivalencies=[]):\r\n        \"\"\"\r\n        The numerical value, possibly in a different unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            The unit in which the value should be given. If not given or `None`,\r\n            use the current unit.\r\n\r\n        equivalencies : list of tuple, optional\r\n            A list of equivalence pairs to try if the units are not directly\r\n            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\r\n            or ``[]``, class default equivalencies will be used (none for\r\n            `~astropy.units.Quantity`, but may be set for subclasses).\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        Returns\r\n        -------\r\n        value : ndarray or scalar\r\n            The value in the units specified. For arrays, this will be a view\r\n            of the data if no unit conversion was necessary.\r\n\r\n        See Also\r\n        --------\r\n        to : Get a new instance in a different unit.\r\n        \"\"\"\r\n        if unit is None or unit is self.unit:\r\n            value = self.view(np.ndarray)\r\n        elif not self.dtype.names:\r\n            # For non-structured, we attempt a short-cut, where we just get\r\n            # the scale.  If that is 1, we do not have to do anything.\r\n            unit = Unit(unit)\r\n            # We want a view if the unit does not change.  One could check\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n            # TODO: would be better for `unit.to` to have an in-place flag.\r\n            try:\r\n                scale = self.unit._to(unit)\r\n            except Exception:\r\n                # Short-cut failed; try default (maybe equivalencies help).\r\n                value = self._to_value(unit, equivalencies)\r\n            else:\r\n                value = self.view(np.ndarray)\r\n                if not is_effectively_unity(scale):\r\n                    # not in-place!\r\n                    value = value * scale\r\n        else:\r\n            # For structured arrays, we go the default route.\r\n            value = self._to_value(unit, equivalencies)\r\n\r\n        # Index with empty tuple to decay array scalars in to numpy scalars.\r\n        return value if value.shape else value[()]\r\n\r\n    value = property(\r\n        to_value,\r\n        doc=\"\"\"The numerical value of this instance.\r\n\r\n    See also\r\n    --------\r\n    to_value : Get the numerical value in a given unit.\r\n    \"\"\",\r\n    )\r\n\r\n    @property\r\n    def unit(self):\r\n        \"\"\"\r\n        A `~astropy.units.UnitBase` object representing the unit of this\r\n        quantity.\r\n        \"\"\"\r\n        return self._unit\r\n\r\n    @property\r\n    def equivalencies(self):\r\n        \"\"\"\r\n        A list of equivalencies that will be applied by default during\r\n        unit conversions.\r\n        \"\"\"\r\n        return self._equivalencies\r\n\r\n    def _recursively_apply(self, func):\r\n        \"\"\"Apply function recursively to every field.\r\n\r\n        Returns a copy with the result.\r\n        \"\"\"\r\n        result = np.empty_like(self)\r\n        result_value = result.view(np.ndarray)\r\n        result_unit = ()\r\n        for name in self.dtype.names:\r\n            part = func(self[name])\r\n            result_value[name] = part.value\r\n            result_unit += (part.unit,)\r\n\r\n        result._set_unit(result_unit)\r\n        return result\r\n\r\n    @property\r\n    def si(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with SI units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"si\"))\r\n        si_unit = self.unit.si\r\n        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\r\n\r\n    @property\r\n    def cgs(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with CGS units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"cgs\"))\r\n        cgs_unit = self.unit.cgs\r\n        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\r\n\r\n    @property\r\n    def isscalar(self):\r\n        \"\"\"\r\n        True if the `value` of this quantity is a scalar, or False if it\r\n        is an array-like object.\r\n\r\n        .. note::\r\n            This is subtly different from `numpy.isscalar` in that\r\n            `numpy.isscalar` returns False for a zero-dimensional array\r\n            (e.g. ``np.array(1)``), while this is True for quantities,\r\n            since quantities cannot represent true numpy scalars.\r\n        \"\"\"\r\n        return not self.shape\r\n\r\n    # This flag controls whether convenience conversion members, such\r\n    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\r\n    # not turned on on Quantity itself, but is on some subclasses of\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n    _include_easy_conversion_members = False\r\n\r\n    def __dir__(self):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.  This function is implemented in\r\n        order to make autocompletion still work correctly in IPython.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            return super().__dir__()\r\n\r\n        dir_values = set(super().__dir__())\r\n        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\r\n        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\r\n            dir_values.update(equivalent.names)\r\n        return sorted(dir_values)\r\n\r\n    def __getattr__(self, attr):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            raise AttributeError(\r\n                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\r\n            )\r\n\r\n        def get_virtual_unit_attribute():\r\n            registry = get_current_unit_registry().registry\r\n            to_unit = registry.get(attr, None)\r\n            if to_unit is None:\r\n                return None\r\n\r\n            try:\r\n                return self.unit.to(\r\n                    to_unit, self.value, equivalencies=self.equivalencies\r\n                )\r\n            except UnitsError:\r\n                return None\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n"]
[245.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[245.002, "i", "sed -n '1200,2000p' astropy/units/quantity.py\r"]
[245.004, "o", "sed -n '1200,2000p' astropy/units/quantity.py\r\n"]
[245.006, "o", "\u001b[?2004l\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n            # so they should raise a TypeError rather than an IndexError.\r\n            if self.isscalar:\r\n                raise TypeError(\r\n                    f\"'{self.__class__.__name__}' object with a scalar value \"\r\n                    \"does not support indexing\"\r\n                )\r\n            else:\r\n                raise\r\n        # For single elements, ndarray.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if not isinstance(out, np.ndarray):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def __setitem__(self, i, value):\r\n        if isinstance(i, str):\r\n            # Indexing will cause a different unit, so by doing this in\r\n            # two steps we effectively try with the right unit.\r\n            self[i][...] = value\r\n            return\r\n\r\n        # update indices in info if the info property has been accessed\r\n        # (in which case 'info' in self.__dict__ is True; this is guaranteed\r\n        # to be the case if we're part of a table).\r\n        if not self.isscalar and \"info\" in self.__dict__:\r\n            self.info.adjust_indices(i, value, len(self))\r\n        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\r\n\r\n    # __contains__ is OK\r\n\r\n    def __bool__(self):\r\n        \"\"\"This method raises ValueError, since truthiness of quantities is ambiguous,\r\n        especially for logarithmic units and temperatures. Use explicit comparisons.\r\n        \"\"\"\r\n        raise ValueError(\r\n            f\"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units\"\r\n            \" and temperatures. Use explicit comparisons.\"\r\n        )\r\n\r\n    def __len__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\r\n            )\r\n        else:\r\n            return len(self.value)\r\n\r\n    # Numerical types\r\n    def __float__(self):\r\n        try:\r\n            return float(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __int__(self):\r\n        try:\r\n            return int(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __index__(self):\r\n        # for indices, we do not want to mess around with scaling at all,\r\n        # so unlike for float, int, we insist here on unscaled dimensionless\r\n        try:\r\n            assert self.unit.is_unity()\r\n            return self.value.__index__()\r\n        except Exception:\r\n            raise TypeError(\r\n                \"only integer dimensionless scalar quantities \"\r\n                \"can be converted to a Python index\"\r\n            )\r\n\r\n    # TODO: we may want to add a hook for dimensionless quantities?\r\n    @property\r\n    def _unitstr(self):\r\n        if self.unit is None:\r\n            unitstr = _UNIT_NOT_INITIALISED\r\n        else:\r\n            unitstr = str(self.unit)\r\n\r\n        if unitstr:\r\n            unitstr = \" \" + unitstr\r\n\r\n        return unitstr\r\n\r\n    def to_string(\r\n        self, unit=None, precision=None, format=None, subfmt=None, *, formatter=None\r\n    ):\r\n        \"\"\"\r\n        Generate a string representation of the quantity and its unit.\r\n\r\n        The behavior of this function can be altered via the\r\n        `numpy.set_printoptions` function and its various keywords.  The\r\n        exception to this is the ``threshold`` keyword, which is controlled via\r\n        the ``[units.quantity]`` configuration item ``latex_array_threshold``.\r\n        This is treated separately because the numpy default of 1000 is too big\r\n        for most browsers to handle.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            Specifies the unit.  If not provided,\r\n            the unit used to initialize the quantity will be used.\r\n\r\n        precision : number, optional\r\n            The level of decimal precision. If `None`, or not provided,\r\n            it will be determined from NumPy print options.\r\n\r\n        format : str, optional\r\n            The format of the result. If not provided, an unadorned\r\n            string is returned. Supported values are:\r\n\r\n            - 'latex': Return a LaTeX-formatted string\r\n\r\n            - 'latex_inline': Return a LaTeX-formatted string that uses\r\n              negative exponents instead of fractions\r\n\r\n        formatter : str, callable, dict, optional\r\n            The formatter to use for the value. If a string, it should be a\r\n            valid format specifier using Python's mini-language. If a callable,\r\n            it will be treated as the default formatter for all values and will\r\n            overwrite default Latex formatting for exponential notation and complex\r\n            numbers. If a dict, it should map a specific type to a callable to be\r\n            directly passed into `numpy.array2string`. If not provided, the default\r\n            formatter will be used.\r\n\r\n        subfmt : str, optional\r\n            Subformat of the result. For the moment, only used for\r\n            ``format='latex'`` and ``format='latex_inline'``. Supported\r\n            values are:\r\n\r\n            - 'inline': Use ``$ ... $`` as delimiters.\r\n\r\n            - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\r\n\r\n        Returns\r\n        -------\r\n        str\r\n            A string with the contents of this Quantity\r\n        \"\"\"\r\n        if unit is not None and unit != self.unit:\r\n            return self.to(unit).to_string(\r\n                unit=None,\r\n                precision=precision,\r\n                format=format,\r\n                subfmt=subfmt,\r\n                formatter=formatter,\r\n            )\r\n\r\n        if format is None and formatter is None and precision is None:\r\n            # Use default formatting settings\r\n            return f\"{self.value}{self._unitstr:s}\"\r\n\r\n        formats = {\r\n            None: None,\r\n            \"latex\": {\r\n                None: (\"$\", \"$\"),\r\n                \"inline\": (\"$\", \"$\"),\r\n                \"display\": (r\"$\\displaystyle \", r\"$\"),\r\n            },\r\n        }\r\n        formats[\"latex_inline\"] = formats[\"latex\"]\r\n\r\n        if format not in formats:\r\n            raise ValueError(f\"Unknown format '{format}'\")\r\n\r\n        format_spec = formatter if isinstance(formatter, str) else None\r\n\r\n        if format is None:\r\n            if format_spec is not None:\r\n\r\n                def formatter(value):\r\n                    return builtins.format(value, format_spec)\r\n\r\n            if callable(formatter):\r\n                formatter = {\"all\": formatter}\r\n\r\n            return (\r\n                np.array2string(\r\n                    self.value,\r\n                    precision=precision,\r\n                    floatmode=\"fixed\",\r\n                    formatter=formatter,\r\n                )\r\n                + self._unitstr\r\n            )\r\n\r\n        # else, for the moment we assume format=\"latex\" or \"latex_inline\".\r\n\r\n        # Set the precision if set, otherwise use numpy default\r\n        pops = np.get_printoptions()\r\n        if format_spec is None:\r\n            format_spec = (\r\n                f\".{precision if precision is not None else pops['precision']}g\"\r\n            )\r\n\r\n        # Use default formatters\r\n        if formatter is None or isinstance(formatter, str):\r\n            # Filter width and alignment operations for latex\r\n            # [[fill]align][sign][\"z\"][\"#\"][\"0\"][width][grouping_option][\".\" precision][type]\r\n            format_spec = re.sub(\r\n                r\"(.*?)([+\\- ]?)(\\d+)?(,)?(\\.\\d+)?([a-zA-Z%]+)?$\",\r\n                r\"\\2\\5\\6\",\r\n                format_spec,\r\n            )\r\n\r\n            if self.dtype.kind == \"c\":  # Complex default latex formatter\r\n                # Disallow sign operations for the imaginary part\r\n                imag_format_spec = re.sub(r\"[+\\- ]\", \"\", format_spec)\r\n\r\n                def formatter(value):\r\n                    return \"({}{}i)\".format(\r\n                        Latex.format_exponential_notation(\r\n                            value.real, format_spec=format_spec\r\n                        ),\r\n                        Latex.format_exponential_notation(\r\n                            value.imag, format_spec=\"+\" + imag_format_spec\r\n                        ),\r\n                    )\r\n\r\n            else:  # Float default latex formatter\r\n\r\n                def formatter(value):\r\n                    return Latex.format_exponential_notation(\r\n                        value, format_spec=format_spec\r\n                    )\r\n\r\n        if callable(formatter):\r\n            formatter = {\"all\": formatter}\r\n\r\n        # The view is needed for the scalar case - self.value might be float.\r\n        latex_value = np.array2string(\r\n            self.view(np.ndarray),\r\n            threshold=(\r\n                conf.latex_array_threshold\r\n                if conf.latex_array_threshold > -1\r\n                else pops[\"threshold\"]\r\n            ),\r\n            formatter=formatter,\r\n            max_line_width=np.inf,\r\n            separator=\",~\",\r\n        )\r\n\r\n        latex_value = latex_value.replace(\"...\", r\"\\dots\")\r\n\r\n        # Format unit\r\n        # [1:-1] strips the '$' on either side needed for math mode\r\n        if self.unit is None:\r\n            latex_unit = _UNIT_NOT_INITIALISED\r\n        elif format == \"latex\":\r\n            latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\r\n        elif format == \"latex_inline\":\r\n            latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\r\n\r\n        delimiter_left, delimiter_right = formats[format][subfmt]\r\n\r\n        # Add a space in front except for super-script units like degrees.\r\n        if not latex_unit.removeprefix(\"\\\\mathrm{\").startswith(\"{}^\"):\r\n            latex_unit = rf\" \\; {latex_unit}\"\r\n\r\n        return rf\"{delimiter_left}{latex_value}{latex_unit}{delimiter_right}\"\r\n\r\n    def __str__(self):\r\n        return self.to_string()\r\n\r\n    def __repr__(self):\r\n        prefixstr = \"<\" + self.__class__.__name__ + \" \"\r\n        arrstr = np.array2string(\r\n            self.view(np.ndarray), separator=\", \", prefix=prefixstr\r\n        )\r\n        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\r\n\r\n    def _repr_latex_(self):\r\n        \"\"\"\r\n        Generate a latex representation of the quantity and its unit.\r\n\r\n        Returns\r\n        -------\r\n        lstr\r\n            A LaTeX string with the contents of this Quantity\r\n        \"\"\"\r\n        # NOTE: This should change to display format in a future release\r\n        return self.to_string(format=\"latex\", subfmt=\"inline\")\r\n\r\n    def __format__(self, format_spec):\r\n        try:\r\n            return self.to_string(format=format_spec)\r\n        except ValueError:\r\n            # We might have a unit format not implemented in `to_string()`.\r\n            if format_spec in Base.registry:\r\n                if self.unit is dimensionless_unscaled:\r\n                    return f\"{self.value}\"\r\n                else:\r\n                    return f\"{self.value} {format(self.unit, format_spec)}\"\r\n            # Can the value be formatted on its own?\r\n            try:\r\n                return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\r\n            except ValueError:\r\n                # Format the whole thing as a single string.\r\n                return format(f\"{self.value}{self._unitstr:s}\", format_spec)\r\n\r\n    def decompose(self, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units\r\n        decomposed. Decomposed units have only irreducible units in\r\n        them (see `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        bases : sequence of `~astropy.units.UnitBase`, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n        \"\"\"\r\n        return self._decompose(False, bases=bases)\r\n\r\n    def _decompose(self, allowscaledunits=False, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units decomposed. Decomposed\r\n        units have only irreducible units in them (see\r\n        `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        allowscaledunits : bool\r\n            If True, the resulting `Quantity` may have a scale factor\r\n            associated with it.  If False, any scaling in the unit will\r\n            be subsumed into the value of the resulting `Quantity`\r\n\r\n        bases : sequence of UnitBase, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n\r\n        \"\"\"\r\n        new_unit = self.unit.decompose(bases=bases)\r\n\r\n        # Be careful here because self.value usually is a view of self;\r\n        # be sure that the original value is not being modified.\r\n        if not allowscaledunits and hasattr(new_unit, \"scale\"):\r\n            new_value = self.value * new_unit.scale\r\n            new_unit = new_unit / new_unit.scale\r\n            return self._new_view(new_value, new_unit)\r\n        else:\r\n            return self._new_view(self.copy(), new_unit)\r\n\r\n    # These functions need to be overridden to take into account the units\r\n    # Array conversion\r\n    # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\r\n\r\n    def item(self, *args):\r\n        \"\"\"Copy an element of an array to a scalar Quantity and return it.\r\n\r\n        Like :meth:`~numpy.ndarray.item` except that it always\r\n        returns a `Quantity`, not a Python scalar.\r\n\r\n        \"\"\"\r\n        return self._new_view(super().item(*args))\r\n\r\n    def tolist(self):\r\n        raise NotImplementedError(\r\n            \"cannot make a list of Quantities. Get list of values with\"\r\n            \" q.value.tolist().\"\r\n        )\r\n\r\n    def _to_own_unit(self, value, check_precision=True, *, unit=None):\r\n        \"\"\"Convert value to one's own unit (or that given).\r\n\r\n        Here, non-quantities are treated as dimensionless, and care is taken\r\n        for values of 0, infinity or nan, which are allowed to have any unit.\r\n\r\n        Parameters\r\n        ----------\r\n        value : anything convertible to `~astropy.units.Quantity`\r\n            The value to be converted to the requested unit.\r\n        check_precision : bool\r\n            Whether to forbid conversion of float to integer if that changes\r\n            the input number.  Default: `True`.\r\n        unit : `~astropy.units.Unit` or None\r\n            The unit to convert to.  By default, the unit of ``self``.\r\n\r\n        Returns\r\n        -------\r\n        value : number or `~numpy.ndarray`\r\n            In the requested units.\r\n\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        try:\r\n            _value = value.to_value(unit)\r\n        except AttributeError:\r\n            # We're not a Quantity.\r\n            # First remove two special cases (with a fast test):\r\n            # 1) Maybe masked printing? MaskedArray with quantities does not\r\n            # work very well, but no reason to break even repr and str.\r\n            # 2) np.ma.masked? useful if we're a MaskedQuantity.\r\n            if value is np.ma.masked or (\r\n                value is np.ma.masked_print_option and self.dtype.kind == \"O\"\r\n            ):\r\n                return value\r\n            # Now, let's try a more general conversion.\r\n            # Plain arrays will be converted to dimensionless in the process,\r\n            # but anything with a unit attribute will use that.\r\n            try:\r\n                as_quantity = Quantity(value)\r\n                _value = as_quantity.to_value(unit)\r\n            except UnitsError:\r\n                # last chance: if this was not something with a unit\r\n                # and is all 0, inf, or nan, we treat it as arbitrary unit.\r\n                if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\r\n                    as_quantity.value\r\n                ):\r\n                    _value = as_quantity.value\r\n                else:\r\n                    raise\r\n\r\n        if self.dtype.kind == \"i\" and check_precision:\r\n            # If, e.g., we are casting float to int, we want to fail if\r\n            # precision is lost, but let things pass if it works.\r\n            _value = np.array(_value, copy=COPY_IF_NEEDED, subok=True)\r\n            if not np.can_cast(_value.dtype, self.dtype):\r\n                self_dtype_array = np.array(_value, self.dtype, subok=True)\r\n                if not np.all((self_dtype_array == _value) | np.isnan(_value)):\r\n                    raise TypeError(\r\n                        \"cannot convert value type to array type without precision loss\"\r\n                    )\r\n\r\n        # Setting names to ensure things like equality work (note that\r\n        # above will have failed already if units did not match).\r\n        # TODO: is this the best place to do this?\r\n        if _value.dtype.names is not None:\r\n            _value = _value.astype(self.dtype, copy=False)\r\n        return _value\r\n\r\n    if NUMPY_LT_2_0:\r\n\r\n        def itemset(self, *args):\r\n            if len(args) == 0:\r\n                raise ValueError(\"itemset must have at least one argument\")\r\n\r\n            self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\r\n\r\n    def tostring(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tostring()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to string.  Write array with\"\r\n            \" q.value.tostring(...).\"\r\n        )\r\n\r\n    def tobytes(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tobytes()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\r\n        )\r\n\r\n    def tofile(self, fid, sep=\"\", format=\"%s\"):\r\n        \"\"\"Not implemented, use ``.value.tofile()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\r\n        )\r\n\r\n    def dump(self, file):\r\n        \"\"\"Not implemented, use ``.value.dump()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to file.  Write array with q.value.dump()\"\r\n        )\r\n\r\n    def dumps(self):\r\n        \"\"\"Not implemented, use ``.value.dumps()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\r\n        )\r\n\r\n    # astype, byteswap, copy, view, getfield, setflags OK as is\r\n\r\n    def fill(self, value):\r\n        self.view(np.ndarray).fill(self._to_own_unit(value))\r\n\r\n    # Shape manipulation: resize cannot be done (does not own data), but\r\n    # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\r\n    # the flat iterator needs to be overwritten, otherwise single items are\r\n    # returned as numbers.\r\n    @property\r\n    def flat(self):\r\n        \"\"\"A 1-D iterator over the Quantity array.\r\n\r\n        This returns a ``QuantityIterator`` instance, which behaves the same\r\n        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\r\n        and is similar to, but not a subclass of, Python's built-in iterator\r\n        object.\r\n        \"\"\"\r\n        return QuantityIterator(self)\r\n\r\n    @flat.setter\r\n    def flat(self, value):\r\n        y = self.ravel()\r\n        y[:] = value\r\n\r\n    # Item selection and manipulation\r\n    # repeat, sort, compress, diagonal OK\r\n    def take(self, indices, axis=None, out=None, mode=\"raise\"):\r\n        out = super().take(indices, axis=axis, out=out, mode=mode)\r\n        # For single elements, ndarray.take returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if type(out) is not type(self):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def put(self, indices, values, mode=\"raise\"):\r\n        self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\r\n\r\n    def choose(self, choices, out=None, mode=\"raise\"):\r\n        raise NotImplementedError(\r\n            \"cannot choose based on quantity.  Choose using array with\"\r\n            \" q.value.choose(...)\"\r\n        )\r\n\r\n    # ensure we do not return indices as quantities\r\n    if NUMPY_LT_2_0:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None):\r\n            return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\r\n\r\n    else:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None, *, stable=None):\r\n            return self.view(np.ndarray).argsort(\r\n                axis=axis, kind=kind, order=order, stable=stable\r\n            )\r\n\r\n    def searchsorted(self, v, *args, **kwargs):\r\n        return np.searchsorted(\r\n            np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\r\n        )  # avoid numpy 1.6 problem\r\n\r\n    def argmax(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def argmin(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def __array_function__(self, function, types, args, kwargs):\r\n        \"\"\"Wrap numpy functions, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap\r\n        types : iterable of classes\r\n            Classes that provide an ``__array_function__`` override. Can\r\n            in principle be used to interact with other classes. Below,\r\n            mostly passed on to `~numpy.ndarray`, which can only interact\r\n            with subclasses.\r\n        args : tuple\r\n            Positional arguments provided in the function call.\r\n        kwargs : dict\r\n            Keyword arguments provided in the function call.\r\n\r\n        Returns\r\n        -------\r\n        result: `~astropy.units.Quantity`, `~numpy.ndarray`\r\n            As appropriate for the function.  If the function is not\r\n            supported, `NotImplemented` is returned, which will lead to\r\n            a `TypeError` unless another argument overrode the function.\r\n\r\n        Raises\r\n        ------\r\n        ~astropy.units.UnitsError\r\n            If operands have incompatible units.\r\n        \"\"\"\r\n        # A function should be in one of the following sets or dicts:\r\n        # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\r\n        #    supports Quantity; we pass on to ndarray.__array_function__.\r\n        # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\r\n        #    after converting quantities to arrays with suitable units,\r\n        #    and possibly setting units on the result.\r\n        # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\r\n        #    requires a Quantity-specific implementation.\r\n        # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\r\n        # For now, since we may not yet have complete coverage, if a\r\n        # function is in none of the above, we simply call the numpy\r\n        # implementation.\r\n        if function in SUBCLASS_SAFE_FUNCTIONS:\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        elif function in FUNCTION_HELPERS:\r\n            function_helper = FUNCTION_HELPERS[function]\r\n            try:\r\n                args, kwargs, unit, out = function_helper(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            result = super().__array_function__(function, types, args, kwargs)\r\n            # Fall through to return section\r\n\r\n        elif function in DISPATCHED_FUNCTIONS:\r\n            dispatched_function = DISPATCHED_FUNCTIONS[function]\r\n            try:\r\n                result, unit, out = dispatched_function(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            # Fall through to return section\r\n\r\n        elif function in UNSUPPORTED_FUNCTIONS:\r\n            return NotImplemented\r\n\r\n        else:\r\n            warnings.warn(\r\n                f\"function '{function.__name__}' is not known to astropy's Quantity.\"\r\n                \" Will run it anyway, hoping it will treat ndarray subclasses\"\r\n                \" correctly. Please raise an issue at\"\r\n                \" https://github.com/astropy/astropy/issues.\",\r\n                AstropyWarning,\r\n            )\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        # If unit is None, a plain array is expected (e.g., boolean), which\r\n        # means we're done.\r\n        # We're also done if the result was NotImplemented, which can happen\r\n        # if other inputs/outputs override __array_function__;\r\n        # hopefully, they can then deal with us.\r\n        if unit is None or result is NotImplemented:\r\n            return result\r\n\r\n        return self._result_as_quantity(result, unit, out=out)\r\n\r\n    def _not_implemented_or_raise(self, function, types):\r\n        # Our function helper or dispatcher found that the function does not\r\n        # work with Quantity.  In principle, there may be another class that\r\n        # knows what to do with us, for which we should return NotImplemented.\r\n        # But if there is ndarray (or a non-Quantity subclass of it) around,\r\n        # it quite likely coerces, so we should just break.\r\n        if any(\r\n            issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\r\n        ):\r\n            raise TypeError(\r\n                f\"the Quantity implementation cannot handle {function} \"\r\n                \"with the given arguments.\"\r\n            ) from None\r\n        else:\r\n            return NotImplemented\r\n\r\n    # Calculation -- override ndarray methods to take into account units.\r\n    # We use the corresponding numpy functions to evaluate the results, since\r\n    # the methods do not always allow calling with keyword arguments.\r\n    # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\r\n    # TypeError: 'a_max' is an invalid keyword argument for this function.\r\n    def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\r\n        \"\"\"Wrap a numpy function that processes self, returning a Quantity.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap.\r\n        args : positional arguments\r\n            Any positional arguments to the function beyond the first argument\r\n            (which will be set to ``self``).\r\n        kwargs : keyword arguments\r\n            Keyword arguments to the function.\r\n\r\n        If present, the following arguments are treated specially:\r\n\r\n        unit : `~astropy.units.Unit`\r\n            Unit of the output result.  If not given, the unit of ``self``.\r\n        out : `~astropy.units.Quantity`\r\n            A Quantity instance in which to store the output.\r\n\r\n        Notes\r\n        -----\r\n        Output should always be assigned via a keyword argument, otherwise\r\n        no proper account of the unit is taken.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            Result of the function call, with the unit set properly.\r\n        \"\"\"\r\n        if unit is None:\r\n"]
[250.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[250.002, "i", "cat asv.ci.conf.json\r"]
[250.004, "o", "cat asv.ci.conf.json\r\n"]
[250.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[255.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[255.002, "i", "sed -n '1,240p' astropy-benchmarks/benchmarks/units.py\r"]
[255.004, "o", "sed -n '1,240p' astropy-benchmarks/benchmarks/units.py\r\n"]
[255.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[260.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[260.002, "i", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r"]
[260.004, "o", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r\n"]
[260.006, "o", "_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\"\r\n\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: argument {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages}: invalid choice: 'dev' (choose from 'help', 'quickstart', 'machine', 'setup', 'run', 'continuous', 'find', 'rm', 'publish', 'preview', 'profile', 'update', 'show', 'compare', 'check', 'gh-pages')\r\n"]
[265.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[265.002, "i", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r"]
[265.004, "o", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[265.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[270.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[270.002, "i", "sed -n '1,400p' astropy/units/quantity.py\r"]
[270.004, "o", "sed -n '1,400p' astropy/units/quantity.py\r\n"]
[270.006, "o", "\u001b[?2004l\r\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\r\n\"\"\"\r\nThis module defines the `Quantity` object, which represents a number with some\r\nassociated units. `Quantity` objects support operations like ordinary numbers,\r\nbut will deal with unit conversions internally.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport builtins\r\nimport numbers\r\nimport operator\r\nimport re\r\nimport warnings\r\nfrom fractions import Fraction\r\nfrom typing import TYPE_CHECKING\r\n\r\nimport numpy as np\r\n\r\nfrom astropy import config as _config\r\nfrom astropy.utils.compat.numpycompat import COPY_IF_NEEDED, NUMPY_LT_2_0\r\nfrom astropy.utils.data_info import ParentDtypeInfo\r\nfrom astropy.utils.exceptions import AstropyWarning\r\n\r\nfrom .core import (\r\n    Unit,\r\n    UnitBase,\r\n    UnitConversionError,\r\n    UnitsError,\r\n    UnitTypeError,\r\n    dimensionless_unscaled,\r\n    get_current_unit_registry,\r\n)\r\nfrom .format import Base, Latex\r\nfrom .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\r\nfrom .quantity_helper.function_helpers import (\r\n    DISPATCHED_FUNCTIONS,\r\n    FUNCTION_HELPERS,\r\n    SUBCLASS_SAFE_FUNCTIONS,\r\n    UNSUPPORTED_FUNCTIONS,\r\n)\r\nfrom .structured import StructuredUnit, _structured_unit_like_dtype\r\nfrom .utils import is_effectively_unity\r\n\r\nif TYPE_CHECKING:\r\n    from typing_extensions import Self\r\n\r\n    from .typing import QuantityLike\r\n\r\n__all__ = [\r\n    \"Quantity\",\r\n    \"SpecificTypeQuantity\",\r\n    \"QuantityInfoBase\",\r\n    \"QuantityInfo\",\r\n    \"allclose\",\r\n    \"isclose\",\r\n]\r\n\r\n\r\n# We don't want to run doctests in the docstrings we inherit from Numpy\r\n__doctest_skip__ = [\"Quantity.*\"]\r\n\r\n_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\r\n_UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\r\n\r\n\r\nclass Conf(_config.ConfigNamespace):\r\n    \"\"\"\r\n    Configuration parameters for Quantity.\r\n    \"\"\"\r\n\r\n    latex_array_threshold = _config.ConfigItem(\r\n        100,\r\n        \"The maximum size an array Quantity can be before its LaTeX \"\r\n        'representation for IPython gets \"summarized\" (meaning only the first '\r\n        'and last few elements are shown with \"...\" between). Setting this to a '\r\n        \"negative number means that the value will instead be whatever numpy \"\r\n        \"gets from get_printoptions.\",\r\n    )\r\n\r\n\r\nconf = Conf()\r\n\r\n\r\nclass QuantityIterator:\r\n    \"\"\"\r\n    Flat iterator object to iterate over Quantities.\r\n\r\n    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\r\n    ``q``.  It allows iterating over the array as if it were a 1-D array,\r\n    either in a for-loop or by calling its `next` method.\r\n\r\n    Iteration is done in C-contiguous style, with the last index varying the\r\n    fastest. The iterator can also be indexed using basic slicing or\r\n    advanced indexing.\r\n\r\n    See Also\r\n    --------\r\n    Quantity.flatten : Returns a flattened copy of an array.\r\n\r\n    Notes\r\n    -----\r\n    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\r\n    is not exported by the `~astropy.units` module.  Instead of\r\n    instantiating a `QuantityIterator` directly, use `Quantity.flat`.\r\n    \"\"\"\r\n\r\n    def __init__(self, q):\r\n        self._quantity = q\r\n        self._dataiter = q.view(np.ndarray).flat\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __getitem__(self, indx):\r\n        out = self._dataiter.__getitem__(indx)\r\n        # For single elements, ndarray.flat.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if isinstance(out, type(self._quantity)):\r\n            return out\r\n        else:\r\n            return self._quantity._new_view(out)\r\n\r\n    def __setitem__(self, index, value):\r\n        self._dataiter[index] = self._quantity._to_own_unit(value)\r\n\r\n    def __next__(self):\r\n        \"\"\"\r\n        Return the next value, or raise StopIteration.\r\n        \"\"\"\r\n        out = next(self._dataiter)\r\n        # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\r\n        return self._quantity._new_view(out)\r\n\r\n    next = __next__\r\n\r\n    def __len__(self):\r\n        return len(self._dataiter)\r\n\r\n    # Properties and methods to match `numpy.ndarray.flatiter`\r\n\r\n    @property\r\n    def base(self):\r\n        \"\"\"A reference to the array that is iterated over.\"\"\"\r\n        return self._quantity\r\n\r\n    @property\r\n    def coords(self):\r\n        \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\r\n        return self._dataiter.coords\r\n\r\n    @property\r\n    def index(self):\r\n        \"\"\"Current flat index into the array.\"\"\"\r\n        return self._dataiter.index\r\n\r\n    def copy(self):\r\n        \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\r\n        return self._quantity.flatten()\r\n\r\n\r\nclass QuantityInfoBase(ParentDtypeInfo):\r\n    # This is on a base class rather than QuantityInfo directly, so that\r\n    # it can be used for EarthLocationInfo yet make clear that that class\r\n    # should not be considered a typical Quantity subclass by Table.\r\n    attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\r\n    _supports_indexing = True\r\n\r\n    @staticmethod\r\n    def default_format(val):\r\n        return f\"{val.value}\"\r\n\r\n    @staticmethod\r\n    def possible_string_format_functions(format_):\r\n        \"\"\"Iterate through possible string-derived format functions.\r\n\r\n        A string can either be a format specifier for the format built-in,\r\n        a new-style format string, or an old-style format string.\r\n\r\n        This method is overridden in order to suppress printing the unit\r\n        in each row since it is already at the top in the column header.\r\n        \"\"\"\r\n        yield lambda format_, val: format(val.value, format_)\r\n        yield lambda format_, val: format_.format(val.value)\r\n        yield lambda format_, val: format_ % val.value\r\n\r\n\r\nclass QuantityInfo(QuantityInfoBase):\r\n    \"\"\"\r\n    Container for meta information like name, description, format.  This is\r\n    required when the object is used as a mixin column within a table, but can\r\n    be used as a general way to store meta information.\r\n    \"\"\"\r\n\r\n    _represent_as_dict_attrs = (\"value\", \"unit\")\r\n    _construct_from_dict_args = [\"value\"]\r\n    _represent_as_dict_primary_data = \"value\"\r\n\r\n    def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\r\n        \"\"\"\r\n        Return a new Quantity instance which is consistent with the\r\n        input ``cols`` and has ``length`` rows.\r\n\r\n        This is intended for creating an empty column object whose elements can\r\n        be set in-place for table operations like join or vstack.\r\n\r\n        Parameters\r\n        ----------\r\n        cols : list\r\n            List of input columns\r\n        length : int\r\n            Length of the output column object\r\n        metadata_conflicts : str ('warn'|'error'|'silent')\r\n            How to handle metadata conflicts\r\n        name : str\r\n            Output column name\r\n\r\n        Returns\r\n        -------\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n            Empty instance of this class consistent with ``cols``\r\n\r\n        \"\"\"\r\n        # Get merged info attributes like shape, dtype, format, description, etc.\r\n        attrs = self.merge_cols_attributes(\r\n            cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\r\n        )\r\n\r\n        # Make an empty quantity using the unit of the last one.\r\n        shape = (length,) + attrs.pop(\"shape\")\r\n        dtype = attrs.pop(\"dtype\")\r\n        # Use zeros so we do not get problems for Quantity subclasses such\r\n        # as Longitude and Latitude, which cannot take arbitrary values.\r\n        data = np.zeros(shape=shape, dtype=dtype)\r\n        # Get arguments needed to reconstruct class\r\n        map = {\r\n            key: (data if key == \"value\" else getattr(cols[-1], key))\r\n            for key in self._represent_as_dict_attrs\r\n        }\r\n        map[\"copy\"] = COPY_IF_NEEDED\r\n        out = self._construct_from_dict(map)\r\n\r\n        # Set remaining info attributes\r\n        for attr, value in attrs.items():\r\n            setattr(out.info, attr, value)\r\n\r\n        return out\r\n\r\n    def get_sortable_arrays(self):\r\n        \"\"\"\r\n        Return a list of arrays which can be lexically sorted to represent\r\n        the order of the parent column.\r\n\r\n        For Quantity this is just the quantity itself.\r\n\r\n\r\n        Returns\r\n        -------\r\n        arrays : list of ndarray\r\n        \"\"\"\r\n        return [self._parent]\r\n\r\n\r\nclass Quantity(np.ndarray):\r\n    \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\r\n\r\n    See also: https://docs.astropy.org/en/stable/units/quantity.html\r\n\r\n    Parameters\r\n    ----------\r\n    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\r\n        The numerical value of this quantity in the units given by unit.  If a\r\n        `Quantity` or sequence of them (or any other valid object with a\r\n        ``unit`` attribute), creates a new `Quantity` object, converting to\r\n        `unit` units as needed.  If a string, it is converted to a number or\r\n        `Quantity`, depending on whether a unit is present.\r\n\r\n    unit : unit-like\r\n        An object that represents the unit associated with the input value.\r\n        Must be an `~astropy.units.UnitBase` object or a string parseable by\r\n        the :mod:`~astropy.units` package.\r\n\r\n    dtype : ~numpy.dtype, optional\r\n        The dtype of the resulting Numpy array or scalar that will\r\n        hold the value.  If not provided, it is determined from the input,\r\n        except that any integer and (non-Quantity) object inputs are converted\r\n        to float by default.\r\n        If `None`, the normal `numpy.dtype` introspection is used, e.g.\r\n        preventing upcasting of integers.\r\n\r\n    copy : bool, optional\r\n        If `True` (default), then the value is copied.  Otherwise, a copy will\r\n        only be made if ``__array__`` returns a copy, if value is a nested\r\n        sequence, or if a copy is needed to satisfy an explicitly given\r\n        ``dtype``.  (The `False` option is intended mostly for internal use,\r\n        to speed up initialization where a copy is known to have been made.\r\n        Use with care.)\r\n\r\n    order : {'C', 'F', 'A'}, optional\r\n        Specify the order of the array.  As in `~numpy.array`.  This parameter\r\n        is ignored if the input is a `Quantity` and ``copy=False``.\r\n\r\n    subok : bool, optional\r\n        If `False` (default), the returned array will be forced to be a\r\n        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\r\n        or a subclass appropriate for the unit will be used (such as\r\n        `~astropy.units.Dex` for ``u.dex(u.AA)``).\r\n\r\n    ndmin : int, optional\r\n        Specifies the minimum number of dimensions that the resulting array\r\n        should have.  Ones will be prepended to the shape as needed to meet\r\n        this requirement.  This parameter is ignored if the input is a\r\n        `Quantity` and ``copy=False``.\r\n\r\n    Raises\r\n    ------\r\n    TypeError\r\n        If the value provided is not a Python numeric type.\r\n    TypeError\r\n        If the unit provided is not either a :class:`~astropy.units.Unit`\r\n        object or a parseable string unit.\r\n\r\n    Notes\r\n    -----\r\n    Quantities can also be created by multiplying a number or array with a\r\n    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\r\n\r\n    Unless the ``dtype`` argument is explicitly specified, integer\r\n    or (non-Quantity) object inputs are converted to `float` by default.\r\n    \"\"\"\r\n\r\n    # Need to set a class-level default for _equivalencies, or\r\n    # Constants can not initialize properly\r\n    _equivalencies = []\r\n\r\n    # Default unit for initialization; can be overridden by subclasses,\r\n    # possibly to `None` to indicate there is no default unit.\r\n    _default_unit = dimensionless_unscaled\r\n\r\n    # Ensures views have an undefined unit.\r\n    _unit = None\r\n\r\n    __array_priority__ = 10000\r\n\r\n    def __class_getitem__(cls, unit_shape_dtype):\r\n        \"\"\"Quantity Type Hints.\r\n\r\n        Unit-aware type hints are ``Annotated`` objects that encode the class,\r\n        the unit, and possibly shape and dtype information, depending on the\r\n        python and :mod:`numpy` versions.\r\n\r\n        Schematically, ``Annotated[cls[shape, dtype], unit]``\r\n\r\n        As a classmethod, the type is the class, ie ``Quantity``\r\n        produces an ``Annotated[Quantity, ...]`` while a subclass\r\n        like :class:`~astropy.coordinates.Angle` returns\r\n        ``Annotated[Angle, ...]``.\r\n\r\n        Parameters\r\n        ----------\r\n        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\r\n            Unit specification, can be the physical type (ie str or class).\r\n            If tuple, then the first element is the unit specification\r\n            and all other elements are for `numpy.ndarray` type annotations.\r\n            Whether they are included depends on the python and :mod:`numpy`\r\n            versions.\r\n\r\n        Returns\r\n        -------\r\n        `typing.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\r\n            Return type in this preference order:\r\n            * `typing.Annotated`\r\n            * `astropy.units.Unit` or `astropy.units.PhysicalType`\r\n\r\n        Raises\r\n        ------\r\n        TypeError\r\n            If the unit/physical_type annotation is not Unit-like or\r\n            PhysicalType-like.\r\n\r\n        Examples\r\n        --------\r\n        Create a unit-aware Quantity type annotation\r\n\r\n            >>> Quantity[Unit(\"s\")]\r\n            Annotated[Quantity, Unit(\"s\")]\r\n\r\n        See Also\r\n        --------\r\n        `~astropy.units.quantity_input`\r\n            Use annotations for unit checks on function arguments and results.\r\n\r\n        Notes\r\n        -----\r\n        |Quantity| types are also static-type compatible.\r\n        \"\"\"\r\n        from typing import Annotated\r\n\r\n        # process whether [unit] or [unit, shape, ptype]\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n"]
[275.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[275.002, "i", "sed -n '400,1200p' astropy/units/quantity.py\r"]
[275.004, "o", "sed -n '400,1200p' astropy/units/quantity.py\r\n"]
[275.006, "o", "\u001b[?2004l\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n            target = unit_shape_dtype[0]\r\n            shape_dtype = unit_shape_dtype[1:]\r\n        else:  # just unit\r\n            target = unit_shape_dtype\r\n            shape_dtype = ()\r\n\r\n        # Allowed unit/physical types. Errors if neither.\r\n        try:\r\n            unit = Unit(target)\r\n        except (TypeError, ValueError):\r\n            from astropy.units.physical import get_physical_type\r\n\r\n            try:\r\n                unit = get_physical_type(target)\r\n            except (TypeError, ValueError, KeyError):  # KeyError for Enum\r\n                raise TypeError(\r\n                    \"unit annotation is not a Unit or PhysicalType\"\r\n                ) from None\r\n\r\n        # Quantity does not (yet) properly extend the NumPy generics types,\r\n        # introduced in numpy v1.22+, instead just including the unit info as\r\n        # metadata using Annotated.\r\n        # TODO: ensure we do interact with NDArray.__class_getitem__.\r\n        return Annotated[cls, unit]\r\n\r\n    def __new__(\r\n        cls: type[Self],\r\n        value: QuantityLike,\r\n        unit=None,\r\n        dtype=np.inexact,\r\n        copy=True,\r\n        order=None,\r\n        subok=False,\r\n        ndmin=0,\r\n    ) -> Self:\r\n        if unit is not None:\r\n            # convert unit first, to avoid multiple string->unit conversions\r\n            unit = Unit(unit)\r\n\r\n        # inexact -> upcast to float dtype\r\n        float_default = dtype is np.inexact\r\n        if float_default:\r\n            dtype = None\r\n\r\n        # optimize speed for Quantity with no dtype given, copy=COPY_IF_NEEDED\r\n        if isinstance(value, Quantity):\r\n            if unit is not None and unit is not value.unit:\r\n                value = value.to(unit)\r\n                # the above already makes a copy (with float dtype)\r\n                copy = COPY_IF_NEEDED\r\n\r\n            if type(value) is not cls and not (subok and isinstance(value, cls)):\r\n                value = value.view(cls)\r\n\r\n            if float_default and value.dtype.kind in \"iu\":\r\n                dtype = float\r\n\r\n            return np.array(\r\n                value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n            )\r\n\r\n        # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\r\n        # To ensure array remains fast, we short-circuit it.\r\n        value_unit = None\r\n        if not isinstance(value, np.ndarray):\r\n            if isinstance(value, str):\r\n                # The first part of the regex string matches any integer/float;\r\n                # the second parts adds possible trailing .+-, which will break\r\n                # the float function below and ensure things like 1.2.3deg\r\n                # will not work.\r\n                pattern = (\r\n                    r\"\\s*[+-]?\"\r\n                    r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\r\n                    r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\r\n                    r\"([eE][+-]?\\d+)?\"\r\n                    r\"[.+-]?\"\r\n                )\r\n\r\n                v = re.match(pattern, value)\r\n                unit_string = None\r\n                try:\r\n                    value = float(v.group())\r\n\r\n                except Exception:\r\n                    raise TypeError(\r\n                        f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\r\n                        \"start with a number.\"\r\n                    )\r\n\r\n                unit_string = v.string[v.end() :].strip()\r\n                if unit_string:\r\n                    value_unit = Unit(unit_string)\r\n                    if unit is None:\r\n                        unit = value_unit  # signal no conversion needed below.\r\n\r\n            elif isinstance(value, (list, tuple)) and len(value) > 0:\r\n                if all(isinstance(v, Quantity) for v in value):\r\n                    # If a list/tuple contains only quantities, stack them,\r\n                    # which also converts them to the same unit.\r\n                    value = np.stack(value)\r\n                    copy = False\r\n\r\n                elif (\r\n                    dtype is None\r\n                    and not hasattr(value, \"dtype\")\r\n                    and isinstance(unit, StructuredUnit)\r\n                ):\r\n                    # Special case for list/tuple of values and a structured unit:\r\n                    # ``np.array(value, dtype=None)`` would treat tuples as lower\r\n                    # levels of the array, rather than as elements of a structured\r\n                    # array, so we use the structure of the unit to help infer the\r\n                    # structured dtype of the value.\r\n                    dtype = unit._recursively_get_dtype(value)\r\n\r\n        using_default_unit = False\r\n        if value_unit is None:\r\n            # If the value has a `unit` attribute and if not None\r\n            # (for Columns with uninitialized unit), treat it like a quantity.\r\n            value_unit = getattr(value, \"unit\", None)\r\n            if value_unit is None:\r\n                # Default to dimensionless for no (initialized) unit attribute.\r\n                if unit is None:\r\n                    using_default_unit = True\r\n                    unit = cls._default_unit\r\n                value_unit = unit  # signal below that no conversion is needed\r\n            else:\r\n                try:\r\n                    value_unit = Unit(value_unit)\r\n                except Exception as exc:\r\n                    raise TypeError(\r\n                        f\"The unit attribute {value.unit!r} of the input could \"\r\n                        \"not be parsed as an astropy Unit.\"\r\n                    ) from exc\r\n\r\n                if unit is None:\r\n                    unit = value_unit\r\n                elif unit is not value_unit:\r\n                    copy = COPY_IF_NEEDED  # copy will be made in conversion at end\r\n\r\n        value = np.array(\r\n            value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n        )\r\n\r\n        # For no-user-input unit, make sure the constructed unit matches the\r\n        # structure of the data.\r\n        if using_default_unit and value.dtype.names is not None:\r\n            unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\r\n\r\n        # check that array contains numbers or long int objects\r\n        if value.dtype.kind in \"OSU\" and not (\r\n            value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\r\n        ):\r\n            raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\r\n\r\n        # by default, cast any integer, boolean, etc., to float\r\n        if float_default and value.dtype.kind in \"iuO\":\r\n            value = value.astype(float)\r\n\r\n        # if we allow subclasses, allow a class from the unit.\r\n        if subok:\r\n            qcls = getattr(unit, \"_quantity_class\", cls)\r\n            if issubclass(qcls, cls):\r\n                cls = qcls\r\n\r\n        value = value.view(cls)\r\n        value._set_unit(value_unit)\r\n        if unit is value_unit:\r\n            return value\r\n        else:\r\n            # here we had non-Quantity input that had a \"unit\" attribute\r\n            # with a unit different from the desired one.  So, convert.\r\n            return value.to(unit)\r\n\r\n    def __array_finalize__(self, obj):\r\n        # Check whether super().__array_finalize should be called\r\n        # (sadly, ndarray.__array_finalize__ is None; we cannot be sure\r\n        # what is above us).\r\n        super_array_finalize = super().__array_finalize__\r\n        if super_array_finalize is not None:\r\n            super_array_finalize(obj)\r\n\r\n        # If we're a new object or viewing an ndarray, nothing has to be done.\r\n        if obj is None or obj.__class__ is np.ndarray:\r\n            return\r\n\r\n        # Copy over the unit and possibly info.  Note that the only way the\r\n        # unit can already be set is if one enters via _new_view(), where the\r\n        # unit is often different from that of self, and where propagation of\r\n        # info is not always desirable.\r\n        if self._unit is None:\r\n            unit = getattr(obj, \"_unit\", None)\r\n            if unit is not None:\r\n                self._set_unit(unit)\r\n\r\n            # Copy info if the original had `info` defined.  Because of the way the\r\n            # DataInfo works, `'info' in obj.__dict__` is False until the\r\n            # `info` attribute is accessed or set.\r\n            if \"info\" in obj.__dict__:\r\n                self.info = obj.info\r\n\r\n    def __array_wrap__(self, obj, context=None, return_scalar=False):\r\n        if context is None:\r\n            # Methods like .squeeze() created a new `ndarray` and then call\r\n            # __array_wrap__ to turn the array into self's subclass.\r\n            return self._new_view(obj)\r\n\r\n        raise NotImplementedError(\r\n            \"__array_wrap__ should not be used with a context any more since all \"\r\n            \"use should go through array_function. Please raise an issue on \"\r\n            \"https://github.com/astropy/astropy\"\r\n        )\r\n\r\n    def __array_ufunc__(self, function, method, *inputs, **kwargs):\r\n        \"\"\"Wrap numpy ufuncs, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            ufunc to wrap.\r\n        method : str\r\n            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\r\n        inputs : tuple\r\n            Input arrays.\r\n        kwargs : keyword arguments\r\n            As passed on, with ``out`` containing possible quantity output.\r\n\r\n        Returns\r\n        -------\r\n        result : `~astropy.units.Quantity` or `NotImplemented`\r\n            Results of the ufunc, with the unit set properly.\r\n        \"\"\"\r\n        # Determine required conversion functions -- to bring the unit of the\r\n        # input to that expected (e.g., radian for np.sin), or to get\r\n        # consistent units between two inputs (e.g., in np.add) --\r\n        # and the unit of the result (or tuple of units for nout > 1).\r\n        try:\r\n            converters, unit = converters_and_unit(function, method, *inputs)\r\n\r\n            out = kwargs.get(\"out\", None)\r\n            # Avoid loop back by turning any Quantity output into array views.\r\n            if out is not None:\r\n                # If pre-allocated output is used, check it is suitable.\r\n                # This also returns array view, to ensure we don't loop back.\r\n                if function.nout == 1:\r\n                    out = out[0]\r\n                out_array = check_output(out, unit, inputs, function=function)\r\n                # Ensure output argument remains a tuple.\r\n                kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\r\n\r\n            if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\r\n                # Special-case for initial argument for reductions like\r\n                # np.add.reduce.  This should be converted to the output unit as\r\n                # well, which is typically the same as the input unit (but can\r\n                # in principle be different: unitless for np.equal, radian\r\n                # for np.arctan2, though those are not necessarily useful!)\r\n                kwargs[\"initial\"] = self._to_own_unit(\r\n                    kwargs[\"initial\"], check_precision=False, unit=unit\r\n                )\r\n\r\n            # Same for inputs, but here also convert if necessary.\r\n            arrays = []\r\n            for input_, converter in zip(inputs, converters):\r\n                input_ = getattr(input_, \"value\", input_)\r\n                arrays.append(converter(input_) if converter else input_)\r\n\r\n            # Call our superclass's __array_ufunc__\r\n            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\r\n            # If unit is None, a plain array is expected (e.g., comparisons), which\r\n            # means we're done.\r\n            # We're also done if the result was None (for method 'at') or\r\n            # NotImplemented, which can happen if other inputs/outputs override\r\n            # __array_ufunc__; hopefully, they can then deal with us.\r\n            if unit is None or result is None or result is NotImplemented:\r\n                return result\r\n\r\n            return self._result_as_quantity(result, unit, out)\r\n\r\n        except (TypeError, ValueError, AttributeError) as e:\r\n            out_normalized = kwargs.get(\"out\", ())\r\n            inputs_and_outputs = inputs + out_normalized\r\n            ignored_ufunc = (\r\n                None,\r\n                np.ndarray.__array_ufunc__,\r\n                type(self).__array_ufunc__,\r\n            )\r\n            if not all(\r\n                getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\r\n                for io in inputs_and_outputs\r\n            ):\r\n                return NotImplemented\r\n            else:\r\n                raise e\r\n\r\n    def _result_as_quantity(self, result, unit, out):\r\n        \"\"\"Turn result into a quantity with the given unit.\r\n\r\n        If no output is given, it will take a view of the array as a quantity,\r\n        and set the unit.  If output is given, those should be quantity views\r\n        of the result arrays, and the function will just set the unit.\r\n\r\n        Parameters\r\n        ----------\r\n        result : ndarray or tuple thereof\r\n            Array(s) which need to be turned into quantity.\r\n        unit : `~astropy.units.Unit`\r\n            Unit for the quantities to be returned (or `None` if the result\r\n            should not be a quantity).  Should be tuple if result is a tuple.\r\n        out : `~astropy.units.Quantity` or None\r\n            Possible output quantity. Should be `None` or a tuple if result\r\n            is a tuple.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n           With units set.\r\n        \"\"\"\r\n        if isinstance(result, (tuple, list)):\r\n            if out is None:\r\n                out = (None,) * len(result)\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n        # ``obj.__class is np.ndarray``. So, not worth special-casing.\r\n        if obj is None:\r\n            obj = self.view(np.ndarray)\r\n        else:\r\n            obj = np.array(obj, copy=COPY_IF_NEEDED, subok=True)\r\n\r\n        # Take the view, set the unit, and update possible other properties\r\n        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\r\n        view = obj.view(quantity_subclass)\r\n        view._set_unit(unit)\r\n        view.__array_finalize__(self)\r\n        if propagate_info and \"info\" in self.__dict__:\r\n            view.info = self.info\r\n        return view\r\n\r\n    def _set_unit(self, unit):\r\n        \"\"\"Set the unit.\r\n\r\n        This is used anywhere the unit is set or modified, i.e., in the\r\n        initializer, in ``__imul__`` and ``__itruediv__`` for in-place\r\n        multiplication and division by another unit, as well as in\r\n        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\r\n        sets the unit, but subclasses can override it to check that, e.g.,\r\n        a unit is consistent.\r\n        \"\"\"\r\n        if not isinstance(unit, UnitBase):\r\n            if isinstance(self._unit, StructuredUnit) or isinstance(\r\n                unit, StructuredUnit\r\n            ):\r\n                unit = StructuredUnit(unit, self.dtype)\r\n            else:\r\n                # Trying to go through a string ensures that, e.g., Magnitudes with\r\n                # dimensionless physical unit become Quantity with units of mag.\r\n                unit = Unit(str(unit), parse_strict=\"silent\")\r\n                if not isinstance(unit, (UnitBase, StructuredUnit)):\r\n                    raise UnitTypeError(\r\n                        f\"{self.__class__.__name__} instances require normal units, \"\r\n                        f\"not {unit.__class__} instances.\"\r\n                    )\r\n\r\n        self._unit = unit\r\n\r\n    def __deepcopy__(self, memo):\r\n        # If we don't define this, ``copy.deepcopy(quantity)`` will\r\n        # return a bare Numpy array.\r\n        return self.copy()\r\n\r\n    def __reduce__(self):\r\n        # patch to pickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        object_state = list(super().__reduce__())\r\n        object_state[2] = (object_state[2], self.__dict__)\r\n        return tuple(object_state)\r\n\r\n    def __setstate__(self, state):\r\n        # patch to unpickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        nd_state, own_state = state\r\n        super().__setstate__(nd_state)\r\n        self.__dict__.update(own_state)\r\n\r\n    info = QuantityInfo()\r\n\r\n    def _to_value(self, unit, equivalencies=[]):\r\n        \"\"\"Helper method for to and to_value.\"\"\"\r\n        if equivalencies == []:\r\n            equivalencies = self._equivalencies\r\n        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\r\n            # Standard path, let unit to do work.\r\n            return self.unit.to(\r\n                unit, self.view(np.ndarray), equivalencies=equivalencies\r\n            )\r\n\r\n        else:\r\n            # The .to() method of a simple unit cannot convert a structured\r\n            # dtype, so we work around it, by recursing.\r\n            # TODO: deprecate this?\r\n            # Convert simple to Structured on initialization?\r\n            result = np.empty_like(self.view(np.ndarray))\r\n            for name in self.dtype.names:\r\n                result[name] = self[name]._to_value(unit, equivalencies)\r\n            return result\r\n\r\n    def to(self, unit, equivalencies=[], copy=True):\r\n        \"\"\"\r\n        Return a new `~astropy.units.Quantity` object with the specified unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like\r\n            An object that represents the unit to convert to. Must be\r\n            an `~astropy.units.UnitBase` object or a string parseable\r\n            by the `~astropy.units` package.\r\n\r\n        equivalencies : list of tuple\r\n            A list of equivalence pairs to try if the units are not\r\n            directly convertible.  See :ref:`astropy:unit_equivalencies`.\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n            (none for `~astropy.units.Quantity`, but may be set for subclasses)\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        copy : bool, optional\r\n            If `True` (default), then the value is copied.  Otherwise, a copy\r\n            will only be made if necessary.\r\n\r\n        See Also\r\n        --------\r\n        to_value : get the numerical value in a given unit.\r\n        \"\"\"\r\n        # We don't use `to_value` below since we always want to make a copy\r\n        # and don't want to slow down this method (esp. the scalar case).\r\n        unit = Unit(unit)\r\n        if copy:\r\n            # Avoid using to_value to ensure that we make a copy. We also\r\n            # don't want to slow down this method (esp. the scalar case).\r\n            value = self._to_value(unit, equivalencies)\r\n        else:\r\n            # to_value only copies if necessary\r\n            value = self.to_value(unit, equivalencies)\r\n        return self._new_view(value, unit)\r\n\r\n    def to_value(self, unit=None, equivalencies=[]):\r\n        \"\"\"\r\n        The numerical value, possibly in a different unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            The unit in which the value should be given. If not given or `None`,\r\n            use the current unit.\r\n\r\n        equivalencies : list of tuple, optional\r\n            A list of equivalence pairs to try if the units are not directly\r\n            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\r\n            or ``[]``, class default equivalencies will be used (none for\r\n            `~astropy.units.Quantity`, but may be set for subclasses).\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        Returns\r\n        -------\r\n        value : ndarray or scalar\r\n            The value in the units specified. For arrays, this will be a view\r\n            of the data if no unit conversion was necessary.\r\n\r\n        See Also\r\n        --------\r\n        to : Get a new instance in a different unit.\r\n        \"\"\"\r\n        if unit is None or unit is self.unit:\r\n            value = self.view(np.ndarray)\r\n        elif not self.dtype.names:\r\n            # For non-structured, we attempt a short-cut, where we just get\r\n            # the scale.  If that is 1, we do not have to do anything.\r\n            unit = Unit(unit)\r\n            # We want a view if the unit does not change.  One could check\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n            # TODO: would be better for `unit.to` to have an in-place flag.\r\n            try:\r\n                scale = self.unit._to(unit)\r\n            except Exception:\r\n                # Short-cut failed; try default (maybe equivalencies help).\r\n                value = self._to_value(unit, equivalencies)\r\n            else:\r\n                value = self.view(np.ndarray)\r\n                if not is_effectively_unity(scale):\r\n                    # not in-place!\r\n                    value = value * scale\r\n        else:\r\n            # For structured arrays, we go the default route.\r\n            value = self._to_value(unit, equivalencies)\r\n\r\n        # Index with empty tuple to decay array scalars in to numpy scalars.\r\n        return value if value.shape else value[()]\r\n\r\n    value = property(\r\n        to_value,\r\n        doc=\"\"\"The numerical value of this instance.\r\n\r\n    See also\r\n    --------\r\n    to_value : Get the numerical value in a given unit.\r\n    \"\"\",\r\n    )\r\n\r\n    @property\r\n    def unit(self):\r\n        \"\"\"\r\n        A `~astropy.units.UnitBase` object representing the unit of this\r\n        quantity.\r\n        \"\"\"\r\n        return self._unit\r\n\r\n    @property\r\n    def equivalencies(self):\r\n        \"\"\"\r\n        A list of equivalencies that will be applied by default during\r\n        unit conversions.\r\n        \"\"\"\r\n        return self._equivalencies\r\n\r\n    def _recursively_apply(self, func):\r\n        \"\"\"Apply function recursively to every field.\r\n\r\n        Returns a copy with the result.\r\n        \"\"\"\r\n        result = np.empty_like(self)\r\n        result_value = result.view(np.ndarray)\r\n        result_unit = ()\r\n        for name in self.dtype.names:\r\n            part = func(self[name])\r\n            result_value[name] = part.value\r\n            result_unit += (part.unit,)\r\n\r\n        result._set_unit(result_unit)\r\n        return result\r\n\r\n    @property\r\n    def si(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with SI units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"si\"))\r\n        si_unit = self.unit.si\r\n        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\r\n\r\n    @property\r\n    def cgs(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with CGS units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"cgs\"))\r\n        cgs_unit = self.unit.cgs\r\n        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\r\n\r\n    @property\r\n    def isscalar(self):\r\n        \"\"\"\r\n        True if the `value` of this quantity is a scalar, or False if it\r\n        is an array-like object.\r\n\r\n        .. note::\r\n            This is subtly different from `numpy.isscalar` in that\r\n            `numpy.isscalar` returns False for a zero-dimensional array\r\n            (e.g. ``np.array(1)``), while this is True for quantities,\r\n            since quantities cannot represent true numpy scalars.\r\n        \"\"\"\r\n        return not self.shape\r\n\r\n    # This flag controls whether convenience conversion members, such\r\n    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\r\n    # not turned on on Quantity itself, but is on some subclasses of\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n    _include_easy_conversion_members = False\r\n\r\n    def __dir__(self):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.  This function is implemented in\r\n        order to make autocompletion still work correctly in IPython.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            return super().__dir__()\r\n\r\n        dir_values = set(super().__dir__())\r\n        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\r\n        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\r\n            dir_values.update(equivalent.names)\r\n        return sorted(dir_values)\r\n\r\n    def __getattr__(self, attr):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            raise AttributeError(\r\n                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\r\n            )\r\n\r\n        def get_virtual_unit_attribute():\r\n            registry = get_current_unit_registry().registry\r\n            to_unit = registry.get(attr, None)\r\n            if to_unit is None:\r\n                return None\r\n\r\n            try:\r\n                return self.unit.to(\r\n                    to_unit, self.value, equivalencies=self.equivalencies\r\n                )\r\n            except UnitsError:\r\n                return None\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n"]
[280.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[280.002, "i", "sed -n '1200,2000p' astropy/units/quantity.py\r"]
[280.004, "o", "sed -n '1200,2000p' astropy/units/quantity.py\r\n"]
[280.006, "o", "\u001b[?2004l\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n            # so they should raise a TypeError rather than an IndexError.\r\n            if self.isscalar:\r\n                raise TypeError(\r\n                    f\"'{self.__class__.__name__}' object with a scalar value \"\r\n                    \"does not support indexing\"\r\n                )\r\n            else:\r\n                raise\r\n        # For single elements, ndarray.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if not isinstance(out, np.ndarray):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def __setitem__(self, i, value):\r\n        if isinstance(i, str):\r\n            # Indexing will cause a different unit, so by doing this in\r\n            # two steps we effectively try with the right unit.\r\n            self[i][...] = value\r\n            return\r\n\r\n        # update indices in info if the info property has been accessed\r\n        # (in which case 'info' in self.__dict__ is True; this is guaranteed\r\n        # to be the case if we're part of a table).\r\n        if not self.isscalar and \"info\" in self.__dict__:\r\n            self.info.adjust_indices(i, value, len(self))\r\n        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\r\n\r\n    # __contains__ is OK\r\n\r\n    def __bool__(self):\r\n        \"\"\"This method raises ValueError, since truthiness of quantities is ambiguous,\r\n        especially for logarithmic units and temperatures. Use explicit comparisons.\r\n        \"\"\"\r\n        raise ValueError(\r\n            f\"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units\"\r\n            \" and temperatures. Use explicit comparisons.\"\r\n        )\r\n\r\n    def __len__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\r\n            )\r\n        else:\r\n            return len(self.value)\r\n\r\n    # Numerical types\r\n    def __float__(self):\r\n        try:\r\n            return float(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __int__(self):\r\n        try:\r\n            return int(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __index__(self):\r\n        # for indices, we do not want to mess around with scaling at all,\r\n        # so unlike for float, int, we insist here on unscaled dimensionless\r\n        try:\r\n            assert self.unit.is_unity()\r\n            return self.value.__index__()\r\n        except Exception:\r\n            raise TypeError(\r\n                \"only integer dimensionless scalar quantities \"\r\n                \"can be converted to a Python index\"\r\n            )\r\n\r\n    # TODO: we may want to add a hook for dimensionless quantities?\r\n    @property\r\n    def _unitstr(self):\r\n        if self.unit is None:\r\n            unitstr = _UNIT_NOT_INITIALISED\r\n        else:\r\n            unitstr = str(self.unit)\r\n\r\n        if unitstr:\r\n            unitstr = \" \" + unitstr\r\n\r\n        return unitstr\r\n\r\n    def to_string(\r\n        self, unit=None, precision=None, format=None, subfmt=None, *, formatter=None\r\n    ):\r\n        \"\"\"\r\n        Generate a string representation of the quantity and its unit.\r\n\r\n        The behavior of this function can be altered via the\r\n        `numpy.set_printoptions` function and its various keywords.  The\r\n        exception to this is the ``threshold`` keyword, which is controlled via\r\n        the ``[units.quantity]`` configuration item ``latex_array_threshold``.\r\n        This is treated separately because the numpy default of 1000 is too big\r\n        for most browsers to handle.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            Specifies the unit.  If not provided,\r\n            the unit used to initialize the quantity will be used.\r\n\r\n        precision : number, optional\r\n            The level of decimal precision. If `None`, or not provided,\r\n            it will be determined from NumPy print options.\r\n\r\n        format : str, optional\r\n            The format of the result. If not provided, an unadorned\r\n            string is returned. Supported values are:\r\n\r\n            - 'latex': Return a LaTeX-formatted string\r\n\r\n            - 'latex_inline': Return a LaTeX-formatted string that uses\r\n              negative exponents instead of fractions\r\n\r\n        formatter : str, callable, dict, optional\r\n            The formatter to use for the value. If a string, it should be a\r\n            valid format specifier using Python's mini-language. If a callable,\r\n            it will be treated as the default formatter for all values and will\r\n            overwrite default Latex formatting for exponential notation and complex\r\n            numbers. If a dict, it should map a specific type to a callable to be\r\n            directly passed into `numpy.array2string`. If not provided, the default\r\n            formatter will be used.\r\n\r\n        subfmt : str, optional\r\n            Subformat of the result. For the moment, only used for\r\n            ``format='latex'`` and ``format='latex_inline'``. Supported\r\n            values are:\r\n\r\n            - 'inline': Use ``$ ... $`` as delimiters.\r\n\r\n            - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\r\n\r\n        Returns\r\n        -------\r\n        str\r\n            A string with the contents of this Quantity\r\n        \"\"\"\r\n        if unit is not None and unit != self.unit:\r\n            return self.to(unit).to_string(\r\n                unit=None,\r\n                precision=precision,\r\n                format=format,\r\n                subfmt=subfmt,\r\n                formatter=formatter,\r\n            )\r\n\r\n        if format is None and formatter is None and precision is None:\r\n            # Use default formatting settings\r\n            return f\"{self.value}{self._unitstr:s}\"\r\n\r\n        formats = {\r\n            None: None,\r\n            \"latex\": {\r\n                None: (\"$\", \"$\"),\r\n                \"inline\": (\"$\", \"$\"),\r\n                \"display\": (r\"$\\displaystyle \", r\"$\"),\r\n            },\r\n        }\r\n        formats[\"latex_inline\"] = formats[\"latex\"]\r\n\r\n        if format not in formats:\r\n            raise ValueError(f\"Unknown format '{format}'\")\r\n\r\n        format_spec = formatter if isinstance(formatter, str) else None\r\n\r\n        if format is None:\r\n            if format_spec is not None:\r\n\r\n                def formatter(value):\r\n                    return builtins.format(value, format_spec)\r\n\r\n            if callable(formatter):\r\n                formatter = {\"all\": formatter}\r\n\r\n            return (\r\n                np.array2string(\r\n                    self.value,\r\n                    precision=precision,\r\n                    floatmode=\"fixed\",\r\n                    formatter=formatter,\r\n                )\r\n                + self._unitstr\r\n            )\r\n\r\n        # else, for the moment we assume format=\"latex\" or \"latex_inline\".\r\n\r\n        # Set the precision if set, otherwise use numpy default\r\n        pops = np.get_printoptions()\r\n        if format_spec is None:\r\n            format_spec = (\r\n                f\".{precision if precision is not None else pops['precision']}g\"\r\n            )\r\n\r\n        # Use default formatters\r\n        if formatter is None or isinstance(formatter, str):\r\n            # Filter width and alignment operations for latex\r\n            # [[fill]align][sign][\"z\"][\"#\"][\"0\"][width][grouping_option][\".\" precision][type]\r\n            format_spec = re.sub(\r\n                r\"(.*?)([+\\- ]?)(\\d+)?(,)?(\\.\\d+)?([a-zA-Z%]+)?$\",\r\n                r\"\\2\\5\\6\",\r\n                format_spec,\r\n            )\r\n\r\n            if self.dtype.kind == \"c\":  # Complex default latex formatter\r\n                # Disallow sign operations for the imaginary part\r\n                imag_format_spec = re.sub(r\"[+\\- ]\", \"\", format_spec)\r\n\r\n                def formatter(value):\r\n                    return \"({}{}i)\".format(\r\n                        Latex.format_exponential_notation(\r\n                            value.real, format_spec=format_spec\r\n                        ),\r\n                        Latex.format_exponential_notation(\r\n                            value.imag, format_spec=\"+\" + imag_format_spec\r\n                        ),\r\n                    )\r\n\r\n            else:  # Float default latex formatter\r\n\r\n                def formatter(value):\r\n                    return Latex.format_exponential_notation(\r\n                        value, format_spec=format_spec\r\n                    )\r\n\r\n        if callable(formatter):\r\n            formatter = {\"all\": formatter}\r\n\r\n        # The view is needed for the scalar case - self.value might be float.\r\n        latex_value = np.array2string(\r\n            self.view(np.ndarray),\r\n            threshold=(\r\n                conf.latex_array_threshold\r\n                if conf.latex_array_threshold > -1\r\n                else pops[\"threshold\"]\r\n            ),\r\n            formatter=formatter,\r\n            max_line_width=np.inf,\r\n            separator=\",~\",\r\n        )\r\n\r\n        latex_value = latex_value.replace(\"...\", r\"\\dots\")\r\n\r\n        # Format unit\r\n        # [1:-1] strips the '$' on either side needed for math mode\r\n        if self.unit is None:\r\n            latex_unit = _UNIT_NOT_INITIALISED\r\n        elif format == \"latex\":\r\n            latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\r\n        elif format == \"latex_inline\":\r\n            latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\r\n\r\n        delimiter_left, delimiter_right = formats[format][subfmt]\r\n\r\n        # Add a space in front except for super-script units like degrees.\r\n        if not latex_unit.removeprefix(\"\\\\mathrm{\").startswith(\"{}^\"):\r\n            latex_unit = rf\" \\; {latex_unit}\"\r\n\r\n        return rf\"{delimiter_left}{latex_value}{latex_unit}{delimiter_right}\"\r\n\r\n    def __str__(self):\r\n        return self.to_string()\r\n\r\n    def __repr__(self):\r\n        prefixstr = \"<\" + self.__class__.__name__ + \" \"\r\n        arrstr = np.array2string(\r\n            self.view(np.ndarray), separator=\", \", prefix=prefixstr\r\n        )\r\n        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\r\n\r\n    def _repr_latex_(self):\r\n        \"\"\"\r\n        Generate a latex representation of the quantity and its unit.\r\n\r\n        Returns\r\n        -------\r\n        lstr\r\n            A LaTeX string with the contents of this Quantity\r\n        \"\"\"\r\n        # NOTE: This should change to display format in a future release\r\n        return self.to_string(format=\"latex\", subfmt=\"inline\")\r\n\r\n    def __format__(self, format_spec):\r\n        try:\r\n            return self.to_string(format=format_spec)\r\n        except ValueError:\r\n            # We might have a unit format not implemented in `to_string()`.\r\n            if format_spec in Base.registry:\r\n                if self.unit is dimensionless_unscaled:\r\n                    return f\"{self.value}\"\r\n                else:\r\n                    return f\"{self.value} {format(self.unit, format_spec)}\"\r\n            # Can the value be formatted on its own?\r\n            try:\r\n                return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\r\n            except ValueError:\r\n                # Format the whole thing as a single string.\r\n                return format(f\"{self.value}{self._unitstr:s}\", format_spec)\r\n\r\n    def decompose(self, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units\r\n        decomposed. Decomposed units have only irreducible units in\r\n        them (see `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        bases : sequence of `~astropy.units.UnitBase`, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n        \"\"\"\r\n        return self._decompose(False, bases=bases)\r\n\r\n    def _decompose(self, allowscaledunits=False, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units decomposed. Decomposed\r\n        units have only irreducible units in them (see\r\n        `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        allowscaledunits : bool\r\n            If True, the resulting `Quantity` may have a scale factor\r\n            associated with it.  If False, any scaling in the unit will\r\n            be subsumed into the value of the resulting `Quantity`\r\n\r\n        bases : sequence of UnitBase, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n\r\n        \"\"\"\r\n        new_unit = self.unit.decompose(bases=bases)\r\n\r\n        # Be careful here because self.value usually is a view of self;\r\n        # be sure that the original value is not being modified.\r\n        if not allowscaledunits and hasattr(new_unit, \"scale\"):\r\n            new_value = self.value * new_unit.scale\r\n            new_unit = new_unit / new_unit.scale\r\n            return self._new_view(new_value, new_unit)\r\n        else:\r\n            return self._new_view(self.copy(), new_unit)\r\n\r\n    # These functions need to be overridden to take into account the units\r\n    # Array conversion\r\n    # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\r\n\r\n    def item(self, *args):\r\n        \"\"\"Copy an element of an array to a scalar Quantity and return it.\r\n\r\n        Like :meth:`~numpy.ndarray.item` except that it always\r\n        returns a `Quantity`, not a Python scalar.\r\n\r\n        \"\"\"\r\n        return self._new_view(super().item(*args))\r\n\r\n    def tolist(self):\r\n        raise NotImplementedError(\r\n            \"cannot make a list of Quantities. Get list of values with\"\r\n            \" q.value.tolist().\"\r\n        )\r\n\r\n    def _to_own_unit(self, value, check_precision=True, *, unit=None):\r\n        \"\"\"Convert value to one's own unit (or that given).\r\n\r\n        Here, non-quantities are treated as dimensionless, and care is taken\r\n        for values of 0, infinity or nan, which are allowed to have any unit.\r\n\r\n        Parameters\r\n        ----------\r\n        value : anything convertible to `~astropy.units.Quantity`\r\n            The value to be converted to the requested unit.\r\n        check_precision : bool\r\n            Whether to forbid conversion of float to integer if that changes\r\n            the input number.  Default: `True`.\r\n        unit : `~astropy.units.Unit` or None\r\n            The unit to convert to.  By default, the unit of ``self``.\r\n\r\n        Returns\r\n        -------\r\n        value : number or `~numpy.ndarray`\r\n            In the requested units.\r\n\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        try:\r\n            _value = value.to_value(unit)\r\n        except AttributeError:\r\n            # We're not a Quantity.\r\n            # First remove two special cases (with a fast test):\r\n            # 1) Maybe masked printing? MaskedArray with quantities does not\r\n            # work very well, but no reason to break even repr and str.\r\n            # 2) np.ma.masked? useful if we're a MaskedQuantity.\r\n            if value is np.ma.masked or (\r\n                value is np.ma.masked_print_option and self.dtype.kind == \"O\"\r\n            ):\r\n                return value\r\n            # Now, let's try a more general conversion.\r\n            # Plain arrays will be converted to dimensionless in the process,\r\n            # but anything with a unit attribute will use that.\r\n            try:\r\n                as_quantity = Quantity(value)\r\n                _value = as_quantity.to_value(unit)\r\n            except UnitsError:\r\n                # last chance: if this was not something with a unit\r\n                # and is all 0, inf, or nan, we treat it as arbitrary unit.\r\n                if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\r\n                    as_quantity.value\r\n                ):\r\n                    _value = as_quantity.value\r\n                else:\r\n                    raise\r\n\r\n        if self.dtype.kind == \"i\" and check_precision:\r\n            # If, e.g., we are casting float to int, we want to fail if\r\n            # precision is lost, but let things pass if it works.\r\n            _value = np.array(_value, copy=COPY_IF_NEEDED, subok=True)\r\n            if not np.can_cast(_value.dtype, self.dtype):\r\n                self_dtype_array = np.array(_value, self.dtype, subok=True)\r\n                if not np.all((self_dtype_array == _value) | np.isnan(_value)):\r\n                    raise TypeError(\r\n                        \"cannot convert value type to array type without precision loss\"\r\n                    )\r\n\r\n        # Setting names to ensure things like equality work (note that\r\n        # above will have failed already if units did not match).\r\n        # TODO: is this the best place to do this?\r\n        if _value.dtype.names is not None:\r\n            _value = _value.astype(self.dtype, copy=False)\r\n        return _value\r\n\r\n    if NUMPY_LT_2_0:\r\n\r\n        def itemset(self, *args):\r\n            if len(args) == 0:\r\n                raise ValueError(\"itemset must have at least one argument\")\r\n\r\n            self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\r\n\r\n    def tostring(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tostring()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to string.  Write array with\"\r\n            \" q.value.tostring(...).\"\r\n        )\r\n\r\n    def tobytes(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tobytes()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\r\n        )\r\n\r\n    def tofile(self, fid, sep=\"\", format=\"%s\"):\r\n        \"\"\"Not implemented, use ``.value.tofile()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\r\n        )\r\n\r\n    def dump(self, file):\r\n        \"\"\"Not implemented, use ``.value.dump()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to file.  Write array with q.value.dump()\"\r\n        )\r\n\r\n    def dumps(self):\r\n        \"\"\"Not implemented, use ``.value.dumps()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\r\n        )\r\n\r\n    # astype, byteswap, copy, view, getfield, setflags OK as is\r\n\r\n    def fill(self, value):\r\n        self.view(np.ndarray).fill(self._to_own_unit(value))\r\n\r\n    # Shape manipulation: resize cannot be done (does not own data), but\r\n    # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\r\n    # the flat iterator needs to be overwritten, otherwise single items are\r\n    # returned as numbers.\r\n    @property\r\n    def flat(self):\r\n        \"\"\"A 1-D iterator over the Quantity array.\r\n\r\n        This returns a ``QuantityIterator`` instance, which behaves the same\r\n        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\r\n        and is similar to, but not a subclass of, Python's built-in iterator\r\n        object.\r\n        \"\"\"\r\n        return QuantityIterator(self)\r\n\r\n    @flat.setter\r\n    def flat(self, value):\r\n        y = self.ravel()\r\n        y[:] = value\r\n\r\n    # Item selection and manipulation\r\n    # repeat, sort, compress, diagonal OK\r\n    def take(self, indices, axis=None, out=None, mode=\"raise\"):\r\n        out = super().take(indices, axis=axis, out=out, mode=mode)\r\n        # For single elements, ndarray.take returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if type(out) is not type(self):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def put(self, indices, values, mode=\"raise\"):\r\n        self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\r\n\r\n    def choose(self, choices, out=None, mode=\"raise\"):\r\n        raise NotImplementedError(\r\n            \"cannot choose based on quantity.  Choose using array with\"\r\n            \" q.value.choose(...)\"\r\n        )\r\n\r\n    # ensure we do not return indices as quantities\r\n    if NUMPY_LT_2_0:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None):\r\n            return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\r\n\r\n    else:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None, *, stable=None):\r\n            return self.view(np.ndarray).argsort(\r\n                axis=axis, kind=kind, order=order, stable=stable\r\n            )\r\n\r\n    def searchsorted(self, v, *args, **kwargs):\r\n        return np.searchsorted(\r\n            np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\r\n        )  # avoid numpy 1.6 problem\r\n\r\n    def argmax(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def argmin(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def __array_function__(self, function, types, args, kwargs):\r\n        \"\"\"Wrap numpy functions, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap\r\n        types : iterable of classes\r\n            Classes that provide an ``__array_function__`` override. Can\r\n            in principle be used to interact with other classes. Below,\r\n            mostly passed on to `~numpy.ndarray`, which can only interact\r\n            with subclasses.\r\n        args : tuple\r\n            Positional arguments provided in the function call.\r\n        kwargs : dict\r\n            Keyword arguments provided in the function call.\r\n\r\n        Returns\r\n        -------\r\n        result: `~astropy.units.Quantity`, `~numpy.ndarray`\r\n            As appropriate for the function.  If the function is not\r\n            supported, `NotImplemented` is returned, which will lead to\r\n            a `TypeError` unless another argument overrode the function.\r\n\r\n        Raises\r\n        ------\r\n        ~astropy.units.UnitsError\r\n            If operands have incompatible units.\r\n        \"\"\"\r\n        # A function should be in one of the following sets or dicts:\r\n        # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\r\n        #    supports Quantity; we pass on to ndarray.__array_function__.\r\n        # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\r\n        #    after converting quantities to arrays with suitable units,\r\n        #    and possibly setting units on the result.\r\n        # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\r\n        #    requires a Quantity-specific implementation.\r\n        # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\r\n        # For now, since we may not yet have complete coverage, if a\r\n        # function is in none of the above, we simply call the numpy\r\n        # implementation.\r\n        if function in SUBCLASS_SAFE_FUNCTIONS:\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        elif function in FUNCTION_HELPERS:\r\n            function_helper = FUNCTION_HELPERS[function]\r\n            try:\r\n                args, kwargs, unit, out = function_helper(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            result = super().__array_function__(function, types, args, kwargs)\r\n            # Fall through to return section\r\n\r\n        elif function in DISPATCHED_FUNCTIONS:\r\n            dispatched_function = DISPATCHED_FUNCTIONS[function]\r\n            try:\r\n                result, unit, out = dispatched_function(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            # Fall through to return section\r\n\r\n        elif function in UNSUPPORTED_FUNCTIONS:\r\n            return NotImplemented\r\n\r\n        else:\r\n            warnings.warn(\r\n                f\"function '{function.__name__}' is not known to astropy's Quantity.\"\r\n                \" Will run it anyway, hoping it will treat ndarray subclasses\"\r\n                \" correctly. Please raise an issue at\"\r\n                \" https://github.com/astropy/astropy/issues.\",\r\n                AstropyWarning,\r\n            )\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        # If unit is None, a plain array is expected (e.g., boolean), which\r\n        # means we're done.\r\n        # We're also done if the result was NotImplemented, which can happen\r\n        # if other inputs/outputs override __array_function__;\r\n        # hopefully, they can then deal with us.\r\n        if unit is None or result is NotImplemented:\r\n            return result\r\n\r\n        return self._result_as_quantity(result, unit, out=out)\r\n\r\n    def _not_implemented_or_raise(self, function, types):\r\n        # Our function helper or dispatcher found that the function does not\r\n        # work with Quantity.  In principle, there may be another class that\r\n        # knows what to do with us, for which we should return NotImplemented.\r\n        # But if there is ndarray (or a non-Quantity subclass of it) around,\r\n        # it quite likely coerces, so we should just break.\r\n        if any(\r\n            issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\r\n        ):\r\n            raise TypeError(\r\n                f\"the Quantity implementation cannot handle {function} \"\r\n                \"with the given arguments.\"\r\n            ) from None\r\n        else:\r\n            return NotImplemented\r\n\r\n    # Calculation -- override ndarray methods to take into account units.\r\n    # We use the corresponding numpy functions to evaluate the results, since\r\n    # the methods do not always allow calling with keyword arguments.\r\n    # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\r\n    # TypeError: 'a_max' is an invalid keyword argument for this function.\r\n    def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\r\n        \"\"\"Wrap a numpy function that processes self, returning a Quantity.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap.\r\n        args : positional arguments\r\n            Any positional arguments to the function beyond the first argument\r\n            (which will be set to ``self``).\r\n        kwargs : keyword arguments\r\n            Keyword arguments to the function.\r\n\r\n        If present, the following arguments are treated specially:\r\n\r\n        unit : `~astropy.units.Unit`\r\n            Unit of the output result.  If not given, the unit of ``self``.\r\n        out : `~astropy.units.Quantity`\r\n            A Quantity instance in which to store the output.\r\n\r\n        Notes\r\n        -----\r\n        Output should always be assigned via a keyword argument, otherwise\r\n        no proper account of the unit is taken.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            Result of the function call, with the unit set properly.\r\n        \"\"\"\r\n        if unit is None:\r\n"]
[285.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[285.002, "i", "cat asv.ci.conf.json\r"]
[285.004, "o", "cat asv.ci.conf.json\r\n"]
[285.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[290.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[290.002, "i", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r"]
[290.004, "o", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r\n"]
[290.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[295.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[295.002, "i", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r"]
[295.004, "o", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r\n"]
[295.006, "o", "_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\"\r\n\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: argument {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages}: invalid choice: 'dev' (choose from 'help', 'quickstart', 'machine', 'setup', 'run', 'continuous', 'find', 'rm', 'publish', 'preview', 'profile', 'update', 'show', 'compare', 'check', 'gh-pages')\r\n"]
[300.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[300.002, "i", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r"]
[300.004, "o", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[300.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[305.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[305.002, "i", "grep -n \"class Quantity\" -n astropy/units/quantity.py\r"]
[305.004, "o", "grep -n \"class Quantity\" -n astropy/units/quantity.py\r\n"]
[305.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K85\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Quantity\u001b[m\u001b[KIterator:\r\n\u001b[32m\u001b[K162\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Quantity\u001b[m\u001b[KInfoBase(ParentDtypeInfo):\r\n\u001b[32m\u001b[K188\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Quantity\u001b[m\u001b[KInfo(QuantityInfoBase):\r\n\u001b[32m\u001b[K264\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Quantity\u001b[m\u001b[K(np.ndarray):\r\n"]
[310.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[310.002, "i", "grep -n \"def __new__\" astropy/units/quantity.py\r"]
[310.004, "o", "grep -n \"def __new__\" astropy/units/quantity.py\r\n"]
[310.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K426\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __new__\u001b[m\u001b[K(\r\n"]
[315.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[315.002, "i", "grep -n \"def __mul__\" astropy/units/quantity.py\r"]
[315.004, "o", "grep -n \"def __mul__\" astropy/units/quantity.py\r\n"]
[315.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K1209\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __mul__\u001b[m\u001b[K(self, other):\r\n"]
[320.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[320.002, "i", "sed -n '1,400p' astropy/units/quantity.py\r"]
[320.004, "o", "sed -n '1,400p' astropy/units/quantity.py\r\n"]
[320.006, "o", "\u001b[?2004l\r\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\r\n\"\"\"\r\nThis module defines the `Quantity` object, which represents a number with some\r\nassociated units. `Quantity` objects support operations like ordinary numbers,\r\nbut will deal with unit conversions internally.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport builtins\r\nimport numbers\r\nimport operator\r\nimport re\r\nimport warnings\r\nfrom fractions import Fraction\r\nfrom typing import TYPE_CHECKING\r\n\r\nimport numpy as np\r\n\r\nfrom astropy import config as _config\r\nfrom astropy.utils.compat.numpycompat import COPY_IF_NEEDED, NUMPY_LT_2_0\r\nfrom astropy.utils.data_info import ParentDtypeInfo\r\nfrom astropy.utils.exceptions import AstropyWarning\r\n\r\nfrom .core import (\r\n    Unit,\r\n    UnitBase,\r\n    UnitConversionError,\r\n    UnitsError,\r\n    UnitTypeError,\r\n    dimensionless_unscaled,\r\n    get_current_unit_registry,\r\n)\r\nfrom .format import Base, Latex\r\nfrom .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\r\nfrom .quantity_helper.function_helpers import (\r\n    DISPATCHED_FUNCTIONS,\r\n    FUNCTION_HELPERS,\r\n    SUBCLASS_SAFE_FUNCTIONS,\r\n    UNSUPPORTED_FUNCTIONS,\r\n)\r\nfrom .structured import StructuredUnit, _structured_unit_like_dtype\r\nfrom .utils import is_effectively_unity\r\n\r\nif TYPE_CHECKING:\r\n    from typing_extensions import Self\r\n\r\n    from .typing import QuantityLike\r\n\r\n__all__ = [\r\n    \"Quantity\",\r\n    \"SpecificTypeQuantity\",\r\n    \"QuantityInfoBase\",\r\n    \"QuantityInfo\",\r\n    \"allclose\",\r\n    \"isclose\",\r\n]\r\n\r\n\r\n# We don't want to run doctests in the docstrings we inherit from Numpy\r\n__doctest_skip__ = [\"Quantity.*\"]\r\n\r\n_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\r\n_UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\r\n\r\n\r\nclass Conf(_config.ConfigNamespace):\r\n    \"\"\"\r\n    Configuration parameters for Quantity.\r\n    \"\"\"\r\n\r\n    latex_array_threshold = _config.ConfigItem(\r\n        100,\r\n        \"The maximum size an array Quantity can be before its LaTeX \"\r\n        'representation for IPython gets \"summarized\" (meaning only the first '\r\n        'and last few elements are shown with \"...\" between). Setting this to a '\r\n        \"negative number means that the value will instead be whatever numpy \"\r\n        \"gets from get_printoptions.\",\r\n    )\r\n\r\n\r\nconf = Conf()\r\n\r\n\r\nclass QuantityIterator:\r\n    \"\"\"\r\n    Flat iterator object to iterate over Quantities.\r\n\r\n    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\r\n    ``q``.  It allows iterating over the array as if it were a 1-D array,\r\n    either in a for-loop or by calling its `next` method.\r\n\r\n    Iteration is done in C-contiguous style, with the last index varying the\r\n    fastest. The iterator can also be indexed using basic slicing or\r\n    advanced indexing.\r\n\r\n    See Also\r\n    --------\r\n    Quantity.flatten : Returns a flattened copy of an array.\r\n\r\n    Notes\r\n    -----\r\n    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\r\n    is not exported by the `~astropy.units` module.  Instead of\r\n    instantiating a `QuantityIterator` directly, use `Quantity.flat`.\r\n    \"\"\"\r\n\r\n    def __init__(self, q):\r\n        self._quantity = q\r\n        self._dataiter = q.view(np.ndarray).flat\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __getitem__(self, indx):\r\n        out = self._dataiter.__getitem__(indx)\r\n        # For single elements, ndarray.flat.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if isinstance(out, type(self._quantity)):\r\n            return out\r\n        else:\r\n            return self._quantity._new_view(out)\r\n\r\n    def __setitem__(self, index, value):\r\n        self._dataiter[index] = self._quantity._to_own_unit(value)\r\n\r\n    def __next__(self):\r\n        \"\"\"\r\n        Return the next value, or raise StopIteration.\r\n        \"\"\"\r\n        out = next(self._dataiter)\r\n        # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\r\n        return self._quantity._new_view(out)\r\n\r\n    next = __next__\r\n\r\n    def __len__(self):\r\n        return len(self._dataiter)\r\n\r\n    # Properties and methods to match `numpy.ndarray.flatiter`\r\n\r\n    @property\r\n    def base(self):\r\n        \"\"\"A reference to the array that is iterated over.\"\"\"\r\n        return self._quantity\r\n\r\n    @property\r\n    def coords(self):\r\n        \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\r\n        return self._dataiter.coords\r\n\r\n    @property\r\n    def index(self):\r\n        \"\"\"Current flat index into the array.\"\"\"\r\n        return self._dataiter.index\r\n\r\n    def copy(self):\r\n        \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\r\n        return self._quantity.flatten()\r\n\r\n\r\nclass QuantityInfoBase(ParentDtypeInfo):\r\n    # This is on a base class rather than QuantityInfo directly, so that\r\n    # it can be used for EarthLocationInfo yet make clear that that class\r\n    # should not be considered a typical Quantity subclass by Table.\r\n    attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\r\n    _supports_indexing = True\r\n\r\n    @staticmethod\r\n    def default_format(val):\r\n        return f\"{val.value}\"\r\n\r\n    @staticmethod\r\n    def possible_string_format_functions(format_):\r\n        \"\"\"Iterate through possible string-derived format functions.\r\n\r\n        A string can either be a format specifier for the format built-in,\r\n        a new-style format string, or an old-style format string.\r\n\r\n        This method is overridden in order to suppress printing the unit\r\n        in each row since it is already at the top in the column header.\r\n        \"\"\"\r\n        yield lambda format_, val: format(val.value, format_)\r\n        yield lambda format_, val: format_.format(val.value)\r\n        yield lambda format_, val: format_ % val.value\r\n\r\n\r\nclass QuantityInfo(QuantityInfoBase):\r\n    \"\"\"\r\n    Container for meta information like name, description, format.  This is\r\n    required when the object is used as a mixin column within a table, but can\r\n    be used as a general way to store meta information.\r\n    \"\"\"\r\n\r\n    _represent_as_dict_attrs = (\"value\", \"unit\")\r\n    _construct_from_dict_args = [\"value\"]\r\n    _represent_as_dict_primary_data = \"value\"\r\n\r\n    def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\r\n        \"\"\"\r\n        Return a new Quantity instance which is consistent with the\r\n        input ``cols`` and has ``length`` rows.\r\n\r\n        This is intended for creating an empty column object whose elements can\r\n        be set in-place for table operations like join or vstack.\r\n\r\n        Parameters\r\n        ----------\r\n        cols : list\r\n            List of input columns\r\n        length : int\r\n            Length of the output column object\r\n        metadata_conflicts : str ('warn'|'error'|'silent')\r\n            How to handle metadata conflicts\r\n        name : str\r\n            Output column name\r\n\r\n        Returns\r\n        -------\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n            Empty instance of this class consistent with ``cols``\r\n\r\n        \"\"\"\r\n        # Get merged info attributes like shape, dtype, format, description, etc.\r\n        attrs = self.merge_cols_attributes(\r\n            cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\r\n        )\r\n\r\n        # Make an empty quantity using the unit of the last one.\r\n        shape = (length,) + attrs.pop(\"shape\")\r\n        dtype = attrs.pop(\"dtype\")\r\n        # Use zeros so we do not get problems for Quantity subclasses such\r\n        # as Longitude and Latitude, which cannot take arbitrary values.\r\n        data = np.zeros(shape=shape, dtype=dtype)\r\n        # Get arguments needed to reconstruct class\r\n        map = {\r\n            key: (data if key == \"value\" else getattr(cols[-1], key))\r\n            for key in self._represent_as_dict_attrs\r\n        }\r\n        map[\"copy\"] = COPY_IF_NEEDED\r\n        out = self._construct_from_dict(map)\r\n\r\n        # Set remaining info attributes\r\n        for attr, value in attrs.items():\r\n            setattr(out.info, attr, value)\r\n\r\n        return out\r\n\r\n    def get_sortable_arrays(self):\r\n        \"\"\"\r\n        Return a list of arrays which can be lexically sorted to represent\r\n        the order of the parent column.\r\n\r\n        For Quantity this is just the quantity itself.\r\n\r\n\r\n        Returns\r\n        -------\r\n        arrays : list of ndarray\r\n        \"\"\"\r\n        return [self._parent]\r\n\r\n\r\nclass Quantity(np.ndarray):\r\n    \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\r\n\r\n    See also: https://docs.astropy.org/en/stable/units/quantity.html\r\n\r\n    Parameters\r\n    ----------\r\n    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\r\n        The numerical value of this quantity in the units given by unit.  If a\r\n        `Quantity` or sequence of them (or any other valid object with a\r\n        ``unit`` attribute), creates a new `Quantity` object, converting to\r\n        `unit` units as needed.  If a string, it is converted to a number or\r\n        `Quantity`, depending on whether a unit is present.\r\n\r\n    unit : unit-like\r\n        An object that represents the unit associated with the input value.\r\n        Must be an `~astropy.units.UnitBase` object or a string parseable by\r\n        the :mod:`~astropy.units` package.\r\n\r\n    dtype : ~numpy.dtype, optional\r\n        The dtype of the resulting Numpy array or scalar that will\r\n        hold the value.  If not provided, it is determined from the input,\r\n        except that any integer and (non-Quantity) object inputs are converted\r\n        to float by default.\r\n        If `None`, the normal `numpy.dtype` introspection is used, e.g.\r\n        preventing upcasting of integers.\r\n\r\n    copy : bool, optional\r\n        If `True` (default), then the value is copied.  Otherwise, a copy will\r\n        only be made if ``__array__`` returns a copy, if value is a nested\r\n        sequence, or if a copy is needed to satisfy an explicitly given\r\n        ``dtype``.  (The `False` option is intended mostly for internal use,\r\n        to speed up initialization where a copy is known to have been made.\r\n        Use with care.)\r\n\r\n    order : {'C', 'F', 'A'}, optional\r\n        Specify the order of the array.  As in `~numpy.array`.  This parameter\r\n        is ignored if the input is a `Quantity` and ``copy=False``.\r\n\r\n    subok : bool, optional\r\n        If `False` (default), the returned array will be forced to be a\r\n        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\r\n        or a subclass appropriate for the unit will be used (such as\r\n        `~astropy.units.Dex` for ``u.dex(u.AA)``).\r\n\r\n    ndmin : int, optional\r\n        Specifies the minimum number of dimensions that the resulting array\r\n        should have.  Ones will be prepended to the shape as needed to meet\r\n        this requirement.  This parameter is ignored if the input is a\r\n        `Quantity` and ``copy=False``.\r\n\r\n    Raises\r\n    ------\r\n    TypeError\r\n        If the value provided is not a Python numeric type.\r\n    TypeError\r\n        If the unit provided is not either a :class:`~astropy.units.Unit`\r\n        object or a parseable string unit.\r\n\r\n    Notes\r\n    -----\r\n    Quantities can also be created by multiplying a number or array with a\r\n    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\r\n\r\n    Unless the ``dtype`` argument is explicitly specified, integer\r\n    or (non-Quantity) object inputs are converted to `float` by default.\r\n    \"\"\"\r\n\r\n    # Need to set a class-level default for _equivalencies, or\r\n    # Constants can not initialize properly\r\n    _equivalencies = []\r\n\r\n    # Default unit for initialization; can be overridden by subclasses,\r\n    # possibly to `None` to indicate there is no default unit.\r\n    _default_unit = dimensionless_unscaled\r\n\r\n    # Ensures views have an undefined unit.\r\n    _unit = None\r\n\r\n    __array_priority__ = 10000\r\n\r\n    def __class_getitem__(cls, unit_shape_dtype):\r\n        \"\"\"Quantity Type Hints.\r\n\r\n        Unit-aware type hints are ``Annotated`` objects that encode the class,\r\n        the unit, and possibly shape and dtype information, depending on the\r\n        python and :mod:`numpy` versions.\r\n\r\n        Schematically, ``Annotated[cls[shape, dtype], unit]``\r\n\r\n        As a classmethod, the type is the class, ie ``Quantity``\r\n        produces an ``Annotated[Quantity, ...]`` while a subclass\r\n        like :class:`~astropy.coordinates.Angle` returns\r\n        ``Annotated[Angle, ...]``.\r\n\r\n        Parameters\r\n        ----------\r\n        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\r\n            Unit specification, can be the physical type (ie str or class).\r\n            If tuple, then the first element is the unit specification\r\n            and all other elements are for `numpy.ndarray` type annotations.\r\n            Whether they are included depends on the python and :mod:`numpy`\r\n            versions.\r\n\r\n        Returns\r\n        -------\r\n        `typing.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\r\n            Return type in this preference order:\r\n            * `typing.Annotated`\r\n            * `astropy.units.Unit` or `astropy.units.PhysicalType`\r\n\r\n        Raises\r\n        ------\r\n        TypeError\r\n            If the unit/physical_type annotation is not Unit-like or\r\n            PhysicalType-like.\r\n\r\n        Examples\r\n        --------\r\n        Create a unit-aware Quantity type annotation\r\n\r\n            >>> Quantity[Unit(\"s\")]\r\n            Annotated[Quantity, Unit(\"s\")]\r\n\r\n        See Also\r\n        --------\r\n        `~astropy.units.quantity_input`\r\n            Use annotations for unit checks on function arguments and results.\r\n\r\n        Notes\r\n        -----\r\n        |Quantity| types are also static-type compatible.\r\n        \"\"\"\r\n        from typing import Annotated\r\n\r\n        # process whether [unit] or [unit, shape, ptype]\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n"]
[325.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[325.002, "i", "sed -n '400,1200p' astropy/units/quantity.py\r"]
[325.004, "o", "sed -n '400,1200p' astropy/units/quantity.py\r\n"]
[325.006, "o", "\u001b[?2004l\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n            target = unit_shape_dtype[0]\r\n            shape_dtype = unit_shape_dtype[1:]\r\n        else:  # just unit\r\n            target = unit_shape_dtype\r\n            shape_dtype = ()\r\n\r\n        # Allowed unit/physical types. Errors if neither.\r\n        try:\r\n            unit = Unit(target)\r\n        except (TypeError, ValueError):\r\n            from astropy.units.physical import get_physical_type\r\n\r\n            try:\r\n                unit = get_physical_type(target)\r\n            except (TypeError, ValueError, KeyError):  # KeyError for Enum\r\n                raise TypeError(\r\n                    \"unit annotation is not a Unit or PhysicalType\"\r\n                ) from None\r\n\r\n        # Quantity does not (yet) properly extend the NumPy generics types,\r\n        # introduced in numpy v1.22+, instead just including the unit info as\r\n        # metadata using Annotated.\r\n        # TODO: ensure we do interact with NDArray.__class_getitem__.\r\n        return Annotated[cls, unit]\r\n\r\n    def __new__(\r\n        cls: type[Self],\r\n        value: QuantityLike,\r\n        unit=None,\r\n        dtype=np.inexact,\r\n        copy=True,\r\n        order=None,\r\n        subok=False,\r\n        ndmin=0,\r\n    ) -> Self:\r\n        if unit is not None:\r\n            # convert unit first, to avoid multiple string->unit conversions\r\n            unit = Unit(unit)\r\n\r\n        # inexact -> upcast to float dtype\r\n        float_default = dtype is np.inexact\r\n        if float_default:\r\n            dtype = None\r\n\r\n        # optimize speed for Quantity with no dtype given, copy=COPY_IF_NEEDED\r\n        if isinstance(value, Quantity):\r\n            if unit is not None and unit is not value.unit:\r\n                value = value.to(unit)\r\n                # the above already makes a copy (with float dtype)\r\n                copy = COPY_IF_NEEDED\r\n\r\n            if type(value) is not cls and not (subok and isinstance(value, cls)):\r\n                value = value.view(cls)\r\n\r\n            if float_default and value.dtype.kind in \"iu\":\r\n                dtype = float\r\n\r\n            return np.array(\r\n                value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n            )\r\n\r\n        # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\r\n        # To ensure array remains fast, we short-circuit it.\r\n        value_unit = None\r\n        if not isinstance(value, np.ndarray):\r\n            if isinstance(value, str):\r\n                # The first part of the regex string matches any integer/float;\r\n                # the second parts adds possible trailing .+-, which will break\r\n                # the float function below and ensure things like 1.2.3deg\r\n                # will not work.\r\n                pattern = (\r\n                    r\"\\s*[+-]?\"\r\n                    r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\r\n                    r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\r\n                    r\"([eE][+-]?\\d+)?\"\r\n                    r\"[.+-]?\"\r\n                )\r\n\r\n                v = re.match(pattern, value)\r\n                unit_string = None\r\n                try:\r\n                    value = float(v.group())\r\n\r\n                except Exception:\r\n                    raise TypeError(\r\n                        f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\r\n                        \"start with a number.\"\r\n                    )\r\n\r\n                unit_string = v.string[v.end() :].strip()\r\n                if unit_string:\r\n                    value_unit = Unit(unit_string)\r\n                    if unit is None:\r\n                        unit = value_unit  # signal no conversion needed below.\r\n\r\n            elif isinstance(value, (list, tuple)) and len(value) > 0:\r\n                if all(isinstance(v, Quantity) for v in value):\r\n                    # If a list/tuple contains only quantities, stack them,\r\n                    # which also converts them to the same unit.\r\n                    value = np.stack(value)\r\n                    copy = False\r\n\r\n                elif (\r\n                    dtype is None\r\n                    and not hasattr(value, \"dtype\")\r\n                    and isinstance(unit, StructuredUnit)\r\n                ):\r\n                    # Special case for list/tuple of values and a structured unit:\r\n                    # ``np.array(value, dtype=None)`` would treat tuples as lower\r\n                    # levels of the array, rather than as elements of a structured\r\n                    # array, so we use the structure of the unit to help infer the\r\n                    # structured dtype of the value.\r\n                    dtype = unit._recursively_get_dtype(value)\r\n\r\n        using_default_unit = False\r\n        if value_unit is None:\r\n            # If the value has a `unit` attribute and if not None\r\n            # (for Columns with uninitialized unit), treat it like a quantity.\r\n            value_unit = getattr(value, \"unit\", None)\r\n            if value_unit is None:\r\n                # Default to dimensionless for no (initialized) unit attribute.\r\n                if unit is None:\r\n                    using_default_unit = True\r\n                    unit = cls._default_unit\r\n                value_unit = unit  # signal below that no conversion is needed\r\n            else:\r\n                try:\r\n                    value_unit = Unit(value_unit)\r\n                except Exception as exc:\r\n                    raise TypeError(\r\n                        f\"The unit attribute {value.unit!r} of the input could \"\r\n                        \"not be parsed as an astropy Unit.\"\r\n                    ) from exc\r\n\r\n                if unit is None:\r\n                    unit = value_unit\r\n                elif unit is not value_unit:\r\n                    copy = COPY_IF_NEEDED  # copy will be made in conversion at end\r\n\r\n        value = np.array(\r\n            value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n        )\r\n\r\n        # For no-user-input unit, make sure the constructed unit matches the\r\n        # structure of the data.\r\n        if using_default_unit and value.dtype.names is not None:\r\n            unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\r\n\r\n        # check that array contains numbers or long int objects\r\n        if value.dtype.kind in \"OSU\" and not (\r\n            value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\r\n        ):\r\n            raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\r\n\r\n        # by default, cast any integer, boolean, etc., to float\r\n        if float_default and value.dtype.kind in \"iuO\":\r\n            value = value.astype(float)\r\n\r\n        # if we allow subclasses, allow a class from the unit.\r\n        if subok:\r\n            qcls = getattr(unit, \"_quantity_class\", cls)\r\n            if issubclass(qcls, cls):\r\n                cls = qcls\r\n\r\n        value = value.view(cls)\r\n        value._set_unit(value_unit)\r\n        if unit is value_unit:\r\n            return value\r\n        else:\r\n            # here we had non-Quantity input that had a \"unit\" attribute\r\n            # with a unit different from the desired one.  So, convert.\r\n            return value.to(unit)\r\n\r\n    def __array_finalize__(self, obj):\r\n        # Check whether super().__array_finalize should be called\r\n        # (sadly, ndarray.__array_finalize__ is None; we cannot be sure\r\n        # what is above us).\r\n        super_array_finalize = super().__array_finalize__\r\n        if super_array_finalize is not None:\r\n            super_array_finalize(obj)\r\n\r\n        # If we're a new object or viewing an ndarray, nothing has to be done.\r\n        if obj is None or obj.__class__ is np.ndarray:\r\n            return\r\n\r\n        # Copy over the unit and possibly info.  Note that the only way the\r\n        # unit can already be set is if one enters via _new_view(), where the\r\n        # unit is often different from that of self, and where propagation of\r\n        # info is not always desirable.\r\n        if self._unit is None:\r\n            unit = getattr(obj, \"_unit\", None)\r\n            if unit is not None:\r\n                self._set_unit(unit)\r\n\r\n            # Copy info if the original had `info` defined.  Because of the way the\r\n            # DataInfo works, `'info' in obj.__dict__` is False until the\r\n            # `info` attribute is accessed or set.\r\n            if \"info\" in obj.__dict__:\r\n                self.info = obj.info\r\n\r\n    def __array_wrap__(self, obj, context=None, return_scalar=False):\r\n        if context is None:\r\n            # Methods like .squeeze() created a new `ndarray` and then call\r\n            # __array_wrap__ to turn the array into self's subclass.\r\n            return self._new_view(obj)\r\n\r\n        raise NotImplementedError(\r\n            \"__array_wrap__ should not be used with a context any more since all \"\r\n            \"use should go through array_function. Please raise an issue on \"\r\n            \"https://github.com/astropy/astropy\"\r\n        )\r\n\r\n    def __array_ufunc__(self, function, method, *inputs, **kwargs):\r\n        \"\"\"Wrap numpy ufuncs, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            ufunc to wrap.\r\n        method : str\r\n            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\r\n        inputs : tuple\r\n            Input arrays.\r\n        kwargs : keyword arguments\r\n            As passed on, with ``out`` containing possible quantity output.\r\n\r\n        Returns\r\n        -------\r\n        result : `~astropy.units.Quantity` or `NotImplemented`\r\n            Results of the ufunc, with the unit set properly.\r\n        \"\"\"\r\n        # Determine required conversion functions -- to bring the unit of the\r\n        # input to that expected (e.g., radian for np.sin), or to get\r\n        # consistent units between two inputs (e.g., in np.add) --\r\n        # and the unit of the result (or tuple of units for nout > 1).\r\n        try:\r\n            converters, unit = converters_and_unit(function, method, *inputs)\r\n\r\n            out = kwargs.get(\"out\", None)\r\n            # Avoid loop back by turning any Quantity output into array views.\r\n            if out is not None:\r\n                # If pre-allocated output is used, check it is suitable.\r\n                # This also returns array view, to ensure we don't loop back.\r\n                if function.nout == 1:\r\n                    out = out[0]\r\n                out_array = check_output(out, unit, inputs, function=function)\r\n                # Ensure output argument remains a tuple.\r\n                kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\r\n\r\n            if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\r\n                # Special-case for initial argument for reductions like\r\n                # np.add.reduce.  This should be converted to the output unit as\r\n                # well, which is typically the same as the input unit (but can\r\n                # in principle be different: unitless for np.equal, radian\r\n                # for np.arctan2, though those are not necessarily useful!)\r\n                kwargs[\"initial\"] = self._to_own_unit(\r\n                    kwargs[\"initial\"], check_precision=False, unit=unit\r\n                )\r\n\r\n            # Same for inputs, but here also convert if necessary.\r\n            arrays = []\r\n            for input_, converter in zip(inputs, converters):\r\n                input_ = getattr(input_, \"value\", input_)\r\n                arrays.append(converter(input_) if converter else input_)\r\n\r\n            # Call our superclass's __array_ufunc__\r\n            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\r\n            # If unit is None, a plain array is expected (e.g., comparisons), which\r\n            # means we're done.\r\n            # We're also done if the result was None (for method 'at') or\r\n            # NotImplemented, which can happen if other inputs/outputs override\r\n            # __array_ufunc__; hopefully, they can then deal with us.\r\n            if unit is None or result is None or result is NotImplemented:\r\n                return result\r\n\r\n            return self._result_as_quantity(result, unit, out)\r\n\r\n        except (TypeError, ValueError, AttributeError) as e:\r\n            out_normalized = kwargs.get(\"out\", ())\r\n            inputs_and_outputs = inputs + out_normalized\r\n            ignored_ufunc = (\r\n                None,\r\n                np.ndarray.__array_ufunc__,\r\n                type(self).__array_ufunc__,\r\n            )\r\n            if not all(\r\n                getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\r\n                for io in inputs_and_outputs\r\n            ):\r\n                return NotImplemented\r\n            else:\r\n                raise e\r\n\r\n    def _result_as_quantity(self, result, unit, out):\r\n        \"\"\"Turn result into a quantity with the given unit.\r\n\r\n        If no output is given, it will take a view of the array as a quantity,\r\n        and set the unit.  If output is given, those should be quantity views\r\n        of the result arrays, and the function will just set the unit.\r\n\r\n        Parameters\r\n        ----------\r\n        result : ndarray or tuple thereof\r\n            Array(s) which need to be turned into quantity.\r\n        unit : `~astropy.units.Unit`\r\n            Unit for the quantities to be returned (or `None` if the result\r\n            should not be a quantity).  Should be tuple if result is a tuple.\r\n        out : `~astropy.units.Quantity` or None\r\n            Possible output quantity. Should be `None` or a tuple if result\r\n            is a tuple.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n           With units set.\r\n        \"\"\"\r\n        if isinstance(result, (tuple, list)):\r\n            if out is None:\r\n                out = (None,) * len(result)\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n        # ``obj.__class is np.ndarray``. So, not worth special-casing.\r\n        if obj is None:\r\n            obj = self.view(np.ndarray)\r\n        else:\r\n            obj = np.array(obj, copy=COPY_IF_NEEDED, subok=True)\r\n\r\n        # Take the view, set the unit, and update possible other properties\r\n        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\r\n        view = obj.view(quantity_subclass)\r\n        view._set_unit(unit)\r\n        view.__array_finalize__(self)\r\n        if propagate_info and \"info\" in self.__dict__:\r\n            view.info = self.info\r\n        return view\r\n\r\n    def _set_unit(self, unit):\r\n        \"\"\"Set the unit.\r\n\r\n        This is used anywhere the unit is set or modified, i.e., in the\r\n        initializer, in ``__imul__`` and ``__itruediv__`` for in-place\r\n        multiplication and division by another unit, as well as in\r\n        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\r\n        sets the unit, but subclasses can override it to check that, e.g.,\r\n        a unit is consistent.\r\n        \"\"\"\r\n        if not isinstance(unit, UnitBase):\r\n            if isinstance(self._unit, StructuredUnit) or isinstance(\r\n                unit, StructuredUnit\r\n            ):\r\n                unit = StructuredUnit(unit, self.dtype)\r\n            else:\r\n                # Trying to go through a string ensures that, e.g., Magnitudes with\r\n                # dimensionless physical unit become Quantity with units of mag.\r\n                unit = Unit(str(unit), parse_strict=\"silent\")\r\n                if not isinstance(unit, (UnitBase, StructuredUnit)):\r\n                    raise UnitTypeError(\r\n                        f\"{self.__class__.__name__} instances require normal units, \"\r\n                        f\"not {unit.__class__} instances.\"\r\n                    )\r\n\r\n        self._unit = unit\r\n\r\n    def __deepcopy__(self, memo):\r\n        # If we don't define this, ``copy.deepcopy(quantity)`` will\r\n        # return a bare Numpy array.\r\n        return self.copy()\r\n\r\n    def __reduce__(self):\r\n        # patch to pickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        object_state = list(super().__reduce__())\r\n        object_state[2] = (object_state[2], self.__dict__)\r\n        return tuple(object_state)\r\n\r\n    def __setstate__(self, state):\r\n        # patch to unpickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        nd_state, own_state = state\r\n        super().__setstate__(nd_state)\r\n        self.__dict__.update(own_state)\r\n\r\n    info = QuantityInfo()\r\n\r\n    def _to_value(self, unit, equivalencies=[]):\r\n        \"\"\"Helper method for to and to_value.\"\"\"\r\n        if equivalencies == []:\r\n            equivalencies = self._equivalencies\r\n        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\r\n            # Standard path, let unit to do work.\r\n            return self.unit.to(\r\n                unit, self.view(np.ndarray), equivalencies=equivalencies\r\n            )\r\n\r\n        else:\r\n            # The .to() method of a simple unit cannot convert a structured\r\n            # dtype, so we work around it, by recursing.\r\n            # TODO: deprecate this?\r\n            # Convert simple to Structured on initialization?\r\n            result = np.empty_like(self.view(np.ndarray))\r\n            for name in self.dtype.names:\r\n                result[name] = self[name]._to_value(unit, equivalencies)\r\n            return result\r\n\r\n    def to(self, unit, equivalencies=[], copy=True):\r\n        \"\"\"\r\n        Return a new `~astropy.units.Quantity` object with the specified unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like\r\n            An object that represents the unit to convert to. Must be\r\n            an `~astropy.units.UnitBase` object or a string parseable\r\n            by the `~astropy.units` package.\r\n\r\n        equivalencies : list of tuple\r\n            A list of equivalence pairs to try if the units are not\r\n            directly convertible.  See :ref:`astropy:unit_equivalencies`.\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n            (none for `~astropy.units.Quantity`, but may be set for subclasses)\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        copy : bool, optional\r\n            If `True` (default), then the value is copied.  Otherwise, a copy\r\n            will only be made if necessary.\r\n\r\n        See Also\r\n        --------\r\n        to_value : get the numerical value in a given unit.\r\n        \"\"\"\r\n        # We don't use `to_value` below since we always want to make a copy\r\n        # and don't want to slow down this method (esp. the scalar case).\r\n        unit = Unit(unit)\r\n        if copy:\r\n            # Avoid using to_value to ensure that we make a copy. We also\r\n            # don't want to slow down this method (esp. the scalar case).\r\n            value = self._to_value(unit, equivalencies)\r\n        else:\r\n            # to_value only copies if necessary\r\n            value = self.to_value(unit, equivalencies)\r\n        return self._new_view(value, unit)\r\n\r\n    def to_value(self, unit=None, equivalencies=[]):\r\n        \"\"\"\r\n        The numerical value, possibly in a different unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            The unit in which the value should be given. If not given or `None`,\r\n            use the current unit.\r\n\r\n        equivalencies : list of tuple, optional\r\n            A list of equivalence pairs to try if the units are not directly\r\n            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\r\n            or ``[]``, class default equivalencies will be used (none for\r\n            `~astropy.units.Quantity`, but may be set for subclasses).\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        Returns\r\n        -------\r\n        value : ndarray or scalar\r\n            The value in the units specified. For arrays, this will be a view\r\n            of the data if no unit conversion was necessary.\r\n\r\n        See Also\r\n        --------\r\n        to : Get a new instance in a different unit.\r\n        \"\"\"\r\n        if unit is None or unit is self.unit:\r\n            value = self.view(np.ndarray)\r\n        elif not self.dtype.names:\r\n            # For non-structured, we attempt a short-cut, where we just get\r\n            # the scale.  If that is 1, we do not have to do anything.\r\n            unit = Unit(unit)\r\n            # We want a view if the unit does not change.  One could check\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n            # TODO: would be better for `unit.to` to have an in-place flag.\r\n            try:\r\n                scale = self.unit._to(unit)\r\n            except Exception:\r\n                # Short-cut failed; try default (maybe equivalencies help).\r\n                value = self._to_value(unit, equivalencies)\r\n            else:\r\n                value = self.view(np.ndarray)\r\n                if not is_effectively_unity(scale):\r\n                    # not in-place!\r\n                    value = value * scale\r\n        else:\r\n            # For structured arrays, we go the default route.\r\n            value = self._to_value(unit, equivalencies)\r\n\r\n        # Index with empty tuple to decay array scalars in to numpy scalars.\r\n        return value if value.shape else value[()]\r\n\r\n    value = property(\r\n        to_value,\r\n        doc=\"\"\"The numerical value of this instance.\r\n\r\n    See also\r\n    --------\r\n    to_value : Get the numerical value in a given unit.\r\n    \"\"\",\r\n    )\r\n\r\n    @property\r\n    def unit(self):\r\n        \"\"\"\r\n        A `~astropy.units.UnitBase` object representing the unit of this\r\n        quantity.\r\n        \"\"\"\r\n        return self._unit\r\n\r\n    @property\r\n    def equivalencies(self):\r\n        \"\"\"\r\n        A list of equivalencies that will be applied by default during\r\n        unit conversions.\r\n        \"\"\"\r\n        return self._equivalencies\r\n\r\n    def _recursively_apply(self, func):\r\n        \"\"\"Apply function recursively to every field.\r\n\r\n        Returns a copy with the result.\r\n        \"\"\"\r\n        result = np.empty_like(self)\r\n        result_value = result.view(np.ndarray)\r\n        result_unit = ()\r\n        for name in self.dtype.names:\r\n            part = func(self[name])\r\n            result_value[name] = part.value\r\n            result_unit += (part.unit,)\r\n\r\n        result._set_unit(result_unit)\r\n        return result\r\n\r\n    @property\r\n    def si(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with SI units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"si\"))\r\n        si_unit = self.unit.si\r\n        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\r\n\r\n    @property\r\n    def cgs(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with CGS units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"cgs\"))\r\n        cgs_unit = self.unit.cgs\r\n        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\r\n\r\n    @property\r\n    def isscalar(self):\r\n        \"\"\"\r\n        True if the `value` of this quantity is a scalar, or False if it\r\n        is an array-like object.\r\n\r\n        .. note::\r\n            This is subtly different from `numpy.isscalar` in that\r\n            `numpy.isscalar` returns False for a zero-dimensional array\r\n            (e.g. ``np.array(1)``), while this is True for quantities,\r\n            since quantities cannot represent true numpy scalars.\r\n        \"\"\"\r\n        return not self.shape\r\n\r\n    # This flag controls whether convenience conversion members, such\r\n    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\r\n    # not turned on on Quantity itself, but is on some subclasses of\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n    _include_easy_conversion_members = False\r\n\r\n    def __dir__(self):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.  This function is implemented in\r\n        order to make autocompletion still work correctly in IPython.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            return super().__dir__()\r\n\r\n        dir_values = set(super().__dir__())\r\n        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\r\n        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\r\n            dir_values.update(equivalent.names)\r\n        return sorted(dir_values)\r\n\r\n    def __getattr__(self, attr):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            raise AttributeError(\r\n                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\r\n            )\r\n\r\n        def get_virtual_unit_attribute():\r\n            registry = get_current_unit_registry().registry\r\n            to_unit = registry.get(attr, None)\r\n            if to_unit is None:\r\n                return None\r\n\r\n            try:\r\n                return self.unit.to(\r\n                    to_unit, self.value, equivalencies=self.equivalencies\r\n                )\r\n            except UnitsError:\r\n                return None\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n"]
[330.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[330.002, "i", "sed -n '1200,2200p' astropy/units/quantity.py\r"]
[330.004, "o", "sed -n '1200,2200p' astropy/units/quantity.py\r\n"]
[330.006, "o", "\u001b[?2004l\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n            # so they should raise a TypeError rather than an IndexError.\r\n            if self.isscalar:\r\n                raise TypeError(\r\n                    f\"'{self.__class__.__name__}' object with a scalar value \"\r\n                    \"does not support indexing\"\r\n                )\r\n            else:\r\n                raise\r\n        # For single elements, ndarray.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if not isinstance(out, np.ndarray):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def __setitem__(self, i, value):\r\n        if isinstance(i, str):\r\n            # Indexing will cause a different unit, so by doing this in\r\n            # two steps we effectively try with the right unit.\r\n            self[i][...] = value\r\n            return\r\n\r\n        # update indices in info if the info property has been accessed\r\n        # (in which case 'info' in self.__dict__ is True; this is guaranteed\r\n        # to be the case if we're part of a table).\r\n        if not self.isscalar and \"info\" in self.__dict__:\r\n            self.info.adjust_indices(i, value, len(self))\r\n        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\r\n\r\n    # __contains__ is OK\r\n\r\n    def __bool__(self):\r\n        \"\"\"This method raises ValueError, since truthiness of quantities is ambiguous,\r\n        especially for logarithmic units and temperatures. Use explicit comparisons.\r\n        \"\"\"\r\n        raise ValueError(\r\n            f\"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units\"\r\n            \" and temperatures. Use explicit comparisons.\"\r\n        )\r\n\r\n    def __len__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\r\n            )\r\n        else:\r\n            return len(self.value)\r\n\r\n    # Numerical types\r\n    def __float__(self):\r\n        try:\r\n            return float(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __int__(self):\r\n        try:\r\n            return int(self.to_value(dimensionless_unscaled))\r\n        except (UnitsError, TypeError):\r\n            raise TypeError(\r\n                \"only dimensionless scalar quantities can be \"\r\n                \"converted to Python scalars\"\r\n            )\r\n\r\n    def __index__(self):\r\n        # for indices, we do not want to mess around with scaling at all,\r\n        # so unlike for float, int, we insist here on unscaled dimensionless\r\n        try:\r\n            assert self.unit.is_unity()\r\n            return self.value.__index__()\r\n        except Exception:\r\n            raise TypeError(\r\n                \"only integer dimensionless scalar quantities \"\r\n                \"can be converted to a Python index\"\r\n            )\r\n\r\n    # TODO: we may want to add a hook for dimensionless quantities?\r\n    @property\r\n    def _unitstr(self):\r\n        if self.unit is None:\r\n            unitstr = _UNIT_NOT_INITIALISED\r\n        else:\r\n            unitstr = str(self.unit)\r\n\r\n        if unitstr:\r\n            unitstr = \" \" + unitstr\r\n\r\n        return unitstr\r\n\r\n    def to_string(\r\n        self, unit=None, precision=None, format=None, subfmt=None, *, formatter=None\r\n    ):\r\n        \"\"\"\r\n        Generate a string representation of the quantity and its unit.\r\n\r\n        The behavior of this function can be altered via the\r\n        `numpy.set_printoptions` function and its various keywords.  The\r\n        exception to this is the ``threshold`` keyword, which is controlled via\r\n        the ``[units.quantity]`` configuration item ``latex_array_threshold``.\r\n        This is treated separately because the numpy default of 1000 is too big\r\n        for most browsers to handle.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            Specifies the unit.  If not provided,\r\n            the unit used to initialize the quantity will be used.\r\n\r\n        precision : number, optional\r\n            The level of decimal precision. If `None`, or not provided,\r\n            it will be determined from NumPy print options.\r\n\r\n        format : str, optional\r\n            The format of the result. If not provided, an unadorned\r\n            string is returned. Supported values are:\r\n\r\n            - 'latex': Return a LaTeX-formatted string\r\n\r\n            - 'latex_inline': Return a LaTeX-formatted string that uses\r\n              negative exponents instead of fractions\r\n\r\n        formatter : str, callable, dict, optional\r\n            The formatter to use for the value. If a string, it should be a\r\n            valid format specifier using Python's mini-language. If a callable,\r\n            it will be treated as the default formatter for all values and will\r\n            overwrite default Latex formatting for exponential notation and complex\r\n            numbers. If a dict, it should map a specific type to a callable to be\r\n            directly passed into `numpy.array2string`. If not provided, the default\r\n            formatter will be used.\r\n\r\n        subfmt : str, optional\r\n            Subformat of the result. For the moment, only used for\r\n            ``format='latex'`` and ``format='latex_inline'``. Supported\r\n            values are:\r\n\r\n            - 'inline': Use ``$ ... $`` as delimiters.\r\n\r\n            - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\r\n\r\n        Returns\r\n        -------\r\n        str\r\n            A string with the contents of this Quantity\r\n        \"\"\"\r\n        if unit is not None and unit != self.unit:\r\n            return self.to(unit).to_string(\r\n                unit=None,\r\n                precision=precision,\r\n                format=format,\r\n                subfmt=subfmt,\r\n                formatter=formatter,\r\n            )\r\n\r\n        if format is None and formatter is None and precision is None:\r\n            # Use default formatting settings\r\n            return f\"{self.value}{self._unitstr:s}\"\r\n\r\n        formats = {\r\n            None: None,\r\n            \"latex\": {\r\n                None: (\"$\", \"$\"),\r\n                \"inline\": (\"$\", \"$\"),\r\n                \"display\": (r\"$\\displaystyle \", r\"$\"),\r\n            },\r\n        }\r\n        formats[\"latex_inline\"] = formats[\"latex\"]\r\n\r\n        if format not in formats:\r\n            raise ValueError(f\"Unknown format '{format}'\")\r\n\r\n        format_spec = formatter if isinstance(formatter, str) else None\r\n\r\n        if format is None:\r\n            if format_spec is not None:\r\n\r\n                def formatter(value):\r\n                    return builtins.format(value, format_spec)\r\n\r\n            if callable(formatter):\r\n                formatter = {\"all\": formatter}\r\n\r\n            return (\r\n                np.array2string(\r\n                    self.value,\r\n                    precision=precision,\r\n                    floatmode=\"fixed\",\r\n                    formatter=formatter,\r\n                )\r\n                + self._unitstr\r\n            )\r\n\r\n        # else, for the moment we assume format=\"latex\" or \"latex_inline\".\r\n\r\n        # Set the precision if set, otherwise use numpy default\r\n        pops = np.get_printoptions()\r\n        if format_spec is None:\r\n            format_spec = (\r\n                f\".{precision if precision is not None else pops['precision']}g\"\r\n            )\r\n\r\n        # Use default formatters\r\n        if formatter is None or isinstance(formatter, str):\r\n            # Filter width and alignment operations for latex\r\n            # [[fill]align][sign][\"z\"][\"#\"][\"0\"][width][grouping_option][\".\" precision][type]\r\n            format_spec = re.sub(\r\n                r\"(.*?)([+\\- ]?)(\\d+)?(,)?(\\.\\d+)?([a-zA-Z%]+)?$\",\r\n                r\"\\2\\5\\6\",\r\n                format_spec,\r\n            )\r\n\r\n            if self.dtype.kind == \"c\":  # Complex default latex formatter\r\n                # Disallow sign operations for the imaginary part\r\n                imag_format_spec = re.sub(r\"[+\\- ]\", \"\", format_spec)\r\n\r\n                def formatter(value):\r\n                    return \"({}{}i)\".format(\r\n                        Latex.format_exponential_notation(\r\n                            value.real, format_spec=format_spec\r\n                        ),\r\n                        Latex.format_exponential_notation(\r\n                            value.imag, format_spec=\"+\" + imag_format_spec\r\n                        ),\r\n                    )\r\n\r\n            else:  # Float default latex formatter\r\n\r\n                def formatter(value):\r\n                    return Latex.format_exponential_notation(\r\n                        value, format_spec=format_spec\r\n                    )\r\n\r\n        if callable(formatter):\r\n            formatter = {\"all\": formatter}\r\n\r\n        # The view is needed for the scalar case - self.value might be float.\r\n        latex_value = np.array2string(\r\n            self.view(np.ndarray),\r\n            threshold=(\r\n                conf.latex_array_threshold\r\n                if conf.latex_array_threshold > -1\r\n                else pops[\"threshold\"]\r\n            ),\r\n            formatter=formatter,\r\n            max_line_width=np.inf,\r\n            separator=\",~\",\r\n        )\r\n\r\n        latex_value = latex_value.replace(\"...\", r\"\\dots\")\r\n\r\n        # Format unit\r\n        # [1:-1] strips the '$' on either side needed for math mode\r\n        if self.unit is None:\r\n            latex_unit = _UNIT_NOT_INITIALISED\r\n        elif format == \"latex\":\r\n            latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\r\n        elif format == \"latex_inline\":\r\n            latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\r\n\r\n        delimiter_left, delimiter_right = formats[format][subfmt]\r\n\r\n        # Add a space in front except for super-script units like degrees.\r\n        if not latex_unit.removeprefix(\"\\\\mathrm{\").startswith(\"{}^\"):\r\n            latex_unit = rf\" \\; {latex_unit}\"\r\n\r\n        return rf\"{delimiter_left}{latex_value}{latex_unit}{delimiter_right}\"\r\n\r\n    def __str__(self):\r\n        return self.to_string()\r\n\r\n    def __repr__(self):\r\n        prefixstr = \"<\" + self.__class__.__name__ + \" \"\r\n        arrstr = np.array2string(\r\n            self.view(np.ndarray), separator=\", \", prefix=prefixstr\r\n        )\r\n        return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\r\n\r\n    def _repr_latex_(self):\r\n        \"\"\"\r\n        Generate a latex representation of the quantity and its unit.\r\n\r\n        Returns\r\n        -------\r\n        lstr\r\n            A LaTeX string with the contents of this Quantity\r\n        \"\"\"\r\n        # NOTE: This should change to display format in a future release\r\n        return self.to_string(format=\"latex\", subfmt=\"inline\")\r\n\r\n    def __format__(self, format_spec):\r\n        try:\r\n            return self.to_string(format=format_spec)\r\n        except ValueError:\r\n            # We might have a unit format not implemented in `to_string()`.\r\n            if format_spec in Base.registry:\r\n                if self.unit is dimensionless_unscaled:\r\n                    return f\"{self.value}\"\r\n                else:\r\n                    return f\"{self.value} {format(self.unit, format_spec)}\"\r\n            # Can the value be formatted on its own?\r\n            try:\r\n                return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\r\n            except ValueError:\r\n                # Format the whole thing as a single string.\r\n                return format(f\"{self.value}{self._unitstr:s}\", format_spec)\r\n\r\n    def decompose(self, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units\r\n        decomposed. Decomposed units have only irreducible units in\r\n        them (see `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        bases : sequence of `~astropy.units.UnitBase`, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n        \"\"\"\r\n        return self._decompose(False, bases=bases)\r\n\r\n    def _decompose(self, allowscaledunits=False, bases=[]):\r\n        \"\"\"\r\n        Generates a new `Quantity` with the units decomposed. Decomposed\r\n        units have only irreducible units in them (see\r\n        `astropy.units.UnitBase.decompose`).\r\n\r\n        Parameters\r\n        ----------\r\n        allowscaledunits : bool\r\n            If True, the resulting `Quantity` may have a scale factor\r\n            associated with it.  If False, any scaling in the unit will\r\n            be subsumed into the value of the resulting `Quantity`\r\n\r\n        bases : sequence of UnitBase, optional\r\n            The bases to decompose into.  When not provided,\r\n            decomposes down to any irreducible units.  When provided,\r\n            the decomposed result will only contain the given units.\r\n            This will raises a `~astropy.units.UnitsError` if it's not possible\r\n            to do so.\r\n\r\n        Returns\r\n        -------\r\n        newq : `~astropy.units.Quantity`\r\n            A new object equal to this quantity with units decomposed.\r\n\r\n        \"\"\"\r\n        new_unit = self.unit.decompose(bases=bases)\r\n\r\n        # Be careful here because self.value usually is a view of self;\r\n        # be sure that the original value is not being modified.\r\n        if not allowscaledunits and hasattr(new_unit, \"scale\"):\r\n            new_value = self.value * new_unit.scale\r\n            new_unit = new_unit / new_unit.scale\r\n            return self._new_view(new_value, new_unit)\r\n        else:\r\n            return self._new_view(self.copy(), new_unit)\r\n\r\n    # These functions need to be overridden to take into account the units\r\n    # Array conversion\r\n    # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\r\n\r\n    def item(self, *args):\r\n        \"\"\"Copy an element of an array to a scalar Quantity and return it.\r\n\r\n        Like :meth:`~numpy.ndarray.item` except that it always\r\n        returns a `Quantity`, not a Python scalar.\r\n\r\n        \"\"\"\r\n        return self._new_view(super().item(*args))\r\n\r\n    def tolist(self):\r\n        raise NotImplementedError(\r\n            \"cannot make a list of Quantities. Get list of values with\"\r\n            \" q.value.tolist().\"\r\n        )\r\n\r\n    def _to_own_unit(self, value, check_precision=True, *, unit=None):\r\n        \"\"\"Convert value to one's own unit (or that given).\r\n\r\n        Here, non-quantities are treated as dimensionless, and care is taken\r\n        for values of 0, infinity or nan, which are allowed to have any unit.\r\n\r\n        Parameters\r\n        ----------\r\n        value : anything convertible to `~astropy.units.Quantity`\r\n            The value to be converted to the requested unit.\r\n        check_precision : bool\r\n            Whether to forbid conversion of float to integer if that changes\r\n            the input number.  Default: `True`.\r\n        unit : `~astropy.units.Unit` or None\r\n            The unit to convert to.  By default, the unit of ``self``.\r\n\r\n        Returns\r\n        -------\r\n        value : number or `~numpy.ndarray`\r\n            In the requested units.\r\n\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        try:\r\n            _value = value.to_value(unit)\r\n        except AttributeError:\r\n            # We're not a Quantity.\r\n            # First remove two special cases (with a fast test):\r\n            # 1) Maybe masked printing? MaskedArray with quantities does not\r\n            # work very well, but no reason to break even repr and str.\r\n            # 2) np.ma.masked? useful if we're a MaskedQuantity.\r\n            if value is np.ma.masked or (\r\n                value is np.ma.masked_print_option and self.dtype.kind == \"O\"\r\n            ):\r\n                return value\r\n            # Now, let's try a more general conversion.\r\n            # Plain arrays will be converted to dimensionless in the process,\r\n            # but anything with a unit attribute will use that.\r\n            try:\r\n                as_quantity = Quantity(value)\r\n                _value = as_quantity.to_value(unit)\r\n            except UnitsError:\r\n                # last chance: if this was not something with a unit\r\n                # and is all 0, inf, or nan, we treat it as arbitrary unit.\r\n                if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\r\n                    as_quantity.value\r\n                ):\r\n                    _value = as_quantity.value\r\n                else:\r\n                    raise\r\n\r\n        if self.dtype.kind == \"i\" and check_precision:\r\n            # If, e.g., we are casting float to int, we want to fail if\r\n            # precision is lost, but let things pass if it works.\r\n            _value = np.array(_value, copy=COPY_IF_NEEDED, subok=True)\r\n            if not np.can_cast(_value.dtype, self.dtype):\r\n                self_dtype_array = np.array(_value, self.dtype, subok=True)\r\n                if not np.all((self_dtype_array == _value) | np.isnan(_value)):\r\n                    raise TypeError(\r\n                        \"cannot convert value type to array type without precision loss\"\r\n                    )\r\n\r\n        # Setting names to ensure things like equality work (note that\r\n        # above will have failed already if units did not match).\r\n        # TODO: is this the best place to do this?\r\n        if _value.dtype.names is not None:\r\n            _value = _value.astype(self.dtype, copy=False)\r\n        return _value\r\n\r\n    if NUMPY_LT_2_0:\r\n\r\n        def itemset(self, *args):\r\n            if len(args) == 0:\r\n                raise ValueError(\"itemset must have at least one argument\")\r\n\r\n            self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\r\n\r\n    def tostring(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tostring()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to string.  Write array with\"\r\n            \" q.value.tostring(...).\"\r\n        )\r\n\r\n    def tobytes(self, order=\"C\"):\r\n        \"\"\"Not implemented, use ``.value.tobytes()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\r\n        )\r\n\r\n    def tofile(self, fid, sep=\"\", format=\"%s\"):\r\n        \"\"\"Not implemented, use ``.value.tofile()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\r\n        )\r\n\r\n    def dump(self, file):\r\n        \"\"\"Not implemented, use ``.value.dump()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to file.  Write array with q.value.dump()\"\r\n        )\r\n\r\n    def dumps(self):\r\n        \"\"\"Not implemented, use ``.value.dumps()`` instead.\"\"\"\r\n        raise NotImplementedError(\r\n            \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\r\n        )\r\n\r\n    # astype, byteswap, copy, view, getfield, setflags OK as is\r\n\r\n    def fill(self, value):\r\n        self.view(np.ndarray).fill(self._to_own_unit(value))\r\n\r\n    # Shape manipulation: resize cannot be done (does not own data), but\r\n    # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\r\n    # the flat iterator needs to be overwritten, otherwise single items are\r\n    # returned as numbers.\r\n    @property\r\n    def flat(self):\r\n        \"\"\"A 1-D iterator over the Quantity array.\r\n\r\n        This returns a ``QuantityIterator`` instance, which behaves the same\r\n        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\r\n        and is similar to, but not a subclass of, Python's built-in iterator\r\n        object.\r\n        \"\"\"\r\n        return QuantityIterator(self)\r\n\r\n    @flat.setter\r\n    def flat(self, value):\r\n        y = self.ravel()\r\n        y[:] = value\r\n\r\n    # Item selection and manipulation\r\n    # repeat, sort, compress, diagonal OK\r\n    def take(self, indices, axis=None, out=None, mode=\"raise\"):\r\n        out = super().take(indices, axis=axis, out=out, mode=mode)\r\n        # For single elements, ndarray.take returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if type(out) is not type(self):\r\n            out = self._new_view(out)\r\n        return out\r\n\r\n    def put(self, indices, values, mode=\"raise\"):\r\n        self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\r\n\r\n    def choose(self, choices, out=None, mode=\"raise\"):\r\n        raise NotImplementedError(\r\n            \"cannot choose based on quantity.  Choose using array with\"\r\n            \" q.value.choose(...)\"\r\n        )\r\n\r\n    # ensure we do not return indices as quantities\r\n    if NUMPY_LT_2_0:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None):\r\n            return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\r\n\r\n    else:\r\n\r\n        def argsort(self, axis=-1, kind=None, order=None, *, stable=None):\r\n            return self.view(np.ndarray).argsort(\r\n                axis=axis, kind=kind, order=order, stable=stable\r\n            )\r\n\r\n    def searchsorted(self, v, *args, **kwargs):\r\n        return np.searchsorted(\r\n            np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\r\n        )  # avoid numpy 1.6 problem\r\n\r\n    def argmax(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def argmin(self, axis=None, out=None, *, keepdims=False):\r\n        return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\r\n\r\n    def __array_function__(self, function, types, args, kwargs):\r\n        \"\"\"Wrap numpy functions, taking care of units.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap\r\n        types : iterable of classes\r\n            Classes that provide an ``__array_function__`` override. Can\r\n            in principle be used to interact with other classes. Below,\r\n            mostly passed on to `~numpy.ndarray`, which can only interact\r\n            with subclasses.\r\n        args : tuple\r\n            Positional arguments provided in the function call.\r\n        kwargs : dict\r\n            Keyword arguments provided in the function call.\r\n\r\n        Returns\r\n        -------\r\n        result: `~astropy.units.Quantity`, `~numpy.ndarray`\r\n            As appropriate for the function.  If the function is not\r\n            supported, `NotImplemented` is returned, which will lead to\r\n            a `TypeError` unless another argument overrode the function.\r\n\r\n        Raises\r\n        ------\r\n        ~astropy.units.UnitsError\r\n            If operands have incompatible units.\r\n        \"\"\"\r\n        # A function should be in one of the following sets or dicts:\r\n        # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\r\n        #    supports Quantity; we pass on to ndarray.__array_function__.\r\n        # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\r\n        #    after converting quantities to arrays with suitable units,\r\n        #    and possibly setting units on the result.\r\n        # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\r\n        #    requires a Quantity-specific implementation.\r\n        # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\r\n        # For now, since we may not yet have complete coverage, if a\r\n        # function is in none of the above, we simply call the numpy\r\n        # implementation.\r\n        if function in SUBCLASS_SAFE_FUNCTIONS:\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        elif function in FUNCTION_HELPERS:\r\n            function_helper = FUNCTION_HELPERS[function]\r\n            try:\r\n                args, kwargs, unit, out = function_helper(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            result = super().__array_function__(function, types, args, kwargs)\r\n            # Fall through to return section\r\n\r\n        elif function in DISPATCHED_FUNCTIONS:\r\n            dispatched_function = DISPATCHED_FUNCTIONS[function]\r\n            try:\r\n                result, unit, out = dispatched_function(*args, **kwargs)\r\n            except NotImplementedError:\r\n                return self._not_implemented_or_raise(function, types)\r\n\r\n            # Fall through to return section\r\n\r\n        elif function in UNSUPPORTED_FUNCTIONS:\r\n            return NotImplemented\r\n\r\n        else:\r\n            warnings.warn(\r\n                f\"function '{function.__name__}' is not known to astropy's Quantity.\"\r\n                \" Will run it anyway, hoping it will treat ndarray subclasses\"\r\n                \" correctly. Please raise an issue at\"\r\n                \" https://github.com/astropy/astropy/issues.\",\r\n                AstropyWarning,\r\n            )\r\n            return super().__array_function__(function, types, args, kwargs)\r\n\r\n        # If unit is None, a plain array is expected (e.g., boolean), which\r\n        # means we're done.\r\n        # We're also done if the result was NotImplemented, which can happen\r\n        # if other inputs/outputs override __array_function__;\r\n        # hopefully, they can then deal with us.\r\n        if unit is None or result is NotImplemented:\r\n            return result\r\n\r\n        return self._result_as_quantity(result, unit, out=out)\r\n\r\n    def _not_implemented_or_raise(self, function, types):\r\n        # Our function helper or dispatcher found that the function does not\r\n        # work with Quantity.  In principle, there may be another class that\r\n        # knows what to do with us, for which we should return NotImplemented.\r\n        # But if there is ndarray (or a non-Quantity subclass of it) around,\r\n        # it quite likely coerces, so we should just break.\r\n        if any(\r\n            issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\r\n        ):\r\n            raise TypeError(\r\n                f\"the Quantity implementation cannot handle {function} \"\r\n                \"with the given arguments.\"\r\n            ) from None\r\n        else:\r\n            return NotImplemented\r\n\r\n    # Calculation -- override ndarray methods to take into account units.\r\n    # We use the corresponding numpy functions to evaluate the results, since\r\n    # the methods do not always allow calling with keyword arguments.\r\n    # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\r\n    # TypeError: 'a_max' is an invalid keyword argument for this function.\r\n    def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\r\n        \"\"\"Wrap a numpy function that processes self, returning a Quantity.\r\n\r\n        Parameters\r\n        ----------\r\n        function : callable\r\n            Numpy function to wrap.\r\n        args : positional arguments\r\n            Any positional arguments to the function beyond the first argument\r\n            (which will be set to ``self``).\r\n        kwargs : keyword arguments\r\n            Keyword arguments to the function.\r\n\r\n        If present, the following arguments are treated specially:\r\n\r\n        unit : `~astropy.units.Unit`\r\n            Unit of the output result.  If not given, the unit of ``self``.\r\n        out : `~astropy.units.Quantity`\r\n            A Quantity instance in which to store the output.\r\n\r\n        Notes\r\n        -----\r\n        Output should always be assigned via a keyword argument, otherwise\r\n        no proper account of the unit is taken.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            Result of the function call, with the unit set properly.\r\n        \"\"\"\r\n        if unit is None:\r\n            unit = self.unit\r\n        # Ensure we don't loop back by turning any Quantity into array views.\r\n        args = (self.value,) + tuple(\r\n            (arg.value if isinstance(arg, Quantity) else arg) for arg in args\r\n        )\r\n        if out is not None:\r\n            # If pre-allocated output is used, check it is suitable.\r\n            # This also returns array view, to ensure we don't loop back.\r\n            arrays = tuple(arg for arg in args if isinstance(arg, np.ndarray))\r\n            kwargs[\"out\"] = check_output(out, unit, arrays, function=function)\r\n        # Apply the function and turn it back into a Quantity.\r\n        result = function(*args, **kwargs)\r\n        return self._result_as_quantity(result, unit, out)\r\n\r\n    def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):\r\n        return self._wrap_function(np.trace, offset, axis1, axis2, dtype, out=out)\r\n\r\n    def var(\r\n        self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True\r\n    ):\r\n        return self._wrap_function(\r\n            np.var,\r\n            axis,\r\n            dtype,\r\n            out=out,\r\n            ddof=ddof,\r\n            keepdims=keepdims,\r\n            where=where,\r\n            unit=self.unit**2,\r\n        )\r\n\r\n    def std(\r\n        self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True\r\n    ):\r\n        return self._wrap_function(\r\n            np.std, axis, dtype, out=out, ddof=ddof, keepdims=keepdims, where=where\r\n        )\r\n\r\n    def mean(self, axis=None, dtype=None, out=None, keepdims=False, *, where=True):\r\n        return self._wrap_function(\r\n            np.mean, axis, dtype, out=out, keepdims=keepdims, where=where\r\n        )\r\n\r\n    def round(self, decimals=0, out=None):\r\n        return self._wrap_function(np.round, decimals, out=out)\r\n\r\n    def dot(self, b, out=None):\r\n        result_unit = self.unit * getattr(b, \"unit\", dimensionless_unscaled)\r\n        return self._wrap_function(np.dot, b, out=out, unit=result_unit)\r\n\r\n    # Calculation: override methods that do not make sense.\r\n\r\n    def all(self, axis=None, out=None):\r\n        raise TypeError(\r\n            \"cannot evaluate truth value of quantities. \"\r\n            \"Evaluate array with q.value.all(...)\"\r\n        )\r\n\r\n    def any(self, axis=None, out=None):\r\n        raise TypeError(\r\n            \"cannot evaluate truth value of quantities. \"\r\n            \"Evaluate array with q.value.any(...)\"\r\n        )\r\n\r\n    # Calculation: numpy functions that can be overridden with methods.\r\n\r\n    def diff(self, n=1, axis=-1):\r\n        return self._wrap_function(np.diff, n, axis)\r\n\r\n    def ediff1d(self, to_end=None, to_begin=None):\r\n        return self._wrap_function(np.ediff1d, to_end, to_begin)\r\n\r\n    def insert(self, obj, values, axis=None):\r\n        \"\"\"\r\n        Insert values along the given axis before the given indices and return\r\n        a new `~astropy.units.Quantity` object.\r\n\r\n        This is a thin wrapper around the `numpy.insert` function.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : int, slice or sequence of int\r\n            Object that defines the index or indices before which ``values`` is\r\n            inserted.\r\n        values : array-like\r\n            Values to insert.  If the type of ``values`` is different\r\n            from that of quantity, ``values`` is converted to the matching type.\r\n            ``values`` should be shaped so that it can be broadcast appropriately\r\n            The unit of ``values`` must be consistent with this quantity.\r\n        axis : int, optional\r\n            Axis along which to insert ``values``.  If ``axis`` is None then\r\n            the quantity array is flattened before insertion.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n            A copy of quantity with ``values`` inserted.  Note that the\r\n            insertion does not occur in-place: a new quantity array is returned.\r\n\r\n        Examples\r\n        --------\r\n        >>> import astropy.units as u\r\n        >>> q = [1, 2] * u.m\r\n        >>> q.insert(0, 50 * u.cm)\r\n        <Quantity [ 0.5,  1.,  2.] m>\r\n\r\n        >>> q = [[1, 2], [3, 4]] * u.m\r\n        >>> q.insert(1, [10, 20] * u.m, axis=0)\r\n        <Quantity [[  1.,  2.],\r\n                   [ 10., 20.],\r\n                   [  3.,  4.]] m>\r\n\r\n        >>> q.insert(1, 10 * u.m, axis=1)\r\n        <Quantity [[  1., 10.,  2.],\r\n                   [  3., 10.,  4.]] m>\r\n\r\n        \"\"\"\r\n        out_array = np.insert(self.value, obj, self._to_own_unit(values), axis)\r\n        return self._new_view(out_array)\r\n\r\n\r\nclass SpecificTypeQuantity(Quantity):\r\n    \"\"\"Superclass for Quantities of specific physical type.\r\n\r\n    Subclasses of these work just like :class:`~astropy.units.Quantity`, except\r\n    that they are for specific physical types (and may have methods that are\r\n    only appropriate for that type).  Astropy examples are\r\n    :class:`~astropy.coordinates.Angle` and\r\n    :class:`~astropy.coordinates.Distance`\r\n\r\n    At a minimum, subclasses should set ``_equivalent_unit`` to the unit\r\n    associated with the physical type.\r\n    \"\"\"\r\n\r\n    # The unit for the specific physical type.  Instances can only be created\r\n    # with units that are equivalent to this.\r\n    _equivalent_unit = None\r\n\r\n    # The default unit used for views.  Even with `None`, views of arrays\r\n    # without units are possible, but will have an uninitialized unit.\r\n    _unit = None\r\n\r\n    # Default unit for initialization through the constructor.\r\n    _default_unit = None\r\n\r\n    # ensure that we get precedence over our superclass.\r\n    __array_priority__ = Quantity.__array_priority__ + 10\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        if unit.is_equivalent(self._equivalent_unit):\r\n            return type(self), True\r\n        else:\r\n            return super().__quantity_subclass__(unit)[0], False\r\n\r\n    def _set_unit(self, unit):\r\n        if unit is None or not unit.is_equivalent(self._equivalent_unit):\r\n            raise UnitTypeError(\r\n                (\r\n                    f\"{type(self).__name__} instances require units equivalent to \"\r\n                    f\"'{self._equivalent_unit}'\"\r\n                )\r\n                + (\r\n                    \", but no unit was given.\"\r\n                    if unit is None\r\n                    else f\", so cannot set it to '{unit}'.\"\r\n                )\r\n            )\r\n\r\n        super()._set_unit(unit)\r\n\r\n\r\ndef isclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False):\r\n    \"\"\"\r\n    Return a boolean array where two arrays are element-wise equal\r\n    within a tolerance.\r\n\r\n    Parameters\r\n    ----------\r\n    a, b : array-like or `~astropy.units.Quantity`\r\n        Input values or arrays to compare\r\n    rtol : array-like or `~astropy.units.Quantity`\r\n        The relative tolerance for the comparison, which defaults to\r\n        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,\r\n        then it must be dimensionless.\r\n    atol : number or `~astropy.units.Quantity`\r\n        The absolute tolerance for the comparison.  The units (or lack\r\n        thereof) of ``a``, ``b``, and ``atol`` must be consistent with\r\n        each other.  If `None`, ``atol`` defaults to zero in the\r\n        appropriate units.\r\n    equal_nan : `bool`\r\n        Whether to compare NaN\u2019s as equal. If `True`, NaNs in ``a`` will\r\n        be considered equal to NaN\u2019s in ``b``.\r\n\r\n    Notes\r\n    -----\r\n    This is a :class:`~astropy.units.Quantity`-aware version of\r\n    :func:`numpy.isclose`. However, this differs from the `numpy` function in\r\n    that the default for the absolute tolerance here is zero instead of\r\n    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default\r\n    *absolute* tolerance given two inputs that may have differently scaled\r\n"]
[335.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[335.002, "i", "cat asv.ci.conf.json\r"]
[335.004, "o", "cat asv.ci.conf.json\r\n"]
[335.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[340.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[340.002, "i", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r"]
[340.004, "o", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r\n"]
[340.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[345.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[345.002, "i", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r"]
[345.004, "o", "asv dev -c asv.ci.conf.json -b \"units.time_quantity_init_small_list|units.time_quantity_creation_nocopy|units.time_\r\n"]
[345.006, "o", "_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\"\r\n\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: argument {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages}: invalid choice: 'dev' (choose from 'help', 'quickstart', 'machine', 'setup', 'run', 'continuous', 'find', 'rm', 'publish', 'preview', 'profile', 'update', 'show', 'compare', 'check', 'gh-pages')\r\n"]
[350.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[350.002, "i", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r"]
[350.004, "o", "asv profile -c asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[350.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[355.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[355.002, "i", "cat asv.ci.conf.json\r"]
[355.004, "o", "cat asv.ci.conf.json\r\n"]
[355.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[360.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[360.002, "i", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r"]
[360.004, "o", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r\n"]
[360.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[365.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[365.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[365.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[365.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 6 total benchmarks (1 commits * 1 environments * 6 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 8.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.28\u00b10ms\r\n[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        142\u00b10\u03bcs\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       350\u00b10\u03bcs\r\n[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        351\u00b10\u03bcs\r\n[41.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             576\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  93.4\u00b10\u03bcs\r\n"]
[370.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[370.002, "i", "asv profile --config asv.ci.conf.json units.time_quantity_times_unit\r"]
[370.004, "o", "asv profile --config asv.ci.conf.json units.time_quantity_times_unit\r\n"]
[370.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mCreating virtualenv for virtualenv-py3.11\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mInstalling requirements for virtualenv-py3.11\u001b[0m\u001b[1;30m.\u001b[0m\u001b[1;30m.\u001b[0m\u001b[1;30m.\u001b[0m\u001b[1;30m.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;31mError running /workspace/repo/env/2bc11cad084fa5bfe9c66b8a2af28d97/bin/python -m pip install -v --upgrade extension-helpers==1. (exit status 1)\u001b[0m\r\n   STDOUT -------->\r\n   Using pip 25.2 from /workspace/repo/env/2bc11cad084fa5bfe9c66b8a2af28d97/lib/python3.11/site-packages/pip (python 3.11)\r\n   STDERR -------->\r\n   ERROR: Invalid requirement: 'extension-helpers==1.': Expected end or semicolon (after version specifier)\r\n       extension-helpers==1.\r\n                        ~~~^\r\n\r\n\u00b7\u00b7 \u001b[0;31mFailure creating environment for virtualenv-py3.11\u001b[0m\r\nTraceback (most recent call last):\r\n  File \"/opt/conda/envs/asv_3.11/bin/asv\", line 7, in <module>\r\n    sys.exit(main())\r\n             ^^^^^^\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/main.py\", line 28, in main\r\n    result = args.func(args)\r\n             ^^^^^^^^^^^^^^^\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/commands/__init__.py\", line 48, in run_from_args\r\n    return cls.run_from_conf_args(conf, args)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/commands/profiling.py\", line 84, in run_from_conf_args\r\n    return cls.run(\r\n           ^^^^^^^^\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/commands/profiling.py\", line 177, in run\r\n    benchmarks = Benchmarks.discover(conf, repo, environments,\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/benchmarks.py\", line 131, in discover\r\n    benchmarks = cls._disc_benchmarks(conf, repo, environments, commit_hash, check)\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/benchmarks.py\", line 177, in _disc_benchmarks\r\n    env.create()\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/environment.py\", line 755, in create\r\n    self._setup()\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/plugins/virtualenv.py\", line 150, in _setup\r\n    self._install_requirements()\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/plugins/virtualenv.py\", line 171, in _install_requirements\r\n    pip_call()\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/plugins/virtualenv.py\", line 176, in _run_pip\r\n    return self.run_executable('python', ['-m', 'pip'] + list(args), **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/environment.py\", line 1007, in run_executable\r\n    return util.check_output([exe] + args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/conda/envs/asv_3.11/lib/python3.11/site-packages/asv/util.py\", line 617, in check_output\r\n    raise ProcessError(args, retcode, stdout, stderr)\r\nasv.util.ProcessError: Command '/workspace/repo/env/2bc11cad084fa5bfe9c66b8a2af28d97/bin/python -m pip install -v --upgrade extension-helpers==1.' returned non-zero exit status 1\r\n"]
[375.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[375.002, "i", "cat asv.ci.conf.json\r"]
[375.004, "o", "cat asv.ci.conf.json\r\n"]
[375.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[380.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[380.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[380.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[380.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 6 total benchmarks (1 commits * 1 environments * 6 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 8.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.03\u00b10ms\r\n[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        124\u00b10\u03bcs\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       264\u00b10\u03bcs\r\n[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        298\u00b10\u03bcs\r\n[41.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             513\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  74.1\u00b10\u03bcs\r\n"]
[385.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[385.002, "i", "asv profile --config asv.ci.conf.json --python=same units.time_quantity_times_unit\r"]
[385.004, "o", "asv profile --config asv.ci.conf.json --python=same units.time_quantity_times_unit\r\n"]
[385.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (units.time_quantity_times_unit--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                          31.7\u00b10.7\u03bcs\r\n\r\nWed Oct  1 12:08:57 2025    /tmp/tmp_pdb7boe\r\n\r\n         54 function calls in 0.000 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.000    0.000 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.000    0.000 units.py:98(time_quantity_times_unit)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:1209(__mul__)\r\n        1    0.000    0.000    0.000    0.000 core.py:869(__mul__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2335(__init__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2416(_expand_and_gather)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:764(_new_view)\r\n        2    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 quantity.py:574(__array_finalize__)\r\n        1    0.000    0.000    0.000    0.000 {method 'copy' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 core.py:2417(add_unit)\r\n        1    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 quantity.py:945(to_value)\r\n        1    0.000    0.000    0.000    0.000 core.py:2451(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 utils.py:193(sanitize_scale)\r\n        2    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        1    0.000    0.000    0.000    0.000 core.py:2069(__call__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2454(<listcomp>)\r\n        5    0.000    0.000    0.000    0.000 core.py:927(__hash__)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        7    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        1    0.000    0.000    0.000    0.000 core.py:1874(name)\r\n        1    0.000    0.000    0.000    0.000 core.py:2450(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 utils.py:328(resolve_fractions)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:836(_set_unit)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:1009(unit)\r\n        1    0.000    0.000    0.000    0.000 utils.py:181(is_effectively_unity)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        1    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        1    0.000    0.000    0.000    0.000 core.py:2453(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 core.py:1752(is_unity)\r\n        1    0.000    0.000    0.000    0.000 utils.py:288(sanitize_power)\r\n        2    0.000    0.000    0.000    0.000 {function Quantity.__array_finalize__ at 0x7f269d8840e0}\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        1    0.000    0.000    0.000    0.000 quantity.py:746(__quantity_subclass__)\r\n        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n\r\n\r\n"]
[390.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[390.002, "i", "cat asv.ci.conf.json\r"]
[390.004, "o", "cat asv.ci.conf.json\r\n"]
[390.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[395.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[395.002, "i", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r"]
[395.004, "o", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r\n"]
[395.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[400.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[400.002, "i", "sed -n '260,520p' astropy-benchmarks/benchmarks/units.py\r"]
[400.004, "o", "sed -n '260,520p' astropy-benchmarks/benchmarks/units.py\r\n"]
[400.006, "o", "\u001b[?2004l\r\n"]
[405.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[405.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[405.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[405.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 26 total benchmarks (1 commits * 1 environments * 26 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  2.84\u00b10ms\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.55\u00b10ms\r\n[ 5.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  3.15\u00b10ms\r\n[ 7.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.98\u00b10ms\r\n[ 9.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.58\u00b10ms\r\n[11.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.41\u00b10ms\r\n[13.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          2.93\u00b10ms\r\n[15.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           2.84\u00b10ms\r\n[17.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  2.43\u00b10ms\r\n[19.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.60\u00b10ms\r\n[21.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.50\u00b10ms\r\n[23.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                1.30\u00b10ms\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.78\u00b10ms\r\n[26.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.56\u00b10ms\r\n[28.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.34\u00b10ms\r\n[30.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          1.29\u00b10ms\r\n[32.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          2.01\u00b10ms\r\n[34.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           1.78\u00b10ms\r\n[36.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  1.34\u00b10ms\r\n[38.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              1.62\u00b10ms\r\n[40.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.55\u00b10ms\r\n[42.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        172\u00b10\u03bcs\r\n[44.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       319\u00b10\u03bcs\r\n[46.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        304\u00b10\u03bcs\r\n[48.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             607\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                   117\u00b10\u03bcs\r\n"]
[410.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[410.002, "i", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r"]
[410.004, "o", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r\n"]
[410.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                1.72\u00b10.2ms\r\n\r\nWed Oct  1 12:10:56 2025    /tmp/tmp_ie5em11\r\n\r\n         86 function calls in 0.002 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.002    0.002 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.002    0.002 units.py:181(time_quantity_mul)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:1209(__mul__)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:613(__array_ufunc__)\r\n        1    0.001    0.001    0.001    0.001 {function Quantity.__array_ufunc__ at 0x7f40167f0220}\r\n        1    0.000    0.000    0.000    0.000 converters.py:141(converters_and_unit)\r\n        1    0.000    0.000    0.000    0.000 helpers.py:219(helper_multiplication)\r\n        1    0.000    0.000    0.000    0.000 core.py:869(__mul__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2335(__init__)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:694(_result_as_quantity)\r\n        1    0.000    0.000    0.000    0.000 core.py:2416(_expand_and_gather)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:764(_new_view)\r\n        2    0.000    0.000    0.000    0.000 core.py:2279(is_unity)\r\n        6    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        3    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 core.py:2484(is_unity)\r\n        2    0.000    0.000    0.000    0.000 core.py:2417(add_unit)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:574(__array_finalize__)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:945(to_value)\r\n        1    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 core.py:2069(__call__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2454(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 core.py:2463(decompose)\r\n        1    0.000    0.000    0.000    0.000 converters.py:178(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2451(<lambda>)\r\n        8    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        1    0.000    0.000    0.000    0.000 utils.py:193(sanitize_scale)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:836(_set_unit)\r\n        3    0.000    0.000    0.000    0.000 quantity.py:1009(unit)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        1    0.000    0.000    0.000    0.000 core.py:2450(<listcomp>)\r\n        5    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        1    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        1    0.000    0.000    0.000    0.000 utils.py:181(is_effectively_unity)\r\n        1    0.000    0.000    0.000    0.000 utils.py:328(resolve_fractions)\r\n        5    0.000    0.000    0.000    0.000 core.py:2282(__hash__)\r\n        1    0.000    0.000    0.000    0.000 core.py:1874(name)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        3    0.000    0.000    0.000    0.000 converters.py:183(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2453(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 core.py:2402(bases)\r\n        1    0.000    0.000    0.000    0.000 utils.py:288(sanitize_power)\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        2    0.000    0.000    0.000    0.000 {function Quantity.__array_finalize__ at 0x7f40167f00e0}\r\n        1    0.000    0.000    0.000    0.000 quantity.py:746(__quantity_subclass__)\r\n        2    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        2    0.000    0.000    0.000    0.000 helpers.py:31(_d)\r\n        1    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n\r\n\r\n"]
[415.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[415.002, "i", "sed -n '1120,1260p' astropy/units/quantity.py\r"]
[415.004, "o", "sed -n '1120,1260p' astropy/units/quantity.py\r\n"]
[415.006, "o", "\u001b[?2004l\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n"]
[420.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[420.002, "i", "sed -n '2320,2480p' astropy/units/core.py\r"]
[420.004, "o", "sed -n '2320,2480p' astropy/units/core.py\r\n"]
[420.006, "o", "\u001b[?2004l\r\n    Parameters\r\n    ----------\r\n    scale : number\r\n        A scaling factor for the unit.\r\n\r\n    bases : sequence of `UnitBase`\r\n        A sequence of units this unit is composed of.\r\n\r\n    powers : sequence of numbers\r\n        A sequence of powers (in parallel with ``bases``) for each\r\n        of the base units.\r\n    \"\"\"\r\n\r\n    _decomposed_cache = None\r\n\r\n    def __init__(\r\n        self,\r\n        scale,\r\n        bases,\r\n        powers,\r\n        decompose=False,\r\n        decompose_bases=set(),\r\n        _error_check=True,\r\n    ):\r\n        # There are many cases internal to astropy.units where we\r\n        # already know that all the bases are Unit objects, and the\r\n        # powers have been validated.  In those cases, we can skip the\r\n        # error checking for performance reasons.  When the private\r\n        # kwarg `_error_check` is False, the error checking is turned\r\n        # off.\r\n        if _error_check:\r\n            for base in bases:\r\n                if not isinstance(base, UnitBase):\r\n                    raise TypeError(\"bases must be sequence of UnitBase instances\")\r\n            powers = [validate_power(p) for p in powers]\r\n\r\n        if not decompose and len(bases) == 1 and powers[0] >= 0:\r\n            # Short-cut; with one unit there's nothing to expand and gather,\r\n            # as that has happened already when creating the unit.  But do only\r\n            # positive powers, since for negative powers we need to re-sort.\r\n            unit = bases[0]\r\n            power = powers[0]\r\n            if power == 1:\r\n                scale *= unit.scale\r\n                self._bases = unit.bases\r\n                self._powers = unit.powers\r\n            elif power == 0:\r\n                self._bases = []\r\n                self._powers = []\r\n            else:\r\n                scale *= unit.scale**power\r\n                self._bases = unit.bases\r\n                self._powers = [\r\n                    sanitize_power(operator.mul(*resolve_fractions(p, power)))\r\n                    for p in unit.powers\r\n                ]\r\n\r\n            self._scale = sanitize_scale(scale)\r\n        else:\r\n            # Regular case: use inputs as preliminary scale, bases, and powers,\r\n            # then \"expand and gather\" identical bases, sanitize the scale, &c.\r\n            self._scale = scale\r\n            self._bases = bases\r\n            self._powers = powers\r\n            self._expand_and_gather(decompose=decompose, bases=decompose_bases)\r\n\r\n    def __repr__(self):\r\n        if len(self._bases):\r\n            return super().__repr__()\r\n        else:\r\n            if self._scale != 1.0:\r\n                return f\"Unit(dimensionless with a scale of {self._scale})\"\r\n            else:\r\n                return \"Unit(dimensionless)\"\r\n\r\n    @property\r\n    def scale(self):\r\n        \"\"\"\r\n        Return the scale of the composite unit.\r\n        \"\"\"\r\n        return self._scale\r\n\r\n    @property\r\n    def bases(self):\r\n        \"\"\"\r\n        Return the bases of the composite unit.\r\n        \"\"\"\r\n        return self._bases\r\n\r\n    @property\r\n    def powers(self):\r\n        \"\"\"\r\n        Return the powers of the composite unit.\r\n        \"\"\"\r\n        return self._powers\r\n\r\n    def _expand_and_gather(self, decompose=False, bases=set()):\r\n        def add_unit(unit, power, scale):\r\n            if bases and unit not in bases:\r\n                for base in bases:\r\n                    try:\r\n                        scale *= unit._to(base) ** power\r\n                    except UnitsError:\r\n                        pass\r\n                    else:\r\n                        unit = base\r\n                        break\r\n\r\n            if unit in new_parts:\r\n                a, b = resolve_fractions(new_parts[unit], power)\r\n                new_parts[unit] = a + b\r\n            else:\r\n                new_parts[unit] = power\r\n            return scale\r\n\r\n        new_parts = {}\r\n        scale = self._scale\r\n\r\n        for b, p in zip(self._bases, self._powers):\r\n            if decompose and b not in bases:\r\n                b = b.decompose(bases=bases)\r\n\r\n            if isinstance(b, CompositeUnit):\r\n                scale *= b._scale**p\r\n                for b_sub, p_sub in zip(b._bases, b._powers):\r\n                    a, b = resolve_fractions(p_sub, p)\r\n                    scale = add_unit(b_sub, a * b, scale)\r\n            else:\r\n                scale = add_unit(b, p, scale)\r\n\r\n        new_parts = [x for x in new_parts.items() if x[1] != 0]\r\n        new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\r\n\r\n        self._bases = [x[0] for x in new_parts]\r\n        self._powers = [sanitize_power(x[1]) for x in new_parts]\r\n        self._scale = sanitize_scale(scale)\r\n\r\n    def __copy__(self):\r\n        \"\"\"\r\n        For compatibility with python copy module.\r\n        \"\"\"\r\n        return CompositeUnit(self._scale, self._bases[:], self._powers[:])\r\n\r\n    def decompose(self, bases=set()):\r\n        if len(bases) == 0 and self._decomposed_cache is not None:\r\n            return self._decomposed_cache\r\n\r\n        for base in self.bases:\r\n            if not isinstance(base, IrreducibleUnit) or (\r\n                len(bases) and base not in bases\r\n            ):\r\n                break\r\n        else:\r\n            if len(bases) == 0:\r\n                self._decomposed_cache = self\r\n            return self\r\n\r\n        x = CompositeUnit(\r\n            self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases\r\n        )\r\n        if len(bases) == 0:\r\n"]
[425.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[425.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[425.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[425.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 26 total benchmarks (1 commits * 1 environments * 26 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  2.23\u00b10ms\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.14\u00b10ms\r\n[ 5.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  1.44\u00b10ms\r\n[ 7.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.07\u00b10ms\r\n[ 9.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.46\u00b10ms\r\n[11.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.40\u00b10ms\r\n[13.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          2.31\u00b10ms\r\n[15.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           1.28\u00b10ms\r\n[17.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  2.08\u00b10ms\r\n[19.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.31\u00b10ms\r\n[21.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.38\u00b10ms\r\n[23.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                1.03\u00b10ms\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.30\u00b10ms\r\n[26.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.41\u00b10ms\r\n[28.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.15\u00b10ms\r\n[30.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          1.48\u00b10ms\r\n[32.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          1.26\u00b10ms\r\n[34.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           1.51\u00b10ms\r\n[36.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  1.34\u00b10ms\r\n[38.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              1.49\u00b10ms\r\n[40.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.12\u00b10ms\r\n[42.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        130\u00b10\u03bcs\r\n[44.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       272\u00b10\u03bcs\r\n[46.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        288\u00b10\u03bcs\r\n[48.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             513\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  87.5\u00b10\u03bcs\r\n"]
[430.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[430.002, "i", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r"]
[430.004, "o", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r\n"]
[430.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                1.36\u00b10.1ms\r\n\r\nWed Oct  1 12:12:44 2025    /tmp/tmpir0qualc\r\n\r\n         86 function calls in 0.002 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.002    0.002 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.002    0.002 units.py:181(time_quantity_mul)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:1209(__mul__)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:613(__array_ufunc__)\r\n        1    0.001    0.001    0.001    0.001 {function Quantity.__array_ufunc__ at 0x7f9b7b118220}\r\n        1    0.000    0.000    0.000    0.000 converters.py:141(converters_and_unit)\r\n        1    0.000    0.000    0.000    0.000 helpers.py:219(helper_multiplication)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:694(_result_as_quantity)\r\n        1    0.000    0.000    0.000    0.000 core.py:869(__mul__)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:764(_new_view)\r\n        1    0.000    0.000    0.000    0.000 core.py:2335(__init__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2416(_expand_and_gather)\r\n        3    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 quantity.py:574(__array_finalize__)\r\n        2    0.000    0.000    0.000    0.000 core.py:2279(is_unity)\r\n        1    0.000    0.000    0.000    0.000 core.py:2069(__call__)\r\n        6    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        2    0.000    0.000    0.000    0.000 core.py:2484(is_unity)\r\n        1    0.000    0.000    0.000    0.000 converters.py:178(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 core.py:2417(add_unit)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:945(to_value)\r\n        1    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 utils.py:193(sanitize_scale)\r\n        8    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        2    0.000    0.000    0.000    0.000 core.py:2463(decompose)\r\n        1    0.000    0.000    0.000    0.000 core.py:2454(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2451(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:836(_set_unit)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        1    0.000    0.000    0.000    0.000 core.py:2450(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 quantity.py:1009(unit)\r\n        1    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        1    0.000    0.000    0.000    0.000 utils.py:181(is_effectively_unity)\r\n        5    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        1    0.000    0.000    0.000    0.000 utils.py:328(resolve_fractions)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        5    0.000    0.000    0.000    0.000 core.py:2282(__hash__)\r\n        1    0.000    0.000    0.000    0.000 core.py:1874(name)\r\n        3    0.000    0.000    0.000    0.000 converters.py:183(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2453(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 core.py:2402(bases)\r\n        2    0.000    0.000    0.000    0.000 {function Quantity.__array_finalize__ at 0x7f9b7b1180e0}\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        2    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 quantity.py:746(__quantity_subclass__)\r\n        1    0.000    0.000    0.000    0.000 utils.py:288(sanitize_power)\r\n        1    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        2    0.000    0.000    0.000    0.000 helpers.py:31(_d)\r\n\r\n\r\n"]
[435.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[435.002, "i", "grep -n \"def __mul__\" astropy/units/quantity.py\r"]
[435.004, "o", "grep -n \"def __mul__\" astropy/units/quantity.py\r\n"]
[435.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K1209\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __mul__\u001b[m\u001b[K(self, other):\r\n"]
[440.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[440.002, "i", "sed -n '1120,1300p' astropy/units/quantity.py\r"]
[440.004, "o", "sed -n '1120,1300p' astropy/units/quantity.py\r\n"]
[440.006, "o", "\u001b[?2004l\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n"]
[445.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[445.002, "i", "grep -n \"def _new_view\" astropy/units/quantity.py\r"]
[445.004, "o", "grep -n \"def _new_view\" astropy/units/quantity.py\r\n"]
[445.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K764\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef _new_view\u001b[m\u001b[K(self, obj=None, unit=None, propagate_info=True):\r\n"]
[450.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[450.002, "i", "sed -n '700,820p' astropy/units/quantity.py\r"]
[450.004, "o", "sed -n '700,820p' astropy/units/quantity.py\r\n"]
[450.006, "o", "\u001b[?2004l\r\n\r\n        Parameters\r\n        ----------\r\n        result : ndarray or tuple thereof\r\n            Array(s) which need to be turned into quantity.\r\n        unit : `~astropy.units.Unit`\r\n            Unit for the quantities to be returned (or `None` if the result\r\n            should not be a quantity).  Should be tuple if result is a tuple.\r\n        out : `~astropy.units.Quantity` or None\r\n            Possible output quantity. Should be `None` or a tuple if result\r\n            is a tuple.\r\n\r\n        Returns\r\n        -------\r\n        out : `~astropy.units.Quantity`\r\n           With units set.\r\n        \"\"\"\r\n        if isinstance(result, (tuple, list)):\r\n            if out is None:\r\n                out = (None,) * len(result)\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n"]
[455.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[455.002, "i", "grep -n \"class CompositeUnit\" astropy/units/core.py\r"]
[455.004, "o", "grep -n \"class CompositeUnit\" astropy/units/core.py\r\n"]
[455.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K2311\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass CompositeUnit\u001b[m\u001b[K(UnitBase):\r\n"]
[460.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[460.002, "i", "sed -n '2320,2480p' astropy/units/core.py\r"]
[460.004, "o", "sed -n '2320,2480p' astropy/units/core.py\r\n"]
[460.006, "o", "\u001b[?2004l\r\n    Parameters\r\n    ----------\r\n    scale : number\r\n        A scaling factor for the unit.\r\n\r\n    bases : sequence of `UnitBase`\r\n        A sequence of units this unit is composed of.\r\n\r\n    powers : sequence of numbers\r\n        A sequence of powers (in parallel with ``bases``) for each\r\n        of the base units.\r\n    \"\"\"\r\n\r\n    _decomposed_cache = None\r\n\r\n    def __init__(\r\n        self,\r\n        scale,\r\n        bases,\r\n        powers,\r\n        decompose=False,\r\n        decompose_bases=set(),\r\n        _error_check=True,\r\n    ):\r\n        # There are many cases internal to astropy.units where we\r\n        # already know that all the bases are Unit objects, and the\r\n        # powers have been validated.  In those cases, we can skip the\r\n        # error checking for performance reasons.  When the private\r\n        # kwarg `_error_check` is False, the error checking is turned\r\n        # off.\r\n        if _error_check:\r\n            for base in bases:\r\n                if not isinstance(base, UnitBase):\r\n                    raise TypeError(\"bases must be sequence of UnitBase instances\")\r\n            powers = [validate_power(p) for p in powers]\r\n\r\n        if not decompose and len(bases) == 1 and powers[0] >= 0:\r\n            # Short-cut; with one unit there's nothing to expand and gather,\r\n            # as that has happened already when creating the unit.  But do only\r\n            # positive powers, since for negative powers we need to re-sort.\r\n            unit = bases[0]\r\n            power = powers[0]\r\n            if power == 1:\r\n                scale *= unit.scale\r\n                self._bases = unit.bases\r\n                self._powers = unit.powers\r\n            elif power == 0:\r\n                self._bases = []\r\n                self._powers = []\r\n            else:\r\n                scale *= unit.scale**power\r\n                self._bases = unit.bases\r\n                self._powers = [\r\n                    sanitize_power(operator.mul(*resolve_fractions(p, power)))\r\n                    for p in unit.powers\r\n                ]\r\n\r\n            self._scale = sanitize_scale(scale)\r\n        else:\r\n            # Regular case: use inputs as preliminary scale, bases, and powers,\r\n            # then \"expand and gather\" identical bases, sanitize the scale, &c.\r\n            self._scale = scale\r\n            self._bases = bases\r\n            self._powers = powers\r\n            self._expand_and_gather(decompose=decompose, bases=decompose_bases)\r\n\r\n    def __repr__(self):\r\n        if len(self._bases):\r\n            return super().__repr__()\r\n        else:\r\n            if self._scale != 1.0:\r\n                return f\"Unit(dimensionless with a scale of {self._scale})\"\r\n            else:\r\n                return \"Unit(dimensionless)\"\r\n\r\n    @property\r\n    def scale(self):\r\n        \"\"\"\r\n        Return the scale of the composite unit.\r\n        \"\"\"\r\n        return self._scale\r\n\r\n    @property\r\n    def bases(self):\r\n        \"\"\"\r\n        Return the bases of the composite unit.\r\n        \"\"\"\r\n        return self._bases\r\n\r\n    @property\r\n    def powers(self):\r\n        \"\"\"\r\n        Return the powers of the composite unit.\r\n        \"\"\"\r\n        return self._powers\r\n\r\n    def _expand_and_gather(self, decompose=False, bases=set()):\r\n        def add_unit(unit, power, scale):\r\n            if bases and unit not in bases:\r\n                for base in bases:\r\n                    try:\r\n                        scale *= unit._to(base) ** power\r\n                    except UnitsError:\r\n                        pass\r\n                    else:\r\n                        unit = base\r\n                        break\r\n\r\n            if unit in new_parts:\r\n                a, b = resolve_fractions(new_parts[unit], power)\r\n                new_parts[unit] = a + b\r\n            else:\r\n                new_parts[unit] = power\r\n            return scale\r\n\r\n        new_parts = {}\r\n        scale = self._scale\r\n\r\n        for b, p in zip(self._bases, self._powers):\r\n            if decompose and b not in bases:\r\n                b = b.decompose(bases=bases)\r\n\r\n            if isinstance(b, CompositeUnit):\r\n                scale *= b._scale**p\r\n                for b_sub, p_sub in zip(b._bases, b._powers):\r\n                    a, b = resolve_fractions(p_sub, p)\r\n                    scale = add_unit(b_sub, a * b, scale)\r\n            else:\r\n                scale = add_unit(b, p, scale)\r\n\r\n        new_parts = [x for x in new_parts.items() if x[1] != 0]\r\n        new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\r\n\r\n        self._bases = [x[0] for x in new_parts]\r\n        self._powers = [sanitize_power(x[1]) for x in new_parts]\r\n        self._scale = sanitize_scale(scale)\r\n\r\n    def __copy__(self):\r\n        \"\"\"\r\n        For compatibility with python copy module.\r\n        \"\"\"\r\n        return CompositeUnit(self._scale, self._bases[:], self._powers[:])\r\n\r\n    def decompose(self, bases=set()):\r\n        if len(bases) == 0 and self._decomposed_cache is not None:\r\n            return self._decomposed_cache\r\n\r\n        for base in self.bases:\r\n            if not isinstance(base, IrreducibleUnit) or (\r\n                len(bases) and base not in bases\r\n            ):\r\n                break\r\n        else:\r\n            if len(bases) == 0:\r\n                self._decomposed_cache = self\r\n            return self\r\n\r\n        x = CompositeUnit(\r\n            self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases\r\n        )\r\n        if len(bases) == 0:\r\n"]
[465.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[465.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[465.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[465.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 26 total benchmarks (1 commits * 1 environments * 26 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  3.40\u00b10ms\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.38\u00b10ms\r\n[ 5.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  1.40\u00b10ms\r\n[ 7.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.42\u00b10ms\r\n[ 9.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.46\u00b10ms\r\n[11.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.44\u00b10ms\r\n[13.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          3.81\u00b10ms\r\n[15.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           1.54\u00b10ms\r\n[17.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  3.54\u00b10ms\r\n[19.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.76\u00b10ms\r\n[21.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.71\u00b10ms\r\n[23.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                1.28\u00b10ms\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.74\u00b10ms\r\n[26.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.70\u00b10ms\r\n[28.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.27\u00b10ms\r\n[30.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          2.49\u00b10ms\r\n[32.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          2.05\u00b10ms\r\n[34.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           3.04\u00b10ms\r\n[36.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  2.38\u00b10ms\r\n[38.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              4.11\u00b10ms\r\n[40.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.36\u00b10ms\r\n[42.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        147\u00b10\u03bcs\r\n[44.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       343\u00b10\u03bcs\r\n[46.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        330\u00b10\u03bcs\r\n[48.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             635\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  83.9\u00b10\u03bcs\r\n"]
[470.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[470.002, "i", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r"]
[470.004, "o", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r\n"]
[470.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                1.41\u00b10.4ms\r\n\r\nWed Oct  1 12:15:22 2025    /tmp/tmpu815eijl\r\n\r\n         86 function calls in 0.002 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.002    0.002 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.002    0.002 units.py:181(time_quantity_mul)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:1209(__mul__)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:613(__array_ufunc__)\r\n        1    0.002    0.002    0.002    0.002 {function Quantity.__array_ufunc__ at 0x7fc08de20220}\r\n        1    0.000    0.000    0.000    0.000 converters.py:141(converters_and_unit)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:694(_result_as_quantity)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:764(_new_view)\r\n        1    0.000    0.000    0.000    0.000 helpers.py:219(helper_multiplication)\r\n        1    0.000    0.000    0.000    0.000 core.py:869(__mul__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2335(__init__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2416(_expand_and_gather)\r\n        3    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        6    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        2    0.000    0.000    0.000    0.000 quantity.py:574(__array_finalize__)\r\n        1    0.000    0.000    0.000    0.000 converters.py:178(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 core.py:2279(is_unity)\r\n        2    0.000    0.000    0.000    0.000 core.py:2484(is_unity)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:945(to_value)\r\n        2    0.000    0.000    0.000    0.000 core.py:2417(add_unit)\r\n        1    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 core.py:2069(__call__)\r\n        2    0.000    0.000    0.000    0.000 core.py:2463(decompose)\r\n        8    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        1    0.000    0.000    0.000    0.000 quantity.py:836(_set_unit)\r\n        1    0.000    0.000    0.000    0.000 utils.py:193(sanitize_scale)\r\n        1    0.000    0.000    0.000    0.000 core.py:2451(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2454(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 quantity.py:1009(unit)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        1    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        5    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        1    0.000    0.000    0.000    0.000 core.py:2450(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 utils.py:181(is_effectively_unity)\r\n        1    0.000    0.000    0.000    0.000 utils.py:328(resolve_fractions)\r\n        5    0.000    0.000    0.000    0.000 core.py:2282(__hash__)\r\n        1    0.000    0.000    0.000    0.000 core.py:1874(name)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        3    0.000    0.000    0.000    0.000 converters.py:183(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 core.py:2402(bases)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:746(__quantity_subclass__)\r\n        2    0.000    0.000    0.000    0.000 {function Quantity.__array_finalize__ at 0x7fc08de200e0}\r\n        2    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 utils.py:288(sanitize_power)\r\n        1    0.000    0.000    0.000    0.000 core.py:2453(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        2    0.000    0.000    0.000    0.000 helpers.py:31(_d)\r\n\r\n\r\n"]
[475.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[475.002, "i", "grep -n \"def __mul__\" astropy/units/quantity.py\r"]
[475.004, "o", "grep -n \"def __mul__\" astropy/units/quantity.py\r\n"]
[475.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K1209\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __mul__\u001b[m\u001b[K(self, other):\r\n"]
[480.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[480.002, "i", "sed -n '1120,1300p' astropy/units/quantity.py\r"]
[480.004, "o", "sed -n '1120,1300p' astropy/units/quantity.py\r\n"]
[480.006, "o", "\u001b[?2004l\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n        \"\"\"Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), self.unit / other, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__truediv__(other)\r\n\r\n    def __itruediv__(self, other):\r\n        \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(self.unit / other)\r\n            return self\r\n\r\n        return super().__itruediv__(other)\r\n\r\n    def __rtruediv__(self, other):\r\n        \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            return self._new_view(\r\n                1.0 / self.value, other / self.unit, propagate_info=False\r\n            )\r\n\r\n        return super().__rtruediv__(other)\r\n\r\n    def __pow__(self, other):\r\n        if isinstance(other, Fraction):\r\n            # Avoid getting object arrays by raising the value to a Fraction.\r\n            return self._new_view(\r\n                self.value ** float(other), self.unit**other, propagate_info=False\r\n            )\r\n\r\n        return super().__pow__(other)\r\n\r\n    # other overrides of special functions\r\n    def __hash__(self):\r\n        return hash(self.value) ^ hash(self.unit)\r\n\r\n    def __iter__(self):\r\n        if self.isscalar:\r\n            raise TypeError(\r\n                f\"'{self.__class__.__name__}' object with a scalar value is not\"\r\n                \" iterable\"\r\n            )\r\n\r\n        # Otherwise return a generator\r\n        def quantity_iter():\r\n            for val in self.value:\r\n                yield self._new_view(val)\r\n\r\n        return quantity_iter()\r\n\r\n    def __getitem__(self, key):\r\n        if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\r\n            return self._new_view(\r\n                self.view(np.ndarray)[key], self.unit[key], propagate_info=False\r\n            )\r\n\r\n        try:\r\n            out = super().__getitem__(key)\r\n        except IndexError:\r\n            # We want zero-dimensional Quantity objects to behave like scalars,\r\n"]
[485.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[485.002, "i", "grep -n \"class CompositeUnit\" astropy/units/core.py\r"]
[485.004, "o", "grep -n \"class CompositeUnit\" astropy/units/core.py\r\n"]
[485.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K2311\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass CompositeUnit\u001b[m\u001b[K(UnitBase):\r\n"]
[490.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[490.002, "i", "sed -n '2320,2480p' astropy/units/core.py\r"]
[490.004, "o", "sed -n '2320,2480p' astropy/units/core.py\r\n"]
[490.006, "o", "\u001b[?2004l\r\n    Parameters\r\n    ----------\r\n    scale : number\r\n        A scaling factor for the unit.\r\n\r\n    bases : sequence of `UnitBase`\r\n        A sequence of units this unit is composed of.\r\n\r\n    powers : sequence of numbers\r\n        A sequence of powers (in parallel with ``bases``) for each\r\n        of the base units.\r\n    \"\"\"\r\n\r\n    _decomposed_cache = None\r\n\r\n    def __init__(\r\n        self,\r\n        scale,\r\n        bases,\r\n        powers,\r\n        decompose=False,\r\n        decompose_bases=set(),\r\n        _error_check=True,\r\n    ):\r\n        # There are many cases internal to astropy.units where we\r\n        # already know that all the bases are Unit objects, and the\r\n        # powers have been validated.  In those cases, we can skip the\r\n        # error checking for performance reasons.  When the private\r\n        # kwarg `_error_check` is False, the error checking is turned\r\n        # off.\r\n        if _error_check:\r\n            for base in bases:\r\n                if not isinstance(base, UnitBase):\r\n                    raise TypeError(\"bases must be sequence of UnitBase instances\")\r\n            powers = [validate_power(p) for p in powers]\r\n\r\n        if not decompose and len(bases) == 1 and powers[0] >= 0:\r\n            # Short-cut; with one unit there's nothing to expand and gather,\r\n            # as that has happened already when creating the unit.  But do only\r\n            # positive powers, since for negative powers we need to re-sort.\r\n            unit = bases[0]\r\n            power = powers[0]\r\n            if power == 1:\r\n                scale *= unit.scale\r\n                self._bases = unit.bases\r\n                self._powers = unit.powers\r\n            elif power == 0:\r\n                self._bases = []\r\n                self._powers = []\r\n            else:\r\n                scale *= unit.scale**power\r\n                self._bases = unit.bases\r\n                self._powers = [\r\n                    sanitize_power(operator.mul(*resolve_fractions(p, power)))\r\n                    for p in unit.powers\r\n                ]\r\n\r\n            self._scale = sanitize_scale(scale)\r\n        else:\r\n            # Regular case: use inputs as preliminary scale, bases, and powers,\r\n            # then \"expand and gather\" identical bases, sanitize the scale, &c.\r\n            self._scale = scale\r\n            self._bases = bases\r\n            self._powers = powers\r\n            self._expand_and_gather(decompose=decompose, bases=decompose_bases)\r\n\r\n    def __repr__(self):\r\n        if len(self._bases):\r\n            return super().__repr__()\r\n        else:\r\n            if self._scale != 1.0:\r\n                return f\"Unit(dimensionless with a scale of {self._scale})\"\r\n            else:\r\n                return \"Unit(dimensionless)\"\r\n\r\n    @property\r\n    def scale(self):\r\n        \"\"\"\r\n        Return the scale of the composite unit.\r\n        \"\"\"\r\n        return self._scale\r\n\r\n    @property\r\n    def bases(self):\r\n        \"\"\"\r\n        Return the bases of the composite unit.\r\n        \"\"\"\r\n        return self._bases\r\n\r\n    @property\r\n    def powers(self):\r\n        \"\"\"\r\n        Return the powers of the composite unit.\r\n        \"\"\"\r\n        return self._powers\r\n\r\n    def _expand_and_gather(self, decompose=False, bases=set()):\r\n        def add_unit(unit, power, scale):\r\n            if bases and unit not in bases:\r\n                for base in bases:\r\n                    try:\r\n                        scale *= unit._to(base) ** power\r\n                    except UnitsError:\r\n                        pass\r\n                    else:\r\n                        unit = base\r\n                        break\r\n\r\n            if unit in new_parts:\r\n                a, b = resolve_fractions(new_parts[unit], power)\r\n                new_parts[unit] = a + b\r\n            else:\r\n                new_parts[unit] = power\r\n            return scale\r\n\r\n        new_parts = {}\r\n        scale = self._scale\r\n\r\n        for b, p in zip(self._bases, self._powers):\r\n            if decompose and b not in bases:\r\n                b = b.decompose(bases=bases)\r\n\r\n            if isinstance(b, CompositeUnit):\r\n                scale *= b._scale**p\r\n                for b_sub, p_sub in zip(b._bases, b._powers):\r\n                    a, b = resolve_fractions(p_sub, p)\r\n                    scale = add_unit(b_sub, a * b, scale)\r\n            else:\r\n                scale = add_unit(b, p, scale)\r\n\r\n        new_parts = [x for x in new_parts.items() if x[1] != 0]\r\n        new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\r\n\r\n        self._bases = [x[0] for x in new_parts]\r\n        self._powers = [sanitize_power(x[1]) for x in new_parts]\r\n        self._scale = sanitize_scale(scale)\r\n\r\n    def __copy__(self):\r\n        \"\"\"\r\n        For compatibility with python copy module.\r\n        \"\"\"\r\n        return CompositeUnit(self._scale, self._bases[:], self._powers[:])\r\n\r\n    def decompose(self, bases=set()):\r\n        if len(bases) == 0 and self._decomposed_cache is not None:\r\n            return self._decomposed_cache\r\n\r\n        for base in self.bases:\r\n            if not isinstance(base, IrreducibleUnit) or (\r\n                len(bases) and base not in bases\r\n            ):\r\n                break\r\n        else:\r\n            if len(bases) == 0:\r\n                self._decomposed_cache = self\r\n            return self\r\n\r\n        x = CompositeUnit(\r\n            self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases\r\n        )\r\n        if len(bases) == 0:\r\n"]
[495.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[495.002, "i", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r"]
[495.004, "o", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r\n"]
[495.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                1.40\u00b10.1ms\r\n\r\nWed Oct  1 12:17:17 2025    /tmp/tmpw70p84sv\r\n\r\n         86 function calls in 0.002 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.002    0.002 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.002    0.002 units.py:181(time_quantity_mul)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:1209(__mul__)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:613(__array_ufunc__)\r\n        1    0.001    0.001    0.001    0.001 {function Quantity.__array_ufunc__ at 0x7fb521f50220}\r\n        1    0.000    0.000    0.000    0.000 converters.py:141(converters_and_unit)\r\n        1    0.000    0.000    0.000    0.000 helpers.py:219(helper_multiplication)\r\n        1    0.000    0.000    0.000    0.000 core.py:869(__mul__)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:694(_result_as_quantity)\r\n        1    0.000    0.000    0.000    0.000 core.py:2335(__init__)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:764(_new_view)\r\n        1    0.000    0.000    0.000    0.000 core.py:2416(_expand_and_gather)\r\n        6    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        2    0.000    0.000    0.000    0.000 core.py:2279(is_unity)\r\n        3    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 core.py:2484(is_unity)\r\n        2    0.000    0.000    0.000    0.000 core.py:2417(add_unit)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:574(__array_finalize__)\r\n        1    0.000    0.000    0.000    0.000 converters.py:178(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:945(to_value)\r\n        2    0.000    0.000    0.000    0.000 core.py:2463(decompose)\r\n        1    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 core.py:2069(__call__)\r\n        8    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        1    0.000    0.000    0.000    0.000 utils.py:193(sanitize_scale)\r\n        1    0.000    0.000    0.000    0.000 core.py:2451(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2454(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:836(_set_unit)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        1    0.000    0.000    0.000    0.000 utils.py:328(resolve_fractions)\r\n        5    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        1    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        1    0.000    0.000    0.000    0.000 utils.py:181(is_effectively_unity)\r\n        3    0.000    0.000    0.000    0.000 quantity.py:1009(unit)\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        5    0.000    0.000    0.000    0.000 core.py:2282(__hash__)\r\n        1    0.000    0.000    0.000    0.000 core.py:1874(name)\r\n        1    0.000    0.000    0.000    0.000 core.py:2450(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 core.py:2402(bases)\r\n        3    0.000    0.000    0.000    0.000 converters.py:183(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        2    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        2    0.000    0.000    0.000    0.000 {function Quantity.__array_finalize__ at 0x7fb521f500e0}\r\n        1    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 core.py:2453(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:746(__quantity_subclass__)\r\n        1    0.000    0.000    0.000    0.000 utils.py:288(sanitize_power)\r\n        2    0.000    0.000    0.000    0.000 helpers.py:31(_d)\r\n        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n\r\n\r\n"]
[500.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[500.002, "i", "applypatch << 'PATCH'\r"]
[500.004, "o", "applypatch << 'PATCH'\r\n"]
[500.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> *** Begin Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> *** Update File: astropy/units/core.py\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -        new_parts = [x for x in new_parts.items() if x[1] != 0]\r\n\u001b[?2004l\r\n\u001b[?2004h> -        new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # Collect the unit parts that remain after combination. In the most\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # common cases, the number of parts is 0 or 1 (e.g., pure scale or a\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # single base unit). Avoid an unnecessary sort in those cases to\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # reduce overhead in hot paths (e.g., large array operations where\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # units are combined once per operation).\r\n\u001b[?2004l\r\n\u001b[?2004h> +        new_parts = [x for x in new_parts.items() if x[1] != 0]\r\n\u001b[?2004l\r\n\u001b[?2004h> +        if len(new_parts) > 1:\r\n\u001b[?2004l\r\n\u001b[?2004h> +            new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -        self._scale = sanitize_scale(scale)\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # Fast-path: if the combined scale is exactly unity, avoid the\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # additional checks in sanitize_scale.\r\n\u001b[?2004l\r\n\u001b[?2004h> +        self._scale = 1.0 if scale == 1 or scale == 1.0 else sanitize_scale(scale)\r\n\u001b[?2004l\r\n\u001b[?2004h> *** End Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> PATCH\r\n\u001b[?2004l\r\n-bash: applypatch: command not found\r\n"]
[505.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[505.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[505.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[505.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 26 total benchmarks (1 commits * 1 environments * 26 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  2.83\u00b10ms\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.61\u00b10ms\r\n[ 5.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  1.85\u00b10ms\r\n[ 7.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.70\u00b10ms\r\n[ 9.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.22\u00b10ms\r\n[11.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.48\u00b10ms\r\n[13.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          2.26\u00b10ms\r\n[15.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           1.59\u00b10ms\r\n[17.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  2.18\u00b10ms\r\n[19.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.50\u00b10ms\r\n[21.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.28\u00b10ms\r\n[23.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                1.11\u00b10ms\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.89\u00b10ms\r\n[26.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.81\u00b10ms\r\n[28.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.52\u00b10ms\r\n[30.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          2.12\u00b10ms\r\n[32.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          1.57\u00b10ms\r\n[34.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           1.60\u00b10ms\r\n[36.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  1.28\u00b10ms\r\n[38.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              1.64\u00b10ms\r\n[40.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.13\u00b10ms\r\n[42.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        129\u00b10\u03bcs\r\n[44.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       322\u00b10\u03bcs\r\n[46.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        309\u00b10\u03bcs\r\n[48.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             509\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  95.7\u00b10\u03bcs\r\n"]
[510.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[510.002, "i", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r"]
[510.004, "o", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r\n"]
[510.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                1.85\u00b10.4ms\r\n\r\nWed Oct  1 12:18:23 2025    /tmp/tmp46vm_y0i\r\n\r\n         86 function calls in 0.003 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.003    0.003 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.003    0.003 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.003    0.003 units.py:181(time_quantity_mul)\r\n        1    0.000    0.000    0.003    0.003 quantity.py:1209(__mul__)\r\n        1    0.000    0.000    0.003    0.003 quantity.py:613(__array_ufunc__)\r\n        1    0.002    0.002    0.002    0.002 {function Quantity.__array_ufunc__ at 0x7fc0f5014220}\r\n        1    0.000    0.000    0.000    0.000 converters.py:141(converters_and_unit)\r\n        1    0.000    0.000    0.000    0.000 helpers.py:219(helper_multiplication)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:694(_result_as_quantity)\r\n        1    0.000    0.000    0.000    0.000 core.py:869(__mul__)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:764(_new_view)\r\n        1    0.000    0.000    0.000    0.000 core.py:2335(__init__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2416(_expand_and_gather)\r\n        6    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        3    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 core.py:2279(is_unity)\r\n        2    0.000    0.000    0.000    0.000 core.py:2484(is_unity)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:574(__array_finalize__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2069(__call__)\r\n        2    0.000    0.000    0.000    0.000 core.py:2417(add_unit)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:945(to_value)\r\n        1    0.000    0.000    0.000    0.000 converters.py:178(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 core.py:2463(decompose)\r\n        1    0.000    0.000    0.000    0.000 utils.py:193(sanitize_scale)\r\n        8    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        1    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 core.py:2451(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2454(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:836(_set_unit)\r\n        1    0.000    0.000    0.000    0.000 core.py:2450(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        3    0.000    0.000    0.000    0.000 quantity.py:1009(unit)\r\n        1    0.000    0.000    0.000    0.000 utils.py:181(is_effectively_unity)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        5    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        1    0.000    0.000    0.000    0.000 utils.py:328(resolve_fractions)\r\n        5    0.000    0.000    0.000    0.000 core.py:2282(__hash__)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        1    0.000    0.000    0.000    0.000 core.py:1874(name)\r\n        2    0.000    0.000    0.000    0.000 core.py:2402(bases)\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        3    0.000    0.000    0.000    0.000 converters.py:183(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2453(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:746(__quantity_subclass__)\r\n        2    0.000    0.000    0.000    0.000 {function Quantity.__array_finalize__ at 0x7fc0f50140e0}\r\n        2    0.000    0.000    0.000    0.000 helpers.py:31(_d)\r\n        1    0.000    0.000    0.000    0.000 utils.py:288(sanitize_power)\r\n        2    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n\r\n\r\n"]
[515.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[515.002, "i", "applypatch << 'PATCH'\r"]
[515.004, "o", "applypatch << 'PATCH'\r\n"]
[515.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> *** Begin Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> *** Update File: astropy/units/core.py\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -        self._bases = [x[0] for x in new_parts]\r\n\u001b[?2004l\r\n\u001b[?2004h> -        self._powers = [sanitize_power(x[1]) for x in new_parts]\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # Extract bases and powers. Avoid calling sanitize_power for the\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # common case of integer powers to reduce overhead on hot paths.\r\n\u001b[?2004l\r\n\u001b[?2004h> +        self._bases = [x[0] for x in new_parts]\r\n\u001b[?2004l\r\n\u001b[?2004h> +        self._powers = [\r\n\u001b[?2004l\r\n\u001b[?2004h> +            (p if isinstance(p, int) else sanitize_power(p)) for _, p in new_parts\r\n\u001b[?2004l\r\n\u001b[?2004h> +        ]\r\n\u001b[?2004l\r\n\u001b[?2004h> *** End Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> PATCH\r\n\u001b[?2004l\r\n-bash: applypatch: command not found\r\n"]
[520.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[520.002, "i", "cat asv.ci.conf.json\r"]
[520.004, "o", "cat asv.ci.conf.json\r\n"]
[520.006, "o", "\u001b[?2004l\r\n {\r\n   \"version\": 1,\r\n   \"project\": \"astropy\",\r\n   \"project_url\": \"http://www.astropy.org/\",\r\n   \"repo\": \".\",\r\n   \"install_command\": [\r\n     \"pip install . matplotlib scipy\"\r\n   ],\r\n   \"branches\": [\"main\"],\r\n   \"show_commit_url\": \"http://github.com/astropy/astropy/commit/\",\r\n   \"pythons\": [\"3.11\"],\r\n   \"environment_type\": \"virtualenv\",\r\n   \"benchmark_dir\": \"astropy-benchmarks/benchmarks\"\r\n }\r\n"]
[525.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[525.002, "i", "grep -R \"compose\" -n astropy-benchmarks/benchmarks || true\r"]
[525.004, "o", "grep -R \"compose\" -n astropy-benchmarks/benchmarks || true\r\n"]
[525.006, "o", "\u001b[?2004l\r\n\u001b[35m\u001b[Kastropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K10\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kdef time_unit_\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K():\r\n\u001b[35m\u001b[Kastropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K11\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    u.Ry.\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K()\r\n\u001b[35m\u001b[Kastropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K34\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kdef time_\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K_to_bases():\r\n\u001b[35m\u001b[Kastropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K39\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kdef time_\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K_complex():\r\n\u001b[35m\u001b[Kastropy-benchmarks/benchmarks/units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K41\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K()\r\ngrep: astropy-benchmarks/benchmarks/__pycache__/units.cpython-311.pyc: binary file matches\r\n"]
[530.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[530.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[530.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[530.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*|units.time_unit_compose.*|units.time_compose_to_bases.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 28 total benchmarks (1 commits * 1 environments * 28 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.79%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  2.14\u00b10ms\r\n[ 3.57%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.01\u00b10ms\r\n[ 5.36%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  1.71\u00b10ms\r\n[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.96\u00b10ms\r\n[ 8.93%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.31\u00b10ms\r\n[10.71%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.44\u00b10ms\r\n[12.50%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          2.90\u00b10ms\r\n[14.29%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           1.75\u00b10ms\r\n[16.07%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  2.35\u00b10ms\r\n[17.86%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.37\u00b10ms\r\n[19.64%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.33\u00b10ms\r\n[21.43%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                1.14\u00b10ms\r\n[23.21%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.80\u00b10ms\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.56\u00b10ms\r\n[26.79%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.21\u00b10ms\r\n[28.57%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          1.42\u00b10ms\r\n[30.36%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          1.44\u00b10ms\r\n[32.14%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           1.56\u00b10ms\r\n[33.93%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  1.49\u00b10ms\r\n[35.71%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              1.38\u00b10ms\r\n[37.50%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_compose_to_bases\u001b[0m                                                                                                               2.16\u00b10ms\r\n[39.29%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.11\u00b10ms\r\n[41.07%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        129\u00b10\u03bcs\r\n[42.86%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       296\u00b10\u03bcs\r\n[44.64%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        314\u00b10\u03bcs\r\n[46.43%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             563\u00b10\u03bcs\r\n[48.21%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  88.8\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_unit_compose\u001b[0m                                                                                                                   1.17\u00b10ms\r\n"]
[535.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[535.002, "i", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r"]
[535.004, "o", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r\n"]
[535.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                1.63\u00b10.1ms\r\n\r\nWed Oct  1 12:21:03 2025    /tmp/tmp5jqzouvd\r\n\r\n         86 function calls in 0.002 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.002    0.002 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.002    0.002 units.py:181(time_quantity_mul)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:1209(__mul__)\r\n        1    0.000    0.000    0.002    0.002 quantity.py:613(__array_ufunc__)\r\n        1    0.001    0.001    0.001    0.001 {function Quantity.__array_ufunc__ at 0x7f552dcdc220}\r\n        1    0.000    0.000    0.000    0.000 converters.py:141(converters_and_unit)\r\n        1    0.000    0.000    0.000    0.000 helpers.py:219(helper_multiplication)\r\n        1    0.000    0.000    0.000    0.000 core.py:869(__mul__)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:694(_result_as_quantity)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:764(_new_view)\r\n        1    0.000    0.000    0.000    0.000 core.py:2335(__init__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2416(_expand_and_gather)\r\n        6    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        2    0.000    0.000    0.000    0.000 core.py:2279(is_unity)\r\n        1    0.000    0.000    0.000    0.000 core.py:2069(__call__)\r\n        3    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 core.py:2417(add_unit)\r\n        2    0.000    0.000    0.000    0.000 core.py:2484(is_unity)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:574(__array_finalize__)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:945(to_value)\r\n        2    0.000    0.000    0.000    0.000 core.py:2463(decompose)\r\n        1    0.000    0.000    0.000    0.000 converters.py:178(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 utils.py:193(sanitize_scale)\r\n        8    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        1    0.000    0.000    0.000    0.000 core.py:2451(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2454(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        1    0.000    0.000    0.000    0.000 core.py:2450(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:836(_set_unit)\r\n        5    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        1    0.000    0.000    0.000    0.000 utils.py:328(resolve_fractions)\r\n        3    0.000    0.000    0.000    0.000 quantity.py:1009(unit)\r\n        5    0.000    0.000    0.000    0.000 core.py:2282(__hash__)\r\n        1    0.000    0.000    0.000    0.000 utils.py:181(is_effectively_unity)\r\n        1    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        1    0.000    0.000    0.000    0.000 core.py:1874(name)\r\n        3    0.000    0.000    0.000    0.000 converters.py:183(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        2    0.000    0.000    0.000    0.000 core.py:2402(bases)\r\n        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        2    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 utils.py:288(sanitize_power)\r\n        2    0.000    0.000    0.000    0.000 {function Quantity.__array_finalize__ at 0x7f552dcdc0e0}\r\n        1    0.000    0.000    0.000    0.000 core.py:2453(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 helpers.py:31(_d)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:746(__quantity_subclass__)\r\n\r\n\r\n"]
[540.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[540.002, "i", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r"]
[540.004, "o", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r\n"]
[540.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[545.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[545.002, "i", "sed -n '260,520p' astropy-benchmarks/benchmarks/units.py\r"]
[545.004, "o", "sed -n '260,520p' astropy-benchmarks/benchmarks/units.py\r\n"]
[545.006, "o", "\u001b[?2004l\r\n"]
[550.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[550.002, "i", "grep -n \"compose\" -n astropy-benchmarks/benchmarks/units.py || true\r"]
[550.004, "o", "grep -n \"compose\" -n astropy-benchmarks/benchmarks/units.py || true\r\n"]
[550.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K10\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kdef time_unit_\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K():\r\n\u001b[32m\u001b[K11\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    u.Ry.\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K34\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kdef time_\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K_to_bases():\r\n\u001b[32m\u001b[K39\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kdef time_\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K_complex():\r\n\u001b[32m\u001b[K41\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).\u001b[01;31m\u001b[Kcompose\u001b[m\u001b[K()\r\n"]
[555.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[555.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[555.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[555.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 26 total benchmarks (1 commits * 1 environments * 26 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  2.31\u00b10ms\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.20\u00b10ms\r\n[ 5.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  1.40\u00b10ms\r\n[ 7.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.21\u00b10ms\r\n[ 9.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.09\u00b10ms\r\n[11.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.88\u00b10ms\r\n[13.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          2.63\u00b10ms\r\n[15.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           1.51\u00b10ms\r\n[17.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  2.38\u00b10ms\r\n[19.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.44\u00b10ms\r\n[21.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.37\u00b10ms\r\n[23.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                1.20\u00b10ms\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.52\u00b10ms\r\n[26.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.37\u00b10ms\r\n[28.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.18\u00b10ms\r\n[30.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          1.38\u00b10ms\r\n[32.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          1.28\u00b10ms\r\n[34.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           1.39\u00b10ms\r\n[36.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  1.78\u00b10ms\r\n[38.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              1.75\u00b10ms\r\n[40.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.19\u00b10ms\r\n[42.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        138\u00b10\u03bcs\r\n[44.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       339\u00b10\u03bcs\r\n[46.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        341\u00b10\u03bcs\r\n[48.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             691\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  99.8\u00b10\u03bcs\r\n"]
[560.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[560.002, "i", "grep -n \"def __mul__\" astropy/units/quantity.py\r"]
[560.004, "o", "grep -n \"def __mul__\" astropy/units/quantity.py\r\n"]
[560.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K1209\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __mul__\u001b[m\u001b[K(self, other):\r\n"]
[565.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[565.002, "i", "sed -n '1180,1235p' astropy/units/quantity.py\r"]
[565.004, "o", "sed -n '1180,1235p' astropy/units/quantity.py\r\n"]
[565.006, "o", "\u001b[?2004l\r\n            return NotImplemented\r\n\r\n        self._set_unit(other)\r\n        return self\r\n\r\n    def __rlshift__(self, other):\r\n        if not self.isscalar:\r\n            return NotImplemented\r\n        return Unit(self).__rlshift__(other)\r\n\r\n    # Give warning for other >> self, since probably other << self was meant.\r\n    def __rrshift__(self, other):\r\n        warnings.warn(\r\n            \">> is not implemented. Did you mean to convert \"\r\n            \"something to this quantity as a unit using '<<'?\",\r\n            AstropyWarning,\r\n        )\r\n        return NotImplemented\r\n\r\n    # Also define __rshift__ and __irshift__ so we override default ndarray\r\n    # behaviour, but instead of emitting a warning here, let it be done by\r\n    # other (which likely is a unit if this was a mistake).\r\n    def __rshift__(self, other):\r\n        return NotImplemented\r\n\r\n    def __irshift__(self, other):\r\n        return NotImplemented\r\n\r\n    # Arithmetic operations\r\n    def __mul__(self, other):\r\n        \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            try:\r\n                return self._new_view(\r\n                    self.value.copy(), other * self.unit, propagate_info=False\r\n                )\r\n            except UnitsError:  # let other try to deal with it\r\n                return NotImplemented\r\n\r\n        return super().__mul__(other)\r\n\r\n    def __imul__(self, other):\r\n        \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\r\n        if isinstance(other, (UnitBase, str)):\r\n            self._set_unit(other * self.unit)\r\n            return self\r\n\r\n        return super().__imul__(other)\r\n\r\n    def __rmul__(self, other):\r\n        \"\"\"\r\n        Right Multiplication between `Quantity` objects and other objects.\r\n        \"\"\"\r\n        return self.__mul__(other)\r\n\r\n    def __truediv__(self, other):\r\n"]
[570.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[570.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[570.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[570.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 26 total benchmarks (1 commits * 1 environments * 26 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  2.84\u00b10ms\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.42\u00b10ms\r\n[ 5.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  1.87\u00b10ms\r\n[ 7.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.98\u00b10ms\r\n[ 9.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.76\u00b10ms\r\n[11.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.72\u00b10ms\r\n[13.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          2.38\u00b10ms\r\n[15.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           1.55\u00b10ms\r\n[17.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  2.53\u00b10ms\r\n[19.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.65\u00b10ms\r\n[21.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.36\u00b10ms\r\n[23.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                1.45\u00b10ms\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.84\u00b10ms\r\n[26.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.80\u00b10ms\r\n[28.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.91\u00b10ms\r\n[30.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          1.95\u00b10ms\r\n[32.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          3.40\u00b10ms\r\n[34.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           1.93\u00b10ms\r\n[36.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  1.89\u00b10ms\r\n[38.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              1.40\u00b10ms\r\n[40.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.24\u00b10ms\r\n[42.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        133\u00b10\u03bcs\r\n[44.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       312\u00b10\u03bcs\r\n[46.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        302\u00b10\u03bcs\r\n[48.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             575\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  85.6\u00b10\u03bcs\r\n"]
[575.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[575.002, "i", "asv show --config asv.ci.conf.json\r"]
[575.004, "o", "asv show --config asv.ci.conf.json\r\n"]
[575.006, "o", "\u001b[?2004l\r\nCommits with results:\r\n\r\n"]
[580.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[580.002, "i", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r"]
[580.004, "o", "asv profile --config asv.ci.conf.json --python=same units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\r\n"]
[580.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                               1.28\u00b10.04ms\r\n\r\nWed Oct  1 12:25:02 2025    /tmp/tmpfutvpxk0\r\n\r\n         86 function calls in 0.002 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.001    0.001 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.001    0.001 units.py:181(time_quantity_mul)\r\n        1    0.000    0.000    0.001    0.001 quantity.py:1209(__mul__)\r\n        1    0.000    0.000    0.001    0.001 quantity.py:613(__array_ufunc__)\r\n        1    0.001    0.001    0.001    0.001 {function Quantity.__array_ufunc__ at 0x7ffa02f44220}\r\n        1    0.000    0.000    0.000    0.000 converters.py:141(converters_and_unit)\r\n        1    0.000    0.000    0.000    0.000 helpers.py:219(helper_multiplication)\r\n        1    0.000    0.000    0.000    0.000 core.py:869(__mul__)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:694(_result_as_quantity)\r\n        1    0.000    0.000    0.000    0.000 quantity.py:764(_new_view)\r\n        1    0.000    0.000    0.000    0.000 core.py:2335(__init__)\r\n        1    0.000    0.000    0.000    0.000 core.py:2416(_expand_and_gather)\r\n        3    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        6    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        2    0.000    0.000    0.000    0.000 core.py:2279(is_unity)\r\n        1    0.000    0.000    0.000    0.000 core.py:2069(__call__)\r\n        2    0.000    0.000    0.000    0.000 core.py:2417(add_unit)\r\n        2    0.000    0.000    0.000    0.000 core.py:2484(is_unity)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:574(__array_finalize__)\r\n        1    0.000    0.000    0.000    0.000 converters.py:178(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 quantity.py:945(to_value)\r\n        1    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}\r\n        8    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        2    0.000    0.000    0.000    0.000 core.py:2463(decompose)\r\n        1    0.000    0.000    0.000    0.000 utils.py:193(sanitize_scale)\r\n        1    0.000    0.000    0.000    0.000 core.py:2450(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2454(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 core.py:2451(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        1    0.000    0.000    0.000    0.000 quantity.py:836(_set_unit)\r\n        5    0.000    0.000    0.000    0.000 core.py:2282(__hash__)\r\n        1    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        5    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        3    0.000    0.000    0.000    0.000 quantity.py:1009(unit)\r\n        1    0.000    0.000    0.000    0.000 utils.py:328(resolve_fractions)\r\n        1    0.000    0.000    0.000    0.000 utils.py:181(is_effectively_unity)\r\n        3    0.000    0.000    0.000    0.000 converters.py:183(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 core.py:1874(name)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        2    0.000    0.000    0.000    0.000 core.py:2402(bases)\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        2    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 utils.py:288(sanitize_power)\r\n        1    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 core.py:2453(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 helpers.py:31(_d)\r\n        2    0.000    0.000    0.000    0.000 {function Quantity.__array_finalize__ at 0x7ffa02f440e0}\r\n        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 quantity.py:746(__quantity_subclass__)\r\n\r\n\r\n"]
[585.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[585.002, "i", "applypatch << 'PATCH'\r"]
[585.004, "o", "applypatch << 'PATCH'\r\n"]
[585.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> *** Begin Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> *** Update File: astropy/units/core.py\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -        # Extract bases and powers. Avoid calling sanitize_power for the\r\n\u001b[?2004l\r\n\u001b[?2004h> -        # common case of integer powers to reduce overhead on hot paths.\r\n\u001b[?2004l\r\n\u001b[?2004h> -        self._bases = [x[0] for x in new_parts]\r\n\u001b[?2004l\r\n\u001b[?2004h> -        self._powers = [\r\n\u001b[?2004l\r\n\u001b[?2004h> -            (p if isinstance(p, int) else sanitize_power(p)) for _, p in new_parts\r\n\u001b[?2004l\r\n\u001b[?2004h> -        ]\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # Extract bases and powers. Avoid calling sanitize_power for the\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # common case of integer powers to reduce overhead on hot paths.\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # Be careful not to treat booleans as powers (bool is a subclass of int);\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # also include NumPy integer types.\r\n\u001b[?2004l\r\n\u001b[?2004h> +        self._bases = [x[0] for x in new_parts]\r\n\u001b[?2004l\r\n\u001b[?2004h> +        self._powers = []\r\n\u001b[?2004l\r\n\u001b[?2004h> +        for _, p in new_parts:\r\n\u001b[?2004l\r\n\u001b[?2004h> +            if (isinstance(p, (int, np.integer)) and not isinstance(p, (bool, np.bool_))):\r\n\u001b[?2004l\r\n\u001b[?2004h> +                self._powers.append(p)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            else:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                self._powers.append(sanitize_power(p))\r\n\u001b[?2004l\r\n\u001b[?2004h> *** End Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> PATCH\r\n\u001b[?2004l\r\n-bash: applypatch: command not found\r\n"]
[590.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[590.002, "i", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r"]
[590.004, "o", "sed -n '1,260p' astropy-benchmarks/benchmarks/units.py\r\n"]
[590.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[595.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[595.002, "i", "sed -n '260,520p' astropy-benchmarks/benchmarks/units.py\r"]
[595.004, "o", "sed -n '260,520p' astropy-benchmarks/benchmarks/units.py\r\n"]
[595.006, "o", "\u001b[?2004l\r\n"]
[600.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[600.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[600.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[600.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 26 total benchmarks (1 commits * 1 environments * 26 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  2.32\u00b10ms\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.00\u00b10ms\r\n[ 5.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  1.33\u00b10ms\r\n[ 7.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.15\u00b10ms\r\n[ 9.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.14\u00b10ms\r\n[11.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.34\u00b10ms\r\n[13.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          2.35\u00b10ms\r\n[15.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           1.75\u00b10ms\r\n[17.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  2.27\u00b10ms\r\n[19.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.42\u00b10ms\r\n[21.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.28\u00b10ms\r\n[23.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                 975\u00b10\u03bcs\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.32\u00b10ms\r\n[26.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.17\u00b10ms\r\n[28.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.09\u00b10ms\r\n[30.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          1.34\u00b10ms\r\n[32.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          1.19\u00b10ms\r\n[34.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           1.59\u00b10ms\r\n[36.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  2.09\u00b10ms\r\n[38.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              1.77\u00b10ms\r\n[40.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.28\u00b10ms\r\n[42.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        152\u00b10\u03bcs\r\n[44.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       486\u00b10\u03bcs\r\n[46.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        329\u00b10\u03bcs\r\n[48.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             546\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  90.1\u00b10\u03bcs\r\n"]
[605.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[605.002, "i", "asv show --config asv.ci.conf.json\r"]
[605.004, "o", "asv show --config asv.ci.conf.json\r\n"]
[605.006, "o", "\u001b[?2004l\r\nCommits with results:\r\n\r\n"]
[610.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[610.002, "i", "sed -n '1,240p' astropy-benchmarks/benchmarks/units.py\r"]
[610.004, "o", "sed -n '1,240p' astropy-benchmarks/benchmarks/units.py\r\n"]
[610.006, "o", "\u001b[?2004l\r\nimport copy\r\n\r\nimport numpy as np\r\nfrom astropy import units as u\r\n\r\n\r\n# Unit tests\r\n\r\n\r\ndef time_unit_compose():\r\n    u.Ry.compose()\r\n\r\n\r\ndef time_unit_to():\r\n    u.m.to(u.pc)\r\n\r\n\r\ndef time_unit_parse():\r\n    u.Unit(\"1e-07 kg m2 / s2\")\r\n\r\n\r\ndef time_simple_unit_parse():\r\n    u.Unit(\"1 d\")\r\n\r\n\r\ndef time_very_simple_unit_parse():\r\n    u.Unit(\"d\")\r\n\r\n\r\ndef mem_unit():\r\n    return u.erg\r\n\r\n\r\ndef time_compose_to_bases():\r\n    x = copy.copy(u.Ry)\r\n    x.cgs\r\n\r\n\r\ndef time_compose_complex():\r\n    # Composing a complex unit can be very inefficient\r\n    (u.kg / u.s**3 * u.au**2.5 / u.yr**0.5 / u.sr**2).compose()\r\n\r\n\r\n# Quantity tests\r\n\r\na = np.arange(100000.0)\r\nb1 = [1.0, 2.0, 3.0]\r\nb2 = np.asarray(b1)\r\nq0 = u.Quantity(1.0, u.s)\r\nq1 = u.Quantity(a, u.m)\r\nq2 = u.Quantity(a[:10000], u.deg)\r\n\r\n\r\ndef time_quantity_creation():\r\n    u.Quantity(a, u.m)\r\n\r\n\r\ndef time_quantity_creation_nocopy():\r\n    u.Quantity(a, u.m, copy=False)\r\n\r\n\r\ndef time_quantity_view():\r\n    q1.view(u.Quantity)\r\n\r\n\r\ndef time_quantity_init_scalar():\r\n    3.0 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_array():\r\n    a * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_list():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small list.\r\n    \"\"\"\r\n    b1 * u.m / u.s\r\n\r\n\r\ndef time_quantity_init_small_array():\r\n    \"\"\"\r\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\r\n    for small array.\r\n    \"\"\"\r\n    b2 * u.m / u.s\r\n\r\n\r\ndef time_quantity_scalar_conversion():\r\n    (3.0 * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_array_conversion():\r\n    (a * u.m / u.s).to(u.km / u.hour)\r\n\r\n\r\ndef time_quantity_times_unit():\r\n    q1 * u.m\r\n\r\n\r\ndef time_quantity_times_quantity():\r\n    q1 * q0\r\n\r\n\r\ndef time_quantity_ufunc_sin():\r\n    np.sin(q2)\r\n\r\n\r\nclass TimeQuantityOpSmallArray:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for a small Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n    def time_quantity_square(self):\r\n        self.data**2\r\n\r\n    def time_quantity_np_square(self):\r\n        np.power(self.data, 2)\r\n\r\n    def time_quantity_np_square_out(self):\r\n        np.power(self.data, 2, out=self.out_sq)\r\n\r\n    def time_quantity_sqrt(self):\r\n        self.data**0.5\r\n\r\n    def time_quantity_np_sqrt(self):\r\n        np.sqrt(self.data)\r\n\r\n    def time_quantity_np_sqrt_out(self):\r\n        np.sqrt(self.data, out=self.out_sqrt)\r\n\r\n\r\nclass TimeQuantityOpLargeArray(TimeQuantityOpSmallArray):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArray` but for a large Numpy array.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.out_sq = data * u.g**2\r\n        self.out_sqrt = data * u.g**0.5\r\n\r\n\r\nclass TimeQuantityOpSmallArrayDiffUnit:\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with different units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n    def time_quantity_equal(self):\r\n        # Same as operator.eq\r\n        self.data == self.data2\r\n\r\n    def time_quantity_np_equal(self):\r\n        np.equal(self.data, self.data2)\r\n\r\n    def time_quantity_truediv(self):\r\n        # Since benchmark is PY3 only, this is always true divide.\r\n        # Same as operator.truediv\r\n        self.data / self.data2\r\n\r\n    def time_quantity_np_truediv(self):\r\n        np.true_divide(self.data, self.data2)\r\n\r\n    def time_quantity_mul(self):\r\n        # Same as operator.mul\r\n        self.data * self.data2\r\n\r\n    def time_quantity_np_multiply(self):\r\n        np.multiply(self.data, self.data2)\r\n\r\n    def time_quantity_sub(self):\r\n        # Same as operator.sub\r\n        self.data - self.data2\r\n\r\n    def time_quantity_np_subtract(self):\r\n        np.subtract(self.data, self.data2)\r\n\r\n    def time_quantity_add(self):\r\n        # Same as operator.add\r\n        self.data + self.data2\r\n\r\n    def time_quantity_np_add(self):\r\n        np.add(self.data, self.data2)\r\n\r\n\r\nclass TimeQuantityOpSmallArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Operator benchmarks from https://github.com/astropy/astropy/issues/7546\r\n    for small Numpy arrays with same units.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.array([1.0, 2.0, 3.0])\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n\r\n\r\nclass TimeQuantityOpLargeArrayDiffUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArrayDiffUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n\r\n        # A different but dimensionally compatible unit\r\n        self.data2 = 0.001 * data * u.kg\r\n\r\n\r\nclass TimeQuantityOpLargeArraySameUnit(TimeQuantityOpSmallArrayDiffUnit):\r\n    \"\"\"\r\n    Like :class:`TimeQuantityOpSmallArraySameUnit` but for large Numpy arrays.\r\n    \"\"\"\r\n\r\n    def setup(self):\r\n        data = np.arange(1e6) + 1\r\n        self.data = data * u.g\r\n        self.data2 = self.data.copy()\r\n"]
[615.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[615.002, "i", "sed -n '240,520p' astropy-benchmarks/benchmarks/units.py\r"]
[615.004, "o", "sed -n '240,520p' astropy-benchmarks/benchmarks/units.py\r\n"]
[615.006, "o", "\u001b[?2004l\r\n"]
[620.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[620.002, "i", "grep -n \"def __new__\" astropy/units/quantity.py\r"]
[620.004, "o", "grep -n \"def __new__\" astropy/units/quantity.py\r\n"]
[620.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K426\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __new__\u001b[m\u001b[K(\r\n"]
[625.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[625.002, "i", "sed -n '1,220p' astropy/units/quantity.py\r"]
[625.004, "o", "sed -n '1,220p' astropy/units/quantity.py\r\n"]
[625.006, "o", "\u001b[?2004l\r\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\r\n\"\"\"\r\nThis module defines the `Quantity` object, which represents a number with some\r\nassociated units. `Quantity` objects support operations like ordinary numbers,\r\nbut will deal with unit conversions internally.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport builtins\r\nimport numbers\r\nimport operator\r\nimport re\r\nimport warnings\r\nfrom fractions import Fraction\r\nfrom typing import TYPE_CHECKING\r\n\r\nimport numpy as np\r\n\r\nfrom astropy import config as _config\r\nfrom astropy.utils.compat.numpycompat import COPY_IF_NEEDED, NUMPY_LT_2_0\r\nfrom astropy.utils.data_info import ParentDtypeInfo\r\nfrom astropy.utils.exceptions import AstropyWarning\r\n\r\nfrom .core import (\r\n    Unit,\r\n    UnitBase,\r\n    UnitConversionError,\r\n    UnitsError,\r\n    UnitTypeError,\r\n    dimensionless_unscaled,\r\n    get_current_unit_registry,\r\n)\r\nfrom .format import Base, Latex\r\nfrom .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\r\nfrom .quantity_helper.function_helpers import (\r\n    DISPATCHED_FUNCTIONS,\r\n    FUNCTION_HELPERS,\r\n    SUBCLASS_SAFE_FUNCTIONS,\r\n    UNSUPPORTED_FUNCTIONS,\r\n)\r\nfrom .structured import StructuredUnit, _structured_unit_like_dtype\r\nfrom .utils import is_effectively_unity\r\n\r\nif TYPE_CHECKING:\r\n    from typing_extensions import Self\r\n\r\n    from .typing import QuantityLike\r\n\r\n__all__ = [\r\n    \"Quantity\",\r\n    \"SpecificTypeQuantity\",\r\n    \"QuantityInfoBase\",\r\n    \"QuantityInfo\",\r\n    \"allclose\",\r\n    \"isclose\",\r\n]\r\n\r\n\r\n# We don't want to run doctests in the docstrings we inherit from Numpy\r\n__doctest_skip__ = [\"Quantity.*\"]\r\n\r\n_UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\r\n_UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\r\n\r\n\r\nclass Conf(_config.ConfigNamespace):\r\n    \"\"\"\r\n    Configuration parameters for Quantity.\r\n    \"\"\"\r\n\r\n    latex_array_threshold = _config.ConfigItem(\r\n        100,\r\n        \"The maximum size an array Quantity can be before its LaTeX \"\r\n        'representation for IPython gets \"summarized\" (meaning only the first '\r\n        'and last few elements are shown with \"...\" between). Setting this to a '\r\n        \"negative number means that the value will instead be whatever numpy \"\r\n        \"gets from get_printoptions.\",\r\n    )\r\n\r\n\r\nconf = Conf()\r\n\r\n\r\nclass QuantityIterator:\r\n    \"\"\"\r\n    Flat iterator object to iterate over Quantities.\r\n\r\n    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\r\n    ``q``.  It allows iterating over the array as if it were a 1-D array,\r\n    either in a for-loop or by calling its `next` method.\r\n\r\n    Iteration is done in C-contiguous style, with the last index varying the\r\n    fastest. The iterator can also be indexed using basic slicing or\r\n    advanced indexing.\r\n\r\n    See Also\r\n    --------\r\n    Quantity.flatten : Returns a flattened copy of an array.\r\n\r\n    Notes\r\n    -----\r\n    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\r\n    is not exported by the `~astropy.units` module.  Instead of\r\n    instantiating a `QuantityIterator` directly, use `Quantity.flat`.\r\n    \"\"\"\r\n\r\n    def __init__(self, q):\r\n        self._quantity = q\r\n        self._dataiter = q.view(np.ndarray).flat\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __getitem__(self, indx):\r\n        out = self._dataiter.__getitem__(indx)\r\n        # For single elements, ndarray.flat.__getitem__ returns scalars; these\r\n        # need a new view as a Quantity.\r\n        if isinstance(out, type(self._quantity)):\r\n            return out\r\n        else:\r\n            return self._quantity._new_view(out)\r\n\r\n    def __setitem__(self, index, value):\r\n        self._dataiter[index] = self._quantity._to_own_unit(value)\r\n\r\n    def __next__(self):\r\n        \"\"\"\r\n        Return the next value, or raise StopIteration.\r\n        \"\"\"\r\n        out = next(self._dataiter)\r\n        # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\r\n        return self._quantity._new_view(out)\r\n\r\n    next = __next__\r\n\r\n    def __len__(self):\r\n        return len(self._dataiter)\r\n\r\n    # Properties and methods to match `numpy.ndarray.flatiter`\r\n\r\n    @property\r\n    def base(self):\r\n        \"\"\"A reference to the array that is iterated over.\"\"\"\r\n        return self._quantity\r\n\r\n    @property\r\n    def coords(self):\r\n        \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\r\n        return self._dataiter.coords\r\n\r\n    @property\r\n    def index(self):\r\n        \"\"\"Current flat index into the array.\"\"\"\r\n        return self._dataiter.index\r\n\r\n    def copy(self):\r\n        \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\r\n        return self._quantity.flatten()\r\n\r\n\r\nclass QuantityInfoBase(ParentDtypeInfo):\r\n    # This is on a base class rather than QuantityInfo directly, so that\r\n    # it can be used for EarthLocationInfo yet make clear that that class\r\n    # should not be considered a typical Quantity subclass by Table.\r\n    attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\r\n    _supports_indexing = True\r\n\r\n    @staticmethod\r\n    def default_format(val):\r\n        return f\"{val.value}\"\r\n\r\n    @staticmethod\r\n    def possible_string_format_functions(format_):\r\n        \"\"\"Iterate through possible string-derived format functions.\r\n\r\n        A string can either be a format specifier for the format built-in,\r\n        a new-style format string, or an old-style format string.\r\n\r\n        This method is overridden in order to suppress printing the unit\r\n        in each row since it is already at the top in the column header.\r\n        \"\"\"\r\n        yield lambda format_, val: format(val.value, format_)\r\n        yield lambda format_, val: format_.format(val.value)\r\n        yield lambda format_, val: format_ % val.value\r\n\r\n\r\nclass QuantityInfo(QuantityInfoBase):\r\n    \"\"\"\r\n    Container for meta information like name, description, format.  This is\r\n    required when the object is used as a mixin column within a table, but can\r\n    be used as a general way to store meta information.\r\n    \"\"\"\r\n\r\n    _represent_as_dict_attrs = (\"value\", \"unit\")\r\n    _construct_from_dict_args = [\"value\"]\r\n    _represent_as_dict_primary_data = \"value\"\r\n\r\n    def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\r\n        \"\"\"\r\n        Return a new Quantity instance which is consistent with the\r\n        input ``cols`` and has ``length`` rows.\r\n\r\n        This is intended for creating an empty column object whose elements can\r\n        be set in-place for table operations like join or vstack.\r\n\r\n        Parameters\r\n        ----------\r\n        cols : list\r\n            List of input columns\r\n        length : int\r\n            Length of the output column object\r\n        metadata_conflicts : str ('warn'|'error'|'silent')\r\n            How to handle metadata conflicts\r\n        name : str\r\n            Output column name\r\n\r\n        Returns\r\n        -------\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n"]
[630.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[630.002, "i", "sed -n '220,560p' astropy/units/quantity.py\r"]
[630.004, "o", "sed -n '220,560p' astropy/units/quantity.py\r\n"]
[630.006, "o", "\u001b[?2004l\r\n        col : `~astropy.units.Quantity` (or subclass)\r\n            Empty instance of this class consistent with ``cols``\r\n\r\n        \"\"\"\r\n        # Get merged info attributes like shape, dtype, format, description, etc.\r\n        attrs = self.merge_cols_attributes(\r\n            cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\r\n        )\r\n\r\n        # Make an empty quantity using the unit of the last one.\r\n        shape = (length,) + attrs.pop(\"shape\")\r\n        dtype = attrs.pop(\"dtype\")\r\n        # Use zeros so we do not get problems for Quantity subclasses such\r\n        # as Longitude and Latitude, which cannot take arbitrary values.\r\n        data = np.zeros(shape=shape, dtype=dtype)\r\n        # Get arguments needed to reconstruct class\r\n        map = {\r\n            key: (data if key == \"value\" else getattr(cols[-1], key))\r\n            for key in self._represent_as_dict_attrs\r\n        }\r\n        map[\"copy\"] = COPY_IF_NEEDED\r\n        out = self._construct_from_dict(map)\r\n\r\n        # Set remaining info attributes\r\n        for attr, value in attrs.items():\r\n            setattr(out.info, attr, value)\r\n\r\n        return out\r\n\r\n    def get_sortable_arrays(self):\r\n        \"\"\"\r\n        Return a list of arrays which can be lexically sorted to represent\r\n        the order of the parent column.\r\n\r\n        For Quantity this is just the quantity itself.\r\n\r\n\r\n        Returns\r\n        -------\r\n        arrays : list of ndarray\r\n        \"\"\"\r\n        return [self._parent]\r\n\r\n\r\nclass Quantity(np.ndarray):\r\n    \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\r\n\r\n    See also: https://docs.astropy.org/en/stable/units/quantity.html\r\n\r\n    Parameters\r\n    ----------\r\n    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\r\n        The numerical value of this quantity in the units given by unit.  If a\r\n        `Quantity` or sequence of them (or any other valid object with a\r\n        ``unit`` attribute), creates a new `Quantity` object, converting to\r\n        `unit` units as needed.  If a string, it is converted to a number or\r\n        `Quantity`, depending on whether a unit is present.\r\n\r\n    unit : unit-like\r\n        An object that represents the unit associated with the input value.\r\n        Must be an `~astropy.units.UnitBase` object or a string parseable by\r\n        the :mod:`~astropy.units` package.\r\n\r\n    dtype : ~numpy.dtype, optional\r\n        The dtype of the resulting Numpy array or scalar that will\r\n        hold the value.  If not provided, it is determined from the input,\r\n        except that any integer and (non-Quantity) object inputs are converted\r\n        to float by default.\r\n        If `None`, the normal `numpy.dtype` introspection is used, e.g.\r\n        preventing upcasting of integers.\r\n\r\n    copy : bool, optional\r\n        If `True` (default), then the value is copied.  Otherwise, a copy will\r\n        only be made if ``__array__`` returns a copy, if value is a nested\r\n        sequence, or if a copy is needed to satisfy an explicitly given\r\n        ``dtype``.  (The `False` option is intended mostly for internal use,\r\n        to speed up initialization where a copy is known to have been made.\r\n        Use with care.)\r\n\r\n    order : {'C', 'F', 'A'}, optional\r\n        Specify the order of the array.  As in `~numpy.array`.  This parameter\r\n        is ignored if the input is a `Quantity` and ``copy=False``.\r\n\r\n    subok : bool, optional\r\n        If `False` (default), the returned array will be forced to be a\r\n        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\r\n        or a subclass appropriate for the unit will be used (such as\r\n        `~astropy.units.Dex` for ``u.dex(u.AA)``).\r\n\r\n    ndmin : int, optional\r\n        Specifies the minimum number of dimensions that the resulting array\r\n        should have.  Ones will be prepended to the shape as needed to meet\r\n        this requirement.  This parameter is ignored if the input is a\r\n        `Quantity` and ``copy=False``.\r\n\r\n    Raises\r\n    ------\r\n    TypeError\r\n        If the value provided is not a Python numeric type.\r\n    TypeError\r\n        If the unit provided is not either a :class:`~astropy.units.Unit`\r\n        object or a parseable string unit.\r\n\r\n    Notes\r\n    -----\r\n    Quantities can also be created by multiplying a number or array with a\r\n    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\r\n\r\n    Unless the ``dtype`` argument is explicitly specified, integer\r\n    or (non-Quantity) object inputs are converted to `float` by default.\r\n    \"\"\"\r\n\r\n    # Need to set a class-level default for _equivalencies, or\r\n    # Constants can not initialize properly\r\n    _equivalencies = []\r\n\r\n    # Default unit for initialization; can be overridden by subclasses,\r\n    # possibly to `None` to indicate there is no default unit.\r\n    _default_unit = dimensionless_unscaled\r\n\r\n    # Ensures views have an undefined unit.\r\n    _unit = None\r\n\r\n    __array_priority__ = 10000\r\n\r\n    def __class_getitem__(cls, unit_shape_dtype):\r\n        \"\"\"Quantity Type Hints.\r\n\r\n        Unit-aware type hints are ``Annotated`` objects that encode the class,\r\n        the unit, and possibly shape and dtype information, depending on the\r\n        python and :mod:`numpy` versions.\r\n\r\n        Schematically, ``Annotated[cls[shape, dtype], unit]``\r\n\r\n        As a classmethod, the type is the class, ie ``Quantity``\r\n        produces an ``Annotated[Quantity, ...]`` while a subclass\r\n        like :class:`~astropy.coordinates.Angle` returns\r\n        ``Annotated[Angle, ...]``.\r\n\r\n        Parameters\r\n        ----------\r\n        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\r\n            Unit specification, can be the physical type (ie str or class).\r\n            If tuple, then the first element is the unit specification\r\n            and all other elements are for `numpy.ndarray` type annotations.\r\n            Whether they are included depends on the python and :mod:`numpy`\r\n            versions.\r\n\r\n        Returns\r\n        -------\r\n        `typing.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\r\n            Return type in this preference order:\r\n            * `typing.Annotated`\r\n            * `astropy.units.Unit` or `astropy.units.PhysicalType`\r\n\r\n        Raises\r\n        ------\r\n        TypeError\r\n            If the unit/physical_type annotation is not Unit-like or\r\n            PhysicalType-like.\r\n\r\n        Examples\r\n        --------\r\n        Create a unit-aware Quantity type annotation\r\n\r\n            >>> Quantity[Unit(\"s\")]\r\n            Annotated[Quantity, Unit(\"s\")]\r\n\r\n        See Also\r\n        --------\r\n        `~astropy.units.quantity_input`\r\n            Use annotations for unit checks on function arguments and results.\r\n\r\n        Notes\r\n        -----\r\n        |Quantity| types are also static-type compatible.\r\n        \"\"\"\r\n        from typing import Annotated\r\n\r\n        # process whether [unit] or [unit, shape, ptype]\r\n        if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\r\n            target = unit_shape_dtype[0]\r\n            shape_dtype = unit_shape_dtype[1:]\r\n        else:  # just unit\r\n            target = unit_shape_dtype\r\n            shape_dtype = ()\r\n\r\n        # Allowed unit/physical types. Errors if neither.\r\n        try:\r\n            unit = Unit(target)\r\n        except (TypeError, ValueError):\r\n            from astropy.units.physical import get_physical_type\r\n\r\n            try:\r\n                unit = get_physical_type(target)\r\n            except (TypeError, ValueError, KeyError):  # KeyError for Enum\r\n                raise TypeError(\r\n                    \"unit annotation is not a Unit or PhysicalType\"\r\n                ) from None\r\n\r\n        # Quantity does not (yet) properly extend the NumPy generics types,\r\n        # introduced in numpy v1.22+, instead just including the unit info as\r\n        # metadata using Annotated.\r\n        # TODO: ensure we do interact with NDArray.__class_getitem__.\r\n        return Annotated[cls, unit]\r\n\r\n    def __new__(\r\n        cls: type[Self],\r\n        value: QuantityLike,\r\n        unit=None,\r\n        dtype=np.inexact,\r\n        copy=True,\r\n        order=None,\r\n        subok=False,\r\n        ndmin=0,\r\n    ) -> Self:\r\n        if unit is not None:\r\n            # convert unit first, to avoid multiple string->unit conversions\r\n            unit = Unit(unit)\r\n\r\n        # inexact -> upcast to float dtype\r\n        float_default = dtype is np.inexact\r\n        if float_default:\r\n            dtype = None\r\n\r\n        # optimize speed for Quantity with no dtype given, copy=COPY_IF_NEEDED\r\n        if isinstance(value, Quantity):\r\n            if unit is not None and unit is not value.unit:\r\n                value = value.to(unit)\r\n                # the above already makes a copy (with float dtype)\r\n                copy = COPY_IF_NEEDED\r\n\r\n            if type(value) is not cls and not (subok and isinstance(value, cls)):\r\n                value = value.view(cls)\r\n\r\n            if float_default and value.dtype.kind in \"iu\":\r\n                dtype = float\r\n\r\n            return np.array(\r\n                value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n            )\r\n\r\n        # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\r\n        # To ensure array remains fast, we short-circuit it.\r\n        value_unit = None\r\n        if not isinstance(value, np.ndarray):\r\n            if isinstance(value, str):\r\n                # The first part of the regex string matches any integer/float;\r\n                # the second parts adds possible trailing .+-, which will break\r\n                # the float function below and ensure things like 1.2.3deg\r\n                # will not work.\r\n                pattern = (\r\n                    r\"\\s*[+-]?\"\r\n                    r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\r\n                    r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\r\n                    r\"([eE][+-]?\\d+)?\"\r\n                    r\"[.+-]?\"\r\n                )\r\n\r\n                v = re.match(pattern, value)\r\n                unit_string = None\r\n                try:\r\n                    value = float(v.group())\r\n\r\n                except Exception:\r\n                    raise TypeError(\r\n                        f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\r\n                        \"start with a number.\"\r\n                    )\r\n\r\n                unit_string = v.string[v.end() :].strip()\r\n                if unit_string:\r\n                    value_unit = Unit(unit_string)\r\n                    if unit is None:\r\n                        unit = value_unit  # signal no conversion needed below.\r\n\r\n            elif isinstance(value, (list, tuple)) and len(value) > 0:\r\n                if all(isinstance(v, Quantity) for v in value):\r\n                    # If a list/tuple contains only quantities, stack them,\r\n                    # which also converts them to the same unit.\r\n                    value = np.stack(value)\r\n                    copy = False\r\n\r\n                elif (\r\n                    dtype is None\r\n                    and not hasattr(value, \"dtype\")\r\n                    and isinstance(unit, StructuredUnit)\r\n                ):\r\n                    # Special case for list/tuple of values and a structured unit:\r\n                    # ``np.array(value, dtype=None)`` would treat tuples as lower\r\n                    # levels of the array, rather than as elements of a structured\r\n                    # array, so we use the structure of the unit to help infer the\r\n                    # structured dtype of the value.\r\n                    dtype = unit._recursively_get_dtype(value)\r\n\r\n        using_default_unit = False\r\n        if value_unit is None:\r\n            # If the value has a `unit` attribute and if not None\r\n            # (for Columns with uninitialized unit), treat it like a quantity.\r\n            value_unit = getattr(value, \"unit\", None)\r\n            if value_unit is None:\r\n                # Default to dimensionless for no (initialized) unit attribute.\r\n                if unit is None:\r\n                    using_default_unit = True\r\n                    unit = cls._default_unit\r\n                value_unit = unit  # signal below that no conversion is needed\r\n            else:\r\n                try:\r\n                    value_unit = Unit(value_unit)\r\n                except Exception as exc:\r\n                    raise TypeError(\r\n                        f\"The unit attribute {value.unit!r} of the input could \"\r\n                        \"not be parsed as an astropy Unit.\"\r\n                    ) from exc\r\n\r\n                if unit is None:\r\n                    unit = value_unit\r\n                elif unit is not value_unit:\r\n                    copy = COPY_IF_NEEDED  # copy will be made in conversion at end\r\n\r\n        value = np.array(\r\n            value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\r\n        )\r\n\r\n        # For no-user-input unit, make sure the constructed unit matches the\r\n        # structure of the data.\r\n        if using_default_unit and value.dtype.names is not None:\r\n            unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\r\n\r\n        # check that array contains numbers or long int objects\r\n        if value.dtype.kind in \"OSU\" and not (\r\n            value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\r\n        ):\r\n            raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\r\n\r\n        # by default, cast any integer, boolean, etc., to float\r\n        if float_default and value.dtype.kind in \"iuO\":\r\n            value = value.astype(float)\r\n\r\n        # if we allow subclasses, allow a class from the unit.\r\n        if subok:\r\n"]
[635.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[635.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[635.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[635.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 6 total benchmarks (1 commits * 1 environments * 6 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 8.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.25\u00b10ms\r\n[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        124\u00b10\u03bcs\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       295\u00b10\u03bcs\r\n[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        306\u00b10\u03bcs\r\n[41.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             606\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  96.3\u00b10\u03bcs\r\n"]
[640.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[640.002, "i", "sed -n '720,820p' astropy/units/quantity.py\r"]
[640.004, "o", "sed -n '720,820p' astropy/units/quantity.py\r\n"]
[640.006, "o", "\u001b[?2004l\r\n            # Some np.linalg functions return namedtuple, which is handy to access\r\n            # elements by name, but cannot be directly initialized with an iterator.\r\n            result_cls = getattr(result, \"_make\", result.__class__)\r\n            return result_cls(\r\n                self._result_as_quantity(result_, unit_, out_)\r\n                for (result_, unit_, out_) in zip(result, unit, out)\r\n            )\r\n\r\n        if out is None:\r\n            # View the result array as a Quantity with the proper unit.\r\n            return (\r\n                result\r\n                if unit is None\r\n                else self._new_view(result, unit, propagate_info=False)\r\n            )\r\n\r\n        elif isinstance(out, Quantity):\r\n            # For given Quantity output, just set the unit. We know the unit\r\n            # is not None and the output is of the correct Quantity subclass,\r\n            # as it was passed through check_output.\r\n            # (We cannot do this unconditionally, though, since it is possible\r\n            # for out to be ndarray and the unit to be dimensionless.)\r\n            out._set_unit(unit)\r\n\r\n        return out\r\n\r\n    def __quantity_subclass__(self, unit):\r\n        \"\"\"\r\n        Overridden by subclasses to change what kind of view is\r\n        created based on the output unit of an operation.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : UnitBase\r\n            The unit for which the appropriate class should be returned\r\n\r\n        Returns\r\n        -------\r\n        tuple :\r\n            - `~astropy.units.Quantity` subclass\r\n            - bool: True if subclasses of the given class are ok\r\n        \"\"\"\r\n        return Quantity, True\r\n\r\n    def _new_view(self, obj=None, unit=None, propagate_info=True):\r\n        \"\"\"Create a Quantity view of some array-like input, and set the unit.\r\n\r\n        By default, return a view of ``obj`` of the same class as ``self`` and\r\n        with the same unit.  Subclasses can override the type of class for a\r\n        given unit using ``__quantity_subclass__``, and can ensure properties\r\n        other than the unit are copied using ``__array_finalize__``.\r\n\r\n        If the given unit defines a ``_quantity_class`` of which ``self``\r\n        is not an instance, a view using this class is taken.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : ndarray or scalar, optional\r\n            The array to create a view of.  If obj is a numpy or python scalar,\r\n            it will be converted to an array scalar.  By default, ``self``\r\n            is converted.\r\n\r\n        unit : unit-like, optional\r\n            The unit of the resulting object.  It is used to select a\r\n            subclass, and explicitly assigned to the view if given.\r\n            If not given, the subclass and unit will be that of ``self``.\r\n\r\n        propagate_info : bool, optional\r\n            Whether to transfer ``info`` if present.  Default: `True`, as\r\n            appropriate for, e.g., unit conversions or slicing, where the\r\n            nature of the object does not change.\r\n\r\n        Returns\r\n        -------\r\n        view : `~astropy.units.Quantity` subclass\r\n\r\n        \"\"\"\r\n        # Determine the unit and quantity subclass that we need for the view.\r\n        if unit is None:\r\n            unit = self.unit\r\n            quantity_subclass = self.__class__\r\n        elif unit is self.unit and self.__class__ is Quantity:\r\n            # The second part is because we should not presume what other\r\n            # classes want to do for the same unit.  E.g., Constant will\r\n            # always want to fall back to Quantity, and relies on going\r\n            # through `__quantity_subclass__`.\r\n            quantity_subclass = Quantity\r\n        else:\r\n            unit = Unit(unit)\r\n            quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\r\n            if isinstance(self, quantity_subclass):\r\n                quantity_subclass, subok = self.__quantity_subclass__(unit)\r\n                if subok:\r\n                    quantity_subclass = self.__class__\r\n\r\n        # We only want to propagate information from ``self`` to our new view,\r\n        # so obj should be a regular array.  By using ``np.array``, we also\r\n        # convert python and numpy scalars, which cannot be viewed as arrays\r\n        # and thus not as Quantity either, to zero-dimensional arrays.\r\n        # (These are turned back into scalar in `.value`)\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n"]
[645.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[645.002, "i", "sed -n '820,920p' astropy/units/quantity.py\r"]
[645.004, "o", "sed -n '820,920p' astropy/units/quantity.py\r\n"]
[645.006, "o", "\u001b[?2004l\r\n        # Note that for an ndarray input, the np.array call takes only double\r\n        # ``obj.__class is np.ndarray``. So, not worth special-casing.\r\n        if obj is None:\r\n            obj = self.view(np.ndarray)\r\n        else:\r\n            obj = np.array(obj, copy=COPY_IF_NEEDED, subok=True)\r\n\r\n        # Take the view, set the unit, and update possible other properties\r\n        # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\r\n        view = obj.view(quantity_subclass)\r\n        view._set_unit(unit)\r\n        view.__array_finalize__(self)\r\n        if propagate_info and \"info\" in self.__dict__:\r\n            view.info = self.info\r\n        return view\r\n\r\n    def _set_unit(self, unit):\r\n        \"\"\"Set the unit.\r\n\r\n        This is used anywhere the unit is set or modified, i.e., in the\r\n        initializer, in ``__imul__`` and ``__itruediv__`` for in-place\r\n        multiplication and division by another unit, as well as in\r\n        ``__array_finalize__`` for wrapping up views.  For Quantity, it just\r\n        sets the unit, but subclasses can override it to check that, e.g.,\r\n        a unit is consistent.\r\n        \"\"\"\r\n        if not isinstance(unit, UnitBase):\r\n            if isinstance(self._unit, StructuredUnit) or isinstance(\r\n                unit, StructuredUnit\r\n            ):\r\n                unit = StructuredUnit(unit, self.dtype)\r\n            else:\r\n                # Trying to go through a string ensures that, e.g., Magnitudes with\r\n                # dimensionless physical unit become Quantity with units of mag.\r\n                unit = Unit(str(unit), parse_strict=\"silent\")\r\n                if not isinstance(unit, (UnitBase, StructuredUnit)):\r\n                    raise UnitTypeError(\r\n                        f\"{self.__class__.__name__} instances require normal units, \"\r\n                        f\"not {unit.__class__} instances.\"\r\n                    )\r\n\r\n        self._unit = unit\r\n\r\n    def __deepcopy__(self, memo):\r\n        # If we don't define this, ``copy.deepcopy(quantity)`` will\r\n        # return a bare Numpy array.\r\n        return self.copy()\r\n\r\n    def __reduce__(self):\r\n        # patch to pickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        object_state = list(super().__reduce__())\r\n        object_state[2] = (object_state[2], self.__dict__)\r\n        return tuple(object_state)\r\n\r\n    def __setstate__(self, state):\r\n        # patch to unpickle Quantity objects (ndarray subclasses), see\r\n        # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\r\n\r\n        nd_state, own_state = state\r\n        super().__setstate__(nd_state)\r\n        self.__dict__.update(own_state)\r\n\r\n    info = QuantityInfo()\r\n\r\n    def _to_value(self, unit, equivalencies=[]):\r\n        \"\"\"Helper method for to and to_value.\"\"\"\r\n        if equivalencies == []:\r\n            equivalencies = self._equivalencies\r\n        if not self.dtype.names or isinstance(self.unit, StructuredUnit):\r\n            # Standard path, let unit to do work.\r\n            return self.unit.to(\r\n                unit, self.view(np.ndarray), equivalencies=equivalencies\r\n            )\r\n\r\n        else:\r\n            # The .to() method of a simple unit cannot convert a structured\r\n            # dtype, so we work around it, by recursing.\r\n            # TODO: deprecate this?\r\n            # Convert simple to Structured on initialization?\r\n            result = np.empty_like(self.view(np.ndarray))\r\n            for name in self.dtype.names:\r\n                result[name] = self[name]._to_value(unit, equivalencies)\r\n            return result\r\n\r\n    def to(self, unit, equivalencies=[], copy=True):\r\n        \"\"\"\r\n        Return a new `~astropy.units.Quantity` object with the specified unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like\r\n            An object that represents the unit to convert to. Must be\r\n            an `~astropy.units.UnitBase` object or a string parseable\r\n            by the `~astropy.units` package.\r\n\r\n        equivalencies : list of tuple\r\n            A list of equivalence pairs to try if the units are not\r\n            directly convertible.  See :ref:`astropy:unit_equivalencies`.\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n"]
[650.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[650.002, "i", "sed -n '920,980p' astropy/units/quantity.py\r"]
[650.004, "o", "sed -n '920,980p' astropy/units/quantity.py\r\n"]
[650.006, "o", "\u001b[?2004l\r\n            If not provided or ``[]``, class default equivalencies will be used\r\n            (none for `~astropy.units.Quantity`, but may be set for subclasses)\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        copy : bool, optional\r\n            If `True` (default), then the value is copied.  Otherwise, a copy\r\n            will only be made if necessary.\r\n\r\n        See Also\r\n        --------\r\n        to_value : get the numerical value in a given unit.\r\n        \"\"\"\r\n        # We don't use `to_value` below since we always want to make a copy\r\n        # and don't want to slow down this method (esp. the scalar case).\r\n        unit = Unit(unit)\r\n        if copy:\r\n            # Avoid using to_value to ensure that we make a copy. We also\r\n            # don't want to slow down this method (esp. the scalar case).\r\n            value = self._to_value(unit, equivalencies)\r\n        else:\r\n            # to_value only copies if necessary\r\n            value = self.to_value(unit, equivalencies)\r\n        return self._new_view(value, unit)\r\n\r\n    def to_value(self, unit=None, equivalencies=[]):\r\n        \"\"\"\r\n        The numerical value, possibly in a different unit.\r\n\r\n        Parameters\r\n        ----------\r\n        unit : unit-like, optional\r\n            The unit in which the value should be given. If not given or `None`,\r\n            use the current unit.\r\n\r\n        equivalencies : list of tuple, optional\r\n            A list of equivalence pairs to try if the units are not directly\r\n            convertible (see :ref:`astropy:unit_equivalencies`). If not provided\r\n            or ``[]``, class default equivalencies will be used (none for\r\n            `~astropy.units.Quantity`, but may be set for subclasses).\r\n            If `None`, no equivalencies will be applied at all, not even any\r\n            set globally or within a context.\r\n\r\n        Returns\r\n        -------\r\n        value : ndarray or scalar\r\n            The value in the units specified. For arrays, this will be a view\r\n            of the data if no unit conversion was necessary.\r\n\r\n        See Also\r\n        --------\r\n        to : Get a new instance in a different unit.\r\n        \"\"\"\r\n        if unit is None or unit is self.unit:\r\n            value = self.view(np.ndarray)\r\n        elif not self.dtype.names:\r\n            # For non-structured, we attempt a short-cut, where we just get\r\n            # the scale.  If that is 1, we do not have to do anything.\r\n            unit = Unit(unit)\r\n            # We want a view if the unit does not change.  One could check\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n"]
[655.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[655.002, "i", "sed -n '980,1080p' astropy/units/quantity.py\r"]
[655.004, "o", "sed -n '980,1080p' astropy/units/quantity.py\r\n"]
[655.006, "o", "\u001b[?2004l\r\n            # with \"==\", but that calculates the scale that we need anyway.\r\n            # TODO: would be better for `unit.to` to have an in-place flag.\r\n            try:\r\n                scale = self.unit._to(unit)\r\n            except Exception:\r\n                # Short-cut failed; try default (maybe equivalencies help).\r\n                value = self._to_value(unit, equivalencies)\r\n            else:\r\n                value = self.view(np.ndarray)\r\n                if not is_effectively_unity(scale):\r\n                    # not in-place!\r\n                    value = value * scale\r\n        else:\r\n            # For structured arrays, we go the default route.\r\n            value = self._to_value(unit, equivalencies)\r\n\r\n        # Index with empty tuple to decay array scalars in to numpy scalars.\r\n        return value if value.shape else value[()]\r\n\r\n    value = property(\r\n        to_value,\r\n        doc=\"\"\"The numerical value of this instance.\r\n\r\n    See also\r\n    --------\r\n    to_value : Get the numerical value in a given unit.\r\n    \"\"\",\r\n    )\r\n\r\n    @property\r\n    def unit(self):\r\n        \"\"\"\r\n        A `~astropy.units.UnitBase` object representing the unit of this\r\n        quantity.\r\n        \"\"\"\r\n        return self._unit\r\n\r\n    @property\r\n    def equivalencies(self):\r\n        \"\"\"\r\n        A list of equivalencies that will be applied by default during\r\n        unit conversions.\r\n        \"\"\"\r\n        return self._equivalencies\r\n\r\n    def _recursively_apply(self, func):\r\n        \"\"\"Apply function recursively to every field.\r\n\r\n        Returns a copy with the result.\r\n        \"\"\"\r\n        result = np.empty_like(self)\r\n        result_value = result.view(np.ndarray)\r\n        result_unit = ()\r\n        for name in self.dtype.names:\r\n            part = func(self[name])\r\n            result_value[name] = part.value\r\n            result_unit += (part.unit,)\r\n\r\n        result._set_unit(result_unit)\r\n        return result\r\n\r\n    @property\r\n    def si(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with SI units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"si\"))\r\n        si_unit = self.unit.si\r\n        return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\r\n\r\n    @property\r\n    def cgs(self):\r\n        \"\"\"\r\n        Returns a copy of the current `Quantity` instance with CGS units. The\r\n        value of the resulting object will be scaled.\r\n        \"\"\"\r\n        if self.dtype.names:\r\n            return self._recursively_apply(operator.attrgetter(\"cgs\"))\r\n        cgs_unit = self.unit.cgs\r\n        return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\r\n\r\n    @property\r\n    def isscalar(self):\r\n        \"\"\"\r\n        True if the `value` of this quantity is a scalar, or False if it\r\n        is an array-like object.\r\n\r\n        .. note::\r\n            This is subtly different from `numpy.isscalar` in that\r\n            `numpy.isscalar` returns False for a zero-dimensional array\r\n            (e.g. ``np.array(1)``), while this is True for quantities,\r\n            since quantities cannot represent true numpy scalars.\r\n        \"\"\"\r\n        return not self.shape\r\n\r\n    # This flag controls whether convenience conversion members, such\r\n    # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\r\n    # not turned on on Quantity itself, but is on some subclasses of\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n"]
[660.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[660.002, "i", "sed -n '1080,1180p' astropy/units/quantity.py\r"]
[660.004, "o", "sed -n '1080,1180p' astropy/units/quantity.py\r\n"]
[660.006, "o", "\u001b[?2004l\r\n    # Quantity, such as `astropy.coordinates.Angle`.\r\n    _include_easy_conversion_members = False\r\n\r\n    def __dir__(self):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.  This function is implemented in\r\n        order to make autocompletion still work correctly in IPython.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            return super().__dir__()\r\n\r\n        dir_values = set(super().__dir__())\r\n        equivalencies = Unit._normalize_equivalencies(self.equivalencies)\r\n        for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\r\n            dir_values.update(equivalent.names)\r\n        return sorted(dir_values)\r\n\r\n    def __getattr__(self, attr):\r\n        \"\"\"\r\n        Quantities are able to directly convert to other units that\r\n        have the same physical type.\r\n        \"\"\"\r\n        if not self._include_easy_conversion_members:\r\n            raise AttributeError(\r\n                f\"'{self.__class__.__name__}' object has no '{attr}' member\"\r\n            )\r\n\r\n        def get_virtual_unit_attribute():\r\n            registry = get_current_unit_registry().registry\r\n            to_unit = registry.get(attr, None)\r\n            if to_unit is None:\r\n                return None\r\n\r\n            try:\r\n                return self.unit.to(\r\n                    to_unit, self.value, equivalencies=self.equivalencies\r\n                )\r\n            except UnitsError:\r\n                return None\r\n\r\n        value = get_virtual_unit_attribute()\r\n\r\n        if value is None:\r\n            raise AttributeError(\r\n                f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\r\n            )\r\n        else:\r\n            return value\r\n\r\n    # Equality needs to be handled explicitly as ndarray.__eq__ gives\r\n    # DeprecationWarnings on any error, which is distracting, and does not\r\n    # deal well with structured arrays (nor does the ufunc).\r\n    def __eq__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return False\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__eq__(other_value)\r\n\r\n    def __ne__(self, other):\r\n        try:\r\n            other_value = self._to_own_unit(other)\r\n        except UnitsError:\r\n            return True\r\n        except Exception:\r\n            return NotImplemented\r\n        return self.value.__ne__(other_value)\r\n\r\n    # Unit conversion operator (<<).\r\n    def __lshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented\r\n\r\n        return self.__class__(self, other, copy=False, subok=True)\r\n\r\n    def __ilshift__(self, other):\r\n        try:\r\n            other = Unit(other, parse_strict=\"silent\")\r\n        except UnitTypeError:\r\n            return NotImplemented  # try other.__rlshift__(self)\r\n\r\n        try:\r\n            factor = self.unit._to(other)\r\n        except UnitConversionError:  # incompatible, or requires an Equivalency\r\n            return NotImplemented\r\n        except AttributeError:  # StructuredUnit does not have `_to`\r\n            # In principle, in-place might be possible.\r\n            return NotImplemented\r\n\r\n        view = self.view(np.ndarray)\r\n        try:\r\n            view *= factor  # operates on view\r\n        except TypeError:\r\n            # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\r\n            # which inherits from `TypeError`.\r\n            return NotImplemented\r\n"]
[665.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[665.002, "i", "applypatch << 'PATCH'\r"]
[665.004, "o", "applypatch << 'PATCH'\r\n"]
[665.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> *** Begin Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> *** Update File: astropy/units/quantity.py\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -        if unit is None or unit is self.unit:\r\n\u001b[?2004l\r\n\u001b[?2004h> -            value = self.view(np.ndarray)\r\n\u001b[?2004l\r\n\u001b[?2004h> -        elif not self.dtype.names:\r\n\u001b[?2004l\r\n\u001b[?2004h> -            # For non-structured, we attempt a short-cut, where we just get\r\n\u001b[?2004l\r\n\u001b[?2004h> -            # the scale.  If that is 1, we do not have to do anything.\r\n\u001b[?2004l\r\n\u001b[?2004h> -            unit = Unit(unit)\r\n\u001b[?2004l\r\n\u001b[?2004h> +        if unit is None or unit is self.unit:\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # Fast-path: exact same unit or unspecified target unit -> view\r\n\u001b[?2004l\r\n\u001b[?2004h> +            value = self.view(np.ndarray)\r\n\u001b[?2004l\r\n\u001b[?2004h> +        elif not self.dtype.names:\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # For non-structured, attempt a short-cut by checking scale only.\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # Avoid constructing a new Unit if one was already provided.\r\n\u001b[?2004l\r\n\u001b[?2004h> +            unit = unit if isinstance(unit, UnitBase) else Unit(unit)\r\n\u001b[?2004l\r\n\u001b[?2004h> *** End Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> PATCH\r\n\u001b[?2004l\r\n-bash: applypatch: command not found\r\n"]
[670.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[670.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[670.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[670.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 6 total benchmarks (1 commits * 1 environments * 6 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 8.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.16\u00b10ms\r\n[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        132\u00b10\u03bcs\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       311\u00b10\u03bcs\r\n[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        369\u00b10\u03bcs\r\n[41.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             566\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  83.1\u00b10\u03bcs\r\n"]
[675.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[675.002, "i", "grep -n \"new_parts = \\[x for x in new_parts.items() if x\\[1\\] != 0\\]\" -n astropy/units/core.py\r"]
[675.004, "o", "grep -n \"new_parts = \\[x for x in new_parts.items() if x\\[1\\] != 0\\]\" -n astropy/units/core.py\r\n"]
[675.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K2450\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Knew_parts = [x for x in new_parts.items() if x[1] != 0]\u001b[m\u001b[K\r\n"]
[680.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[680.002, "i", "sed -n '2400,2480p' astropy/units/core.py\r"]
[680.004, "o", "sed -n '2400,2480p' astropy/units/core.py\r\n"]
[680.006, "o", "\u001b[?2004l\r\n        return self._scale\r\n\r\n    @property\r\n    def bases(self):\r\n        \"\"\"\r\n        Return the bases of the composite unit.\r\n        \"\"\"\r\n        return self._bases\r\n\r\n    @property\r\n    def powers(self):\r\n        \"\"\"\r\n        Return the powers of the composite unit.\r\n        \"\"\"\r\n        return self._powers\r\n\r\n    def _expand_and_gather(self, decompose=False, bases=set()):\r\n        def add_unit(unit, power, scale):\r\n            if bases and unit not in bases:\r\n                for base in bases:\r\n                    try:\r\n                        scale *= unit._to(base) ** power\r\n                    except UnitsError:\r\n                        pass\r\n                    else:\r\n                        unit = base\r\n                        break\r\n\r\n            if unit in new_parts:\r\n                a, b = resolve_fractions(new_parts[unit], power)\r\n                new_parts[unit] = a + b\r\n            else:\r\n                new_parts[unit] = power\r\n            return scale\r\n\r\n        new_parts = {}\r\n        scale = self._scale\r\n\r\n        for b, p in zip(self._bases, self._powers):\r\n            if decompose and b not in bases:\r\n                b = b.decompose(bases=bases)\r\n\r\n            if isinstance(b, CompositeUnit):\r\n                scale *= b._scale**p\r\n                for b_sub, p_sub in zip(b._bases, b._powers):\r\n                    a, b = resolve_fractions(p_sub, p)\r\n                    scale = add_unit(b_sub, a * b, scale)\r\n            else:\r\n                scale = add_unit(b, p, scale)\r\n\r\n        new_parts = [x for x in new_parts.items() if x[1] != 0]\r\n        new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\r\n\r\n        self._bases = [x[0] for x in new_parts]\r\n        self._powers = [sanitize_power(x[1]) for x in new_parts]\r\n        self._scale = sanitize_scale(scale)\r\n\r\n    def __copy__(self):\r\n        \"\"\"\r\n        For compatibility with python copy module.\r\n        \"\"\"\r\n        return CompositeUnit(self._scale, self._bases[:], self._powers[:])\r\n\r\n    def decompose(self, bases=set()):\r\n        if len(bases) == 0 and self._decomposed_cache is not None:\r\n            return self._decomposed_cache\r\n\r\n        for base in self.bases:\r\n            if not isinstance(base, IrreducibleUnit) or (\r\n                len(bases) and base not in bases\r\n            ):\r\n                break\r\n        else:\r\n            if len(bases) == 0:\r\n                self._decomposed_cache = self\r\n            return self\r\n\r\n        x = CompositeUnit(\r\n            self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases\r\n        )\r\n        if len(bases) == 0:\r\n"]
[685.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[685.002, "i", "python - << 'PY'\r"]
[685.004, "o", "python - << 'PY'\r\n"]
[685.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('astropy/units/core.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> s = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> # 1) Conditional sort for new_parts and fast-path scale==1\r\n\u001b[?2004l\r\n\u001b[?2004h> s = s.replace(\r\n\u001b[?2004l\r\n\u001b[?2004h>     'new_parts = [x for x in new_parts.items() if x[1] != 0]\\n        new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))',\r\n\u001b[?2004l\r\n\u001b[?2004h>     'new_parts = [x for x in new_parts.items() if x[1] != 0]\\n        if len(new_parts) > 1:\\n            new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"n\r\nname\", \"\")))'\r\n\u001b[?2004l\r\n\u001b[?2004h> )\r\n\u001b[?2004l\r\n\u001b[?2004h> s = s.replace(\r\n\u001b[?2004l\r\n\u001b[?2004h>     'self._scale = sanitize_scale(scale)',\r\n\u001b[?2004l\r\n\u001b[?2004h>     'self._scale = 1.0 if (scale == 1 or scale == 1.0) else sanitize_scale(scale)'\r\n\u001b[?2004l\r\n\u001b[?2004h> )\r\n\u001b[?2004l\r\n\u001b[?2004h> # 2) Avoid sanitize_power for integer powers (exclude bool, include numpy ints)\r\n\u001b[?2004l\r\n\u001b[?2004h> s = s.replace(\r\n\u001b[?2004l\r\n\u001b[?2004h>     'self._bases = [x[0] for x in new_parts]\\n        self._powers = [sanitize_power(x[1]) for x in new_parts]',\r\n\u001b[?2004l\r\n\u001b[?2004h>     'self._bases = [x[0] for x in new_parts]\\n        self._powers = []\\n        for _, p in new_parts:\\n            try:\\n                import numpy as _np\\\r\n\\n            except Exception:\\n                _np = None\\n            if ((isinstance(p, int) and not isinstance(p, bool)) or (_np is not None and isinstance(\r\n(p, _np.integer))):\\n                self._powers.append(p)\\n            else:\\n                self._powers.append(sanitize_power(p))'\r\n\u001b[?2004l\r\n\u001b[?2004h> )\r\n\u001b[?2004l\r\n\u001b[?2004h> p.write_text(s)\r\n\u001b[?2004l\r\n\u001b[?2004h> print('patched core.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\npatched core.py\r\n"]
[690.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[690.002, "i", "sed -n '2400,2480p' astropy/units/core.py\r"]
[690.004, "o", "sed -n '2400,2480p' astropy/units/core.py\r\n"]
[690.006, "o", "\u001b[?2004l\r\n        return self._scale\r\n\r\n    @property\r\n    def bases(self):\r\n        \"\"\"\r\n        Return the bases of the composite unit.\r\n        \"\"\"\r\n        return self._bases\r\n\r\n    @property\r\n    def powers(self):\r\n        \"\"\"\r\n        Return the powers of the composite unit.\r\n        \"\"\"\r\n        return self._powers\r\n\r\n    def _expand_and_gather(self, decompose=False, bases=set()):\r\n        def add_unit(unit, power, scale):\r\n            if bases and unit not in bases:\r\n                for base in bases:\r\n                    try:\r\n                        scale *= unit._to(base) ** power\r\n                    except UnitsError:\r\n                        pass\r\n                    else:\r\n                        unit = base\r\n                        break\r\n\r\n            if unit in new_parts:\r\n                a, b = resolve_fractions(new_parts[unit], power)\r\n                new_parts[unit] = a + b\r\n            else:\r\n                new_parts[unit] = power\r\n            return scale\r\n\r\n        new_parts = {}\r\n        scale = self._scale\r\n\r\n        for b, p in zip(self._bases, self._powers):\r\n            if decompose and b not in bases:\r\n                b = b.decompose(bases=bases)\r\n\r\n            if isinstance(b, CompositeUnit):\r\n                scale *= b._scale**p\r\n                for b_sub, p_sub in zip(b._bases, b._powers):\r\n                    a, b = resolve_fractions(p_sub, p)\r\n                    scale = add_unit(b_sub, a * b, scale)\r\n            else:\r\n                scale = add_unit(b, p, scale)\r\n\r\n        new_parts = [x for x in new_parts.items() if x[1] != 0]\r\n        if len(new_parts) > 1:\r\n            new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\r\n\r\n        self._bases = [x[0] for x in new_parts]\r\n        self._powers = []\r\n        for _, p in new_parts:\r\n            try:\r\n                import numpy as _np\r\n            except Exception:\r\n                _np = None\r\n            if ((isinstance(p, int) and not isinstance(p, bool)) or (_np is not None and isinstance(p, _np.integer))):\r\n                self._powers.append(p)\r\n            else:\r\n                self._powers.append(sanitize_power(p))\r\n        self._scale = 1.0 if (scale == 1 or scale == 1.0) else sanitize_scale(scale)\r\n\r\n    def __copy__(self):\r\n        \"\"\"\r\n        For compatibility with python copy module.\r\n        \"\"\"\r\n        return CompositeUnit(self._scale, self._bases[:], self._powers[:])\r\n\r\n    def decompose(self, bases=set()):\r\n        if len(bases) == 0 and self._decomposed_cache is not None:\r\n            return self._decomposed_cache\r\n\r\n        for base in self.bases:\r\n            if not isinstance(base, IrreducibleUnit) or (\r\n                len(bases) and base not in bases\r\n            ):\r\n"]
[695.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[695.002, "i", "python - << 'PY'\r"]
[695.004, "o", "python - << 'PY'\r\n"]
[695.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('astropy/units/quantity.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> s = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> s = s.replace(\r\n\u001b[?2004l\r\n\u001b[?2004h>     'unit = Unit(unit)\\n            # We want a view if the unit does not change.  One could check',\r\n\u001b[?2004l\r\n\u001b[?2004h>     'unit = unit if isinstance(unit, UnitBase) else Unit(unit)\\n            # We want a view if the unit does not change.  One could check'\r\n\u001b[?2004l\r\n\u001b[?2004h> )\r\n\u001b[?2004l\r\n\u001b[?2004h> p.write_text(s)\r\n\u001b[?2004l\r\n\u001b[?2004h> print('patched quantity.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\npatched quantity.py\r\n"]
[700.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[700.002, "i", "git status --porcelain\r"]
[700.004, "o", "git status --porcelain\r\n"]
[700.006, "o", "\u001b[?2004l\r\n M astropy/units/core.py\r\n M astropy/units/quantity.py\r\n?? astropy-benchmarks/\r\n"]
[705.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[705.002, "i", "git add -A && git commit -m \"Optimize units.CompositeUnit init: skip sort when <=1 part, fast-path scale==1, avoid \r"]
[705.004, "o", "git add -A && git commit -m \"Optimize units.CompositeUnit init: skip sort when <=1 part, fast-path scale==1, avoid \r\n"]
[705.006, "o", " sanitize_power for ints; optimize Quantity.to_value to avoid Unit() when already UnitBase\"\r\n\u001b[?2004l\r\nwarning: adding embedded git repository: astropy-benchmarks\r\n\u001b[33mhint: You've added another git repository inside your current repository.\u001b[m\r\n\u001b[33mhint: Clones of the outer repository will not contain the contents of\u001b[m\r\n\u001b[33mhint: the embedded repository and will not know how to obtain it.\u001b[m\r\n\u001b[33mhint: If you meant to add a submodule, use:\u001b[m\r\n\u001b[33mhint:\u001b[m\r\n\u001b[33mhint: \tgit submodule add <url> astropy-benchmarks\u001b[m\r\n\u001b[33mhint:\u001b[m\r\n\u001b[33mhint: If you added this path by mistake, you can remove it from the\u001b[m\r\n\u001b[33mhint: index with:\u001b[m\r\n\u001b[33mhint:\u001b[m\r\n\u001b[33mhint: \tgit rm --cached astropy-benchmarks\u001b[m\r\n\u001b[33mhint:\u001b[m\r\n\u001b[33mhint: See \"git help submodule\" for more information.\u001b[m\r\n\u001b[33mhint: Disable this message with \"git config set advice.addEmbeddedRepo false\"\u001b[m\r\nAuthor identity unknown\r\n\r\n*** Please tell me who you are.\r\n\r\nRun\r\n\r\n  git config --global user.email \"you@example.com\"\r\n  git config --global user.name \"Your Name\"\r\n\r\nto set your account's default identity.\r\nOmit --global to set the identity only in this repository.\r\n\r\nfatal: unable to auto-detect email address (got 'root@52adc14744e5.(none)')\r\n"]
[710.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[710.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[710.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[710.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view|units.TimeQuanti\r\nityOpLargeArraySameUnit.*|units.TimeQuantityOpLargeArrayDiffUnit.*\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 26 total benchmarks (1 commits * 1 environments * 26 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 1.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add\u001b[0m                                                                                  2.36\u00b10ms\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal\u001b[0m                                                                                2.13\u00b10ms\r\n[ 5.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul\u001b[0m                                                                                  2.11\u00b10ms\r\n[ 7.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add\u001b[0m                                                                               2.29\u00b10ms\r\n[ 9.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal\u001b[0m                                                                             2.36\u00b10ms\r\n[11.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply\u001b[0m                                                                          1.84\u00b10ms\r\n[13.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract\u001b[0m                                                                          2.71\u00b10ms\r\n[15.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv\u001b[0m                                                                           2.57\u00b10ms\r\n[17.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub\u001b[0m                                                                                  2.50\u00b10ms\r\n[19.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv\u001b[0m                                                                              1.54\u00b10ms\r\n[21.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_add\u001b[0m                                                                                  1.52\u00b10ms\r\n[23.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_equal\u001b[0m                                                                                1.12\u00b10ms\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_mul\u001b[0m                                                                                  1.37\u00b10ms\r\n[26.92%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add\u001b[0m                                                                               1.96\u00b10ms\r\n[28.85%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal\u001b[0m                                                                             1.43\u00b10ms\r\n[30.77%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply\u001b[0m                                                                          2.81\u00b10ms\r\n[32.69%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract\u001b[0m                                                                          1.73\u00b10ms\r\n[34.62%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv\u001b[0m                                                                           1.58\u00b10ms\r\n[36.54%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_sub\u001b[0m                                                                                  1.27\u00b10ms\r\n[38.46%] \u00b7\u00b7\u00b7 \u001b[0;39munits.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv\u001b[0m                                                                              1.36\u00b10ms\r\n[40.38%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.09\u00b10ms\r\n[42.31%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        105\u00b10\u03bcs\r\n[44.23%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       291\u00b10\u03bcs\r\n[46.15%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        336\u00b10\u03bcs\r\n[48.08%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             556\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  80.6\u00b10\u03bcs\r\n"]
[715.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[715.002, "i", "git config user.email \"devnull@example.com\"\r"]
[715.004, "o", "git config user.email \"devnull@example.com\"\r\n"]
[715.006, "o", "\u001b[?2004l\r\n"]
[720.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[720.002, "i", "git config user.name \"ASV Optimizer\"\r"]
[720.004, "o", "git config user.name \"ASV Optimizer\"\r\n"]
[720.006, "o", "\u001b[?2004l\r\n"]
[725.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[725.002, "i", "git add -A\r"]
[725.004, "o", "git add -A\r\n"]
[725.006, "o", "\u001b[?2004l\r\n"]
[730.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[730.002, "i", "git commit -m \"Optimize CompositeUnit init: skip sort for <=1 part, fast-path scale==1, avoid sanitize_power for in\r"]
[730.004, "o", "git commit -m \"Optimize CompositeUnit init: skip sort for <=1 part, fast-path scale==1, avoid sanitize_power for in\r\n"]
[730.006, "o", "nts; optimize Quantity.to_value to avoid Unit() when already UnitBase\"\r\n\u001b[?2004l\r\n[main 90545e515] Optimize CompositeUnit init: skip sort for <=1 part, fast-path scale==1, avoid sanitize_power for ints; optimize Quantity.to_value to avoid Unit() when already UnitBase\r\n 3 files changed, 16 insertions(+), 5 deletions(-)\r\n create mode 160000 astropy-benchmarks\r\n"]
[735.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[735.002, "i", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r"]
[735.004, "o", "asv run --config asv.ci.conf.json --python=same --bench=\"units.time_quantity_init_small_list|units.time_quantity_cr\r\n"]
[735.006, "o", "reation_nocopy|units.time_quantity_init_small_array|units.time_quantity_times_unit|units.time_quantity_array_conversion|units.time_quantity_view\" --quick\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 6 total benchmarks (1 commits * 1 environments * 6 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.11_bin_python3.11\u001b[0m\r\n[ 8.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_array_conversion\u001b[0m                                                                                                      1.09\u00b10ms\r\n[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_creation_nocopy\u001b[0m                                                                                                        132\u00b10\u03bcs\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_array\u001b[0m                                                                                                       289\u00b10\u03bcs\r\n[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_init_small_list\u001b[0m                                                                                                        297\u00b10\u03bcs\r\n[41.67%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_times_unit\u001b[0m                                                                                                             549\u00b10\u03bcs\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39munits.time_quantity_view\u001b[0m                                                                                                                  88.3\u00b10\u03bcs\r\n"]
[740.0, "o", "(asv_3.11) root@52adc14744e5:/workspace/repo# "]
[740.002, "i", "\u001b[?2004l\r"]
[740.004, "o", "\u001b[?2004l\r\n"]
[740.006, "o", "\r\nlogout\r\n"]
