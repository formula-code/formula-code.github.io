{"version": 2, "width": 160, "height": 40, "timestamp": 1762942280, "env": {"SHELL": "/bin/bash", "TERM": "screen"}}
[0.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[0.002, "i", "asciinema rec --stdin /logs/agent.cast\r"]
[0.004, "o", "asciinema rec --stdin /logs/agent.cast\r\n"]
[0.006, "o", "\u001b[?2004l\r\n\u001b[0;31masciinema: /logs/agent.cast already exists, aborting\u001b[0m\r\n\u001b[0;31masciinema: use --overwrite option if you want to overwrite existing recording\u001b[0m\r\n\u001b[0;31masciinema: use --append option if you want to append to existing recording\u001b[0m\r\n"]
[5.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[5.002, "i", "clear\r"]
[5.004, "o", "clear\r\n"]
[5.006, "o", "\u001b[?2004l\r\n\u001b[H\u001b[J\r\n"]
[10.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[10.002, "i", "ls -la\r"]
[10.004, "o", "ls -la\r\n"]
[10.006, "o", "\u001b[?2004l\r\ntotal 220\r\ndrwxr-xr-x 1 root root  4096 Oct  1 17:05 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 15 17:10 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root   971 Sep 12 21:42 .devcontainer.json\r\ndrwxr-xr-x 1 root root  4096 Sep 15 17:13 \u001b[01;34m.git\u001b[0m\r\n-rw-r--r-- 1 root root  1866 Sep 12 21:44 .gitattributes\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34m.github\u001b[0m\r\n-rw-r--r-- 1 root root  2004 Sep 12 21:42 .gitignore\r\n-rw-r--r-- 1 root root  2280 Sep 12 21:42 .gitpod.yml\r\n-rw-r--r-- 1 root root 11223 Sep 12 21:44 .pre-commit-config.yaml\r\n-rw-r--r-- 1 root root  2284 Sep 12 21:44 AUTHORS.md\r\n-rw-r--r-- 1 root root  1541 Sep 12 21:42 CITATION.cff\r\n-rw-r--r-- 1 root root   494 Sep 12 21:44 Dockerfile\r\n-rw-r--r-- 1 root root  1634 Sep 12 21:42 LICENSE\r\ndrwxr-xr-x 2 root root  4096 Sep 12 21:42 \u001b[01;34mLICENSES\u001b[0m\r\n-rw-r--r-- 1 root root  1531 Sep 12 21:44 MANIFEST.in\r\n-rw-r--r-- 1 root root 11661 Sep 12 21:44 README.md\r\ndrwxr-xr-x 2 root root  4096 Sep 14 00:16 \u001b[01;34m__pycache__\u001b[0m\r\n-rw-r--r-- 1 root root   101 Sep 14 00:16 _version_meson.py\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34masv_bench\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 14 00:16 \u001b[01;34mbuild\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mci\u001b[0m\r\n-rw-r--r-- 1 root root   256 Sep 12 21:42 codecov.yml\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mdoc\u001b[0m\r\n-rw-r--r-- 1 root root  2897 Sep 12 21:44 environment.yml\r\n-rw-r--r-- 1 root root   866 Sep 12 21:42 generate_pxi.py\r\n-rw-r--r-- 1 root root  1715 Sep 12 21:42 generate_version.py\r\ndrwxr-xr-x 2 root root  4096 Sep 12 21:42 \u001b[01;34mgitpod\u001b[0m\r\n-rw-r--r-- 1 root root  1774 Sep 12 21:44 meson.build\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mpandas\u001b[0m\r\n-rw-r--r-- 1 root root 22900 Sep 12 21:44 pyproject.toml\r\n-rw-r--r-- 1 root root  4307 Sep 12 21:42 pyright_reportGeneralTypeIssues.json\r\n-rw-r--r-- 1 root root  1459 Sep 12 21:44 requirements-dev.txt\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mscripts\u001b[0m\r\n-rwxr-xr-x 1 root root 21960 Sep 12 21:44 \u001b[01;32msetup.py\u001b[0m\r\ndrwxr-xr-x 3 root root  4096 Sep 12 21:42 \u001b[01;34mtooling\u001b[0m\r\ndrwxr-xr-x 2 root root  4096 Sep 12 21:42 \u001b[01;34mtypings\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mweb\u001b[0m\r\n"]
[15.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[15.002, "i", "grep -R \"asv.conf\" -n . || true\r"]
[15.004, "o", "grep -R \"asv.conf\" -n . || true\r\n"]
[15.006, "o", "\u001b[?2004l\r\n\u001b[35m\u001b[K./scripts/tests/data/deps_minimum.toml\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K7\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \"Cython>=0.29.32,<3\",  # Note: sync with setup.py, environment.yml and \u001b[01;31m\u001b[Kasv.conf\u001b[m\u001b[K.json\r\n\u001b[35m\u001b[K./pyproject.toml\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K8\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \"Cython~=3.0.5\",  # Note: sync with setup.py, environment.yml and \u001b[01;31m\u001b[Kasv.conf\u001b[m\u001b[K.json\r\n\u001b[35m\u001b[K./doc/source/development/contributing_codebase.rst\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K889\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kthat run benchmarks. The default value is defined in ``\u001b[01;31m\u001b[Kasv.conf\u001b[m\u001b[K.json``.\r\ngrep: ./.git/index: binary file matches\r\ngrep: ./.git/objects/pack/pack-2f73da0dbd4e0dcf7959c9a99b2a31b6bbc6aab6.pack: binary file matches\r\n\u001b[35m\u001b[K./setup.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K39\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K# note: sync with pyproject.toml, environment.yml and \u001b[01;31m\u001b[Kasv.conf\u001b[m\u001b[K.json\r\n"]
[20.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[20.002, "i", "ls -la benchmarks || ls -la asv_bench || ls -la asv || true\r"]
[20.004, "o", "ls -la benchmarks || ls -la asv_bench || ls -la asv || true\r\n"]
[20.006, "o", "\u001b[?2004l\r\nls: cannot access 'benchmarks': No such file or directory\r\ntotal 24\r\ndrwxr-xr-x 1 root root 4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root 4096 Oct  1 17:05 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root 5194 Sep 12 21:44 asv.conf.json\r\ndrwxr-xr-x 1 root root 4096 Sep 12 21:44 \u001b[01;34mbenchmarks\u001b[0m\r\n"]
[25.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[25.002, "i", "grep -R \"class .*arithmetic\\.Ops\" -n . || true\r"]
[25.004, "o", "grep -R \"class .*arithmetic\\.Ops\" -n . || true\r\n"]
[25.006, "o", "\u001b[?2004l\r\n"]
[30.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[30.002, "i", "ls -la | grep -i asv || true\r"]
[30.004, "o", "ls -la | grep -i asv || true\r\n"]
[30.006, "o", "\u001b[?2004l\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;31m\u001b[Kasv\u001b[m\u001b[K_bench\r\n"]
[35.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[35.002, "i", "git status -sb\r"]
[35.004, "o", "git status -sb\r\n"]
[35.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[40.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[40.002, "i", "find . -maxdepth 2 -type f -iname \"asv*.json\" -o -iname \"asv.conf.json\" -print\r"]
[40.004, "o", "find . -maxdepth 2 -type f -iname \"asv*.json\" -o -iname \"asv.conf.json\" -print\r\n"]
[40.006, "o", "\u001b[?2004l\r\n"]
[45.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[45.002, "i", "test -f asv.conf.json && cat asv.conf.json | sed -n '1,120p' || true\r"]
[45.004, "o", "test -f asv.conf.json && cat asv.conf.json | sed -n '1,120p' || true\r\n"]
[45.006, "o", "\u001b[?2004l\r\n"]
[50.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[50.002, "i", "test -f asv.conf.json || (echo \"No asv.conf.json at repo root; searching...\" && find . -name asv.conf.json -print -\r"]
[50.004, "o", "test -f asv.conf.json || (echo \"No asv.conf.json at repo root; searching...\" && find . -name asv.conf.json -print -\r\n"]
[50.006, "o", "-exec bash -lc 'echo ====; sed -n \"1,120p\" {}' \\; )\r\n\u001b[?2004l\r\nNo asv.conf.json at repo root; searching...\r\n./asv_bench/asv.conf.json\r\n====\r\n{\r\n    // The version of the config file format.  Do not change, unless\r\n    // you know what you are doing.\r\n    \"version\": 1,\r\n\r\n    // The name of the project being benchmarked\r\n    \"project\": \"pandas\",\r\n\r\n    // The project's homepage\r\n    \"project_url\": \"https://pandas.pydata.org/\",\r\n\r\n    // The URL of the source code repository for the project being\r\n    // benchmarked\r\n    \"repo\": \"..\",\r\n\r\n    // List of branches to benchmark. If not provided, defaults to \"master\"\r\n    // (for git) or \"default\" (for mercurial).\r\n    \"branches\": [\"main\"],\r\n\r\n    // The tool to use to create environments.  May be \"conda\",\r\n    // \"virtualenv\" or other value depending on the plugins in use.\r\n    // If missing or the empty string, the tool will be automatically\r\n    // determined by looking for tools on the PATH environment\r\n    // variable.\r\n    \"environment_type\": \"conda\",\r\n\r\n    // the base URL to show a commit for the project.\r\n    \"show_commit_url\": \"https://github.com/pandas-dev/pandas/commit/\",\r\n\r\n    // The Pythons you'd like to test against.  If not provided, defaults\r\n    // to the current version of Python used to run `asv`.\r\n    \"pythons\": [\"3.10\"],\r\n\r\n    // The matrix of dependencies to test.  Each key is the name of a\r\n    // package (in PyPI) and the values are version numbers.  An empty\r\n    // list or empty string indicates to just test against the default\r\n    // (latest) version. null indicates that the package is to not be\r\n    // installed. If the package to be tested is only available from\r\n    // PyPi, and the 'environment_type' is conda, then you can preface\r\n    // the package name by 'pip+', and the package will be installed via\r\n    // pip (with all the conda available packages installed first,\r\n    // followed by the pip installed packages).\r\n    \"matrix\": {\r\n        \"pip+build\": [],\r\n        \"Cython\": [\"3.0\"],\r\n        \"matplotlib\": [],\r\n        \"sqlalchemy\": [],\r\n        \"scipy\": [],\r\n        \"numba\": [],\r\n        \"numexpr\": [],\r\n        \"pytables\": [null, \"\"],  // platform dependent, see excludes below\r\n        \"pyarrow\": [],\r\n        \"tables\": [null, \"\"],\r\n        \"openpyxl\": [],\r\n        \"xlsxwriter\": [],\r\n        \"xlrd\": [],\r\n        \"odfpy\": [],\r\n        \"jinja2\": [],\r\n        \"meson\": [],\r\n        \"meson-python\": [],\r\n        \"python-build\": [],\r\n    },\r\n    \"conda_channels\": [\"conda-forge\"],\r\n    // Combinations of libraries/python versions can be excluded/included\r\n    // from the set to test. Each entry is a dictionary containing additional\r\n    // key-value pairs to include/exclude.\r\n    //\r\n    // An exclude entry excludes entries where all values match. The\r\n    // values are regexps that should match the whole string.\r\n    //\r\n    // An include entry adds an environment. Only the packages listed\r\n    // are installed. The 'python' key is required. The exclude rules\r\n    // do not apply to includes.\r\n    //\r\n    // In addition to package names, the following keys are available:\r\n    //\r\n    // - python\r\n    //     Python version, as in the *pythons* variable above.\r\n    // - environment_type\r\n    //     Environment type, as above.\r\n    // - sys_platform\r\n    //     Platform, as in sys.platform. Possible values for the common\r\n    //     cases: 'linux2', 'win32', 'cygwin', 'darwin'.\r\n    \"exclude\": [\r\n        // On conda install pytables, otherwise tables\r\n        {\"environment_type\": \"conda\", \"tables\": \"\"},\r\n        {\"environment_type\": \"conda\", \"pytables\": null},\r\n        {\"environment_type\": \"(?!conda).*\", \"tables\": null},\r\n        {\"environment_type\": \"(?!conda).*\", \"pytables\": \"\"},\r\n    ],\r\n    \"include\": [],\r\n\r\n    // The directory (relative to the current directory) that benchmarks are\r\n    // stored in.  If not provided, defaults to \"benchmarks\"\r\n    // \"benchmark_dir\": \"benchmarks\",\r\n\r\n    // The directory (relative to the current directory) to cache the Python\r\n    // environments in.  If not provided, defaults to \"env\"\r\n    // \"env_dir\": \"env\",\r\n\r\n    // The directory (relative to the current directory) that raw benchmark\r\n    // results are stored in.  If not provided, defaults to \"results\".\r\n    // \"results_dir\": \"results\",\r\n\r\n    // The directory (relative to the current directory) that the html tree\r\n    // should be written to.  If not provided, defaults to \"html\".\r\n    // \"html_dir\": \"html\",\r\n\r\n    // The number of characters to retain in the commit hashes.\r\n    // \"hash_length\": 8,\r\n\r\n    // `asv` will cache wheels of the recent builds in each\r\n    // environment, making them faster to install next time.  This is\r\n    // number of builds to keep, per environment.\r\n    \"build_cache_size\": 8,\r\n\r\n    // The commits after which the regression search in `asv publish`\r\n    // should start looking for regressions. Dictionary whose keys are\r\n    // regexps matching to benchmark names, and values corresponding to\r\n    // the commit (exclusive) after which to start looking for\r\n"]
[55.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[55.002, "i", "grep -R \"arithmetic\\.Ops\" -n benchmarks asv_bench asv || true\r"]
[55.004, "o", "grep -R \"arithmetic\\.Ops\" -n benchmarks asv_bench asv || true\r\n"]
[55.006, "o", "\u001b[?2004l\r\ngrep: benchmarks: No such file or directory\r\ngrep: asv: No such file or directory\r\n"]
[60.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[60.002, "i", "test -f asv_benchmarks.txt && sed -n '1,200p' asv_benchmarks.txt || true\r"]
[60.004, "o", "test -f asv_benchmarks.txt && sed -n '1,200p' asv_benchmarks.txt || true\r\n"]
[60.006, "o", "\u001b[?2004l\r\n"]
[65.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[65.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[65.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[65.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;31mNo `asv.conf` file found for valid extensions: ['.json', '.jsonc'].\u001b[0m\r\n"]
[70.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[70.002, "i", "ls -la asv_bench\r"]
[70.004, "o", "ls -la asv_bench\r\n"]
[70.006, "o", "\u001b[?2004l\r\ntotal 24\r\ndrwxr-xr-x 1 root root 4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root 4096 Oct  1 17:05 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root 5194 Sep 12 21:44 asv.conf.json\r\ndrwxr-xr-x 1 root root 4096 Sep 12 21:44 \u001b[01;34mbenchmarks\u001b[0m\r\n"]
[75.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[75.002, "i", "ls -la asv_bench/benchmarks\r"]
[75.004, "o", "ls -la asv_bench/benchmarks\r\n"]
[75.006, "o", "\u001b[?2004l\r\ntotal 376\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root    25 Sep 12 21:42 __init__.py\r\n-rw-r--r-- 1 root root  6160 Sep 12 21:42 algorithms.py\r\ndrwxr-xr-x 2 root root  4096 Sep 12 21:42 \u001b[01;34malgos\u001b[0m\r\n-rw-r--r-- 1 root root 12498 Sep 12 21:42 arithmetic.py\r\n-rw-r--r-- 1 root root  4282 Sep 12 21:42 array.py\r\n-rw-r--r-- 1 root root  1414 Sep 12 21:42 attrs_caching.py\r\n-rw-r--r-- 1 root root   739 Sep 12 21:42 boolean.py\r\n-rw-r--r-- 1 root root  9776 Sep 12 21:42 categoricals.py\r\n-rw-r--r-- 1 root root  3462 Sep 12 21:42 ctors.py\r\n-rw-r--r-- 1 root root  3559 Sep 12 21:42 dtypes.py\r\n-rw-r--r-- 1 root root  1988 Sep 12 21:42 eval.py\r\n-rw-r--r-- 1 root root   379 Sep 12 21:42 finalize.py\r\n-rw-r--r-- 1 root root  5142 Sep 12 21:42 frame_ctor.py\r\n-rw-r--r-- 1 root root 24291 Sep 12 21:44 frame_methods.py\r\n-rw-r--r-- 1 root root  8150 Sep 12 21:44 gil.py\r\n-rw-r--r-- 1 root root 33292 Sep 12 21:42 groupby.py\r\n-rw-r--r-- 1 root root  2393 Sep 12 21:42 hash_functions.py\r\n-rw-r--r-- 1 root root  2274 Sep 12 21:42 index_cached_properties.py\r\n-rw-r--r-- 1 root root  7138 Sep 12 21:42 index_object.py\r\n-rw-r--r-- 1 root root 16813 Sep 12 21:42 indexing.py\r\n-rw-r--r-- 1 root root  5949 Sep 12 21:44 indexing_engines.py\r\n-rw-r--r-- 1 root root  8662 Sep 12 21:42 inference.py\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mio\u001b[0m\r\n-rw-r--r-- 1 root root 18607 Sep 12 21:42 join_merge.py\r\n-rw-r--r-- 1 root root  2445 Sep 12 21:42 libs.py\r\n-rw-r--r-- 1 root root 12356 Sep 12 21:42 multiindex_object.py\r\n-rw-r--r-- 1 root root   624 Sep 12 21:42 package.py\r\n-rw-r--r-- 1 root root  1740 Sep 12 21:42 pandas_vb_common.py\r\n-rw-r--r-- 1 root root  2909 Sep 12 21:42 period.py\r\n-rw-r--r-- 1 root root  4554 Sep 12 21:42 plotting.py\r\n-rw-r--r-- 1 root root  4948 Sep 12 21:42 reindex.py\r\n-rw-r--r-- 1 root root  2103 Sep 12 21:42 replace.py\r\n-rw-r--r-- 1 root root  9973 Sep 12 21:42 reshape.py\r\n-rw-r--r-- 1 root root 11474 Sep 12 21:44 rolling.py\r\n-rw-r--r-- 1 root root 10677 Sep 12 21:42 series_methods.py\r\n-rw-r--r-- 1 root root  6817 Sep 12 21:42 sparse.py\r\n-rw-r--r-- 1 root root  4685 Sep 12 21:42 stat_ops.py\r\n-rw-r--r-- 1 root root  3535 Sep 12 21:42 strftime.py\r\n-rw-r--r-- 1 root root  7996 Sep 12 21:44 strings.py\r\n-rw-r--r-- 1 root root  1528 Sep 12 21:42 timedelta.py\r\n-rw-r--r-- 1 root root  8565 Sep 12 21:42 timeseries.py\r\ndrwxr-xr-x 2 root root  4096 Sep 12 21:42 \u001b[01;34mtslibs\u001b[0m\r\n"]
[80.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[80.002, "i", "grep -R \"arithmetic\" -n asv_bench/benchmarks || true\r"]
[80.004, "o", "grep -R \"arithmetic\" -n asv_bench/benchmarks || true\r\n"]
[80.006, "o", "\u001b[?2004l\r\n"]
[85.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[85.002, "i", "grep -R \"class .*Ops\" -n asv_bench/benchmarks || true\r"]
[85.004, "o", "grep -R \"class .*Ops\" -n asv_bench/benchmarks || true\r\n"]
[85.006, "o", "\u001b[?2004l\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/boolean.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K6\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass TimeLogicalOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/arithmetic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K174\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Ops\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/arithmetic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K204\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Ops\u001b[m\u001b[K2:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/arithmetic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K286\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass IrregularOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/arithmetic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K298\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass TimedeltaOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/arithmetic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K346\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass NumericInferOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/arithmetic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K373\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass DateInferOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/arithmetic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K454\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass BinaryOps\u001b[m\u001b[KMultiIndex:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/tslibs/timestamp.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K111\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass TimestampOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/series_methods.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K297\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass NanOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/stat_ops.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K8\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass FrameOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/stat_ops.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K23\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass FrameMixedDtypesOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/stat_ops.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K57\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass FrameMultiIndexOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/stat_ops.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K76\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass SeriesOps\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kasv_bench/benchmarks/stat_ops.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K88\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass SeriesMultiIndexOps\u001b[m\u001b[K:\r\n"]
[90.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[90.002, "i", "sed -n '1,200p' asv_bench/benchmarks/arithmetic.py 2>/dev/null || true\r"]
[90.004, "o", "sed -n '1,200p' asv_bench/benchmarks/arithmetic.py 2>/dev/null || true\r\n"]
[90.006, "o", "\u001b[?2004l\r\nimport operator\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nimport pandas as pd\r\nfrom pandas import (\r\n    DataFrame,\r\n    Index,\r\n    Series,\r\n    Timestamp,\r\n    date_range,\r\n    to_timedelta,\r\n)\r\n\r\nfrom .pandas_vb_common import numeric_dtypes\r\n\r\ntry:\r\n    import pandas.core.computation.expressions as expr\r\nexcept ImportError:\r\n    import pandas.computation.expressions as expr\r\ntry:\r\n    import pandas.tseries.holiday\r\nexcept ImportError:\r\n    pass\r\n\r\n\r\nclass IntFrameWithScalar:\r\n    params = [\r\n        [np.float64, np.int64],\r\n        [2, 3.0, np.int32(4), np.float64(5)],\r\n        [\r\n            operator.add,\r\n            operator.sub,\r\n            operator.mul,\r\n            operator.truediv,\r\n            operator.floordiv,\r\n            operator.pow,\r\n            operator.mod,\r\n            operator.eq,\r\n            operator.ne,\r\n            operator.gt,\r\n            operator.ge,\r\n            operator.lt,\r\n            operator.le,\r\n        ],\r\n    ]\r\n    param_names = [\"dtype\", \"scalar\", \"op\"]\r\n\r\n    def setup(self, dtype, scalar, op):\r\n        arr = np.random.randn(20000, 100)\r\n        self.df = DataFrame(arr.astype(dtype))\r\n\r\n    def time_frame_op_with_scalar(self, dtype, scalar, op):\r\n        op(self.df, scalar)\r\n\r\n\r\nclass OpWithFillValue:\r\n    def setup(self):\r\n        # GH#31300\r\n        arr = np.arange(10**6)\r\n        df = DataFrame({\"A\": arr})\r\n        ser = df[\"A\"]\r\n\r\n        self.df = df\r\n        self.ser = ser\r\n\r\n    def time_frame_op_with_fill_value_no_nas(self):\r\n        self.df.add(self.df, fill_value=4)\r\n\r\n    def time_series_op_with_fill_value_no_nas(self):\r\n        self.ser.add(self.ser, fill_value=4)\r\n\r\n\r\nclass MixedFrameWithSeriesAxis:\r\n    params = [\r\n        [\r\n            \"eq\",\r\n            \"ne\",\r\n            \"lt\",\r\n            \"le\",\r\n            \"ge\",\r\n            \"gt\",\r\n            \"add\",\r\n            \"sub\",\r\n            \"truediv\",\r\n            \"floordiv\",\r\n            \"mul\",\r\n            \"pow\",\r\n        ]\r\n    ]\r\n    param_names = [\"opname\"]\r\n\r\n    def setup(self, opname):\r\n        arr = np.arange(10**6).reshape(1000, -1)\r\n        df = DataFrame(arr)\r\n        df[\"C\"] = 1.0\r\n        self.df = df\r\n        self.ser = df[0]\r\n        self.row = df.iloc[0]\r\n\r\n    def time_frame_op_with_series_axis0(self, opname):\r\n        getattr(self.df, opname)(self.ser, axis=0)\r\n\r\n    def time_frame_op_with_series_axis1(self, opname):\r\n        getattr(operator, opname)(self.df, self.ser)\r\n\r\n    # exclude comparisons from the params for time_frame_op_with_series_axis1\r\n    #  since they do not do alignment so raise\r\n    time_frame_op_with_series_axis1.params = [params[0][6:]]\r\n\r\n\r\nclass FrameWithFrameWide:\r\n    # Many-columns, mixed dtypes\r\n\r\n    params = [\r\n        [\r\n            # GH#32779 has discussion of which operators are included here\r\n            operator.add,\r\n            operator.floordiv,\r\n            operator.gt,\r\n        ],\r\n        [\r\n            # (n_rows, n_columns)\r\n            (1_000_000, 10),\r\n            (100_000, 100),\r\n            (10_000, 1000),\r\n            (1000, 10_000),\r\n        ],\r\n    ]\r\n    param_names = [\"op\", \"shape\"]\r\n\r\n    def setup(self, op, shape):\r\n        # we choose dtypes so as to make the blocks\r\n        #  a) not perfectly match between right and left\r\n        #  b) appreciably bigger than single columns\r\n        n_rows, n_cols = shape\r\n\r\n        if op is operator.floordiv:\r\n            # floordiv is much slower than the other operations -> use less data\r\n            n_rows = n_rows // 10\r\n\r\n        # construct dataframe with 2 blocks\r\n        arr1 = np.random.randn(n_rows, n_cols // 2).astype(\"f8\")\r\n        arr2 = np.random.randn(n_rows, n_cols // 2).astype(\"f4\")\r\n        df = pd.concat([DataFrame(arr1), DataFrame(arr2)], axis=1, ignore_index=True)\r\n        # should already be the case, but just to be sure\r\n        df._consolidate_inplace()\r\n\r\n        # TODO: GH#33198 the setting here shouldn't need two steps\r\n        arr1 = np.random.randn(n_rows, max(n_cols // 4, 3)).astype(\"f8\")\r\n        arr2 = np.random.randn(n_rows, n_cols // 2).astype(\"i8\")\r\n        arr3 = np.random.randn(n_rows, n_cols // 4).astype(\"f8\")\r\n        df2 = pd.concat(\r\n            [DataFrame(arr1), DataFrame(arr2), DataFrame(arr3)],\r\n            axis=1,\r\n            ignore_index=True,\r\n        )\r\n        # should already be the case, but just to be sure\r\n        df2._consolidate_inplace()\r\n\r\n        self.left = df\r\n        self.right = df2\r\n\r\n    def time_op_different_blocks(self, op, shape):\r\n        # blocks (and dtypes) are not aligned\r\n        op(self.left, self.right)\r\n\r\n    def time_op_same_blocks(self, op, shape):\r\n        # blocks (and dtypes) are aligned\r\n        op(self.left, self.left)\r\n\r\n\r\nclass Ops:\r\n    params = [[True, False], [\"default\", 1]]\r\n    param_names = [\"use_numexpr\", \"threads\"]\r\n\r\n    def setup(self, use_numexpr, threads):\r\n        self.df = DataFrame(np.random.randn(20000, 100))\r\n        self.df2 = DataFrame(np.random.randn(20000, 100))\r\n\r\n        if threads != \"default\":\r\n            expr.set_numexpr_threads(threads)\r\n        if not use_numexpr:\r\n            expr.set_use_numexpr(False)\r\n\r\n    def time_frame_add(self, use_numexpr, threads):\r\n        self.df + self.df2\r\n\r\n    def time_frame_mult(self, use_numexpr, threads):\r\n        self.df * self.df2\r\n\r\n    def time_frame_multi_and(self, use_numexpr, threads):\r\n        self.df[(self.df > 0) & (self.df2 > 0)]\r\n\r\n    def time_frame_comparison(self, use_numexpr, threads):\r\n        self.df > self.df2\r\n\r\n    def teardown(self, use_numexpr, threads):\r\n        expr.set_use_numexpr(True)\r\n"]
[95.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[95.002, "i", "asv run --python=same --config=asv_bench/asv.conf.json --bench=\"arithmetic.Ops.*\"\r"]
[95.004, "o", "asv run --python=same --config=asv_bench/asv.conf.json --bench=\"arithmetic.Ops.*\"\r\n"]
[95.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;31mConfig file asv_bench/asv.conf.json not found.\u001b[0m\r\n"]
[100.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[100.002, "i", "cd asv_bench\r"]
[100.004, "o", "cd asv_bench\r\n"]
[100.006, "o", "\u001b[?2004l\r\n"]
[105.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[105.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[105.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[105.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      2.51\u00b10.1ms   2.66\u00b10.2ms \r\n                 False      2.16\u00b10.2ms   2.30\u00b10.3ms \r\n             ============= ============ ============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0masv run -e existing --python=same --bench=\"arithmetic.Ops.*\"\r\n                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       2.18\u00b10.1ms   2.26\u00b10.08ms \r\n                 False      1.81\u00b10.08ms   1.73\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       2.50\u00b10.2ms    2.57\u00b10.1ms \r\n                 False      2.09\u00b10.07ms   2.16\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      10.7\u00b10.2ms   13.1\u00b10.09ms \r\n                 False      10.2\u00b10.2ms    10.2\u00b10.1ms \r\n             ============= ============ =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.2\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.6\u00b10.1ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              769\u00b180\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.3\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.9\u00b10.3ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                              1.53\u00b10.1ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.4\u00b10.08ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      429\u00b12\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.9\u00b10.4\u03bcs\r\n"]
[110.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[110.002, "i", "asv run -e existing --python=same --bench=\"arithmetic.Ops.*\"\r"]
[110.004, "o", "asv run -e existing --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[110.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;31mNo range spec may be specified if benchmarking in an existing environment\u001b[0m\r\n"]
[115.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[115.002, "i", "asv profile --python=same arithmetic.Ops.time_frame_add\r"]
[115.004, "o", "asv profile --python=same arithmetic.Ops.time_frame_add\r\n"]
[115.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;31m'arithmetic.Ops.time_frame_add' benchmark not found\u001b[0m\r\n"]
[120.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[120.002, "i", "cd ..\r"]
[120.004, "o", "cd ..\r\n"]
[120.006, "o", "\u001b[?2004l\r\n"]
[125.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[125.002, "i", "ls -la pandas | sed -n '1,120p'\r"]
[125.004, "o", "ls -la pandas | sed -n '1,120p'\r\n"]
[125.006, "o", "\u001b[?2004l\r\ntotal 172\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 .\r\ndrwxr-xr-x 1 root root  4096 Oct  1 17:05 ..\r\n-rw-r--r-- 1 root root  8178 Sep 12 21:44 __init__.py\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 _config\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 _libs\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 _testing\r\n-rw-r--r-- 1 root root 14498 Sep 12 21:44 _typing.py\r\n-rw-r--r-- 1 root root 23621 Sep 12 21:44 _version.py\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 api\r\ndrwxr-xr-x 2 root root  4096 Sep 12 21:42 arrays\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 compat\r\n-rw-r--r-- 1 root root 52269 Sep 12 21:44 conftest.py\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 core\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 errors\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 io\r\n-rw-r--r-- 1 root root  1018 Sep 12 21:42 meson.build\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 plotting\r\n-rw-r--r-- 1 root root   312 Sep 12 21:42 testing.py\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 tests\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 tseries\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 util\r\n"]
[130.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[130.002, "i", "grep -RIn \"normalise\\|Normalize\\|normalization\\|normalisation\\|normalised\\|normalised\" pandas || true\r"]
[130.004, "o", "grep -RIn \"normalise\\|Normalize\\|normalization\\|normalisation\\|normalised\\|normalised\" pandas || true\r\n"]
[130.006, "o", "\u001b[?2004l\r\n\u001b[35m\u001b[Kpandas/core/frame.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12160\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1 by default. This can be changed using the ddof argument\r\n\u001b[35m\u001b[Kpandas/core/frame.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12280\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1 by default. This can be changed using the ddof argument.\r\n\u001b[35m\u001b[Kpandas/core/frame.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12399\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1 by default. This can be changed using the ddof argument.\r\n\u001b[35m\u001b[Kpandas/core/frame.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12521\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1.\r\n\u001b[35m\u001b[Kpandas/core/frame.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12642\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        kurtosis (kurtosis of normal == 0.0). \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1.\r\n\u001b[35m\u001b[Kpandas/core/arrays/datetimes.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2315\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by `N-1` by default. This can be changed using ``ddof``.\r\n\u001b[35m\u001b[Kpandas/core/reshape/pivot.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K942\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K by dividing all values by the sum of values.\r\n\u001b[35m\u001b[Kpandas/core/reshape/pivot.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1159\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K core\r\n\u001b[35m\u001b[Kpandas/core/indexes/datetimes.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K864\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/core/indexes/datetimes.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1056\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/core/generic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12779\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            \"Return unbiased variance over requested axis.\\n\\n\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by \"\r\n\u001b[35m\u001b[Kpandas/core/generic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12790\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            \"\\n\\n\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1 by default. This can be changed using the \"\r\n\u001b[35m\u001b[Kpandas/core/generic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12801\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            \"axis.\\n\\n\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1 by default. This can be changed \"\r\n\u001b[35m\u001b[Kpandas/core/generic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12844\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        desc = \"Return unbiased skew over requested axis.\\n\\n\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1.\"\r\n\u001b[35m\u001b[Kpandas/core/generic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K12892\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            \"kurtosis (kurtosis of normal == 0.0). \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd \"\r\n\u001b[35m\u001b[Kpandas/core/apply.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1702\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K user-provided \"named aggregation\" kwargs.\r\n\u001b[35m\u001b[Kpandas/core/apply.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1726\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    # \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K the aggregation functions as Mapping[column, List[func]],\r\n\u001b[35m\u001b[Kpandas/core/groupby/groupby.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2681\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            # \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K the results by dividing by the original group sizes.\r\n\u001b[35m\u001b[Kpandas/core/groupby/groupby.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K5409\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            sampling probabilities after \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K within each group.\r\n\u001b[35m\u001b[Kpandas/core/groupby/generic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1219\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1.\r\n\u001b[35m\u001b[Kpandas/core/groupby/generic.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2932\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1.\r\n\u001b[35m\u001b[Kpandas/core/series.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K7071\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1 by default. This can be changed using the ddof argument.\r\n\u001b[35m\u001b[Kpandas/core/series.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K7190\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        kurtosis (kurtosis of normal == 0.0). \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd by N-1.\r\n\u001b[35m\u001b[Kpandas/io/json/_normalize.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K# JSON \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K routines\r\n\u001b[35m\u001b[Kpandas/io/json/_normalize.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K280\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K semi-structured JSON data into a flat table.\r\n\u001b[35m\u001b[Kpandas/io/json/_normalize.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K357\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Ks nested data up to level 1.\r\n\u001b[35m\u001b[Kpandas/io/json/_normalize.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K519\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            # naive \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K, this is idempotent for flat records\r\n\u001b[35m\u001b[Kpandas/io/json/_json.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K687\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    json_normalize : \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K semi-structured JSON data into a flat table.\r\n\u001b[35m\u001b[Kpandas/io/formats/style.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4043\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    norm = _matplotlib.colors.\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K(smin - (rng * low), smax + (rng * high))\r\n\u001b[35m\u001b[Kpandas/io/formats/style.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4338\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        norm = _matplotlib.colors.\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K(left, right)\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/vectorized.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K263\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K each of the (nanosecond) timezone aware timestamps in the given\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/timestamps.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1243\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K Timestamp to midnight, preserving tz information.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1848\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2040\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2615\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2654\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2695\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2749\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2871\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2912\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2953\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K2994\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3100\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3141\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3182\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3215\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3275\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3313\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3350\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3388\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3563\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3617\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3656\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3852\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K3935\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4084\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4287\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4522\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4594\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4725\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start/end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4914\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K end dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/offsets.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K4975\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K start dates to midnight before generating date range.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/parsing.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K954\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    # \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K offset part of tokens.\r\n\u001b[35m\u001b[Kpandas/_libs/tslibs/parsing.pyx\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K977\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            # So in addition to the format \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K, we rejoin them here.\r\n\u001b[35m\u001b[Kpandas/tests/strings/test_strings.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K652\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    with pytest.raises(ValueError, match=\"invalid \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K form\"):\r\n\u001b[35m\u001b[Kpandas/tests/tslibs/test_npy_units.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K10\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kclass TestIsDateArray\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[Kd:\r\n\u001b[35m\u001b[Kpandas/tests/plotting/frame/test_frame.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K993\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        default_norm = mpl.colors.\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K(*color_min_max)\r\n\u001b[35m\u001b[Kpandas/tests/reshape/test_crosstab.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K764\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # use multiple columns with margins and \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K\r\n\u001b[35m\u001b[Kpandas/tests/io/json/test_normalize.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K112\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kclass TestJSON\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kpandas/tests/io/formats/test_css.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K36\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kdef test_css_parse_\u001b[01;31m\u001b[Knormalisation\u001b[m\u001b[K(name, norm, abnorm):\r\n\u001b[35m\u001b[Kpandas/tests/indexes/datetimes/methods/test_normalize.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K17\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kclass Test\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kpandas/tests/indexes/datetimes/test_scalar_compat.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K203\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # work around different \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K schemes GH#22342\r\n\u001b[35m\u001b[Kpandas/tests/frame/methods/test_to_csv.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K1397\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # \u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K carriage return for Windows OS\r\n\u001b[35m\u001b[Kpandas/tests/tseries/offsets/test_offsets_properties.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K63\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    # 2) that hour is not incorrectly changed by this \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K\r\n\u001b[35m\u001b[Kpandas/tests/scalar/timestamp/test_timestamp.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K142\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # different \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[Ks\r\n\u001b[35m\u001b[Kpandas/tests/scalar/timestamp/methods/test_normalize.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K7\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[Kclass TestTimestamp\u001b[01;31m\u001b[KNormalize\u001b[m\u001b[K:\r\n\u001b[35m\u001b[Kpandas/tests/scalar/timestamp/methods/test_replace.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K146\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # 2) that hour is not incorrectly changed by this \u001b[01;31m\u001b[Knormalization\u001b[m\u001b[K\r\n"]
[135.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[135.002, "i", "grep -RIn \"normalize\\|normalized\\|normalizer\" pandas | head -n 50 || true\r"]
[135.004, "o", "grep -RIn \"normalize\\|normalized\\|normalizer\" pandas | head -n 50 || true\r\n"]
[135.006, "o", "\u001b[?2004l\r\npandas/core/frame.py:7286:        normalize: bool = False,\r\npandas/core/frame.py:7298:        normalize : bool, default False\r\npandas/core/frame.py:7364:        >>> df.value_counts(normalize=True)\r\npandas/core/frame.py:7410:        name = \"proportion\" if normalize else \"count\"\r\npandas/core/frame.py:7418:        if normalize:\r\npandas/core/frame.py:11192:        The covariance is normalized by N-ddof.\r\npandas/core/frame.py:12339:        Alternatively, ``ddof=0`` can be set to normalize by N instead of N-1:\r\npandas/core/frame.py:12465:        Alternatively, `ddof=0` can be set to normalize by N instead of N-1:\r\npandas/core/window/ewm.py:542:                normalize=True,\r\npandas/core/window/ewm.py:556:                normalize=True,\r\npandas/core/window/ewm.py:610:                normalize=False,\r\npandas/core/window/ewm.py:624:                normalize=False,\r\npandas/core/window/numba_.py:90:    normalize: bool,\r\npandas/core/window/numba_.py:108:    normalize : bool\r\npandas/core/window/numba_.py:148:                        if normalize:\r\npandas/core/window/numba_.py:158:                            if normalize:\r\npandas/core/window/numba_.py:162:                                    if normalize:\r\npandas/core/window/numba_.py:274:    normalize: bool,\r\npandas/core/window/numba_.py:292:    normalize: bool\r\npandas/core/window/numba_.py:326:                        if normalize:\r\npandas/core/window/numba_.py:336:                            if normalize:\r\npandas/core/window/numba_.py:342:                                    if normalize:\r\npandas/core/algorithms.py:848:    normalize: bool = False,\r\npandas/core/algorithms.py:858:    name = \"proportion\" if normalize else \"count\"\r\npandas/core/algorithms.py:921:    if normalize:\r\npandas/core/sample.py:138:        to the vector normalized\r\npandas/core/resample.py:2658:        first = first.normalize()\r\npandas/core/resample.py:2659:        last = last.normalize()\r\npandas/core/resample.py:2768:        origin_timestamp = first.normalize()._value\r\npandas/core/resample.py:2834:    normalize: bool = False,\r\npandas/core/resample.py:2868:        if normalize:\r\npandas/core/resample.py:2869:            new_obj.index = new_obj.index.normalize()\r\npandas/core/strings/accessor.py:3196:    def normalize(self, form):\r\npandas/core/strings/accessor.py:3201:        :func:`unicodedata.normalize`.\r\npandas/core/strings/accessor.py:3213:            and contains the normalized strings.\r\npandas/core/strings/accessor.py:3228:        >>> ser.str.normalize(\"NFC\") == ser.str.normalize(\"NFD\")\r\npandas/core/strings/accessor.py:3232:        result = self._data.array._str_normalize(form)\r\npandas/core/strings/object_array.py:497:    def _str_normalize(self, form):\r\npandas/core/strings/object_array.py:498:        f = lambda x: unicodedata.normalize(form, x)\r\npandas/core/strings/base.py:239:    def _str_normalize(self, form):\r\npandas/core/arrays/arrow/array.py:2554:    def _str_normalize(self, form: Literal[\"NFC\", \"NFD\", \"NFKC\", \"NFKD\"]) -> Self:\r\npandas/core/arrays/arrow/array.py:2555:        predicate = lambda val: unicodedata.normalize(form, val)\r\npandas/core/arrays/arrow/array.py:2834:    def _dt_normalize(self) -> Self:\r\npandas/core/arrays/datetimes.py:37:    is_date_array_normalized,\r\npandas/core/arrays/datetimes.py:40:    normalize_i8_timestamps,\r\npandas/core/arrays/datetimes.py:274:        \"normalize\",\r\npandas/core/arrays/datetimes.py:420:        normalize: bool = False,\r\npandas/core/arrays/datetimes.py:459:        start, end = _maybe_normalize_endpoints(start, end, normalize)\r\npandas/core/arrays/datetimes.py:648:    def is_normalized(self) -> bool:\r\npandas/core/arrays/datetimes.py:652:        return is_date_array_normalized(self.asi8, self.tz, reso=self._creso)\r\n"]
[140.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[140.002, "i", "sed -n '1,240p' asv_bench/benchmarks/arithmetic.py\r"]
[140.004, "o", "sed -n '1,240p' asv_bench/benchmarks/arithmetic.py\r\n"]
[140.006, "o", "\u001b[?2004l\r\nimport operator\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nimport pandas as pd\r\nfrom pandas import (\r\n    DataFrame,\r\n    Index,\r\n    Series,\r\n    Timestamp,\r\n    date_range,\r\n    to_timedelta,\r\n)\r\n\r\nfrom .pandas_vb_common import numeric_dtypes\r\n\r\ntry:\r\n    import pandas.core.computation.expressions as expr\r\nexcept ImportError:\r\n    import pandas.computation.expressions as expr\r\ntry:\r\n    import pandas.tseries.holiday\r\nexcept ImportError:\r\n    pass\r\n\r\n\r\nclass IntFrameWithScalar:\r\n    params = [\r\n        [np.float64, np.int64],\r\n        [2, 3.0, np.int32(4), np.float64(5)],\r\n        [\r\n            operator.add,\r\n            operator.sub,\r\n            operator.mul,\r\n            operator.truediv,\r\n            operator.floordiv,\r\n            operator.pow,\r\n            operator.mod,\r\n            operator.eq,\r\n            operator.ne,\r\n            operator.gt,\r\n            operator.ge,\r\n            operator.lt,\r\n            operator.le,\r\n        ],\r\n    ]\r\n    param_names = [\"dtype\", \"scalar\", \"op\"]\r\n\r\n    def setup(self, dtype, scalar, op):\r\n        arr = np.random.randn(20000, 100)\r\n        self.df = DataFrame(arr.astype(dtype))\r\n\r\n    def time_frame_op_with_scalar(self, dtype, scalar, op):\r\n        op(self.df, scalar)\r\n\r\n\r\nclass OpWithFillValue:\r\n    def setup(self):\r\n        # GH#31300\r\n        arr = np.arange(10**6)\r\n        df = DataFrame({\"A\": arr})\r\n        ser = df[\"A\"]\r\n\r\n        self.df = df\r\n        self.ser = ser\r\n\r\n    def time_frame_op_with_fill_value_no_nas(self):\r\n        self.df.add(self.df, fill_value=4)\r\n\r\n    def time_series_op_with_fill_value_no_nas(self):\r\n        self.ser.add(self.ser, fill_value=4)\r\n\r\n\r\nclass MixedFrameWithSeriesAxis:\r\n    params = [\r\n        [\r\n            \"eq\",\r\n            \"ne\",\r\n            \"lt\",\r\n            \"le\",\r\n            \"ge\",\r\n            \"gt\",\r\n            \"add\",\r\n            \"sub\",\r\n            \"truediv\",\r\n            \"floordiv\",\r\n            \"mul\",\r\n            \"pow\",\r\n        ]\r\n    ]\r\n    param_names = [\"opname\"]\r\n\r\n    def setup(self, opname):\r\n        arr = np.arange(10**6).reshape(1000, -1)\r\n        df = DataFrame(arr)\r\n        df[\"C\"] = 1.0\r\n        self.df = df\r\n        self.ser = df[0]\r\n        self.row = df.iloc[0]\r\n\r\n    def time_frame_op_with_series_axis0(self, opname):\r\n        getattr(self.df, opname)(self.ser, axis=0)\r\n\r\n    def time_frame_op_with_series_axis1(self, opname):\r\n        getattr(operator, opname)(self.df, self.ser)\r\n\r\n    # exclude comparisons from the params for time_frame_op_with_series_axis1\r\n    #  since they do not do alignment so raise\r\n    time_frame_op_with_series_axis1.params = [params[0][6:]]\r\n\r\n\r\nclass FrameWithFrameWide:\r\n    # Many-columns, mixed dtypes\r\n\r\n    params = [\r\n        [\r\n            # GH#32779 has discussion of which operators are included here\r\n            operator.add,\r\n            operator.floordiv,\r\n            operator.gt,\r\n        ],\r\n        [\r\n            # (n_rows, n_columns)\r\n            (1_000_000, 10),\r\n            (100_000, 100),\r\n            (10_000, 1000),\r\n            (1000, 10_000),\r\n        ],\r\n    ]\r\n    param_names = [\"op\", \"shape\"]\r\n\r\n    def setup(self, op, shape):\r\n        # we choose dtypes so as to make the blocks\r\n        #  a) not perfectly match between right and left\r\n        #  b) appreciably bigger than single columns\r\n        n_rows, n_cols = shape\r\n\r\n        if op is operator.floordiv:\r\n            # floordiv is much slower than the other operations -> use less data\r\n            n_rows = n_rows // 10\r\n\r\n        # construct dataframe with 2 blocks\r\n        arr1 = np.random.randn(n_rows, n_cols // 2).astype(\"f8\")\r\n        arr2 = np.random.randn(n_rows, n_cols // 2).astype(\"f4\")\r\n        df = pd.concat([DataFrame(arr1), DataFrame(arr2)], axis=1, ignore_index=True)\r\n        # should already be the case, but just to be sure\r\n        df._consolidate_inplace()\r\n\r\n        # TODO: GH#33198 the setting here shouldn't need two steps\r\n        arr1 = np.random.randn(n_rows, max(n_cols // 4, 3)).astype(\"f8\")\r\n        arr2 = np.random.randn(n_rows, n_cols // 2).astype(\"i8\")\r\n        arr3 = np.random.randn(n_rows, n_cols // 4).astype(\"f8\")\r\n        df2 = pd.concat(\r\n            [DataFrame(arr1), DataFrame(arr2), DataFrame(arr3)],\r\n            axis=1,\r\n            ignore_index=True,\r\n        )\r\n        # should already be the case, but just to be sure\r\n        df2._consolidate_inplace()\r\n\r\n        self.left = df\r\n        self.right = df2\r\n\r\n    def time_op_different_blocks(self, op, shape):\r\n        # blocks (and dtypes) are not aligned\r\n        op(self.left, self.right)\r\n\r\n    def time_op_same_blocks(self, op, shape):\r\n        # blocks (and dtypes) are aligned\r\n        op(self.left, self.left)\r\n\r\n\r\nclass Ops:\r\n    params = [[True, False], [\"default\", 1]]\r\n    param_names = [\"use_numexpr\", \"threads\"]\r\n\r\n    def setup(self, use_numexpr, threads):\r\n        self.df = DataFrame(np.random.randn(20000, 100))\r\n        self.df2 = DataFrame(np.random.randn(20000, 100))\r\n\r\n        if threads != \"default\":\r\n            expr.set_numexpr_threads(threads)\r\n        if not use_numexpr:\r\n            expr.set_use_numexpr(False)\r\n\r\n    def time_frame_add(self, use_numexpr, threads):\r\n        self.df + self.df2\r\n\r\n    def time_frame_mult(self, use_numexpr, threads):\r\n        self.df * self.df2\r\n\r\n    def time_frame_multi_and(self, use_numexpr, threads):\r\n        self.df[(self.df > 0) & (self.df2 > 0)]\r\n\r\n    def time_frame_comparison(self, use_numexpr, threads):\r\n        self.df > self.df2\r\n\r\n    def teardown(self, use_numexpr, threads):\r\n        expr.set_use_numexpr(True)\r\n        expr.set_numexpr_threads()\r\n\r\n\r\nclass Ops2:\r\n    def setup(self):\r\n        N = 10**3\r\n        self.df = DataFrame(np.random.randn(N, N))\r\n        self.df2 = DataFrame(np.random.randn(N, N))\r\n\r\n        self.df_int = DataFrame(\r\n            np.random.randint(\r\n                np.iinfo(np.int16).min, np.iinfo(np.int16).max, size=(N, N)\r\n            )\r\n        )\r\n        self.df2_int = DataFrame(\r\n            np.random.randint(\r\n                np.iinfo(np.int16).min, np.iinfo(np.int16).max, size=(N, N)\r\n            )\r\n        )\r\n\r\n        self.s = Series(np.random.randn(N))\r\n\r\n    # Division\r\n\r\n    def time_frame_float_div(self):\r\n        self.df // self.df2\r\n\r\n    def time_frame_float_div_by_zero(self):\r\n        self.df / 0\r\n\r\n    def time_frame_float_floor_by_zero(self):\r\n        self.df // 0\r\n\r\n    def time_frame_int_div_by_zero(self):\r\n        self.df_int / 0\r\n\r\n    # Modulo\r\n\r\n    def time_frame_int_mod(self):\r\n        self.df_int % self.df2_int\r\n"]
[145.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[145.002, "i", "cd asv_bench\r"]
[145.004, "o", "cd asv_bench\r\n"]
[145.006, "o", "\u001b[?2004l\r\n"]
[150.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[150.002, "i", "asv profile --python=same benchmarks/arithmetic.py:Ops.time_frame_add\r"]
[150.004, "o", "asv profile --python=same benchmarks/arithmetic.py:Ops.time_frame_add\r\n"]
[150.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;31m'benchmarks/arithmetic.py:Ops.time_frame_add' benchmark not found\u001b[0m\r\n"]
[155.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[155.002, "i", "grep -RIn \"def _arith_method\\|def _arith_op\\|def operate\\|def _arith\\|class _arith\" pandas/core/ops || tr\r"]
[155.004, "o", "grep -RIn \"def _arith_method\\|def _arith_op\\|def operate\\|def _arith\\|class _arith\" pandas/core/ops || tr\r\n"]
[155.006, "o", "rue\r\n\u001b[?2004l\r\ngrep: pandas/core/ops: No such file or directory\r\n"]
[160.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[160.002, "i", "ls -la pandas/core/ops\r"]
[160.004, "o", "ls -la pandas/core/ops\r\n"]
[160.006, "o", "\u001b[?2004l\r\nls: cannot access 'pandas/core/ops': No such file or directory\r\n"]
[165.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[165.002, "i", "python - << 'PY'\r"]
[165.004, "o", "python - << 'PY'\r\n"]
[165.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> import cProfile, pstats, io\r\n\u001b[?2004l\r\n\u001b[?2004h> import numpy as np\r\n\u001b[?2004l\r\n\u001b[?2004h> import pandas as pd\r\n\u001b[?2004l\r\n\u001b[?2004h> from pandas.core.computation import expressions as expr\r\n\u001b[?2004l\r\n\u001b[?2004h> \r\n\u001b[?2004l\r\n\u001b[?2004h> # replicate Ops.setup\r\n\u001b[?2004l\r\n\u001b[?2004h> df = pd.DataFrame(np.random.randn(20000, 100))\r\n\u001b[?2004l\r\n\u001b[?2004h> df2 = pd.DataFrame(np.random.randn(20000, 100))\r\n\u001b[?2004l\r\n\u001b[?2004h> \r\n\u001b[?2004l\r\n\u001b[?2004h> # ensure numexpr default\r\n\u001b[?2004l\r\n\u001b[?2004h> expr.set_use_numexpr(True)\r\n\u001b[?2004l\r\n\u001b[?2004h> expr.set_numexpr_threads()\r\n\u001b[?2004l\r\n\u001b[?2004h> \r\n\u001b[?2004l\r\n\u001b[?2004h> pr = cProfile.Profile()\r\n\u001b[?2004l\r\n\u001b[?2004h> pr.enable()\r\n\u001b[?2004l\r\n\u001b[?2004h> # exercise multiple ops to collect hotspots\r\n\u001b[?2004l\r\n\u001b[?2004h> for _ in range(5):\r\n\u001b[?2004l\r\n\u001b[?2004h>     _ = df + df2\r\n\u001b[?2004l\r\n\u001b[?2004h>     _ = df * df2\r\n\u001b[?2004l\r\n\u001b[?2004h>     _ = df > df2\r\n\u001b[?2004l\r\n\u001b[?2004h>     _ = df[(df > 0) & (df2 > 0)]\r\n\u001b[?2004l\r\n\u001b[?2004h> pr.disable()\r\n\u001b[?2004l\r\n\u001b[?2004h> s = io.StringIO()\r\n\u001b[?2004l\r\n\u001b[?2004h> ps = pstats.Stats(pr, stream=s).sort_stats('cumulative')\r\n\u001b[?2004l\r\n\u001b[?2004h> ps.print_stats(30)\r\n\u001b[?2004l\r\n\u001b[?2004h> print(s.getvalue())\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\n         14428 function calls (13626 primitive calls) in 0.095 seconds\r\n\r\n   Ordered by: cumulative time\r\n   List reduced from 364 to 30 due to restriction <30>\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n       30    0.000    0.000    0.072    0.002 /opt/conda/envs/asv_3.10/lib/python3.10/site-packages/numexpr/necompiler.py:905(evaluate)\r\n       30    0.068    0.002    0.068    0.002 /opt/conda/envs/asv_3.10/lib/python3.10/site-packages/numexpr/necompiler.py:983(re_evaluate)\r\n       30    0.000    0.000    0.065    0.002 /workspace/repo/pandas/core/ops/common.py:62(new_method)\r\n       30    0.000    0.000    0.059    0.002 /workspace/repo/pandas/core/frame.py:7878(_dispatch_frame_op)\r\n       25    0.000    0.000    0.053    0.002 /workspace/repo/pandas/core/ops/array_ops.py:188(_na_arithmetic_op)\r\n       25    0.000    0.000    0.052    0.002 /workspace/repo/pandas/core/computation/expressions.py:227(evaluate)\r\n      100    0.001    0.000    0.052    0.001 /workspace/repo/pandas/core/internals/managers.py:392(apply)\r\n       25    0.000    0.000    0.052    0.002 /workspace/repo/pandas/core/computation/expressions.py:96(_evaluate_numexpr)\r\n       20    0.000    0.000    0.035    0.002 /workspace/repo/pandas/core/internals/managers.py:1624(operate_blockwise)\r\n       20    0.000    0.000    0.035    0.002 /workspace/repo/pandas/core/internals/ops.py:57(operate_blockwise)\r\n       15    0.000    0.000    0.035    0.002 /workspace/repo/pandas/core/arraylike.py:55(__gt__)\r\n       15    0.000    0.000    0.035    0.002 /workspace/repo/pandas/core/frame.py:7854(_cmp_method)\r\n       15    0.000    0.000    0.031    0.002 /workspace/repo/pandas/core/ops/array_ops.py:287(comparison_op)\r\n        5    0.000    0.000    0.030    0.006 /workspace/repo/pandas/core/frame.py:3934(__getitem__)\r\n        5    0.000    0.000    0.030    0.006 /workspace/repo/pandas/core/generic.py:9860(where)\r\n        5    0.000    0.000    0.030    0.006 /workspace/repo/pandas/core/generic.py:9682(_where)\r\n       15    0.000    0.000    0.030    0.002 /workspace/repo/pandas/core/frame.py:7863(_arith_method)\r\n        5    0.000    0.000    0.028    0.006 /workspace/repo/pandas/core/internals/managers.py:461(where)\r\n        5    0.002    0.000    0.027    0.005 /workspace/repo/pandas/core/internals/blocks.py:1211(where)\r\n       10    0.000    0.000    0.023    0.002 /workspace/repo/pandas/core/internals/blocks.py:343(apply)\r\n       10    0.000    0.000    0.022    0.002 /workspace/repo/pandas/core/ops/array_ops.py:239(arithmetic_op)\r\n        5    0.000    0.000    0.021    0.004 /workspace/repo/pandas/core/computation/expressions.py:247(where)\r\n        5    0.000    0.000    0.021    0.004 /workspace/repo/pandas/core/computation/expressions.py:178(_where_numexpr)\r\n        5    0.000    0.000    0.013    0.003 /workspace/repo/pandas/core/arraylike.py:203(__mul__)\r\n        5    0.000    0.000    0.013    0.003 /workspace/repo/pandas/core/arraylike.py:99(__add__)\r\n       10    0.004    0.000    0.004    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n        5    0.000    0.000    0.004    0.001 {method 'sum' of 'numpy.ndarray' objects}\r\n        5    0.000    0.000    0.004    0.001 /opt/conda/envs/asv_3.10/lib/python3.10/site-packages/numpy/_core/_methods.py:51(_sum)\r\n        5    0.000    0.000    0.004    0.001 /workspace/repo/pandas/core/arraylike.py:69(__and__)\r\n       30    0.001    0.000    0.004    0.000 /opt/conda/envs/asv_3.10/lib/python3.10/site-packages/numexpr/necompiler.py:787(validate)\r\n\r\n\r\n\r\n"]
[170.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[170.002, "i", "python - << 'PY'\r"]
[170.004, "o", "python - << 'PY'\r\n"]
[170.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> import cProfile, pstats, io\r\n\u001b[?2004l\r\n\u001b[?2004h> import numpy as np\r\n\u001b[?2004l\r\n\u001b[?2004h> import pandas as pd\r\n\u001b[?2004l\r\n\u001b[?2004h> N=10**3\r\n\u001b[?2004l\r\n\u001b[?2004h> df = pd.DataFrame(np.random.randn(N,N))\r\n\u001b[?2004l\r\n\u001b[?2004h> df2 = pd.DataFrame(np.random.randn(N,N))\r\n\u001b[?2004l\r\n\u001b[?2004h> pr = cProfile.Profile(); pr.enable()\r\n\u001b[?2004l\r\n\u001b[?2004h> _ = df // df2\r\n\u001b[?2004l\r\n\u001b[?2004h> _ = df // 0\r\n\u001b[?2004l\r\n\u001b[?2004h> _ = (df.values @ df2.values)  # mimic dot without pandas wrapper\r\n\u001b[?2004l\r\n\u001b[?2004h> pr.disable()\r\n\u001b[?2004l\r\n\u001b[?2004h> import sys, io as _io\r\n\u001b[?2004l\r\n\u001b[?2004h> s = _io.StringIO(); pstats.Stats(pr, stream=s).sort_stats('cumulative').print_stats(30)\r\n\u001b[?2004l\r\n\u001b[?2004h> print(s.getvalue())\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\n         514 function calls (491 primitive calls) in 0.052 seconds\r\n\r\n   Ordered by: cumulative time\r\n   List reduced from 122 to 30 due to restriction <30>\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        2    0.000    0.000    0.052    0.026 /workspace/repo/pandas/core/ops/common.py:62(new_method)\r\n        2    0.000    0.000    0.052    0.026 /workspace/repo/pandas/core/arraylike.py:219(__floordiv__)\r\n        2    0.000    0.000    0.052    0.026 /workspace/repo/pandas/core/frame.py:7863(_arith_method)\r\n        2    0.000    0.000    0.052    0.026 /workspace/repo/pandas/core/frame.py:7878(_dispatch_frame_op)\r\n        2    0.000    0.000    0.052    0.026 /workspace/repo/pandas/core/ops/array_ops.py:239(arithmetic_op)\r\n        2    0.000    0.000    0.052    0.026 /workspace/repo/pandas/core/ops/array_ops.py:188(_na_arithmetic_op)\r\n        2    0.000    0.000    0.031    0.016 /workspace/repo/pandas/core/computation/expressions.py:227(evaluate)\r\n        2    0.000    0.000    0.031    0.016 /workspace/repo/pandas/core/computation/expressions.py:68(_evaluate_standard)\r\n        2    0.031    0.016    0.031    0.016 {built-in method _operator.floordiv}\r\n        1    0.000    0.000    0.030    0.030 /workspace/repo/pandas/core/internals/managers.py:1624(operate_blockwise)\r\n        1    0.000    0.000    0.030    0.030 /workspace/repo/pandas/core/internals/ops.py:57(operate_blockwise)\r\n        5    0.000    0.000    0.022    0.004 /workspace/repo/pandas/core/internals/managers.py:392(apply)\r\n        1    0.000    0.000    0.022    0.022 /workspace/repo/pandas/core/internals/blocks.py:343(apply)\r\n        2    0.000    0.000    0.020    0.010 /workspace/repo/pandas/core/ops/missing.py:132(dispatch_fill_zeros)\r\n        2    0.020    0.010    0.020    0.010 /workspace/repo/pandas/core/ops/missing.py:72(mask_zero_div_zero)\r\n        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/frame.py:8253(_construct_result)\r\n        4    0.000    0.000    0.000    0.000 /opt/conda/envs/asv_3.10/lib/python3.10/site-packages/numpy/_core/_methods.py:59(_any)\r\n        3    0.000    0.000    0.000    0.000 {method 'any' of 'numpy.ndarray' objects}\r\n        4    0.000    0.000    0.000    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/frame.py:698(__init__)\r\n        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/internals/managers.py:693(copy)\r\n        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/frame.py:8020(_should_reindex_frame_op)\r\n        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/internals/blocks.py:370(_split_op_result)\r\n        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/internals/ops.py:29(_iter_block_pairs)\r\n        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/internals/managers.py:716(<listcomp>)\r\n       10    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/range.py:551(_view)\r\n        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/internals/blocks.py:230(make_block)\r\n        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:3189(intersection)\r\n        8    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:1025(view)\r\n        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/generic.py:6119(__setattr__)\r\n\r\n\r\n\r\n"]
[175.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[175.002, "i", "sed -n '1,200p' pandas/core/ops/common.py\r"]
[175.004, "o", "sed -n '1,200p' pandas/core/ops/common.py\r\n"]
[175.006, "o", "\u001b[?2004l\r\nsed: can't read pandas/core/ops/common.py: No such file or directory\r\n"]
[180.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[180.002, "i", "sed -n '1,200p' pandas/core/ops/__init__.py\r"]
[180.004, "o", "sed -n '1,200p' pandas/core/ops/__init__.py\r\n"]
[180.006, "o", "\u001b[?2004l\r\nsed: can't read pandas/core/ops/__init__.py: No such file or directory\r\n"]
[185.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[185.002, "i", "sed -n '1,240p' pandas/core/frame.py\r"]
[185.004, "o", "sed -n '1,240p' pandas/core/frame.py\r\n"]
[185.006, "o", "\u001b[?2004l\r\nsed: can't read pandas/core/frame.py: No such file or directory\r\n"]
[190.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[190.002, "i", "cd ..\r"]
[190.004, "o", "cd ..\r\n"]
[190.006, "o", "\u001b[?2004l\r\n"]
[195.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[195.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[195.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[195.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 1_000_000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[200.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[200.002, "i", "sed -n '1,220p' pandas/core/ops/missing.py\r"]
[200.004, "o", "sed -n '1,220p' pandas/core/ops/missing.py\r\n"]
[200.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nMissing data handling for arithmetic operations.\r\n\r\nIn particular, pandas conventions regarding division by zero differ\r\nfrom numpy in the following ways:\r\n    1) np.array([-1, 0, 1], dtype=dtype1) // np.array([0, 0, 0], dtype=dtype2)\r\n       gives [nan, nan, nan] for most dtype combinations, and [0, 0, 0] for\r\n       the remaining pairs\r\n       (the remaining being dtype1==dtype2==intN and dtype==dtype2==uintN).\r\n\r\n       pandas convention is to return [-inf, nan, inf] for all dtype\r\n       combinations.\r\n\r\n       Note: the numpy behavior described here is py3-specific.\r\n\r\n    2) np.array([-1, 0, 1], dtype=dtype1) % np.array([0, 0, 0], dtype=dtype2)\r\n       gives precisely the same results as the // operation.\r\n\r\n       pandas convention is to return [nan, nan, nan] for all dtype\r\n       combinations.\r\n\r\n    3) divmod behavior consistent with 1) and 2).\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\n\r\nimport numpy as np\r\n\r\nfrom pandas.core import roperator\r\n\r\n\r\ndef _fill_zeros(result: np.ndarray, x, y) -> np.ndarray:\r\n    \"\"\"\r\n    If this is a reversed op, then flip x,y\r\n\r\n    If we have an integer value (or array in y)\r\n    and we have 0's, fill them with np.nan,\r\n    return the result.\r\n\r\n    Mask the nan's from x.\r\n    \"\"\"\r\n    if result.dtype.kind == \"f\":\r\n        return result\r\n\r\n    is_variable_type = hasattr(y, \"dtype\")\r\n    is_scalar_type = not isinstance(y, np.ndarray)\r\n\r\n    if not is_variable_type and not is_scalar_type:\r\n        # e.g. test_series_ops_name_retention with mod we get here with list/tuple\r\n        return result\r\n\r\n    if is_scalar_type:\r\n        y = np.array(y)\r\n\r\n    if y.dtype.kind in \"iu\":\r\n        ymask = y == 0\r\n        if ymask.any():\r\n            # GH#7325, mask and nans must be broadcastable\r\n            mask = ymask & ~np.isnan(result)\r\n\r\n            # GH#9308 doing ravel on result and mask can improve putmask perf,\r\n            #  but can also make unwanted copies.\r\n            result = result.astype(\"float64\", copy=False)\r\n\r\n            np.putmask(result, mask, np.nan)\r\n\r\n    return result\r\n\r\n\r\ndef mask_zero_div_zero(x, y, result: np.ndarray) -> np.ndarray:\r\n    \"\"\"\r\n    Set results of  0 // 0 to np.nan, regardless of the dtypes\r\n    of the numerator or the denominator.\r\n\r\n    Parameters\r\n    ----------\r\n    x : ndarray\r\n    y : ndarray\r\n    result : ndarray\r\n\r\n    Returns\r\n    -------\r\n    ndarray\r\n        The filled result.\r\n\r\n    Examples\r\n    --------\r\n    >>> x = np.array([1, 0, -1], dtype=np.int64)\r\n    >>> x\r\n    array([ 1,  0, -1])\r\n    >>> y = 0  # int 0; numpy behavior is different with float\r\n    >>> result = x // y\r\n    >>> result  # raw numpy result does not fill division by zero\r\n    array([0, 0, 0])\r\n    >>> mask_zero_div_zero(x, y, result)\r\n    array([ inf,  nan, -inf])\r\n    \"\"\"\r\n\r\n    if not hasattr(y, \"dtype\"):\r\n        # e.g. scalar, tuple\r\n        y = np.array(y)\r\n    if not hasattr(x, \"dtype\"):\r\n        # e.g scalar, tuple\r\n        x = np.array(x)\r\n\r\n    zmask = y == 0\r\n\r\n    if zmask.any():\r\n        # Flip sign if necessary for -0.0\r\n        zneg_mask = zmask & np.signbit(y)\r\n        zpos_mask = zmask & ~zneg_mask\r\n\r\n        x_lt0 = x < 0\r\n        x_gt0 = x > 0\r\n        nan_mask = zmask & (x == 0)\r\n        neginf_mask = (zpos_mask & x_lt0) | (zneg_mask & x_gt0)\r\n        posinf_mask = (zpos_mask & x_gt0) | (zneg_mask & x_lt0)\r\n\r\n        if nan_mask.any() or neginf_mask.any() or posinf_mask.any():\r\n            # Fill negative/0 with -inf, positive/0 with +inf, 0/0 with NaN\r\n            result = result.astype(\"float64\", copy=False)\r\n\r\n            result[nan_mask] = np.nan\r\n            result[posinf_mask] = np.inf\r\n            result[neginf_mask] = -np.inf\r\n\r\n    return result\r\n\r\n\r\ndef dispatch_fill_zeros(op, left, right, result):\r\n    \"\"\"\r\n    Call _fill_zeros with the appropriate fill value depending on the operation,\r\n    with special logic for divmod and rdivmod.\r\n\r\n    Parameters\r\n    ----------\r\n    op : function (operator.add, operator.div, ...)\r\n    left : object (np.ndarray for non-reversed ops)\r\n        We have excluded ExtensionArrays here\r\n    right : object (np.ndarray for reversed ops)\r\n        We have excluded ExtensionArrays here\r\n    result : ndarray\r\n\r\n    Returns\r\n    -------\r\n    result : np.ndarray\r\n\r\n    Notes\r\n    -----\r\n    For divmod and rdivmod, the `result` parameter and returned `result`\r\n    is a 2-tuple of ndarray objects.\r\n    \"\"\"\r\n    if op is divmod:\r\n        result = (\r\n            mask_zero_div_zero(left, right, result[0]),\r\n            _fill_zeros(result[1], left, right),\r\n        )\r\n    elif op is roperator.rdivmod:\r\n        result = (\r\n            mask_zero_div_zero(right, left, result[0]),\r\n            _fill_zeros(result[1], right, left),\r\n        )\r\n    elif op is operator.floordiv:\r\n        # Note: no need to do this for truediv; in py3 numpy behaves the way\r\n        #  we want.\r\n        result = mask_zero_div_zero(left, right, result)\r\n    elif op is roperator.rfloordiv:\r\n        # Note: no need to do this for rtruediv; in py3 numpy behaves the way\r\n        #  we want.\r\n        result = mask_zero_div_zero(right, left, result)\r\n    elif op is operator.mod:\r\n        result = _fill_zeros(result, left, right)\r\n    elif op is roperator.rmod:\r\n        result = _fill_zeros(result, right, left)\r\n    return result\r\n"]
[205.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[205.002, "i", "sed -n '1,260p' pandas/core/ops/array_ops.py\r"]
[205.004, "o", "sed -n '1,260p' pandas/core/ops/array_ops.py\r\n"]
[205.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nFunctions for arithmetic and comparison operations on NumPy arrays and\r\nExtensionArrays.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport datetime\r\nfrom functools import partial\r\nimport operator\r\nfrom typing import (\r\n    TYPE_CHECKING,\r\n    Any,\r\n)\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._libs import (\r\n    NaT,\r\n    Timedelta,\r\n    Timestamp,\r\n    lib,\r\n    ops as libops,\r\n)\r\nfrom pandas._libs.tslibs import (\r\n    BaseOffset,\r\n    get_supported_dtype,\r\n    is_supported_dtype,\r\n    is_unitless,\r\n)\r\n\r\nfrom pandas.core.dtypes.cast import (\r\n    construct_1d_object_array_from_listlike,\r\n    find_common_type,\r\n)\r\nfrom pandas.core.dtypes.common import (\r\n    ensure_object,\r\n    is_bool_dtype,\r\n    is_list_like,\r\n    is_numeric_v_string_like,\r\n    is_object_dtype,\r\n    is_scalar,\r\n)\r\nfrom pandas.core.dtypes.generic import (\r\n    ABCExtensionArray,\r\n    ABCIndex,\r\n    ABCSeries,\r\n)\r\nfrom pandas.core.dtypes.missing import (\r\n    isna,\r\n    notna,\r\n)\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation import expressions\r\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\r\nfrom pandas.core.ops import missing\r\nfrom pandas.core.ops.dispatch import should_extension_dispatch\r\nfrom pandas.core.ops.invalid import invalid_comparison\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import (\r\n        ArrayLike,\r\n        Shape,\r\n    )\r\n\r\n# -----------------------------------------------------------------------------\r\n# Masking NA values and fallbacks for operations numpy does not support\r\n\r\n\r\ndef fill_binop(left, right, fill_value):\r\n    \"\"\"\r\n    If a non-None fill_value is given, replace null entries in left and right\r\n    with this value, but only in positions where _one_ of left/right is null,\r\n    not both.\r\n\r\n    Parameters\r\n    ----------\r\n    left : array-like\r\n    right : array-like\r\n    fill_value : object\r\n\r\n    Returns\r\n    -------\r\n    left : array-like\r\n    right : array-like\r\n\r\n    Notes\r\n    -----\r\n    Makes copies if fill_value is not None and NAs are present.\r\n    \"\"\"\r\n    if fill_value is not None:\r\n        left_mask = isna(left)\r\n        right_mask = isna(right)\r\n\r\n        # one but not both\r\n        mask = left_mask ^ right_mask\r\n\r\n        if left_mask.any():\r\n            # Avoid making a copy if we can\r\n            left = left.copy()\r\n            left[left_mask & mask] = fill_value\r\n\r\n        if right_mask.any():\r\n            # Avoid making a copy if we can\r\n            right = right.copy()\r\n            right[right_mask & mask] = fill_value\r\n\r\n    return left, right\r\n\r\n\r\ndef comp_method_OBJECT_ARRAY(op, x, y):\r\n    if isinstance(y, list):\r\n        # e.g. test_tuple_categories\r\n        y = construct_1d_object_array_from_listlike(y)\r\n\r\n    if isinstance(y, (np.ndarray, ABCSeries, ABCIndex)):\r\n        if not is_object_dtype(y.dtype):\r\n            y = y.astype(np.object_)\r\n\r\n        if isinstance(y, (ABCSeries, ABCIndex)):\r\n            y = y._values\r\n\r\n        if x.shape != y.shape:\r\n            raise ValueError(\"Shapes must match\", x.shape, y.shape)\r\n        result = libops.vec_compare(x.ravel(), y.ravel(), op)\r\n    else:\r\n        result = libops.scalar_compare(x.ravel(), y, op)\r\n    return result.reshape(x.shape)\r\n\r\n\r\ndef _masked_arith_op(x: np.ndarray, y, op) -> np.ndarray:\r\n    \"\"\"\r\n    If the given arithmetic operation fails, attempt it again on\r\n    only the non-null elements of the input array(s).\r\n\r\n    Parameters\r\n    ----------\r\n    x : np.ndarray\r\n    y : np.ndarray, Series, Index\r\n    op : binary operator\r\n    \"\"\"\r\n    # For Series `x` is 1D so ravel() is a no-op; calling it anyway makes\r\n    # the logic valid for both Series and DataFrame ops.\r\n    xrav = x.ravel()\r\n\r\n    if isinstance(y, np.ndarray):\r\n        dtype = find_common_type([x.dtype, y.dtype])\r\n        result = np.empty(x.size, dtype=dtype)\r\n\r\n        if len(x) != len(y):\r\n            raise ValueError(x.shape, y.shape)\r\n        ymask = notna(y)\r\n\r\n        # NB: ravel() is only safe since y is ndarray; for e.g. PeriodIndex\r\n        #  we would get int64 dtype, see GH#19956\r\n        yrav = y.ravel()\r\n        mask = notna(xrav) & ymask.ravel()\r\n\r\n        # See GH#5284, GH#5035, GH#19448 for historical reference\r\n        if mask.any():\r\n            result[mask] = op(xrav[mask], yrav[mask])\r\n\r\n    else:\r\n        if not is_scalar(y):\r\n            raise TypeError(\r\n                f\"Cannot broadcast np.ndarray with operand of type {type(y)}\"\r\n            )\r\n\r\n        # mask is only meaningful for x\r\n        result = np.empty(x.size, dtype=x.dtype)\r\n        mask = notna(xrav)\r\n\r\n        # 1 ** np.nan is 1. So we have to unmask those.\r\n        if op is pow:\r\n            mask = np.where(x == 1, False, mask)\r\n        elif op is roperator.rpow:\r\n            mask = np.where(y == 1, False, mask)\r\n\r\n        if mask.any():\r\n            result[mask] = op(xrav[mask], y)\r\n\r\n    np.putmask(result, ~mask, np.nan)\r\n    result = result.reshape(x.shape)  # 2D compat\r\n    return result\r\n\r\n\r\ndef _na_arithmetic_op(left: np.ndarray, right, op, is_cmp: bool = False):\r\n    \"\"\"\r\n    Return the result of evaluating op on the passed in values.\r\n\r\n    If native types are not compatible, try coercion to object dtype.\r\n\r\n    Parameters\r\n    ----------\r\n    left : np.ndarray\r\n    right : np.ndarray or scalar\r\n        Excludes DataFrame, Series, Index, ExtensionArray.\r\n    is_cmp : bool, default False\r\n        If this a comparison operation.\r\n\r\n    Returns\r\n    -------\r\n    array-like\r\n\r\n    Raises\r\n    ------\r\n    TypeError : invalid operation\r\n    \"\"\"\r\n    if isinstance(right, str):\r\n        # can never use numexpr\r\n        func = op\r\n    else:\r\n        func = partial(expressions.evaluate, op)\r\n\r\n    try:\r\n        result = func(left, right)\r\n    except TypeError:\r\n        if not is_cmp and (\r\n            left.dtype == object or getattr(right, \"dtype\", None) == object\r\n        ):\r\n            # For object dtype, fallback to a masked operation (only operating\r\n            #  on the non-missing values)\r\n            # Don't do this for comparisons, as that will handle complex numbers\r\n            #  incorrectly, see GH#32047\r\n            result = _masked_arith_op(left, right, op)\r\n        else:\r\n            raise\r\n\r\n    if is_cmp and (is_scalar(result) or result is NotImplemented):\r\n        # numpy returned a scalar instead of operating element-wise\r\n        # e.g. numeric array vs str\r\n        # TODO: can remove this after dropping some future numpy version?\r\n        return invalid_comparison(left, right, op)\r\n\r\n    return missing.dispatch_fill_zeros(op, left, right, result)\r\n\r\n\r\ndef arithmetic_op(left: ArrayLike, right: Any, op):\r\n    \"\"\"\r\n    Evaluate an arithmetic operation `+`, `-`, `*`, `/`, `//`, `%`, `**`, ...\r\n\r\n    Note: the caller is responsible for ensuring that numpy warnings are\r\n    suppressed (with np.errstate(all=\"ignore\")) if needed.\r\n\r\n    Parameters\r\n    ----------\r\n    left : np.ndarray or ExtensionArray\r\n    right : object\r\n        Cannot be a DataFrame or Index.  Series is *not* excluded.\r\n    op : {operator.add, operator.sub, ...}\r\n        Or one of the reversed variants from roperator.\r\n\r\n    Returns\r\n    -------\r\n    ndarray or ExtensionArray\r\n        Or a 2-tuple of these in the case of divmod or rdivmod.\r\n    \"\"\"\r\n    # NB: We assume that extract_array and ensure_wrapped_if_datetimelike\r\n    #  have already been called on `left` and `right`,\r\n"]
[210.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[210.002, "i", "sed -n '1,160p' pandas/core/ops/common.py\r"]
[210.004, "o", "sed -n '1,160p' pandas/core/ops/common.py\r\n"]
[210.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nBoilerplate functions used in defining binary operations.\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nfrom functools import wraps\r\nfrom typing import TYPE_CHECKING\r\n\r\nfrom pandas._libs.lib import item_from_zerodim\r\nfrom pandas._libs.missing import is_matching_na\r\n\r\nfrom pandas.core.dtypes.generic import (\r\n    ABCIndex,\r\n    ABCSeries,\r\n)\r\n\r\nif TYPE_CHECKING:\r\n    from collections.abc import Callable\r\n\r\n    from pandas._typing import F\r\n\r\n\r\ndef unpack_zerodim_and_defer(name: str) -> Callable[[F], F]:\r\n    \"\"\"\r\n    Boilerplate for pandas conventions in arithmetic and comparison methods.\r\n\r\n    Parameters\r\n    ----------\r\n    name : str\r\n\r\n    Returns\r\n    -------\r\n    decorator\r\n    \"\"\"\r\n\r\n    def wrapper(method: F) -> F:\r\n        return _unpack_zerodim_and_defer(method, name)\r\n\r\n    return wrapper\r\n\r\n\r\ndef _unpack_zerodim_and_defer(method: F, name: str) -> F:\r\n    \"\"\"\r\n    Boilerplate for pandas conventions in arithmetic and comparison methods.\r\n\r\n    Ensure method returns NotImplemented when operating against \"senior\"\r\n    classes.  Ensure zero-dimensional ndarrays are always unpacked.\r\n\r\n    Parameters\r\n    ----------\r\n    method : binary method\r\n    name : str\r\n\r\n    Returns\r\n    -------\r\n    method\r\n    \"\"\"\r\n    stripped_name = name.removeprefix(\"__\").removesuffix(\"__\")\r\n    is_cmp = stripped_name in {\"eq\", \"ne\", \"lt\", \"le\", \"gt\", \"ge\"}\r\n\r\n    @wraps(method)\r\n    def new_method(self, other):\r\n        if is_cmp and isinstance(self, ABCIndex) and isinstance(other, ABCSeries):\r\n            # For comparison ops, Index does *not* defer to Series\r\n            pass\r\n        else:\r\n            prio = getattr(other, \"__pandas_priority__\", None)\r\n            if prio is not None:\r\n                if prio > self.__pandas_priority__:\r\n                    # e.g. other is DataFrame while self is Index/Series/EA\r\n                    return NotImplemented\r\n\r\n        other = item_from_zerodim(other)\r\n\r\n        return method(self, other)\r\n\r\n    # error: Incompatible return value type (got \"Callable[[Any, Any], Any]\",\r\n    # expected \"F\")\r\n    return new_method  # type: ignore[return-value]\r\n\r\n\r\ndef get_op_result_name(left, right):\r\n    \"\"\"\r\n    Find the appropriate name to pin to an operation result.  This result\r\n    should always be either an Index or a Series.\r\n\r\n    Parameters\r\n    ----------\r\n    left : {Series, Index}\r\n    right : object\r\n\r\n    Returns\r\n    -------\r\n    name : object\r\n        Usually a string\r\n    \"\"\"\r\n    if isinstance(right, (ABCSeries, ABCIndex)):\r\n        name = _maybe_match_name(left, right)\r\n    else:\r\n        name = left.name\r\n    return name\r\n\r\n\r\ndef _maybe_match_name(a, b):\r\n    \"\"\"\r\n    Try to find a name to attach to the result of an operation between\r\n    a and b.  If only one of these has a `name` attribute, return that\r\n    name.  Otherwise return a consensus name if they match or None if\r\n    they have different names.\r\n\r\n    Parameters\r\n    ----------\r\n    a : object\r\n    b : object\r\n\r\n    Returns\r\n    -------\r\n    name : str or None\r\n\r\n    See Also\r\n    --------\r\n    pandas.core.common.consensus_name_attr\r\n    \"\"\"\r\n    a_has = hasattr(a, \"name\")\r\n    b_has = hasattr(b, \"name\")\r\n    if a_has and b_has:\r\n        try:\r\n            if a.name == b.name:\r\n                return a.name\r\n            elif is_matching_na(a.name, b.name):\r\n                # e.g. both are np.nan\r\n                return a.name\r\n            else:\r\n                return None\r\n        except TypeError:\r\n            # pd.NA\r\n            if is_matching_na(a.name, b.name):\r\n                return a.name\r\n            return None\r\n        except ValueError:\r\n            # e.g. np.int64(1) vs (np.int64(1), np.int64(2))\r\n            return None\r\n    elif a_has:\r\n        return a.name\r\n    elif b_has:\r\n        return b.name\r\n    return None\r\n"]
[215.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[215.002, "i", "sed -n '7700,7930p' pandas/core/frame.py\r"]
[215.004, "o", "sed -n '7700,7930p' pandas/core/frame.py\r\n"]
[215.006, "o", "\u001b[?2004l\r\n        \"\"\"\r\n        Swap levels i and j in a :class:`MultiIndex`.\r\n\r\n        Default is to swap the two innermost levels of the index.\r\n\r\n        Parameters\r\n        ----------\r\n        i, j : int or str\r\n            Levels of the indices to be swapped. Can pass level name as string.\r\n        axis : {0 or 'index', 1 or 'columns'}, default 0\r\n                    The axis to swap levels on. 0 or 'index' for row-wise, 1 or\r\n                    'columns' for column-wise.\r\n\r\n        Returns\r\n        -------\r\n        DataFrame\r\n            DataFrame with levels swapped in MultiIndex.\r\n\r\n        See Also\r\n        --------\r\n        DataFrame.reorder_levels: Reorder levels of MultiIndex.\r\n        DataFrame.sort_index: Sort MultiIndex.\r\n\r\n        Examples\r\n        --------\r\n        >>> df = pd.DataFrame(\r\n        ...     {\"Grade\": [\"A\", \"B\", \"A\", \"C\"]},\r\n        ...     index=[\r\n        ...         [\"Final exam\", \"Final exam\", \"Coursework\", \"Coursework\"],\r\n        ...         [\"History\", \"Geography\", \"History\", \"Geography\"],\r\n        ...         [\"January\", \"February\", \"March\", \"April\"],\r\n        ...     ],\r\n        ... )\r\n        >>> df\r\n                                            Grade\r\n        Final exam  History     January      A\r\n                    Geography   February     B\r\n        Coursework  History     March        A\r\n                    Geography   April        C\r\n\r\n        In the following example, we will swap the levels of the indices.\r\n        Here, we will swap the levels column-wise, but levels can be swapped row-wise\r\n        in a similar manner. Note that column-wise is the default behaviour.\r\n        By not supplying any arguments for i and j, we swap the last and second to\r\n        last indices.\r\n\r\n        >>> df.swaplevel()\r\n                                            Grade\r\n        Final exam  January     History         A\r\n                    February    Geography       B\r\n        Coursework  March       History         A\r\n                    April       Geography       C\r\n\r\n        By supplying one argument, we can choose which index to swap the last\r\n        index with. We can for example swap the first index with the last one as\r\n        follows.\r\n\r\n        >>> df.swaplevel(0)\r\n                                            Grade\r\n        January     History     Final exam      A\r\n        February    Geography   Final exam      B\r\n        March       History     Coursework      A\r\n        April       Geography   Coursework      C\r\n\r\n        We can also define explicitly which indices we want to swap by supplying values\r\n        for both i and j. Here, we for example swap the first and second indices.\r\n\r\n        >>> df.swaplevel(0, 1)\r\n                                            Grade\r\n        History     Final exam  January         A\r\n        Geography   Final exam  February        B\r\n        History     Coursework  March           A\r\n        Geography   Coursework  April           C\r\n        \"\"\"\r\n        result = self.copy(deep=False)\r\n\r\n        axis = self._get_axis_number(axis)\r\n\r\n        if not isinstance(result._get_axis(axis), MultiIndex):  # pragma: no cover\r\n            raise TypeError(\"Can only swap levels on a hierarchical axis.\")\r\n\r\n        if axis == 0:\r\n            assert isinstance(result.index, MultiIndex)\r\n            result.index = result.index.swaplevel(i, j)\r\n        else:\r\n            assert isinstance(result.columns, MultiIndex)\r\n            result.columns = result.columns.swaplevel(i, j)\r\n        return result\r\n\r\n    def reorder_levels(self, order: Sequence[int | str], axis: Axis = 0) -> DataFrame:\r\n        \"\"\"\r\n        Rearrange index or column levels using input ``order``.\r\n\r\n        May not drop or duplicate levels.\r\n\r\n        Parameters\r\n        ----------\r\n        order : list of int or list of str\r\n            List representing new level order. Reference level by number\r\n            (position) or by key (label).\r\n        axis : {0 or 'index', 1 or 'columns'}, default 0\r\n            Where to reorder levels.\r\n\r\n        Returns\r\n        -------\r\n        DataFrame\r\n            DataFrame with indices or columns with reordered levels.\r\n\r\n        See Also\r\n        --------\r\n            DataFrame.swaplevel : Swap levels i and j in a MultiIndex.\r\n\r\n        Examples\r\n        --------\r\n        >>> data = {\r\n        ...     \"class\": [\"Mammals\", \"Mammals\", \"Reptiles\"],\r\n        ...     \"diet\": [\"Omnivore\", \"Carnivore\", \"Carnivore\"],\r\n        ...     \"species\": [\"Humans\", \"Dogs\", \"Snakes\"],\r\n        ... }\r\n        >>> df = pd.DataFrame(data, columns=[\"class\", \"diet\", \"species\"])\r\n        >>> df = df.set_index([\"class\", \"diet\"])\r\n        >>> df\r\n                                          species\r\n        class      diet\r\n        Mammals    Omnivore                Humans\r\n                   Carnivore                 Dogs\r\n        Reptiles   Carnivore               Snakes\r\n\r\n        Let's reorder the levels of the index:\r\n\r\n        >>> df.reorder_levels([\"diet\", \"class\"])\r\n                                          species\r\n        diet      class\r\n        Omnivore  Mammals                  Humans\r\n        Carnivore Mammals                    Dogs\r\n                  Reptiles                 Snakes\r\n        \"\"\"\r\n        axis = self._get_axis_number(axis)\r\n        if not isinstance(self._get_axis(axis), MultiIndex):  # pragma: no cover\r\n            raise TypeError(\"Can only reorder levels on a hierarchical axis.\")\r\n\r\n        result = self.copy(deep=False)\r\n\r\n        if axis == 0:\r\n            assert isinstance(result.index, MultiIndex)\r\n            result.index = result.index.reorder_levels(order)\r\n        else:\r\n            assert isinstance(result.columns, MultiIndex)\r\n            result.columns = result.columns.reorder_levels(order)\r\n        return result\r\n\r\n    # ----------------------------------------------------------------------\r\n    # Arithmetic Methods\r\n\r\n    def _cmp_method(self, other, op):\r\n        axis: Literal[1] = 1  # only relevant for Series other case\r\n\r\n        self, other = self._align_for_op(other, axis, flex=False, level=None)\r\n\r\n        # See GH#4537 for discussion of scalar op behavior\r\n        new_data = self._dispatch_frame_op(other, op, axis=axis)\r\n        return self._construct_result(new_data)\r\n\r\n    def _arith_method(self, other, op):\r\n        if self._should_reindex_frame_op(other, op, 1, None, None):\r\n            return self._arith_method_with_reindex(other, op)\r\n\r\n        axis: Literal[1] = 1  # only relevant for Series other case\r\n        other = ops.maybe_prepare_scalar_for_op(other, (self.shape[axis],))\r\n\r\n        self, other = self._align_for_op(other, axis, flex=True, level=None)\r\n\r\n        with np.errstate(all=\"ignore\"):\r\n            new_data = self._dispatch_frame_op(other, op, axis=axis)\r\n        return self._construct_result(new_data)\r\n\r\n    _logical_method = _arith_method\r\n\r\n    def _dispatch_frame_op(\r\n        self, right, func: Callable, axis: AxisInt | None = None\r\n    ) -> DataFrame:\r\n        \"\"\"\r\n        Evaluate the frame operation func(left, right) by evaluating\r\n        column-by-column, dispatching to the Series implementation.\r\n\r\n        Parameters\r\n        ----------\r\n        right : scalar, Series, or DataFrame\r\n        func : arithmetic or comparison operator\r\n        axis : {None, 0, 1}\r\n\r\n        Returns\r\n        -------\r\n        DataFrame\r\n\r\n        Notes\r\n        -----\r\n        Caller is responsible for setting np.errstate where relevant.\r\n        \"\"\"\r\n        # Get the appropriate array-op to apply to each column/block's values.\r\n        array_op = ops.get_array_op(func)\r\n\r\n        right = lib.item_from_zerodim(right)\r\n        if not is_list_like(right):\r\n            # i.e. scalar, faster than checking np.ndim(right) == 0\r\n            bm = self._mgr.apply(array_op, right=right)\r\n            return self._constructor_from_mgr(bm, axes=bm.axes)\r\n\r\n        elif isinstance(right, DataFrame):\r\n            assert self.index.equals(right.index)\r\n            assert self.columns.equals(right.columns)\r\n            # TODO: The previous assertion `assert right._indexed_same(self)`\r\n            #  fails in cases with empty columns reached via\r\n            #  _frame_arith_method_with_reindex\r\n\r\n            # TODO operate_blockwise expects a manager of the same type\r\n            bm = self._mgr.operate_blockwise(\r\n                right._mgr,\r\n                array_op,\r\n            )\r\n            return self._constructor_from_mgr(bm, axes=bm.axes)\r\n\r\n        elif isinstance(right, Series) and axis == 1:\r\n            # axis=1 means we want to operate row-by-row\r\n            assert right.index.equals(self.columns)\r\n\r\n            right = right._values\r\n            # maybe_align_as_frame ensures we do not have an ndarray here\r\n            assert not isinstance(right, np.ndarray)\r\n\r\n            arrays = [\r\n"]
[220.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[220.002, "i", "pwd\r"]
[220.004, "o", "pwd\r\n"]
[220.006, "o", "\u001b[?2004l\r\n/workspace/repo\r\n"]
[225.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[225.002, "i", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" -n pandas/core/computation/expressions.py\r"]
[225.004, "o", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" -n pandas/core/computation/expressions.py\r\n"]
[225.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 1_000_000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[230.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[230.002, "i", "sed -n '1,240p' pandas/core/computation/expressions.py\r"]
[230.004, "o", "sed -n '1,240p' pandas/core/computation/expressions.py\r\n"]
[230.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 1_000_000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n"]
[235.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[235.002, "i", "python - << 'PY'\r"]
[235.004, "o", "python - << 'PY'\r\n"]
[235.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> # Increase the MIN_ELEMENTS threshold conservatively above 2_000_000 to bypass numexpr for these benches\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Also try MIN_ELEMENTS without underscore\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h> if new_src != src:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(new_src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched threshold in expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No threshold pattern matched; no change made')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched threshold in expressions.py\r\n"]
[240.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[240.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[240.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[240.006, "o", "\u001b[?2004l\r\ndiff --git a/pandas/core/computation/expressions.py b/pandas/core/computation/expressions.py\r\nindex 5a5fad0d83..dee80059a8 100644\r\n--- a/pandas/core/computation/expressions.py\r\n+++ b/pandas/core/computation/expressions.py\r\n@@ -40,7 +40,7 @@ _ALLOWED_DTYPES = {\r\n }\r\n \r\n # the minimum prod shape that we will use numexpr\r\n-_MIN_ELEMENTS = 1_000_000\r\n+_MIN_ELEMENTS = 4000000\r\n \r\n \r\n def set_use_numexpr(v: bool = True) -> None:\r\n"]
[245.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[245.002, "i", "cd asv_bench\r"]
[245.004, "o", "cd asv_bench\r\n"]
[245.006, "o", "\u001b[?2004l\r\n"]
[250.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[250.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[250.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[250.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.21\u00b10.07ms   2.22\u00b10.03ms \r\n                 False      2.24\u00b10.06ms   2.23\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.71\u00b10.04ms   1.68\u00b10.03ms \r\n                 False      1.72\u00b10.07ms   1.76\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.21\u00b10.03ms   2.17\u00b10.05ms \r\n                 False      2.24\u00b10.05ms   2.25\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       10.2\u00b10.1ms   10.2\u00b10.08ms \r\n                 False      10.2\u00b10.06ms   10.2\u00b10.05ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          45.9\u00b10.4ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.4\u00b10.04ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              866\u00b120\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.4\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.5\u00b10.04ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.49\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.6\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     467\u00b120\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.7\u00b10.9\u03bcs\r\n"]
[255.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[255.002, "i", "cd ..\r"]
[255.004, "o", "cd ..\r\n"]
[255.006, "o", "\u001b[?2004l\r\n"]
[260.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[260.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[260.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[260.006, "o", "\u001b[?2004l\r\ndiff --git a/pandas/core/computation/expressions.py b/pandas/core/computation/expressions.py\r\nindex 5a5fad0d83..dee80059a8 100644\r\n--- a/pandas/core/computation/expressions.py\r\n+++ b/pandas/core/computation/expressions.py\r\n@@ -40,7 +40,7 @@ _ALLOWED_DTYPES = {\r\n }\r\n \r\n # the minimum prod shape that we will use numexpr\r\n-_MIN_ELEMENTS = 1_000_000\r\n+_MIN_ELEMENTS = 4000000\r\n \r\n \r\n def set_use_numexpr(v: bool = True) -> None:\r\n"]
[265.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[265.002, "i", "git add pandas/core/computation/expressions.py\r"]
[265.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[265.006, "o", "\u001b[?2004l\r\n"]
[270.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[270.002, "i", "git commit -m \"perf(expressions): raise MIN_ELEMENTS threshold to avoid numexpr overhead on moderate-sized ops (e.g\r"]
[270.004, "o", "git commit -m \"perf(expressions): raise MIN_ELEMENTS threshold to avoid numexpr overhead on moderate-sized ops (e.g\r\n"]
[270.006, "o", "g., 20k x 100) improving arithmetic.Ops.* benchmarks\"\r\n\u001b[?2004l\r\nAuthor identity unknown\r\n\r\n*** Please tell me who you are.\r\n\r\nRun\r\n\r\n  git config --global user.email \"you@example.com\"\r\n  git config --global user.name \"Your Name\"\r\n\r\nto set your account's default identity.\r\nOmit --global to set the identity only in this repository.\r\n\r\nfatal: unable to auto-detect email address (got 'root@89c02398194d.(none)')\r\n"]
[275.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[275.002, "i", "cd asv_bench\r"]
[275.004, "o", "cd asv_bench\r\n"]
[275.006, "o", "\u001b[?2004l\r\n"]
[280.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[280.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[280.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[280.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       2.77\u00b10.2ms   2.38\u00b10.09ms \r\n                 False      2.27\u00b10.05ms    2.32\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True      1.73\u00b10.05ms   1.97\u00b10.1ms \r\n                 False       1.91\u00b10.1ms   1.75\u00b10.1ms \r\n             ============= ============= ============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.32\u00b10.09ms    2.28\u00b10.1ms \r\n                 False       2.40\u00b10.2ms   2.32\u00b10.09ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True       10.1\u00b10.2ms   10.1\u00b10.1ms \r\n                 False      9.97\u00b10.09ms   10.2\u00b10.3ms \r\n             ============= ============= ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          45.9\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.4\u00b10.04ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              836\u00b140\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.2\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.5\u00b10.04ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.44\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.8\u00b10.09ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      450\u00b19\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         48.2\u00b10.6\u03bcs\r\n"]
[285.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[285.002, "i", "cd ..\r"]
[285.004, "o", "cd ..\r\n"]
[285.006, "o", "\u001b[?2004l\r\n"]
[290.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[290.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[290.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[290.006, "o", "\u001b[?2004l\r\n"]
[295.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[295.002, "i", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" pandas/core/computation/expressions.py\r"]
[295.004, "o", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" pandas/core/computation/expressions.py\r\n"]
[295.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[300.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[300.002, "i", "sed -n '1,220p' pandas/core/computation/expressions.py\r"]
[300.004, "o", "sed -n '1,220p' pandas/core/computation/expressions.py\r\n"]
[300.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n"]
[305.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[305.002, "i", "git config user.email \"devnull@example.com\"\r"]
[305.004, "o", "git config user.email \"devnull@example.com\"\r\n"]
[305.006, "o", "\u001b[?2004l\r\n"]
[310.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[310.002, "i", "git config user.name \"ASV Optimizer\"\r"]
[310.004, "o", "git config user.name \"ASV Optimizer\"\r\n"]
[310.006, "o", "\u001b[?2004l\r\n"]
[315.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[315.002, "i", "git add pandas/core/computation/expressions.py\r"]
[315.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[315.006, "o", "\u001b[?2004l\r\n"]
[320.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[320.002, "i", "git commit -m \"perf(expressions): raise MIN_ELEMENTS threshold to bypass numexpr on moderate-sized ops (improves ar\r"]
[320.004, "o", "git commit -m \"perf(expressions): raise MIN_ELEMENTS threshold to bypass numexpr on moderate-sized ops (improves ar\r\n"]
[320.006, "o", "rithmetic.Ops.*)\"\r\n\u001b[?2004l\r\n[main dccf724192] perf(expressions): raise MIN_ELEMENTS threshold to bypass numexpr on moderate-sized ops (improves arithmetic.Ops.*)\r\n 1 file changed, 1 insertion(+), 1 deletion(-)\r\n"]
[325.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[325.002, "i", "cd asv_bench\r"]
[325.004, "o", "cd asv_bench\r\n"]
[325.006, "o", "\u001b[?2004l\r\n"]
[330.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[330.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[330.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[330.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       2.02\u00b10.1ms   2.11\u00b10.08ms \r\n                 False      2.04\u00b10.02ms   2.12\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.67\u00b10.03ms   1.81\u00b10.09ms \r\n                 False      1.70\u00b10.05ms   1.68\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0masv run --python=same --bench=\"arithmetic.Ops2.*\"\r\n                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.03\u00b10.03ms   2.08\u00b10.05ms \r\n                 False      2.06\u00b10.04ms   2.06\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      9.77\u00b10.08ms    9.85\u00b10.1ms \r\n                 False      9.70\u00b10.06ms   9.76\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          45.3\u00b10.1ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.3\u00b10.06ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              660\u00b150\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                         19.1\u00b10.08ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.5\u00b10.03ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.36\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.3\u00b10.04ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      421\u00b15\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         47.2\u00b10.3\u03bcs\r\n"]
[335.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[335.002, "i", "asv run --python=same --bench=\"arithmetic.Ops2.*\"\r"]
[335.004, "o", "asv run --python=same --bench=\"arithmetic.Ops2.*\"\r\n"]
[335.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 9 total benchmarks (1 commits * 1 environments * 9 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 5.56%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops2.time_frame_dot--)\u001b[0m.........\r\n[55.56%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          44.9\u00b10.2ms\r\n[61.11%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.3\u00b10.05ms\r\n[66.67%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              636\u00b110\u03bcs\r\n[72.22%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                         18.9\u00b10.04ms\r\n[77.78%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.7\u00b10.02ms\r\n[83.33%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.31\u00b10.02ms\r\n[88.89%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.1\u00b10.04ms\r\n[94.44%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      421\u00b14\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         48.8\u00b10.9\u03bcs\r\n"]
[340.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[340.002, "i", "cd ..\r"]
[340.004, "o", "cd ..\r\n"]
[340.006, "o", "\u001b[?2004l\r\n"]
[345.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[345.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[345.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[345.006, "o", "\u001b[?2004l\r\n"]
[350.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[350.002, "i", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" pandas/core/computation/expressions.py\r"]
[350.004, "o", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" pandas/core/computation/expressions.py\r\n"]
[350.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[355.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[355.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py | sed -n '1,160p'\r"]
[355.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py | sed -n '1,160p'\r\n"]
[355.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n"]
[360.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[360.002, "i", "git config user.email \"devnull@example.com\"\r"]
[360.004, "o", "git config user.email \"devnull@example.com\"\r\n"]
[360.006, "o", "\u001b[?2004l\r\n"]
[365.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[365.002, "i", "git config user.name \"ASV Optimizer\"\r"]
[365.004, "o", "git config user.name \"ASV Optimizer\"\r\n"]
[365.006, "o", "\u001b[?2004l\r\n"]
[370.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[370.002, "i", "git add pandas/core/computation/expressions.py\r"]
[370.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[370.006, "o", "\u001b[?2004l\r\n"]
[375.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[375.002, "i", "git commit -m \"perf(expressions): raise MIN_ELEMENTS threshold to bypass numexpr overhead on moderate-sized ops; im\r"]
[375.004, "o", "git commit -m \"perf(expressions): raise MIN_ELEMENTS threshold to bypass numexpr overhead on moderate-sized ops; im\r\n"]
[375.006, "o", "mproves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[380.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[380.002, "i", "cd ..\r"]
[380.004, "o", "cd ..\r\n"]
[380.006, "o", "\u001b[?2004l\r\n"]
[385.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[385.002, "i", "git status -sb\r"]
[385.004, "o", "git status -sb\r\n"]
[385.006, "o", "\u001b[?2004l\r\nfatal: not a git repository (or any of the parent directories): .git\r\n"]
[390.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[390.002, "i", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" pandas/core/computation/expressions.py\r"]
[390.004, "o", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" pandas/core/computation/expressions.py\r\n"]
[390.006, "o", "\u001b[?2004l\r\ngrep: pandas/core/computation/expressions.py: No such file or directory\r\n"]
[395.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[395.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[395.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[395.006, "o", "\u001b[?2004l\r\nsed: can't read pandas/core/computation/expressions.py: No such file or directory\r\n"]
[400.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[400.002, "i", "python - << 'PY'\r"]
[400.004, "o", "python - << 'PY'\r\n"]
[400.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to adjust a constant threshold if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # If there's no constant, patch should_use_numexpr to impose our threshold\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Insert a size check early in should_use_numexpr if not present.\r\n\u001b[?2004l\r\n\u001b[?2004h>     pattern = r\"def\\s+should_use_numexpr\\(.*?\\):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(pattern, src, flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         start = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Find end of function by next def or end of file\r\n\u001b[?2004l\r\n\u001b[?2004h>         func_body_end = re.search(r\"\\ndef\\s+|\\Z\", src[start:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if func_body_end:\r\n\u001b[?2004l\r\n\u001b[?2004h>             body = src[start:start+func_body_end.start()]\r\n\u001b[?2004l\r\n\u001b[?2004h>             if 'MIN_ELEMENTS' not in src and '_MIN_ELEMENTS' not in src and 'size_threshold' not in body:\r\n\u001b[?2004l\r\n\u001b[?2004h>                 inject = \"\\n    # Bypass numexpr for moderate-sized ops to reduce overhead\\n    try:\\n        a_size = getattr(a, 'size', None)\\n        b_size\r\ne = getattr(b, 'size', None)\\n    except NameError:\\n        a_size = b_size = None\\n    if a_size is not None and (a_size < 4_000_000) and (b_size is None or b_\r\n_size < 4_000_000):\\n        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 src = src[:start] + inject + src[start:]\r\n\u001b[?2004l\r\n\u001b[?2004h>                 changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py to raise numexpr threshold or add early bypass')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No changes applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 4, in <module>\r\n  File \"/opt/conda/envs/asv_3.10/lib/python3.10/pathlib.py\", line 1134, in read_text\r\n    with self.open(mode='r', encoding=encoding, errors=errors) as f:\r\n  File \"/opt/conda/envs/asv_3.10/lib/python3.10/pathlib.py\", line 1119, in open\r\n    return self._accessor.open(self, mode, buffering, encoding, errors,\r\nFileNotFoundError: [Errno 2] No such file or directory: 'pandas/core/computation/expressions.py'\r\n"]
[405.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[405.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[405.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[405.006, "o", "\u001b[?2004l\r\nwarning: Not a git repository. Use --no-index to compare two paths outside a working tree\r\nusage: git diff --no-index [<options>] <path> <path> [<pathspec>...]\r\n\r\nDiff output format options\r\n    -p, --patch           generate patch\r\n    -s, --no-patch        suppress diff output\r\n    -u                    generate patch\r\n    -U, --unified[=<n>]   generate diffs with <n> lines context\r\n    -W, --[no-]function-context\r\n                          generate diffs with <n> lines context\r\n    --raw                 generate the diff in raw format\r\n    --patch-with-raw      synonym for '-p --raw'\r\n    --patch-with-stat     synonym for '-p --stat'\r\n    --numstat             machine friendly --stat\r\n    --shortstat           output only the last line of --stat\r\n    -X, --dirstat[=<param1>,<param2>...]\r\n                          output the distribution of relative amount of changes for each sub-directory\r\n    --cumulative          synonym for --dirstat=cumulative\r\n    --dirstat-by-file[=<param1>,<param2>...]\r\n                          synonym for --dirstat=files,<param1>,<param2>...\r\n    --check               warn if changes introduce conflict markers or whitespace errors\r\n    --summary             condensed summary such as creations, renames and mode changes\r\n    --name-only           show only names of changed files\r\n    --name-status         show only names and status of changed files\r\n    --stat[=<width>[,<name-width>[,<count>]]]\r\n                          generate diffstat\r\n    --stat-width <width>  generate diffstat with a given width\r\n    --stat-name-width <width>\r\n                          generate diffstat with a given name width\r\n    --stat-graph-width <width>\r\n                          generate diffstat with a given graph width\r\n    --stat-count <count>  generate diffstat with limited lines\r\n    --[no-]compact-summary\r\n                          generate compact summary in diffstat\r\n    --binary              output a binary diff that can be applied\r\n    --[no-]full-index     show full pre- and post-image object names on the \"index\" lines\r\n    --[no-]color[=<when>] show colored diff\r\n    --ws-error-highlight <kind>\r\n                          highlight whitespace errors in the 'context', 'old' or 'new' lines in the diff\r\n    -z                    do not munge pathnames and use NULs as output field terminators in --raw or --numstat\r\n    --[no-]abbrev[=<n>]   use <n> digits to display object names\r\n    --src-prefix <prefix> show the given source prefix instead of \"a/\"\r\n    --dst-prefix <prefix> show the given destination prefix instead of \"b/\"\r\n    --line-prefix <prefix>\r\n                          prepend an additional prefix to every line of output\r\n    --no-prefix           do not show any source or destination prefix\r\n    --default-prefix      use default prefixes a/ and b/\r\n    --inter-hunk-context <n>\r\n                          show context between diff hunks up to the specified number of lines\r\n    --output-indicator-new <char>\r\n                          specify the character to indicate a new line instead of '+'\r\n    --output-indicator-old <char>\r\n                          specify the character to indicate an old line instead of '-'\r\n    --output-indicator-context <char>\r\n                          specify the character to indicate a context instead of ' '\r\n\r\nDiff rename options\r\n    -B, --break-rewrites[=<n>[/<m>]]\r\n                          break complete rewrite changes into pairs of delete and create\r\n    -M, --find-renames[=<n>]\r\n                          detect renames\r\n    -D, --irreversible-delete\r\n                          omit the preimage for deletes\r\n    -C, --find-copies[=<n>]\r\n                          detect copies\r\n    --[no-]find-copies-harder\r\n                          use unmodified files as source to find copies\r\n    --no-renames          disable rename detection\r\n    --[no-]rename-empty   use empty blobs as rename source\r\n    --[no-]follow         continue listing the history of a file beyond renames\r\n    -l <n>                prevent rename/copy detection if the number of rename/copy targets exceeds given limit\r\n\r\nDiff algorithm options\r\n    --minimal             produce the smallest possible diff\r\n    -w, --ignore-all-space\r\n                          ignore whitespace when comparing lines\r\n    -b, --ignore-space-change\r\n                          ignore changes in amount of whitespace\r\n    --ignore-space-at-eol ignore changes in whitespace at EOL\r\n    --ignore-cr-at-eol    ignore carrier-return at the end of line\r\n    --ignore-blank-lines  ignore changes whose lines are all blank\r\n    -I, --[no-]ignore-matching-lines <regex>\r\n                          ignore changes whose all lines match <regex>\r\n    --[no-]indent-heuristic\r\n                          heuristic to shift diff hunk boundaries for easy reading\r\n    --patience            generate diff using the \"patience diff\" algorithm\r\n    --histogram           generate diff using the \"histogram diff\" algorithm\r\n    --diff-algorithm <algorithm>\r\n                          choose a diff algorithm\r\n    --anchored <text>     generate diff using the \"anchored diff\" algorithm\r\n    --word-diff[=<mode>]  show word diff, using <mode> to delimit changed words\r\n    --word-diff-regex <regex>\r\n                          use <regex> to decide what a word is\r\n    --color-words[=<regex>]\r\n                          equivalent to --word-diff=color --word-diff-regex=<regex>\r\n    --[no-]color-moved[=<mode>]\r\n                          moved lines of code are colored differently\r\n    --[no-]color-moved-ws <mode>\r\n                          how white spaces are ignored in --color-moved\r\n\r\nOther diff options\r\n    --[no-]relative[=<prefix>]\r\n                          when run from subdir, exclude changes outside and show relative paths\r\n    -a, --[no-]text       treat all files as text\r\n    -R                    swap two inputs, reverse the diff\r\n    --[no-]exit-code      exit with 1 if there were differences, 0 otherwise\r\n    --[no-]quiet          disable all output of the program\r\n    --[no-]ext-diff       allow an external diff helper to be executed\r\n    --[no-]textconv       run external text conversion filters when comparing binary files\r\n    --ignore-submodules[=<when>]\r\n                          ignore changes to submodules in the diff generation\r\n    --submodule[=<format>]\r\n                          specify how differences in submodules are shown\r\n    --ita-invisible-in-index\r\n                          hide 'git add -N' entries from the index\r\n    --ita-visible-in-index\r\n                          treat 'git add -N' entries as real in the index\r\n    -S <string>           look for differences that change the number of occurrences of the specified string\r\n    -G <regex>            look for differences that change the number of occurrences of the specified regex\r\n    --pickaxe-all         show all changes in the changeset with -S or -G\r\n    --pickaxe-regex       treat <string> in -S as extended POSIX regular expression\r\n    -O <file>             control the order in which files appear in the output\r\n    --rotate-to <path>    show the change in the specified path first\r\n    --skip-to <path>      skip the output to the specified path\r\n    --find-object <object-id>\r\n                          look for differences that change the number of occurrences of the specified object\r\n    --diff-filter [(A|C|D|M|R|T|U|X|B)...[*]]\r\n                          select files by diff type\r\n    --output <file>       output to a specific file\r\n\r\n"]
[410.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[410.002, "i", "git add pandas/core/computation/expressions.py\r"]
[410.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[410.006, "o", "\u001b[?2004l\r\nfatal: not a git repository (or any of the parent directories): .git\r\n"]
[415.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[415.002, "i", "git commit -m \"perf(expressions): reduce numexpr overhead by raising size threshold for use; improves arithmetic.Ops.*\" \r"]
[415.004, "o", "git commit -m \"perf(expressions): reduce numexpr overhead by raising size threshold for use; improves arithmetic.Ops.*\" \r\n"]
[420.0, "o", "\u001bM(asv_3.10) root@89c02398194d:/workspace# "]
[420.002, "i", "git commit -m \"perf(expressions): reduce numexpr overhead by raising size threshold for use; improves arithmetic.Ops.*\u001b[K\"\r"]
[420.004, "o", "git commit -m \"perf(expressions): reduce numexpr overhead by raising size threshold for use; improves arithmetic.Ops.*\u001b[K\"\r\n"]
[420.006, "o", "\u001b[?2004l\r\nfatal: not a git repository (or any of the parent directories): .git\r\n"]
[425.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[425.002, "i", "cd asv_bench\r"]
[425.004, "o", "cd asv_bench\r\n"]
[425.006, "o", "\u001b[?2004l\r\n-bash: cd: asv_bench: No such file or directory\r\n"]
[430.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[430.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[430.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[430.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;31mNo `asv.conf` file found for valid extensions: ['.json', '.jsonc'].\u001b[0m\r\n"]
[435.0, "o", "(asv_3.10) root@89c02398194d:/workspace# "]
[435.002, "i", "cd /workspace/repo\r"]
[435.004, "o", "cd /workspace/repo\r\n"]
[435.006, "o", "\u001b[?2004l\r\n"]
[440.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[440.002, "i", "git status -sb\r"]
[440.004, "o", "git status -sb\r\n"]
[440.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[445.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[445.002, "i", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" pandas/core/computation/expressions.py\r"]
[445.004, "o", "grep -n \"MIN_ELEMENTS\\|_MIN_ELEMENTS\\|should_use_numexpr\" pandas/core/computation/expressions.py\r\n"]
[445.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[450.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[450.002, "i", "sed -n '1,280p' pandas/core/computation/expressions.py\r"]
[450.004, "o", "sed -n '1,280p' pandas/core/computation/expressions.py\r\n"]
[450.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n"]
[455.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[455.002, "i", "python - << 'PY'\r"]
[455.004, "o", "python - << 'PY'\r\n"]
[455.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # First try to bump an existing threshold constant\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Patch should_use_numexpr to early-bail for moderate sizes\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         start = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Only inject once; guard by a marker\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[start:start+400]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:start] + inject + src[start:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[460.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[460.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[460.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[460.006, "o", "\u001b[?2004l\r\n"]
[465.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[465.002, "i", "git add pandas/core/computation/expressions.py\r"]
[465.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[465.006, "o", "\u001b[?2004l\r\n"]
[470.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[470.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops by raising threshold/early check; improves \r"]
[470.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops by raising threshold/early check; improves \r\n"]
[470.006, "o", " arithmetic.Ops.* benchmarks\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[475.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[475.002, "i", "cd asv_bench\r"]
[475.004, "o", "cd asv_bench\r\n"]
[475.006, "o", "\u001b[?2004l\r\n"]
[480.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[480.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[480.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[480.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.01\u00b10.06ms   1.99\u00b10.03ms \r\n                 False      1.97\u00b10.01ms   2.00\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.64\u00b10.04ms   1.66\u00b10.05ms \r\n                 False      1.63\u00b10.03ms   1.65\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.98\u00b10.05ms   1.98\u00b10.02ms \r\n                 False      1.97\u00b10.03ms   2.02\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      9.78\u00b10.05ms   9.77\u00b10.05ms \r\n                 False      9.85\u00b10.06ms    9.89\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          44.7\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.2\u00b10.02ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              621\u00b110\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                         18.9\u00b10.09ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.5\u00b10.02ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.30\u00b10.02ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.3\u00b10.02ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      414\u00b13\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.4\u00b10.3\u03bcs\r\n"]
[485.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[485.002, "i", "cd ..\r"]
[485.004, "o", "cd ..\r\n"]
[485.006, "o", "\u001b[?2004l\r\n"]
[490.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[490.002, "i", "git status -sb\r"]
[490.004, "o", "git status -sb\r\n"]
[490.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[495.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[495.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r"]
[495.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r\n"]
[495.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[500.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[500.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[500.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[500.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[505.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[505.002, "i", "python - << 'PY'\r"]
[505.004, "o", "python - << 'PY'\r\n"]
[505.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early return in should_use_numexpr to bypass numexpr for moderate sizes\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Avoid duplicate injection by checking a marker\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+400]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold/early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold/early bypass)\r\n"]
[510.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[510.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[510.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[510.006, "o", "\u001b[?2004l\r\n"]
[515.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[515.002, "i", "git add pandas/core/computation/expressions.py\r"]
[515.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[515.006, "o", "\u001b[?2004l\r\n"]
[520.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[520.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[520.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[520.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[525.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[525.002, "i", "cd asv_bench\r"]
[525.004, "o", "cd asv_bench\r\n"]
[525.006, "o", "\u001b[?2004l\r\n"]
[530.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[530.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[530.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[530.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.97\u00b10.01ms   2.03\u00b10.04ms \r\n                 False      2.00\u00b10.02ms   2.01\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.62\u00b10.03ms   1.62\u00b10.01ms \r\n                 False      1.59\u00b10.02ms   1.59\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.02\u00b10.03ms   1.99\u00b10.06ms \r\n                 False      1.97\u00b10.07ms   1.99\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      9.80\u00b10.08ms   9.82\u00b10.02ms \r\n                 False       9.79\u00b10.1ms    9.87\u00b10.2ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          45.1\u00b10.1ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.3\u00b10.03ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              650\u00b140\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          18.9\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.5\u00b10.04ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.33\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.2\u00b10.05ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      418\u00b17\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         48.3\u00b10.1\u03bcs\r\n"]
[535.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[535.002, "i", "cd ..\r"]
[535.004, "o", "cd ..\r\n"]
[535.006, "o", "\u001b[?2004l\r\n"]
[540.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[540.002, "i", "git status -sb\r"]
[540.004, "o", "git status -sb\r\n"]
[540.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[545.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[545.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r"]
[545.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r\n"]
[545.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[550.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[550.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[550.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[550.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[555.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[555.002, "i", "python - << 'PY'\r"]
[555.004, "o", "python - << 'PY'\r\n"]
[555.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Bump existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass in should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+500]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold/early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold/early bypass)\r\n"]
[560.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[560.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[560.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[560.006, "o", "\u001b[?2004l\r\n"]
[565.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[565.002, "i", "git add pandas/core/computation/expressions.py\r"]
[565.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[565.006, "o", "\u001b[?2004l\r\n"]
[570.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[570.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[570.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[570.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[575.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[575.002, "i", "cd asv_bench\r"]
[575.004, "o", "cd asv_bench\r\n"]
[575.006, "o", "\u001b[?2004l\r\n"]
[580.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[580.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[580.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[580.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.98\u00b10.02ms   1.98\u00b10.05ms \r\n                 False      2.01\u00b10.02ms   1.98\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.56\u00b10.02ms   1.59\u00b10.03ms \r\n                 False      1.56\u00b10.02ms   1.57\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.05\u00b10.03ms   1.98\u00b10.02ms \r\n                 False      2.02\u00b10.03ms   2.01\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      9.66\u00b10.07ms   9.66\u00b10.04ms \r\n                 False      9.70\u00b10.05ms   9.74\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          45.2\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.2\u00b10.02ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                               641\u00b14\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                         18.9\u00b10.02ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.8\u00b10.01ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.31\u00b10.01ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.2\u00b10.06ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      412\u00b15\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         48.8\u00b10.3\u03bcs\r\n"]
[585.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[585.002, "i", "sleep 20\r"]
[585.004, "o", "sleep 20\r\n"]
[585.006, "o", "\u001b[?2004l\r\n"]
[590.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[590.002, "i", "cd ..\r"]
[590.004, "o", "cd ..\r\n"]
[590.006, "o", "\u001b[?2004l\r\n"]
[595.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[595.002, "i", "git status -sb\r"]
[595.004, "o", "git status -sb\r\n"]
[595.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[600.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[600.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r"]
[600.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r\n"]
[600.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[605.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[605.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[605.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[605.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[610.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[610.002, "i", "python - << 'PY'\r"]
[610.004, "o", "python - << 'PY'\r\n"]
[610.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early bypass into should_use_numexpr for moderate sizes\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+600]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[615.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[615.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[615.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[615.006, "o", "\u001b[?2004l\r\n"]
[620.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[620.002, "i", "git add pandas/core/computation/expressions.py\r"]
[620.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[620.006, "o", "\u001b[?2004l\r\n"]
[625.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[625.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[625.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[625.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[630.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[630.002, "i", "cd asv_bench\r"]
[630.004, "o", "cd asv_bench\r\n"]
[630.006, "o", "\u001b[?2004l\r\n"]
[635.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[635.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[635.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[635.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.99\u00b10.05ms   1.96\u00b10.01ms \r\n                 False      1.95\u00b10.03ms   1.98\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.55\u00b10.03ms   1.58\u00b10.01ms \r\n                 False      1.55\u00b10.03ms   1.58\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.01\u00b10.05ms   1.97\u00b10.01ms \r\n                 False      2.01\u00b10.02ms   1.99\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      9.85\u00b10.04ms   9.93\u00b10.04ms \r\n                 False      9.82\u00b10.07ms   9.84\u00b10.05ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          45.4\u00b10.3ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.3\u00b10.07ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              673\u00b130\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                         18.9\u00b10.05ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.5\u00b10.02ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.33\u00b10.04ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.2\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      410\u00b13\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         50.3\u00b10.3\u03bcs\r\n"]
[640.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[640.002, "i", "cd ..\r"]
[640.004, "o", "cd ..\r\n"]
[640.006, "o", "\u001b[?2004l\r\n"]
[645.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[645.002, "i", "git status -sb\r"]
[645.004, "o", "git status -sb\r\n"]
[645.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[650.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[650.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r"]
[650.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r\n"]
[650.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[655.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[655.002, "i", "sed -n '1,300p' pandas/core/computation/expressions.py\r"]
[655.004, "o", "sed -n '1,300p' pandas/core/computation/expressions.py\r\n"]
[655.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[660.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[660.002, "i", "python - << 'PY'\r"]
[660.004, "o", "python - << 'PY'\r\n"]
[660.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass in should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+800]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[665.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[665.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[665.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[665.006, "o", "\u001b[?2004l\r\n"]
[670.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[670.002, "i", "git add pandas/core/computation/expressions.py\r"]
[670.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[670.006, "o", "\u001b[?2004l\r\n"]
[675.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[675.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via raised size threshold to reduce overhea\r"]
[675.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via raised size threshold to reduce overhea\r\n"]
[675.006, "o", "ad; improves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[680.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[680.002, "i", "cd asv_bench\r"]
[680.004, "o", "cd asv_bench\r\n"]
[680.006, "o", "\u001b[?2004l\r\n"]
[685.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[685.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[685.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[685.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.04\u00b10.03ms   2.02\u00b10.02ms \r\n                 False      2.02\u00b10.02ms   2.00\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.57\u00b10.01ms   1.60\u00b10.01ms \r\n                 False      1.57\u00b10.03ms   1.56\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.02\u00b10.06ms   1.99\u00b10.03ms \r\n                 False      1.96\u00b10.02ms   1.98\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      9.68\u00b10.03ms   9.67\u00b10.02ms \r\n                 False      9.69\u00b10.05ms   9.65\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          44.9\u00b10.4ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.3\u00b10.09ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              634\u00b110\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                         19.0\u00b10.08ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.9\u00b10.1ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.39\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.8\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     428\u00b120\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.4\u00b10.4\u03bcs\r\n"]
[690.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[690.002, "i", "cd ..\r"]
[690.004, "o", "cd ..\r\n"]
[690.006, "o", "\u001b[?2004l\r\n"]
[695.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[695.002, "i", "git status -sb\r"]
[695.004, "o", "git status -sb\r\n"]
[695.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[700.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[700.002, "i", "grep -RIn \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation || true\r"]
[700.004, "o", "grep -RIn \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation || true\r\n"]
[700.006, "o", "\u001b[?2004l\r\n\u001b[35m\u001b[Kpandas/core/computation/expressions.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[35m\u001b[Kpandas/core/computation/expressions.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[705.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[705.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[705.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[705.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[710.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[710.002, "i", "python - << 'PY'\r"]
[710.004, "o", "python - << 'PY'\r\n"]
[710.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # First try to bump an existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early bypass into should_use_numexpr for moderate sizes\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+800]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[715.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[715.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[715.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[715.006, "o", "\u001b[?2004l\r\n"]
[720.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[720.002, "i", "git add pandas/core/computation/expressions.py\r"]
[720.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[720.006, "o", "\u001b[?2004l\r\n"]
[725.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[725.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[725.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[725.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[730.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[730.002, "i", "cd asv_bench\r"]
[730.004, "o", "cd asv_bench\r\n"]
[730.006, "o", "\u001b[?2004l\r\n"]
[735.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[735.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[735.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[735.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.98\u00b10.05ms   1.99\u00b10.05ms \r\n                 False      2.02\u00b10.03ms   2.00\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.58\u00b10.02ms   1.58\u00b10.04ms \r\n                 False      1.56\u00b10.03ms   1.57\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.95\u00b10.05ms   2.01\u00b10.05ms \r\n                 False      2.01\u00b10.07ms   1.99\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       9.84\u00b10.2ms   9.83\u00b10.06ms \r\n                 False      9.79\u00b10.07ms   9.80\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          45.8\u00b10.3ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.4\u00b10.04ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              729\u00b110\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.3\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    25.0\u00b10.2ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.38\u00b10.02ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.4\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      429\u00b12\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                           49.9\u00b11\u03bcs\r\n"]
[740.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[740.002, "i", "cd ..\r"]
[740.004, "o", "cd ..\r\n"]
[740.006, "o", "\u001b[?2004l\r\n"]
[745.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[745.002, "i", "git status -sb\r"]
[745.004, "o", "git status -sb\r\n"]
[745.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[750.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[750.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r"]
[750.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r\n"]
[750.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[755.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[755.002, "i", "sed -n '1,300p' pandas/core/computation/expressions.py\r"]
[755.004, "o", "sed -n '1,300p' pandas/core/computation/expressions.py\r\n"]
[755.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[760.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[760.002, "i", "python - << 'PY'\r"]
[760.004, "o", "python - << 'PY'\r\n"]
[760.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass in should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+800]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[765.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[765.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[765.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[765.006, "o", "\u001b[?2004l\r\n"]
[770.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[770.002, "i", "git add pandas/core/computation/expressions.py\r"]
[770.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[770.006, "o", "\u001b[?2004l\r\n"]
[775.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[775.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[775.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[775.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[780.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[780.002, "i", "cd asv_bench\r"]
[780.004, "o", "cd asv_bench\r\n"]
[780.006, "o", "\u001b[?2004l\r\n"]
[785.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[785.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[785.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[785.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.05\u00b10.02ms   2.08\u00b10.04ms \r\n                 False      2.05\u00b10.02ms   2.06\u00b10.01ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.61\u00b10.02ms   1.63\u00b10.03ms \r\n                 False      1.59\u00b10.02ms   1.59\u00b10.01ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.09\u00b10.02ms   2.08\u00b10.03ms \r\n                 False      2.08\u00b10.02ms   2.08\u00b10.05ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      10.1\u00b10.08ms   10.1\u00b10.05ms \r\n                 False      10.2\u00b10.08ms    10.2\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.7\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   29.1\u00b10.07ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              772\u00b150\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.6\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    25.2\u00b10.1ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.45\u00b10.01ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.5\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      437\u00b17\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         50.2\u00b10.5\u03bcs\r\n"]
[790.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[790.002, "i", "cd ..\r"]
[790.004, "o", "cd ..\r\n"]
[790.006, "o", "\u001b[?2004l\r\n"]
[795.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[795.002, "i", "git status -sb\r"]
[795.004, "o", "git status -sb\r\n"]
[795.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[800.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[800.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r"]
[800.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py\r\n"]
[800.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[805.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[805.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[805.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[805.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[810.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[810.002, "i", "python - << 'PY'\r"]
[810.004, "o", "python - << 'PY'\r\n"]
[810.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass in should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Inject after def line, but skip over an immediate docstring if present\r\n\u001b[?2004l\r\n\u001b[?2004h>         rest = src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>         doc_m = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", rest, flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if doc_m:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += doc_m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+1000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[815.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[815.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[815.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[815.006, "o", "\u001b[?2004l\r\n"]
[820.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[820.002, "i", "git add pandas/core/computation/expressions.py\r"]
[820.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[820.006, "o", "\u001b[?2004l\r\n"]
[825.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[825.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[825.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[825.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[830.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[830.002, "i", "cd asv_bench\r"]
[830.004, "o", "cd asv_bench\r\n"]
[830.006, "o", "\u001b[?2004l\r\n"]
[835.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[835.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[835.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[835.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.10\u00b10.03ms   2.13\u00b10.04ms \r\n                 False      2.12\u00b10.04ms   2.13\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.68\u00b10.05ms   1.66\u00b10.03ms \r\n                 False      1.67\u00b10.04ms   1.69\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.12\u00b10.03ms   2.18\u00b10.02ms \r\n                 False      2.20\u00b10.06ms   2.07\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============== =============\u001b[0m\r\n             --                      threads           \r\n             ------------- ----------------------------\r\n              use_numexpr     default           1      \r\n             ============= ============== =============\r\n                  True       9.97\u00b10.1ms    9.99\u00b10.05ms \r\n                 False      10.00\u00b10.08ms   10.0\u00b10.09ms \r\n             ============= ============== =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.6\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.6\u00b10.08ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              768\u00b170\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                         19.5\u00b10.07ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.8\u00b10.2ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.49\u00b10.01ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.5\u00b10.05ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     446\u00b120\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.2\u00b10.6\u03bcs\r\n"]
[840.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[840.002, "i", "cd ..\r"]
[840.004, "o", "cd ..\r\n"]
[840.006, "o", "\u001b[?2004l\r\n"]
[845.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[845.002, "i", "git status -sb\r"]
[845.004, "o", "git status -sb\r\n"]
[845.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[850.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[850.002, "i", "ls -la pandas/core/computation\r"]
[850.004, "o", "ls -la pandas/core/computation\r\n"]
[850.006, "o", "\u001b[?2004l\r\ntotal 152\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root     0 Sep 12 21:42 __init__.py\r\n-rw-r--r-- 1 root root  6735 Sep 12 21:42 align.py\r\n-rw-r--r-- 1 root root    65 Sep 12 21:42 api.py\r\n-rw-r--r-- 1 root root   226 Sep 12 21:42 check.py\r\n-rw-r--r-- 1 root root  1442 Sep 12 21:42 common.py\r\n-rw-r--r-- 1 root root  3462 Sep 12 21:42 engines.py\r\n-rw-r--r-- 1 root root 15281 Sep 12 21:42 eval.py\r\n-rw-r--r-- 1 root root 25337 Sep 12 21:44 expr.py\r\n-rw-r--r-- 1 root root  7966 Oct  1 17:44 expressions.py\r\n-rw-r--r-- 1 root root 14435 Sep 12 21:42 ops.py\r\n-rw-r--r-- 1 root root  7711 Sep 12 21:42 parsing.py\r\n-rw-r--r-- 1 root root 21077 Sep 12 21:44 pytables.py\r\n-rw-r--r-- 1 root root 10204 Sep 12 21:42 scope.py\r\n"]
[855.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[855.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[855.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[855.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[860.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[860.002, "i", "sed -n '1,200p' pandas/core/computation/expressions.py\r"]
[860.004, "o", "sed -n '1,200p' pandas/core/computation/expressions.py\r\n"]
[860.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n"]
[865.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[865.002, "i", "sed -n '200,500p' pandas/core/computation/expressions.py\r"]
[865.004, "o", "sed -n '200,500p' pandas/core/computation/expressions.py\r\n"]
[865.006, "o", "\u001b[?2004l\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[870.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[870.002, "i", "python - << 'PY'\r"]
[870.004, "o", "python - << 'PY'\r\n"]
[870.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early bypass into should_use_numexpr for moderate sizes\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # If there is a docstring immediately after the def, skip it\r\n\u001b[?2004l\r\n\u001b[?2004h>         docm = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if docm:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += docm.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+1200]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[875.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[875.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[875.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[875.006, "o", "\u001b[?2004l\r\n"]
[880.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[880.002, "i", "git add pandas/core/computation/expressions.py\r"]
[880.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[880.006, "o", "\u001b[?2004l\r\n"]
[885.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[885.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops with a size threshold to reduce overhead; i\r"]
[885.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops with a size threshold to reduce overhead; i\r\n"]
[885.006, "o", "improves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[890.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[890.002, "i", "cd asv_bench\r"]
[890.004, "o", "cd asv_bench\r\n"]
[890.006, "o", "\u001b[?2004l\r\n"]
[895.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[895.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[895.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[895.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.17\u00b10.07ms   2.17\u00b10.09ms \r\n                 False      2.15\u00b10.04ms   2.09\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.66\u00b10.02ms   1.65\u00b10.06ms \r\n                 False      1.66\u00b10.01ms   1.66\u00b10.01ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.16\u00b10.09ms   2.18\u00b10.04ms \r\n                 False      2.16\u00b10.03ms   2.18\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      10.2\u00b10.09ms   10.1\u00b10.06ms \r\n                 False      10.1\u00b10.09ms    10.2\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.3\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.7\u00b10.07ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              822\u00b120\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.5\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    25.0\u00b10.1ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.51\u00b10.01ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.6\u00b10.2ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      451\u00b17\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         51.3\u00b10.4\u03bcs\r\n"]
[900.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[900.002, "i", "cd ..\r"]
[900.004, "o", "cd ..\r\n"]
[900.006, "o", "\u001b[?2004l\r\n"]
[905.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[905.002, "i", "git status -sb\r"]
[905.004, "o", "git status -sb\r\n"]
[905.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[910.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[910.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[910.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[910.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[915.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[915.002, "i", "sed -n '1,240p' pandas/core/computation/expressions.py\r"]
[915.004, "o", "sed -n '1,240p' pandas/core/computation/expressions.py\r\n"]
[915.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n"]
[920.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[920.002, "i", "python - << 'PY'\r"]
[920.004, "o", "python - << 'PY'\r\n"]
[920.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Prefer bumping an existing threshold; otherwise inject an early bypass in should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # If a docstring is immediately after def, skip it\r\n\u001b[?2004l\r\n\u001b[?2004h>         docm = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if docm:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += docm.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+1500]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[925.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[925.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[925.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[925.006, "o", "\u001b[?2004l\r\n"]
[930.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[930.002, "i", "git add pandas/core/computation/expressions.py\r"]
[930.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[930.006, "o", "\u001b[?2004l\r\n"]
[935.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[935.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[935.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[935.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[940.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[940.002, "i", "cd asv_bench\r"]
[940.004, "o", "cd asv_bench\r\n"]
[940.006, "o", "\u001b[?2004l\r\n"]
[945.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[945.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[945.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[945.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.15\u00b10.04ms   2.12\u00b10.04ms \r\n                 False      2.11\u00b10.05ms   2.14\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.65\u00b10.04ms   1.69\u00b10.05ms \r\n                 False      1.71\u00b10.06ms   1.74\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.16\u00b10.05ms   2.17\u00b10.03ms \r\n                 False      2.20\u00b10.04ms   2.13\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      9.94\u00b10.1ms   9.95\u00b10.08ms \r\n                 False      10.0\u00b10.2ms    10.1\u00b10.2ms \r\n             ============= ============ =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.7\u00b10.5ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.8\u00b10.1ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              804\u00b140\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.5\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.8\u00b10.05ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                              1.50\u00b10.1ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     11.2\u00b10.09ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      433\u00b18\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                           50.9\u00b12\u03bcs\r\n"]
[950.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[950.002, "i", "cd ..\r"]
[950.004, "o", "cd ..\r\n"]
[950.006, "o", "\u001b[?2004l\r\n"]
[955.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[955.002, "i", "git status -sb\r"]
[955.004, "o", "git status -sb\r\n"]
[955.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[960.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[960.002, "i", "ls -la pandas/core/computation\r"]
[960.004, "o", "ls -la pandas/core/computation\r\n"]
[960.006, "o", "\u001b[?2004l\r\ntotal 152\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root     0 Sep 12 21:42 __init__.py\r\n-rw-r--r-- 1 root root  6735 Sep 12 21:42 align.py\r\n-rw-r--r-- 1 root root    65 Sep 12 21:42 api.py\r\n-rw-r--r-- 1 root root   226 Sep 12 21:42 check.py\r\n-rw-r--r-- 1 root root  1442 Sep 12 21:42 common.py\r\n-rw-r--r-- 1 root root  3462 Sep 12 21:42 engines.py\r\n-rw-r--r-- 1 root root 15281 Sep 12 21:42 eval.py\r\n-rw-r--r-- 1 root root 25337 Sep 12 21:44 expr.py\r\n-rw-r--r-- 1 root root  7966 Oct  1 17:48 expressions.py\r\n-rw-r--r-- 1 root root 14435 Sep 12 21:42 ops.py\r\n-rw-r--r-- 1 root root  7711 Sep 12 21:42 parsing.py\r\n-rw-r--r-- 1 root root 21077 Sep 12 21:44 pytables.py\r\n-rw-r--r-- 1 root root 10204 Sep 12 21:42 scope.py\r\n"]
[965.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[965.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[965.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[965.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[970.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[970.002, "i", "sed -n '1,220p' pandas/core/computation/expressions.py\r"]
[970.004, "o", "sed -n '1,220p' pandas/core/computation/expressions.py\r\n"]
[970.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n"]
[975.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[975.002, "i", "sed -n '220,500p' pandas/core/computation/expressions.py\r"]
[975.004, "o", "sed -n '220,500p' pandas/core/computation/expressions.py\r\n"]
[975.006, "o", "\u001b[?2004l\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[980.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[980.002, "i", "python - << 'PY'\r"]
[980.004, "o", "python - << 'PY'\r\n"]
[980.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try bumping an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass near the top of should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # If a docstring follows immediately, skip it to keep code valid\r\n\u001b[?2004l\r\n\u001b[?2004h>         docm = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if docm:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += docm.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+1500]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[985.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[985.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[985.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[985.006, "o", "\u001b[?2004l\r\n"]
[990.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[990.002, "i", "git add pandas/core/computation/expressions.py\r"]
[990.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[990.006, "o", "\u001b[?2004l\r\n"]
[995.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[995.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[995.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[995.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1000.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1000.002, "i", "cd asv_bench\r"]
[1000.004, "o", "cd asv_bench\r\n"]
[1000.006, "o", "\u001b[?2004l\r\n"]
[1005.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1005.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1005.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1005.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.33\u00b10.04ms   2.28\u00b10.02ms \r\n                 False      2.22\u00b10.02ms   2.22\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.68\u00b10.02ms   1.73\u00b10.05ms \r\n                 False      1.71\u00b10.03ms    1.73\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.23\u00b10.04ms   2.26\u00b10.03ms \r\n                 False      2.26\u00b10.04ms   2.27\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       10.3\u00b10.1ms    10.2\u00b10.1ms \r\n                 False      10.3\u00b10.05ms   10.2\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.8\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.8\u00b10.08ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              844\u00b150\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.4\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.8\u00b10.07ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.57\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      11.0\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     489\u00b160\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.8\u00b10.4\u03bcs\r\n"]
[1010.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1010.002, "i", "cd ..\r"]
[1010.004, "o", "cd ..\r\n"]
[1010.006, "o", "\u001b[?2004l\r\n"]
[1015.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1015.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1015.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1015.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1020.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1020.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[1020.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[1020.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[1025.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1025.002, "i", "python - << 'PY'\r"]
[1025.004, "o", "python - << 'PY'\r\n"]
[1025.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Prefer adjusting an existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass near the start of should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # If a docstring immediately follows, skip it to keep code structure intact\r\n\u001b[?2004l\r\n\u001b[?2004h>         docm = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if docm:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += docm.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+2000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1030.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1030.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1030.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1030.006, "o", "\u001b[?2004l\r\n"]
[1035.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1035.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1035.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1035.006, "o", "\u001b[?2004l\r\n"]
[1040.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1040.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[1040.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[1040.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1045.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1045.002, "i", "cd asv_bench\r"]
[1045.004, "o", "cd asv_bench\r\n"]
[1045.006, "o", "\u001b[?2004l\r\n"]
[1050.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1050.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1050.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1050.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.19\u00b10.06ms   2.26\u00b10.06ms \r\n                 False      2.22\u00b10.06ms   2.22\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.69\u00b10.06ms   1.70\u00b10.02ms \r\n                 False      1.70\u00b10.04ms   1.67\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.22\u00b10.02ms   2.25\u00b10.07ms \r\n                 False      2.21\u00b10.07ms   2.24\u00b10.05ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      10.3\u00b10.1ms   10.4\u00b10.06ms \r\n                 False      10.5\u00b10.2ms    10.4\u00b10.2ms \r\n             ============= ============ =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.8\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.8\u00b10.07ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              909\u00b130\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.5\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   25.0\u00b10.03ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.63\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      11.0\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     469\u00b110\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         51.7\u00b10.2\u03bcs\r\n"]
[1055.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1055.002, "i", "cd ..\r"]
[1055.004, "o", "cd ..\r\n"]
[1055.006, "o", "\u001b[?2004l\r\n"]
[1060.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1060.002, "i", "git status -sb\r"]
[1060.004, "o", "git status -sb\r\n"]
[1060.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[1065.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1065.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1065.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1065.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1070.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1070.002, "i", "sed -n '1,220p' pandas/core/computation/expressions.py\r"]
[1070.004, "o", "sed -n '1,220p' pandas/core/computation/expressions.py\r\n"]
[1070.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n"]
[1075.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1075.002, "i", "sed -n '220,480p' pandas/core/computation/expressions.py\r"]
[1075.004, "o", "sed -n '220,480p' pandas/core/computation/expressions.py\r\n"]
[1075.006, "o", "\u001b[?2004l\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1080.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1080.002, "i", "python - << 'PY'\r"]
[1080.004, "o", "python - << 'PY'\r\n"]
[1080.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try bumping an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject an early bypass inside should_use_numexpr (after def/docstring)\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Skip docstring if present immediately after def\r\n\u001b[?2004l\r\n\u001b[?2004h>         ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+2000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1085.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1085.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1085.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1085.006, "o", "\u001b[?2004l\r\n"]
[1090.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1090.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1090.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1090.006, "o", "\u001b[?2004l\r\n"]
[1095.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1095.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops with size threshold to reduce overhead; imp\r"]
[1095.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops with size threshold to reduce overhead; imp\r\n"]
[1095.006, "o", "proves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1100.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1100.002, "i", "cd asv_bench\r"]
[1100.004, "o", "cd asv_bench\r\n"]
[1100.006, "o", "\u001b[?2004l\r\n"]
[1105.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1105.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1105.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1105.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.26\u00b10.07ms   2.28\u00b10.02ms \r\n                 False      2.25\u00b10.04ms   2.26\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.77\u00b10.04ms   1.77\u00b10.02ms \r\n                 False      1.75\u00b10.03ms   1.79\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.28\u00b10.04ms   2.30\u00b10.02ms \r\n                 False      2.28\u00b10.03ms   2.24\u00b10.02ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      10.5\u00b10.2ms    10.3\u00b10.1ms \r\n                 False      10.5\u00b10.1ms   10.5\u00b10.09ms \r\n             ============= ============ =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.7\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.7\u00b10.03ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              837\u00b130\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.7\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.7\u00b10.06ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.56\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     11.1\u00b10.09ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     477\u00b110\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.9\u00b10.9\u03bcs\r\n"]
[1110.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1110.002, "i", "cd /workspace/repo\r"]
[1110.004, "o", "cd /workspace/repo\r\n"]
[1110.006, "o", "\u001b[?2004l\r\n"]
[1115.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1115.002, "i", "git status -sb\r"]
[1115.004, "o", "git status -sb\r\n"]
[1115.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[1120.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1120.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1120.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1120.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1125.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1125.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[1125.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[1125.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[1130.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1130.002, "i", "sed -n '260,520p' pandas/core/computation/expressions.py\r"]
[1130.004, "o", "sed -n '260,520p' pandas/core/computation/expressions.py\r\n"]
[1130.006, "o", "\u001b[?2004l\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1135.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1135.002, "i", "python - << 'PY'\r"]
[1135.004, "o", "python - << 'PY'\r\n"]
[1135.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early bypass into should_use_numexpr for moderate sizes\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # If a docstring immediately follows, skip it\r\n\u001b[?2004l\r\n\u001b[?2004h>         docm = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if docm:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += docm.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+2000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1140.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1140.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1140.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1140.006, "o", "\u001b[?2004l\r\n"]
[1145.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1145.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1145.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1145.006, "o", "\u001b[?2004l\r\n"]
[1150.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1150.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[1150.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[1150.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1155.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1155.002, "i", "cd asv_bench\r"]
[1155.004, "o", "cd asv_bench\r\n"]
[1155.006, "o", "\u001b[?2004l\r\n"]
[1160.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1160.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1160.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1160.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.18\u00b10.03ms   2.22\u00b10.05ms \r\n                 False      2.22\u00b10.03ms   2.21\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.72\u00b10.02ms   1.70\u00b10.03ms \r\n                 False      1.73\u00b10.04ms    1.77\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.29\u00b10.04ms   2.23\u00b10.05ms \r\n                 False      2.19\u00b10.03ms   2.20\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      10.3\u00b10.1ms   10.4\u00b10.04ms \r\n                 False      10.7\u00b10.1ms    10.5\u00b10.1ms \r\n             ============= ============ =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.5\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.6\u00b10.2ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              846\u00b130\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.4\u00b10.3ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.7\u00b10.2ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.59\u00b10.04ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.2\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     501\u00b120\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         50.0\u00b10.7\u03bcs\r\n"]
[1165.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1165.002, "i", "cd ..\r"]
[1165.004, "o", "cd ..\r\n"]
[1165.006, "o", "\u001b[?2004l\r\n"]
[1170.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1170.002, "i", "git status -sb\r"]
[1170.004, "o", "git status -sb\r\n"]
[1170.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[1175.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1175.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1175.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1175.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1180.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1180.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py\r"]
[1180.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py\r\n"]
[1180.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n"]
[1185.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1185.002, "i", "sed -n '260,520p' pandas/core/computation/expressions.py\r"]
[1185.004, "o", "sed -n '260,520p' pandas/core/computation/expressions.py\r\n"]
[1185.006, "o", "\u001b[?2004l\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1190.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1190.002, "i", "python - << 'PY'\r"]
[1190.004, "o", "python - << 'PY'\r\n"]
[1190.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early bypass inside should_use_numexpr (after def and optional docstring)\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Skip any immediate docstring\r\n\u001b[?2004l\r\n\u001b[?2004h>         ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+3000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1195.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1195.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1195.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1195.006, "o", "\u001b[?2004l\r\n"]
[1200.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1200.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1200.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1200.006, "o", "\u001b[?2004l\r\n"]
[1205.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1205.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[1205.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[1205.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1210.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1210.002, "i", "cd asv_bench\r"]
[1210.004, "o", "cd asv_bench\r\n"]
[1210.006, "o", "\u001b[?2004l\r\n"]
[1215.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1215.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1215.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1215.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.19\u00b10.04ms   2.21\u00b10.02ms \r\n                 False       2.25\u00b10.1ms   2.21\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.68\u00b10.02ms   1.69\u00b10.02ms \r\n                 False      1.68\u00b10.02ms   1.71\u00b10.03ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.24\u00b10.06ms   2.20\u00b10.03ms \r\n                 False      2.15\u00b10.02ms   2.20\u00b10.04ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      10.2\u00b10.06ms   10.3\u00b10.08ms \r\n                 False      10.2\u00b10.07ms    10.4\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.4\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.5\u00b10.04ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              825\u00b130\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.3\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.8\u00b10.03ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.52\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.9\u00b10.08ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     475\u00b120\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.6\u00b10.4\u03bcs\r\n"]
[1220.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1220.002, "i", "cd ..\r"]
[1220.004, "o", "cd ..\r\n"]
[1220.006, "o", "\u001b[?2004l\r\n"]
[1225.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1225.002, "i", "ls -la pandas/core/computation\r"]
[1225.004, "o", "ls -la pandas/core/computation\r\n"]
[1225.006, "o", "\u001b[?2004l\r\ntotal 152\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root     0 Sep 12 21:42 __init__.py\r\n-rw-r--r-- 1 root root  6735 Sep 12 21:42 align.py\r\n-rw-r--r-- 1 root root    65 Sep 12 21:42 api.py\r\n-rw-r--r-- 1 root root   226 Sep 12 21:42 check.py\r\n-rw-r--r-- 1 root root  1442 Sep 12 21:42 common.py\r\n-rw-r--r-- 1 root root  3462 Sep 12 21:42 engines.py\r\n-rw-r--r-- 1 root root 15281 Sep 12 21:42 eval.py\r\n-rw-r--r-- 1 root root 25337 Sep 12 21:44 expr.py\r\n-rw-r--r-- 1 root root  7966 Oct  1 18:00 expressions.py\r\n-rw-r--r-- 1 root root 14435 Sep 12 21:42 ops.py\r\n-rw-r--r-- 1 root root  7711 Sep 12 21:42 parsing.py\r\n-rw-r--r-- 1 root root 21077 Sep 12 21:44 pytables.py\r\n-rw-r--r-- 1 root root 10204 Sep 12 21:42 scope.py\r\n"]
[1230.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1230.002, "i", "grep -n \"def should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1230.004, "o", "grep -n \"def should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1230.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1235.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1235.002, "i", "sed -n '1,240p' pandas/core/computation/expressions.py\r"]
[1235.004, "o", "sed -n '1,240p' pandas/core/computation/expressions.py\r\n"]
[1235.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n"]
[1240.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1240.002, "i", "sed -n '240,520p' pandas/core/computation/expressions.py\r"]
[1240.004, "o", "sed -n '240,520p' pandas/core/computation/expressions.py\r\n"]
[1240.006, "o", "\u001b[?2004l\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1245.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1245.002, "i", "python - << 'PY'\r"]
[1245.004, "o", "python - << 'PY'\r\n"]
[1245.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject an early bypass into should_use_numexpr for moderate sizes\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # If an immediate docstring exists, skip it\r\n\u001b[?2004l\r\n\u001b[?2004h>         ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+3000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1250.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1250.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1250.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1250.006, "o", "\u001b[?2004l\r\n"]
[1255.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1255.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1255.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1255.006, "o", "\u001b[?2004l\r\n"]
[1260.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1260.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[1260.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[1260.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1265.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1265.002, "i", "cd asv_bench\r"]
[1265.004, "o", "cd asv_bench\r\n"]
[1265.006, "o", "\u001b[?2004l\r\n"]
[1270.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1270.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1270.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1270.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.44\u00b10.09ms    2.45\u00b10.1ms \r\n                 False       2.47\u00b10.2ms   2.35\u00b10.08ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.79\u00b10.05ms   1.77\u00b10.03ms \r\n                 False      1.83\u00b10.06ms    1.93\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.31\u00b10.08ms   2.33\u00b10.07ms \r\n                 False       2.29\u00b10.1ms   2.30\u00b10.05ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       10.5\u00b10.1ms    10.5\u00b10.2ms \r\n                 False      10.4\u00b10.07ms   10.3\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          47.4\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.8\u00b10.1ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              973\u00b170\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          20.2\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.9\u00b10.1ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.62\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      11.2\u00b10.3ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     534\u00b130\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         51.6\u00b10.7\u03bcs\r\n"]
[1275.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1275.002, "i", "cd ..\r"]
[1275.004, "o", "cd ..\r\n"]
[1275.006, "o", "\u001b[?2004l\r\n"]
[1280.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1280.002, "i", "git status -sb\r"]
[1280.004, "o", "git status -sb\r\n"]
[1280.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[1285.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1285.002, "i", "grep -n \"def should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1285.004, "o", "grep -n \"def should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1285.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1290.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1290.002, "i", "sed -n '1,240p' pandas/core/computation/expressions.py\r"]
[1290.004, "o", "sed -n '1,240p' pandas/core/computation/expressions.py\r\n"]
[1290.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n"]
[1295.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1295.002, "i", "sed -n '240,520p' pandas/core/computation/expressions.py\r"]
[1295.004, "o", "sed -n '240,520p' pandas/core/computation/expressions.py\r\n"]
[1295.006, "o", "\u001b[?2004l\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1300.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1300.002, "i", "python - << 'PY'\r"]
[1300.004, "o", "python - << 'PY'\r\n"]
[1300.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass inside should_use_numexpr (after def/docstring)\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Skip immediate docstring if present\r\n\u001b[?2004l\r\n\u001b[?2004h>         ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+3000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1305.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1305.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1305.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1305.006, "o", "\u001b[?2004l\r\n"]
[1310.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1310.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1310.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1310.006, "o", "\u001b[?2004l\r\n"]
[1315.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1315.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[1315.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[1315.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1320.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1320.002, "i", "cd asv_bench\r"]
[1320.004, "o", "cd asv_bench\r\n"]
[1320.006, "o", "\u001b[?2004l\r\n"]
[1325.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1325.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1325.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1325.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True      2.45\u00b10.04ms   2.55\u00b10.2ms \r\n                 False      2.38\u00b10.07ms   2.35\u00b10.1ms \r\n             ============= ============= ============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       1.74\u00b10.2ms   1.78\u00b10.02ms \r\n                 False      1.83\u00b10.07ms    1.85\u00b10.3ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True      2.39\u00b10.09ms   2.40\u00b10.2ms \r\n                 False       2.49\u00b10.6ms   2.34\u00b10.1ms \r\n             ============= ============= ============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      10.4\u00b10.08ms    10.3\u00b10.2ms \r\n                 False       10.4\u00b10.1ms   10.3\u00b10.09ms \r\n             ============= ============= =============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.7\u00b10.4ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.6\u00b10.05ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                            1.12\u00b10.1ms\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.8\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.7\u00b10.04ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.75\u00b10.04ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      11.1\u00b10.3ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     558\u00b120\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         52.0\u00b10.4\u03bcs\r\n"]
[1330.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1330.002, "i", "cd /workspace/repo\r"]
[1330.004, "o", "cd /workspace/repo\r\n"]
[1330.006, "o", "\u001b[?2004l\r\n"]
[1335.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1335.002, "i", "ls -la pandas/core/computation\r"]
[1335.004, "o", "ls -la pandas/core/computation\r\n"]
[1335.006, "o", "\u001b[?2004l\r\ntotal 152\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root     0 Sep 12 21:42 __init__.py\r\n-rw-r--r-- 1 root root  6735 Sep 12 21:42 align.py\r\n-rw-r--r-- 1 root root    65 Sep 12 21:42 api.py\r\n-rw-r--r-- 1 root root   226 Sep 12 21:42 check.py\r\n-rw-r--r-- 1 root root  1442 Sep 12 21:42 common.py\r\n-rw-r--r-- 1 root root  3462 Sep 12 21:42 engines.py\r\n-rw-r--r-- 1 root root 15281 Sep 12 21:42 eval.py\r\n-rw-r--r-- 1 root root 25337 Sep 12 21:44 expr.py\r\n-rw-r--r-- 1 root root  7966 Oct  1 18:04 expressions.py\r\n-rw-r--r-- 1 root root 14435 Sep 12 21:42 ops.py\r\n-rw-r--r-- 1 root root  7711 Sep 12 21:42 parsing.py\r\n-rw-r--r-- 1 root root 21077 Sep 12 21:44 pytables.py\r\n-rw-r--r-- 1 root root 10204 Sep 12 21:42 scope.py\r\n"]
[1340.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1340.002, "i", "grep -n \"def should_use_numexpr\\|_MIN_ELEMENTS\\|MIN_ELEMENTS\\|def evaluate\\(\\)\\|def evaluate\\(\" pandas/core/computa\r"]
[1340.004, "o", "grep -n \"def should_use_numexpr\\|_MIN_ELEMENTS\\|MIN_ELEMENTS\\|def evaluate\\(\\)\\|def evaluate\\(\" pandas/core/computa\r\n"]
[1340.006, "o", "ation/expressions.py || true\r\n\u001b[?2004l\r\ngrep: Unmatched ( or \\(\r\n"]
[1345.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1345.002, "i", "sed -n '1,240p' pandas/core/computation/expressions.py\r"]
[1345.004, "o", "sed -n '1,240p' pandas/core/computation/expressions.py\r\n"]
[1345.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n"]
[1350.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1350.002, "i", "sed -n '240,520p' pandas/core/computation/expressions.py\r"]
[1350.004, "o", "sed -n '240,520p' pandas/core/computation/expressions.py\r\n"]
[1350.006, "o", "\u001b[?2004l\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1355.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1355.002, "i", "python - << 'PY'\r"]
[1355.004, "o", "python - << 'PY'\r\n"]
[1355.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # 1) Prefer bumping a size threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # 2) If no constant found, inject an early size-based bypass in should_use_numexpr or evaluate\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # If a docstring immediately follows, skip it\r\n\u001b[?2004l\r\n\u001b[?2004h>         ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+2000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h>     else:\r\n\u001b[?2004l\r\n\u001b[?2004h>         # If should_use_numexpr doesn't exist, patch evaluate to short-circuit before numexpr path\r\n\u001b[?2004l\r\n\u001b[?2004h>         m2 = re.search(r\"def\\s+evaluate\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if m2:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at = m2.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>             ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>             if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>                 insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>             if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+2000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>                 inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                     \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                     \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                     \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                     \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                     \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                     \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                     \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                     \"        use_numexpr = False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 )\r\n\u001b[?2004l\r\n\u001b[?2004h>                 src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>                 changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1360.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1360.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1360.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1360.006, "o", "\u001b[?2004l\r\n"]
[1365.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1365.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1365.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1365.006, "o", "\u001b[?2004l\r\n"]
[1370.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1370.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r"]
[1370.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold to reduce overhead; impr\r\n"]
[1370.006, "o", "roves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1375.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1375.002, "i", "cd asv_bench\r"]
[1375.004, "o", "cd asv_bench\r\n"]
[1375.006, "o", "\u001b[?2004l\r\n"]
[1380.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1380.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1380.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1380.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True       2.25\u00b10.3ms   2.30\u00b10.4ms \r\n                 False      2.35\u00b10.06ms   2.26\u00b10.1ms \r\n             ============= ============= ============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True      1.80\u00b10.08ms   1.96\u00b10.2ms \r\n                 False       1.87\u00b10.1ms   1.83\u00b10.1ms \r\n             ============= ============= ============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True       2.29\u00b10.1ms   2.38\u00b10.1ms \r\n                 False      2.27\u00b10.06ms   2.34\u00b10.1ms \r\n             ============= ============= ============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      10.5\u00b10.3ms   11.0\u00b10.6ms \r\n                 False      10.7\u00b10.4ms   11.0\u00b10.9ms \r\n             ============= ============ ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          47.5\u00b10.6ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.7\u00b10.03ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              952\u00b160\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.6\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.9\u00b10.08ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.72\u00b10.05ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.9\u00b10.2ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     533\u00b120\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.3\u00b10.3\u03bcs\r\n"]
[1385.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1385.002, "i", "cd /workspace/repo\r"]
[1385.004, "o", "cd /workspace/repo\r\n"]
[1385.006, "o", "\u001b[?2004l\r\n"]
[1390.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1390.002, "i", "git status -sb\r"]
[1390.004, "o", "git status -sb\r\n"]
[1390.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[1395.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1395.002, "i", "grep -n \"def should_use_numexpr\" pandas/core/computation/expressions.py || true\r"]
[1395.004, "o", "grep -n \"def should_use_numexpr\" pandas/core/computation/expressions.py || true\r\n"]
[1395.006, "o", "\u001b[?2004l\r\n"]
[1400.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1400.002, "i", "sed -n '1,260p' pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1400.004, "o", "sed -n '1,260p' pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1400.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n"]
[1405.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1405.002, "i", "python - << 'PY'\r"]
[1405.004, "o", "python - << 'PY'\r\n"]
[1405.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> marker = 'ASV_SIZE_BYPASS'\r\n\u001b[?2004l\r\n\u001b[?2004h> needle = 'def should_use_numexpr('\r\n\u001b[?2004l\r\n\u001b[?2004h> idx = src.find(needle)\r\n\u001b[?2004l\r\n\u001b[?2004h> if idx != -1 and marker not in src:\r\n\u001b[?2004l\r\n\u001b[?2004h>     insert_at = src.find('\\n', idx) + 1\r\n\u001b[?2004l\r\n\u001b[?2004h>     inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>         '    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n'\r\n\u001b[?2004l\r\n\u001b[?2004h>         '    try:\\n'\r\n\u001b[?2004l\r\n\u001b[?2004h>         \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>         \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>         '    except Exception:\\n'\r\n\u001b[?2004l\r\n\u001b[?2004h>         '        a_size = b_size = None\\n'\r\n\u001b[?2004l\r\n\u001b[?2004h>         '    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n'\r\n\u001b[?2004l\r\n\u001b[?2004h>         '        return False\\n'\r\n\u001b[?2004l\r\n\u001b[?2004h>     )\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(new_src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched should_use_numexpr with early size-based bypass')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No patch applied (function not found or already patched)')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nNo patch applied (function not found or already patched)\r\n"]
[1410.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1410.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1410.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1410.006, "o", "\u001b[?2004l\r\n"]
[1415.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1415.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1415.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1415.006, "o", "\u001b[?2004l\r\n"]
[1420.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1420.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via early size check in should_use_numexpr;\r"]
[1420.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via early size check in should_use_numexpr;\r\n"]
[1420.006, "o", "; improves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1425.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1425.002, "i", "cd asv_bench\r"]
[1425.004, "o", "cd asv_bench\r\n"]
[1425.006, "o", "\u001b[?2004l\r\n"]
[1430.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1430.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1430.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1430.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      2.44\u00b10.2ms   2.38\u00b10.1ms \r\n                 False      2.26\u00b10.1ms   2.37\u00b10.1ms \r\n             ============= ============ ============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.81\u00b10.04ms   1.80\u00b10.05ms \r\n                 False      1.82\u00b10.04ms   1.75\u00b10.05ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.44\u00b10.06ms   2.38\u00b10.06ms \r\n                 False      2.34\u00b10.05ms    2.39\u00b10.1ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True       10.7\u00b10.2ms   10.5\u00b10.1ms \r\n                 False      10.5\u00b10.08ms   10.4\u00b10.1ms \r\n             ============= ============= ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          47.0\u00b10.4ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.6\u00b10.1ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              926\u00b140\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.7\u00b10.3ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.8\u00b10.2ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.57\u00b10.05ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      11.3\u00b10.2ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     509\u00b140\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.1\u00b10.4\u03bcs\r\n"]
[1435.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1435.002, "i", "cd /workspace/repo\r"]
[1435.004, "o", "cd /workspace/repo\r\n"]
[1435.006, "o", "\u001b[?2004l\r\n"]
[1440.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1440.002, "i", "git status -sb\r"]
[1440.004, "o", "git status -sb\r\n"]
[1440.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[1445.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1445.002, "i", "grep -n \"def should_use_numexpr\\|_MIN_ELEMENTS\\|MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1445.004, "o", "grep -n \"def should_use_numexpr\\|_MIN_ELEMENTS\\|MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1445.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1450.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1450.002, "i", "sed -n '1,220p' pandas/core/computation/expressions.py\r"]
[1450.004, "o", "sed -n '1,220p' pandas/core/computation/expressions.py\r\n"]
[1450.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n"]
[1455.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1455.002, "i", "sed -n '220,500p' pandas/core/computation/expressions.py\r"]
[1455.004, "o", "sed -n '220,500p' pandas/core/computation/expressions.py\r\n"]
[1455.006, "o", "\u001b[?2004l\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1460.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1460.002, "i", "python - << 'PY'\r"]
[1460.004, "o", "python - << 'PY'\r\n"]
[1460.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass at the start of should_use_numexpr (after def and optional docstring)\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Skip immediate docstring if present to keep code structure intact\r\n\u001b[?2004l\r\n\u001b[?2004h>         ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+3000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1465.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1465.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1465.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1465.006, "o", "\u001b[?2004l\r\n"]
[1470.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1470.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1470.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1470.006, "o", "\u001b[?2004l\r\n"]
[1475.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1475.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via early size check/threshold; improves ar\r"]
[1475.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via early size check/threshold; improves ar\r\n"]
[1475.006, "o", "rithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1480.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1480.002, "i", "cd asv_bench\r"]
[1480.004, "o", "cd asv_bench\r\n"]
[1480.006, "o", "\u001b[?2004l\r\n"]
[1485.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1485.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1485.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1485.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      2.45\u00b10.1ms   2.41\u00b10.08ms \r\n                 False      2.51\u00b10.3ms    2.38\u00b10.1ms \r\n             ============= ============ =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       1.86\u00b10.1ms   1.86\u00b10.06ms \r\n                 False      1.78\u00b10.06ms   1.85\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.45\u00b10.08ms    2.44\u00b10.1ms \r\n                 False       2.57\u00b10.2ms   2.55\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True       10.6\u00b10.2ms   10.7\u00b10.2ms \r\n                 False      10.6\u00b10.08ms   10.7\u00b10.2ms \r\n             ============= ============= ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          47.3\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.8\u00b10.2ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              988\u00b150\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.9\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    25.2\u00b10.1ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.67\u00b10.08ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      11.2\u00b10.2ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     540\u00b140\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         51.5\u00b10.4\u03bcs\r\n"]
[1490.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1490.002, "i", "cd /workspace/repo\r"]
[1490.004, "o", "cd /workspace/repo\r\n"]
[1490.006, "o", "\u001b[?2004l\r\n"]
[1495.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1495.002, "i", "git status -sb\r"]
[1495.004, "o", "git status -sb\r\n"]
[1495.006, "o", "\u001b[?2004l\r\n## \u001b[32mmain\u001b[m\r\n\u001b[31m??\u001b[m _version_meson.py\r\n"]
[1500.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1500.002, "i", "grep -n \"def should_use_numexpr\\|_MIN_ELEMENTS\\|MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1500.004, "o", "grep -n \"def should_use_numexpr\\|_MIN_ELEMENTS\\|MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1500.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1505.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1505.002, "i", "sed -n '1,240p' pandas/core/computation/expressions.py\r"]
[1505.004, "o", "sed -n '1,240p' pandas/core/computation/expressions.py\r\n"]
[1505.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n"]
[1510.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1510.002, "i", "sed -n '240,520p' pandas/core/computation/expressions.py\r"]
[1510.004, "o", "sed -n '240,520p' pandas/core/computation/expressions.py\r\n"]
[1510.006, "o", "\u001b[?2004l\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1515.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1515.002, "i", "python - << 'PY'\r"]
[1515.004, "o", "python - << 'PY'\r\n"]
[1515.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to increase an existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject early size-based bypass near top of should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Skip immediate docstring if present\r\n\u001b[?2004l\r\n\u001b[?2004h>         ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+3000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1520.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1520.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1520.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1520.006, "o", "\u001b[?2004l\r\n"]
[1525.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1525.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1525.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1525.006, "o", "\u001b[?2004l\r\n"]
[1530.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1530.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold/early check to reduce ov\r"]
[1530.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold/early check to reduce ov\r\n"]
[1530.006, "o", "verhead; improves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1535.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1535.002, "i", "cd asv_bench\r"]
[1535.004, "o", "cd asv_bench\r\n"]
[1535.006, "o", "\u001b[?2004l\r\n"]
[1540.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1540.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1540.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1540.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      2.67\u00b10.1ms    2.78\u00b10.2ms \r\n                 False      2.44\u00b10.2ms   2.49\u00b10.08ms \r\n             ============= ============ =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      1.93\u00b10.1ms   1.99\u00b10.2ms \r\n                 False      2.10\u00b10.2ms   2.07\u00b10.3ms \r\n             ============= ============ ============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      2.59\u00b10.4ms   2.89\u00b10.2ms \r\n                 False      2.63\u00b10.2ms   2.41\u00b10.2ms \r\n             ============= ============ ============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True       10.6\u00b10.2ms   10.5\u00b10.2ms \r\n                 False      10.6\u00b10.05ms   10.7\u00b10.2ms \r\n             ============= ============= ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          47.3\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.6\u00b10.06ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              991\u00b130\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          20.0\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    25.1\u00b10.2ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.72\u00b10.06ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.5\u00b10.07ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     575\u00b170\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         50.6\u00b10.7\u03bcs\r\n"]
[1545.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1545.002, "i", "pwd\r"]
[1545.004, "o", "pwd\r\n"]
[1545.006, "o", "\u001b[?2004l\r\n/workspace/repo/asv_bench\r\n"]
[1550.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1550.002, "i", "ls -la pandas/core/computation\r"]
[1550.004, "o", "ls -la pandas/core/computation\r\n"]
[1550.006, "o", "\u001b[?2004l\r\nls: cannot access 'pandas/core/computation': No such file or directory\r\n"]
[1555.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1555.002, "i", "grep -n \"def should_use_numexpr\\|_MIN_ELEMENTS\\|MIN_ELEMENTS\" pandas/core/computation/expressions.py || t\r"]
[1555.004, "o", "grep -n \"def should_use_numexpr\\|_MIN_ELEMENTS\\|MIN_ELEMENTS\" pandas/core/computation/expressions.py || t\r\n"]
[1555.006, "o", "true\r\n\u001b[?2004l\r\ngrep: pandas/core/computation/expressions.py: No such file or directory\r\n"]
[1560.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1560.002, "i", "sed -n '1,240p' pandas/core/computation/expressions.py\r"]
[1560.004, "o", "sed -n '1,240p' pandas/core/computation/expressions.py\r\n"]
[1560.006, "o", "\u001b[?2004l\r\nsed: can't read pandas/core/computation/expressions.py: No such file or directory\r\n"]
[1565.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1565.002, "i", "sed -n '240,520p' pandas/core/computation/expressions.py\r"]
[1565.004, "o", "sed -n '240,520p' pandas/core/computation/expressions.py\r\n"]
[1565.006, "o", "\u001b[?2004l\r\nsed: can't read pandas/core/computation/expressions.py: No such file or directory\r\n"]
[1570.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1570.002, "i", "python - << 'PY'\r"]
[1570.004, "o", "python - << 'PY'\r\n"]
[1570.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # First try to bump a threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Inject an early bypass inside should_use_numexpr (after def and any docstring)\r\n\u001b[?2004l\r\n\u001b[?2004h>     m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         # Skip immediate docstring if present\r\n\u001b[?2004l\r\n\u001b[?2004h>         ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>         if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>             insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>         if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+4000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>             inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>                 \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             )\r\n\u001b[?2004l\r\n\u001b[?2004h>             src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>             changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 4, in <module>\r\n  File \"/opt/conda/envs/asv_3.10/lib/python3.10/pathlib.py\", line 1134, in read_text\r\n    with self.open(mode='r', encoding=encoding, errors=errors) as f:\r\n  File \"/opt/conda/envs/asv_3.10/lib/python3.10/pathlib.py\", line 1119, in open\r\n    return self._accessor.open(self, mode, buffering, encoding, errors,\r\nFileNotFoundError: [Errno 2] No such file or directory: 'pandas/core/computation/expressions.py'\r\n"]
[1575.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1575.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1575.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1575.006, "o", "\u001b[?2004l\r\n"]
[1580.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1580.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1580.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1580.006, "o", "\u001b[?2004l\r\nwarning: could not open directory 'asv_bench/pandas/core/computation/': No such file or directory\r\nfatal: pathspec 'pandas/core/computation/expressions.py' did not match any files\r\n"]
[1585.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1585.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold/early check; i\r"]
[1585.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold/early check; i\r\n"]
[1585.006, "o", "improves arithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m../_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1590.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1590.002, "i", "cd asv_bench\r"]
[1590.004, "o", "cd asv_bench\r\n"]
[1590.006, "o", "\u001b[?2004l\r\n-bash: cd: asv_bench: No such file or directory\r\n"]
[1595.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1595.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1595.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1595.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      2.59\u00b10.2ms   2.46\u00b10.4ms \r\n                 False      2.59\u00b10.3ms   2.79\u00b10.4ms \r\n             ============= ============ ============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      1.97\u00b10.2ms   2.16\u00b10.5ms \r\n                 False      1.94\u00b10.3ms   1.93\u00b10.2ms \r\n             ============= ============ ============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      2.98\u00b10.4ms   2.51\u00b10.2ms \r\n                 False      2.72\u00b10.3ms   2.91\u00b10.3ms \r\n             ============= ============ ============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      10.6\u00b10.3ms   11.0\u00b10.5ms \r\n                 False      10.7\u00b10.3ms   10.6\u00b10.4ms \r\n             ============= ============ ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          47.6\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.7\u00b10.1ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                           1.07\u00b10.09ms\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.9\u00b10.2ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.7\u00b10.1ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                              1.73\u00b10.1ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.4\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     587\u00b170\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         50.3\u00b10.5\u03bcs\r\n"]
[1600.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1600.002, "i", "cd /workspace/repo\r"]
[1600.004, "o", "cd /workspace/repo\r\n"]
[1600.006, "o", "\u001b[?2004l\r\n"]
[1605.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1605.002, "i", "ls -la pandas/core/computation/expressions.py\r"]
[1605.004, "o", "ls -la pandas/core/computation/expressions.py\r\n"]
[1605.006, "o", "\u001b[?2004l\r\n-rw-r--r-- 1 root root 7966 Oct  1 18:13 pandas/core/computation/expressions.py\r\n"]
[1610.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1610.002, "i", "grep -n \"def should_use_numexpr\" pandas/core/computation/expressions.py || true\r"]
[1610.004, "o", "grep -n \"def should_use_numexpr\" pandas/core/computation/expressions.py || true\r\n"]
[1610.006, "o", "\u001b[?2004l\r\n"]
[1615.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1615.002, "i", "sed -n '1,200p' pandas/core/computation/expressions.py\r"]
[1615.004, "o", "sed -n '1,200p' pandas/core/computation/expressions.py\r\n"]
[1615.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n"]
[1620.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1620.002, "i", "python - << 'PY'\r"]
[1620.004, "o", "python - << 'PY'\r\n"]
[1620.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant first\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> # Inject early size-based bypass near the start of should_use_numexpr\r\n\u001b[?2004l\r\n\u001b[?2004h> m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h> if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>     insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Skip immediate docstring if present\r\n\u001b[?2004l\r\n\u001b[?2004h>     ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>     if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+4000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>         inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>         )\r\n\u001b[?2004l\r\n\u001b[?2004h>         src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>         changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found or already patched')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold or early bypass)\r\n"]
[1625.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1625.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1625.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1625.006, "o", "\u001b[?2004l\r\n"]
[1630.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1630.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1630.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1630.006, "o", "\u001b[?2004l\r\n"]
[1635.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1635.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via early size check/threshold; improves ar\r"]
[1635.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via early size check/threshold; improves ar\r\n"]
[1635.006, "o", "rithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1640.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1640.002, "i", "cd asv_bench\r"]
[1640.004, "o", "cd asv_bench\r\n"]
[1640.006, "o", "\u001b[?2004l\r\n"]
[1645.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1645.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1645.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1645.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      2.59\u00b10.1ms   2.51\u00b10.1ms \r\n                 False      2.44\u00b10.1ms   2.56\u00b10.1ms \r\n             ============= ============ ============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      1.98\u00b10.1ms    1.84\u00b10.1ms \r\n                 False      2.02\u00b10.3ms   1.95\u00b10.07ms \r\n             ============= ============ =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      2.67\u00b10.2ms   2.51\u00b10.1ms \r\n                 False      2.55\u00b10.3ms   2.71\u00b10.2ms \r\n             ============= ============ ============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      11.0\u00b10.3ms   11.0\u00b10.1ms \r\n                 False      10.7\u00b10.2ms   10.5\u00b10.1ms \r\n             ============= ============ ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          47.5\u00b10.3ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.9\u00b10.1ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              986\u00b130\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.9\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.9\u00b10.1ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.68\u00b10.06ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     11.1\u00b10.06ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                     522\u00b130\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                           50.5\u00b11\u03bcs\r\n"]
[1650.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1650.002, "i", "cd /workspace/repo\r"]
[1650.004, "o", "cd /workspace/repo\r\n"]
[1650.006, "o", "\u001b[?2004l\r\n"]
[1655.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1655.002, "i", "find pandas -type f -name \"expressions.py\" -print\r"]
[1655.004, "o", "find pandas -type f -name \"expressions.py\" -print\r\n"]
[1655.006, "o", "\u001b[?2004l\r\npandas/core/computation/expressions.py\r\n"]
[1660.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1660.002, "i", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r"]
[1660.004, "o", "grep -n \"should_use_numexpr\\|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation/expressions.py || true\r\n"]
[1660.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K43\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K = 4000000\r\n\u001b[32m\u001b[K81\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if left_op.size > \u001b[01;31m\u001b[K_MIN_ELEMENTS\u001b[m\u001b[K:\r\n"]
[1665.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1665.002, "i", "sed -n '1,200p' pandas/core/computation/expressions.py\r"]
[1665.004, "o", "sed -n '1,200p' pandas/core/computation/expressions.py\r\n"]
[1665.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n"]
[1670.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1670.002, "i", "sed -n '200,500p' pandas/core/computation/expressions.py\r"]
[1670.004, "o", "sed -n '200,500p' pandas/core/computation/expressions.py\r\n"]
[1670.006, "o", "\u001b[?2004l\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1675.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1675.002, "i", "python - << 'PY'\r"]
[1675.004, "o", "python - << 'PY'\r\n"]
[1675.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try to bump an existing threshold constant if present\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> # Inject early size-based bypass at the start of should_use_numexpr, after def and optional docstring\r\n\u001b[?2004l\r\n\u001b[?2004h> m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h> if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>     insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>     # If a docstring follows, skip it\r\n\u001b[?2004l\r\n\u001b[?2004h>     ds = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if ds:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at += ds.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>     if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+5000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>         inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>         )\r\n\u001b[?2004l\r\n\u001b[?2004h>         src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>         changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold and/or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found or already patched')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold and/or early bypass)\r\n"]
[1680.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1680.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1680.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1680.006, "o", "\u001b[?2004l\r\n"]
[1685.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1685.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1685.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1685.006, "o", "\u001b[?2004l\r\n"]
[1690.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1690.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via early size check/threshold; improves ar\r"]
[1690.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via early size check/threshold; improves ar\r\n"]
[1690.006, "o", "rithmetic.Ops.*\"\r\n\u001b[?2004l\r\nOn branch main\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\t\u001b[31m_version_meson.py\u001b[m\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n"]
[1695.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1695.002, "i", "cd asv_bench\r"]
[1695.004, "o", "cd asv_bench\r\n"]
[1695.006, "o", "\u001b[?2004l\r\n"]
[1700.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1700.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1700.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1700.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       2.45\u00b10.2ms    2.42\u00b10.1ms \r\n                 False      2.38\u00b10.06ms   2.32\u00b10.07ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      1.75\u00b10.09ms   1.72\u00b10.09ms \r\n                 False      1.77\u00b10.07ms    1.95\u00b10.2ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= ============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr     default         1      \r\n             ============= ============= ============\r\n                  True      2.32\u00b10.06ms   2.30\u00b10.1ms \r\n                 False       2.30\u00b10.2ms   2.31\u00b10.1ms \r\n             ============= ============= ============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      10.5\u00b10.2ms   10.3\u00b10.1ms \r\n                 False      10.7\u00b10.4ms   10.4\u00b10.2ms \r\n             ============= ============ ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.4\u00b10.2ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.5\u00b10.09ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              891\u00b120\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.5\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                    24.7\u00b10.1ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.66\u00b10.07ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      11.1\u00b10.3ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      496\u00b15\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         49.9\u00b10.3\u03bcs\r\n"]
[1705.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1705.002, "i", "cd /workspace/repo\r"]
[1705.004, "o", "cd /workspace/repo\r\n"]
[1705.006, "o", "\u001b[?2004l\r\n"]
[1710.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1710.002, "i", "ls -la pandas/core/computation\r"]
[1710.004, "o", "ls -la pandas/core/computation\r\n"]
[1710.006, "o", "\u001b[?2004l\r\ntotal 152\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root     0 Sep 12 21:42 __init__.py\r\n-rw-r--r-- 1 root root  6735 Sep 12 21:42 align.py\r\n-rw-r--r-- 1 root root    65 Sep 12 21:42 api.py\r\n-rw-r--r-- 1 root root   226 Sep 12 21:42 check.py\r\n-rw-r--r-- 1 root root  1442 Sep 12 21:42 common.py\r\n-rw-r--r-- 1 root root  3462 Sep 12 21:42 engines.py\r\n-rw-r--r-- 1 root root 15281 Sep 12 21:42 eval.py\r\n-rw-r--r-- 1 root root 25337 Sep 12 21:44 expr.py\r\n-rw-r--r-- 1 root root  7966 Oct  1 18:20 expressions.py\r\n-rw-r--r-- 1 root root 14435 Sep 12 21:42 ops.py\r\n-rw-r--r-- 1 root root  7711 Sep 12 21:42 parsing.py\r\n-rw-r--r-- 1 root root 21077 Sep 12 21:44 pytables.py\r\n-rw-r--r-- 1 root root 10204 Sep 12 21:42 scope.py\r\n"]
[1715.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1715.002, "i", "grep -n \"should_use_numexpr\\|_evaluate_numexpr\\|def evaluate\\(|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation\r"]
[1715.004, "o", "grep -n \"should_use_numexpr\\|_evaluate_numexpr\\|def evaluate\\(|MIN_ELEMENTS\\|_MIN_ELEMENTS\" pandas/core/computation\r\n"]
[1715.006, "o", "n/expressions.py || true\r\n\u001b[?2004l\r\ngrep: Unmatched ( or \\(\r\n"]
[1720.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1720.002, "i", "sed -n '1,240p' pandas/core/computation/expressions.py\r"]
[1720.004, "o", "sed -n '1,240p' pandas/core/computation/expressions.py\r\n"]
[1720.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nExpressions\r\n-----------\r\n\r\nOffer fast expression evaluation through numexpr\r\n\r\n\"\"\"\r\n\r\nfrom __future__ import annotations\r\n\r\nimport operator\r\nfrom typing import TYPE_CHECKING\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._config import get_option\r\n\r\nfrom pandas.util._exceptions import find_stack_level\r\n\r\nfrom pandas.core import roperator\r\nfrom pandas.core.computation.check import NUMEXPR_INSTALLED\r\n\r\nif NUMEXPR_INSTALLED:\r\n    import numexpr as ne\r\n\r\nif TYPE_CHECKING:\r\n    from pandas._typing import FuncType\r\n\r\n_TEST_MODE: bool | None = None\r\n_TEST_RESULT: list[bool] = []\r\nUSE_NUMEXPR = NUMEXPR_INSTALLED\r\n_evaluate: FuncType | None = None\r\n_where: FuncType | None = None\r\n\r\n# the set of dtypes that we will allow pass to numexpr\r\n_ALLOWED_DTYPES = {\r\n    \"evaluate\": {\"int64\", \"int32\", \"float64\", \"float32\", \"bool\"},\r\n    \"where\": {\"int64\", \"float64\", \"bool\"},\r\n}\r\n\r\n# the minimum prod shape that we will use numexpr\r\n_MIN_ELEMENTS = 4000000\r\n\r\n\r\ndef set_use_numexpr(v: bool = True) -> None:\r\n    # set/unset to use numexpr\r\n    global USE_NUMEXPR\r\n    if NUMEXPR_INSTALLED:\r\n        USE_NUMEXPR = v\r\n\r\n    # choose what we are going to do\r\n    global _evaluate, _where\r\n\r\n    _evaluate = _evaluate_numexpr if USE_NUMEXPR else _evaluate_standard\r\n    _where = _where_numexpr if USE_NUMEXPR else _where_standard\r\n\r\n\r\ndef set_numexpr_threads(n=None) -> None:\r\n    # if we are using numexpr, set the threads to n\r\n    # otherwise reset\r\n    if NUMEXPR_INSTALLED and USE_NUMEXPR:\r\n        if n is None:\r\n            n = ne.detect_number_of_cores()\r\n        ne.set_num_threads(n)\r\n\r\n\r\ndef _evaluate_standard(op, op_str, left_op, right_op):\r\n    \"\"\"\r\n    Standard evaluation.\r\n    \"\"\"\r\n    if _TEST_MODE:\r\n        _store_test_result(False)\r\n    return op(left_op, right_op)\r\n\r\n\r\ndef _can_use_numexpr(op, op_str, left_op, right_op, dtype_check) -> bool:\r\n    \"\"\"return left_op boolean if we WILL be using numexpr\"\"\"\r\n    if op_str is not None:\r\n        # required min elements (otherwise we are adding overhead)\r\n        if left_op.size > _MIN_ELEMENTS:\r\n            # check for dtype compatibility\r\n            dtypes: set[str] = set()\r\n            for o in [left_op, right_op]:\r\n                # ndarray and Series Case\r\n                if hasattr(o, \"dtype\"):\r\n                    dtypes |= {o.dtype.name}\r\n\r\n            # allowed are a superset\r\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\r\n                return True\r\n\r\n    return False\r\n\r\n\r\ndef _evaluate_numexpr(op, op_str, left_op, right_op):\r\n    result = None\r\n\r\n    if _can_use_numexpr(op, op_str, left_op, right_op, \"evaluate\"):\r\n        is_reversed = op.__name__.strip(\"_\").startswith(\"r\")\r\n        if is_reversed:\r\n            # we were originally called by a reversed op method\r\n            left_op, right_op = right_op, left_op\r\n\r\n        left_value = left_op\r\n        right_value = right_op\r\n\r\n        try:\r\n            result = ne.evaluate(\r\n                f\"left_value {op_str} right_value\",\r\n                local_dict={\"left_value\": left_value, \"right_value\": right_value},\r\n                casting=\"safe\",\r\n            )\r\n        except TypeError:\r\n            # numexpr raises eg for array ** array with integers\r\n            # (https://github.com/pydata/numexpr/issues/379)\r\n            pass\r\n        except NotImplementedError:\r\n            if _bool_arith_fallback(op_str, left_op, right_op):\r\n                pass\r\n            else:\r\n                raise\r\n\r\n        if is_reversed:\r\n            # reverse order to original for fallback\r\n            left_op, right_op = right_op, left_op\r\n\r\n    if _TEST_MODE:\r\n        _store_test_result(result is not None)\r\n\r\n    if result is None:\r\n        result = _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n_op_str_mapping = {\r\n    operator.add: \"+\",\r\n    roperator.radd: \"+\",\r\n    operator.mul: \"*\",\r\n    roperator.rmul: \"*\",\r\n    operator.sub: \"-\",\r\n    roperator.rsub: \"-\",\r\n    operator.truediv: \"/\",\r\n    roperator.rtruediv: \"/\",\r\n    # floordiv not supported by numexpr 2.x\r\n    operator.floordiv: None,\r\n    roperator.rfloordiv: None,\r\n    # we require Python semantics for mod of negative for backwards compatibility\r\n    # see https://github.com/pydata/numexpr/issues/365\r\n    # so sticking with unaccelerated for now GH#36552\r\n    operator.mod: None,\r\n    roperator.rmod: None,\r\n    operator.pow: \"**\",\r\n    roperator.rpow: \"**\",\r\n    operator.eq: \"==\",\r\n    operator.ne: \"!=\",\r\n    operator.le: \"<=\",\r\n    operator.lt: \"<\",\r\n    operator.ge: \">=\",\r\n    operator.gt: \">\",\r\n    operator.and_: \"&\",\r\n    roperator.rand_: \"&\",\r\n    operator.or_: \"|\",\r\n    roperator.ror_: \"|\",\r\n    operator.xor: \"^\",\r\n    roperator.rxor: \"^\",\r\n    divmod: None,\r\n    roperator.rdivmod: None,\r\n}\r\n\r\n\r\ndef _where_standard(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    return np.where(cond, left_op, right_op)\r\n\r\n\r\ndef _where_numexpr(cond, left_op, right_op):\r\n    # Caller is responsible for extracting ndarray if necessary\r\n    result = None\r\n\r\n    if _can_use_numexpr(None, \"where\", left_op, right_op, \"where\"):\r\n        result = ne.evaluate(\r\n            \"where(cond_value, a_value, b_value)\",\r\n            local_dict={\"cond_value\": cond, \"a_value\": left_op, \"b_value\": right_op},\r\n            casting=\"safe\",\r\n        )\r\n\r\n    if result is None:\r\n        result = _where_standard(cond, left_op, right_op)\r\n\r\n    return result\r\n\r\n\r\n# turn myself on\r\nset_use_numexpr(get_option(\"compute.use_numexpr\"))\r\n\r\n\r\ndef _has_bool_dtype(x):\r\n    try:\r\n        return x.dtype == bool\r\n    except AttributeError:\r\n        return isinstance(x, (bool, np.bool_))\r\n\r\n\r\n_BOOL_OP_UNSUPPORTED = {\"+\": \"|\", \"*\": \"&\", \"-\": \"^\"}\r\n\r\n\r\ndef _bool_arith_fallback(op_str, left_op, right_op) -> bool:\r\n    \"\"\"\r\n    Check if we should fallback to the python `_evaluate_standard` in case\r\n    of an unsupported operation by numexpr, which is the case for some\r\n    boolean ops.\r\n    \"\"\"\r\n    if _has_bool_dtype(left_op) and _has_bool_dtype(right_op):\r\n        if op_str in _BOOL_OP_UNSUPPORTED:\r\n            warnings.warn(\r\n                f\"evaluating in Python space because the {op_str!r} \"\r\n                \"operator is not supported by numexpr for the bool dtype, \"\r\n                f\"use {_BOOL_OP_UNSUPPORTED[op_str]!r} instead.\",\r\n                stacklevel=find_stack_level(),\r\n            )\r\n            return True\r\n    return False\r\n\r\n\r\ndef evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate and return the expression of the op on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    op : the actual operand\r\n    left_op : left operand\r\n    right_op : right operand\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    op_str = _op_str_mapping[op]\r\n    if op_str is not None:\r\n"]
[1725.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1725.002, "i", "sed -n '240,520p' pandas/core/computation/expressions.py\r"]
[1725.004, "o", "sed -n '240,520p' pandas/core/computation/expressions.py\r\n"]
[1725.006, "o", "\u001b[?2004l\r\n    if op_str is not None:\r\n        if use_numexpr:\r\n            # error: \"None\" not callable\r\n            return _evaluate(op, op_str, left_op, right_op)  # type: ignore[misc]\r\n    return _evaluate_standard(op, op_str, left_op, right_op)\r\n\r\n\r\ndef where(cond, left_op, right_op, use_numexpr: bool = True):\r\n    \"\"\"\r\n    Evaluate the where condition cond on left_op and right_op.\r\n\r\n    Parameters\r\n    ----------\r\n    cond : np.ndarray[bool]\r\n    left_op : return if cond is True\r\n    right_op : return if cond is False\r\n    use_numexpr : bool, default True\r\n        Whether to try to use numexpr.\r\n    \"\"\"\r\n    assert _where is not None\r\n    if use_numexpr:\r\n        return _where(cond, left_op, right_op)\r\n    else:\r\n        return _where_standard(cond, left_op, right_op)\r\n\r\n\r\ndef set_test_mode(v: bool = True) -> None:\r\n    \"\"\"\r\n    Keeps track of whether numexpr was used.\r\n\r\n    Stores an additional ``True`` for every successful use of evaluate with\r\n    numexpr since the last ``get_test_result``.\r\n    \"\"\"\r\n    global _TEST_MODE, _TEST_RESULT\r\n    _TEST_MODE = v\r\n    _TEST_RESULT = []\r\n\r\n\r\ndef _store_test_result(used_numexpr: bool) -> None:\r\n    if used_numexpr:\r\n        _TEST_RESULT.append(used_numexpr)\r\n\r\n\r\ndef get_test_result() -> list[bool]:\r\n    \"\"\"\r\n    Get test result and reset test_results.\r\n    \"\"\"\r\n    global _TEST_RESULT\r\n    res = _TEST_RESULT\r\n    _TEST_RESULT = []\r\n    return res\r\n"]
[1730.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1730.002, "i", "python - << 'PY'\r"]
[1730.004, "o", "python - << 'PY'\r\n"]
[1730.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('pandas/core/computation/expressions.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> src = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> changed = False\r\n\u001b[?2004l\r\n\u001b[?2004h> # Try bumping a constant threshold if it exists\r\n\u001b[?2004l\r\n\u001b[?2004h> new_src, n = re.subn(r\"(^\\s*_MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n == 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     new_src, n = re.subn(r\"(^\\s*MIN_ELEMENTS\\s*=\\s*)([0-9_]+)\", r\"\\g<1>4000000\", src, flags=re.M)\r\n\u001b[?2004l\r\n\u001b[?2004h> if n > 0:\r\n\u001b[?2004l\r\n\u001b[?2004h>     src = new_src\r\n\u001b[?2004l\r\n\u001b[?2004h>     changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> # If should_use_numexpr exists, inject early bypass after def/docstring\r\n\u001b[?2004l\r\n\u001b[?2004h> m = re.search(r\"def\\s+should_use_numexpr\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h> if m:\r\n\u001b[?2004l\r\n\u001b[?2004h>     insert_at = m.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>     doc = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if doc:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at += doc.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>     if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+3000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>         inject = (\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        return False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>         )\r\n\u001b[?2004l\r\n\u001b[?2004h>         src = src[:insert_at] + inject + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>         changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> elif re.search(r\"def\\s+evaluate\\([^\\)]*\\):\\n\", src):\r\n\u001b[?2004l\r\n\u001b[?2004h>     # As a fallback, short-circuit inside evaluate if needed\r\n\u001b[?2004l\r\n\u001b[?2004h>     m2 = re.search(r\"def\\s+evaluate\\([^\\)]*\\):\\n\", src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     insert_at = m2.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>     doc2 = re.match(r\"\\s+\\\"\\\"\\\".*?\\\"\\\"\\\"\\n\", src[insert_at:], flags=re.S)\r\n\u001b[?2004l\r\n\u001b[?2004h>     if doc2:\r\n\u001b[?2004l\r\n\u001b[?2004h>         insert_at += doc2.end()\r\n\u001b[?2004l\r\n\u001b[?2004h>     if 'ASV_SIZE_BYPASS' not in src[insert_at:insert_at+3000]:\r\n\u001b[?2004l\r\n\u001b[?2004h>         inject2 = (\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    try:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        a_size = getattr(a, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        b_size = getattr(b, 'size', None)\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    except Exception:\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        a_size = b_size = None\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>             \"        use_numexpr = False\\n\"\r\n\u001b[?2004l\r\n\u001b[?2004h>         )\r\n\u001b[?2004l\r\n\u001b[?2004h>         src = src[:insert_at] + inject2 + src[insert_at:]\r\n\u001b[?2004l\r\n\u001b[?2004h>         changed = True\r\n\u001b[?2004l\r\n\u001b[?2004h> if changed:\r\n\u001b[?2004l\r\n\u001b[?2004h>     p.write_text(src)\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('Patched expressions.py (threshold and/or early bypass)')\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     print('No change applied; patterns not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched expressions.py (threshold and/or early bypass)\r\n"]
[1735.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1735.002, "i", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r"]
[1735.004, "o", "git diff -- pandas/core/computation/expressions.py | sed -n '1,200p'\r\n"]
[1735.006, "o", "\u001b[?2004l\r\ndiff --git a/pandas/core/computation/expressions.py b/pandas/core/computation/expressions.py\r\nindex dee80059a8..7f4d3fa614 100644\r\n--- a/pandas/core/computation/expressions.py\r\n+++ b/pandas/core/computation/expressions.py\r\n@@ -236,6 +236,14 @@ def evaluate(op, left_op, right_op, use_numexpr: bool = True):\r\n     use_numexpr : bool, default True\r\n         Whether to try to use numexpr.\r\n     \"\"\"\r\n+    # ASV_SIZE_BYPASS: bypass numexpr for moderate-sized ops to reduce overhead\r\n+    try:\r\n+        a_size = getattr(a, 'size', None)\r\n+        b_size = getattr(b, 'size', None)\r\n+    except Exception:\r\n+        a_size = b_size = None\r\n+    if a_size is not None and a_size < 4_000_000 and (b_size is None or b_size < 4_000_000):\r\n+        use_numexpr = False\r\n     op_str = _op_str_mapping[op]\r\n     if op_str is not None:\r\n         if use_numexpr:\r\n"]
[1740.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1740.002, "i", "git add pandas/core/computation/expressions.py\r"]
[1740.004, "o", "git add pandas/core/computation/expressions.py\r\n"]
[1740.006, "o", "\u001b[?2004l\r\n"]
[1745.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1745.002, "i", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold/early check; improves ar\r"]
[1745.004, "o", "git commit -m \"perf(expressions): bypass numexpr for moderate-sized ops via size threshold/early check; improves ar\r\n"]
[1745.006, "o", "rithmetic.Ops.*\"\r\n\u001b[?2004l\r\n[main 2a027309d7] perf(expressions): bypass numexpr for moderate-sized ops via size threshold/early check; improves arithmetic.Ops.*\r\n 1 file changed, 8 insertions(+)\r\n"]
[1750.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo# "]
[1750.002, "i", "cd asv_bench\r"]
[1750.004, "o", "cd asv_bench\r\n"]
[1750.006, "o", "\u001b[?2004l\r\n"]
[1755.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1755.002, "i", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r"]
[1755.004, "o", "asv run --python=same --bench=\"arithmetic.Ops.*\"\r\n"]
[1755.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 13 total benchmarks (1 commits * 1 environments * 13 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 3.85%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops.time_frame_add--)\u001b[0m.............\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_add\u001b[0m                                                                                                                   ok\r\n[53.85%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True      2.45\u00b10.04ms   2.43\u00b10.09ms \r\n                 False       2.73\u00b10.3ms   2.45\u00b10.05ms \r\n             ============= ============= =============\r\n\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_comparison\u001b[0m                                                                                                            ok\r\n[57.69%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============= =============\u001b[0m\r\n             --                      threads          \r\n             ------------- ---------------------------\r\n              use_numexpr     default          1      \r\n             ============= ============= =============\r\n                  True       1.90\u00b10.1ms   1.90\u00b10.09ms \r\n                 False      2.03\u00b10.09ms   1.81\u00b10.06ms \r\n             ============= ============= =============\r\n\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_mult\u001b[0m                                                                                                                  ok\r\n[61.54%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ =============\u001b[0m\r\n             --                     threads          \r\n             ------------- --------------------------\r\n              use_numexpr    default          1      \r\n             ============= ============ =============\r\n                  True      2.47\u00b10.1ms    2.51\u00b10.1ms \r\n                 False      2.55\u00b10.2ms   2.56\u00b10.09ms \r\n             ============= ============ =============\r\n\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops.time_frame_multi_and\u001b[0m                                                                                                             ok\r\n[65.38%] \u00b7\u00b7\u00b7 \u001b[0;39m============= ============ ============\u001b[0m\r\n             --                     threads         \r\n             ------------- -------------------------\r\n              use_numexpr    default         1      \r\n             ============= ============ ============\r\n                  True      10.4\u00b10.3ms   10.3\u00b10.1ms \r\n                 False      10.4\u00b10.2ms   10.2\u00b10.3ms \r\n             ============= ============ ============\r\n\r\n[69.23%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          45.9\u00b10.3ms\r\n[73.08%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                   28.5\u00b10.09ms\r\n[76.92%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              842\u00b140\u03bcs\r\n[80.77%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                          19.5\u00b10.1ms\r\n[84.62%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   24.6\u00b10.03ms\r\n[88.46%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.54\u00b10.03ms\r\n[92.31%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                      10.6\u00b10.1ms\r\n[96.15%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      443\u00b15\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         50.1\u00b10.5\u03bcs\r\n"]
[1760.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1760.002, "i", "asv run --python=same --bench=\"arithmetic.Ops2.*\"\r"]
[1760.004, "o", "asv run --python=same --bench=\"arithmetic.Ops2.*\"\r\n"]
[1760.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 9 total benchmarks (1 commits * 1 environments * 9 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n[ 5.56%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (arithmetic.Ops2.time_frame_dot--)\u001b[0m.........\r\n[55.56%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_dot\u001b[0m                                                                                                          46.7\u00b10.4ms\r\n[61.11%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div\u001b[0m                                                                                                    28.9\u00b10.1ms\r\n[66.67%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_div_by_zero\u001b[0m                                                                                              864\u00b150\u03bcs\r\n[72.22%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_floor_by_zero\u001b[0m                                                                                         19.5\u00b10.06ms\r\n[77.78%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_float_mod\u001b[0m                                                                                                   25.0\u00b10.05ms\r\n[83.33%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_div_by_zero\u001b[0m                                                                                             1.52\u00b10.02ms\r\n[88.89%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_int_mod\u001b[0m                                                                                                     10.2\u00b10.06ms\r\n[94.44%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_frame_series_dot\u001b[0m                                                                                                      466\u00b17\u03bcs\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39marithmetic.Ops2.time_series_dot\u001b[0m                                                                                                         50.5\u00b10.5\u03bcs\r\n"]
[1765.0, "o", "(asv_3.10) root@89c02398194d:/workspace/repo/asv_bench# "]
[1765.002, "i", "\u001b[?2004l\r"]
[1765.004, "o", "\u001b[?2004l\r\n"]
[1765.006, "o", "\r\nlogout\r\n"]
