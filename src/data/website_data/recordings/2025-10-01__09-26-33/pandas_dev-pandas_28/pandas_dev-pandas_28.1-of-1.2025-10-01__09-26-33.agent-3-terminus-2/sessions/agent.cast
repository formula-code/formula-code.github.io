{"version": 2, "width": 160, "height": 40, "timestamp": 1762995173, "env": {"SHELL": "/bin/bash", "TERM": "screen"}}
[0.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[0.002, "i", "asciinema rec --stdin /logs/agent.cast\r"]
[0.004, "o", "asciinema rec --stdin /logs/agent.cast\r\n"]
[1.242, "o", "\u001b[?2004l\r\n"]
[2.478, "o", "\u001b[0;31masciinema: /logs/agent.cast already exists, aborting\u001b[0m\r\n"]
[3.714, "o", "\u001b[0;31masciinema: use --overwrite option if you want to overwrite existing recording\u001b[0m\r\n"]
[5.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[5.002, "i", "clear\r"]
[5.004, "o", "clear\r\n"]
[7.478, "o", "\u001b[?2004l\r\n"]
[10.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[10.002, "i", "ls -la\r"]
[10.004, "o", "ls -la\r\n"]
[10.139622, "o", "\u001b[?2004l\r\n"]
[10.273243, "o", "total 212\r\n"]
[10.406865, "o", "drwxr-xr-x 1 root root  4096 Oct  1 14:53 \u001b[0m\u001b[01;34m.\u001b[0m\r\n"]
[10.540486, "o", "drwxr-xr-x 1 root root  4096 Sep 15 17:16 \u001b[01;34m..\u001b[0m\r\n"]
[10.674108, "o", "drwxr-xr-x 2 root root  4096 Sep 12 22:25 \u001b[01;34m.circleci\u001b[0m\r\n"]
[10.80773, "o", "-rw-r--r-- 1 root root  1021 Sep 12 22:25 .devcontainer.json\r\n"]
[10.941351, "o", "drwxr-xr-x 1 root root  4096 Oct  1 14:53 \u001b[01;34m.git\u001b[0m\r\n"]
[11.074973, "o", "-rw-r--r-- 1 root root   229 Sep 12 22:25 .gitattributes\r\n"]
[11.208595, "o", "drwxr-xr-x 1 root root  4096 Sep 12 22:25 \u001b[01;34m.github\u001b[0m\r\n"]
[11.342216, "o", "-rw-r--r-- 1 root root  1765 Sep 12 22:25 .gitignore\r\n"]
[11.475838, "o", "-rw-r--r-- 1 root root  2322 Sep 12 22:25 .gitpod.yml\r\n"]
[11.609459, "o", "-rw-r--r-- 1 root root   761 Sep 12 22:25 .libcst.codemod.yaml\r\n"]
[11.743081, "o", "-rw-r--r-- 1 root root 15546 Sep 12 22:25 .pre-commit-config.yaml\r\n"]
[11.876703, "o", "-rw-r--r-- 1 root root  2284 Sep 12 22:25 AUTHORS.md\r\n"]
[12.010324, "o", "-rw-r--r-- 1 root root   372 Sep 12 22:25 CITATION.cff\r\n"]
[12.143946, "o", "-rw-r--r-- 1 root root   369 Sep 12 22:25 Dockerfile\r\n"]
[12.277568, "o", "-rw-r--r-- 1 root root  1634 Sep 12 22:25 LICENSE\r\n"]
[12.411189, "o", "drwxr-xr-x 1 root root  4096 Sep 12 22:25 \u001b[01;34mLICENSES\u001b[0m\r\n"]
[12.544811, "o", "-rw-r--r-- 1 root root  1294 Sep 12 22:25 MANIFEST.in\r\n"]
[12.678432, "o", "-rw-r--r-- 1 root root 10387 Sep 12 22:25 README.md\r\n"]
[12.812054, "o", "-rw-r--r-- 1 root root   246 Sep 12 22:25 RELEASE.md\r\n"]
[12.945676, "o", "drwxr-xr-x 1 root root  4096 Sep 12 22:25 \u001b[01;34masv_bench\u001b[0m\r\n"]
[13.079297, "o", "drwxr-xr-x 1 root root  4096 Sep 12 22:25 \u001b[01;34mci\u001b[0m\r\n"]
[13.212919, "o", "-rw-r--r-- 1 root root   256 Sep 12 22:25 codecov.yml\r\n"]
[13.346541, "o", "drwxr-xr-x 1 root root  4096 Sep 12 22:25 \u001b[01;34mdoc\u001b[0m\r\n"]
[13.480162, "o", "-rw-r--r-- 1 root root  2405 Sep 12 22:25 environment.yml\r\n"]
[13.613784, "o", "drwxr-xr-x 1 root root  4096 Sep 12 22:25 \u001b[01;34mgitpod\u001b[0m\r\n"]
[13.747405, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:58 \u001b[01;34mpandas\u001b[0m\r\n"]
[13.881027, "o", "drwxr-xr-x 2 root root  4096 Sep 13 21:43 \u001b[01;34mpandas.egg-info\u001b[0m\r\n"]
[14.014649, "o", "-rw-r--r-- 1 root root 17415 Sep 12 22:25 pyproject.toml\r\n"]
[14.14827, "o", "-rw-r--r-- 1 root root  4429 Sep 12 22:25 pyright_reportGeneralTypeIssues.json\r\n"]
[14.281892, "o", "-rw-r--r-- 1 root root  1355 Sep 12 22:25 requirements-dev.txt\r\n"]
[14.415514, "o", "drwxr-xr-x 1 root root  4096 Sep 12 22:25 \u001b[01;34mscripts\u001b[0m\r\n"]
[14.549135, "o", "-rw-r--r-- 1 root root   645 Sep 12 22:25 setup.cfg\r\n"]
[14.682757, "o", "-rwxr-xr-x 1 root root 22455 Sep 12 22:25 \u001b[01;32msetup.py\u001b[0m\r\n"]
[14.816378, "o", "drwxr-xr-x 1 root root  4096 Sep 12 22:25 \u001b[01;34mtypings\u001b[0m\r\n"]
[15.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[15.002, "i", "ls -la asv_bench/\r"]
[15.004, "o", "ls -la asv_bench/\r\n"]
[15.83, "o", "\u001b[?2004l\r\n"]
[16.654, "o", "total 24\r\n"]
[17.478, "o", "drwxr-xr-x 1 root root 4096 Sep 12 22:25 \u001b[0m\u001b[01;34m.\u001b[0m\r\n"]
[18.302, "o", "drwxr-xr-x 1 root root 4096 Oct  1 14:53 \u001b[01;34m..\u001b[0m\r\n"]
[19.126, "o", "-rw-r--r-- 1 root root 5217 Sep 12 22:25 asv.conf.json\r\n"]
[20.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[20.002, "i", "find asv_bench/benchmarks -name '*.py' | head -20\r"]
[20.004, "o", "find asv_bench/benchmarks -name '*.py' | head -20\r\n"]
[20.241429, "o", "\u001b[?2004l\r\n"]
[20.476857, "o", "asv_bench/benchmarks/indexing_engines.py\r\n"]
[20.712286, "o", "asv_bench/benchmarks/multiindex_object.py\r\n"]
[20.947714, "o", "asv_bench/benchmarks/frame_ctor.py\r\n"]
[21.183143, "o", "asv_bench/benchmarks/tslibs/normalize.py\r\n"]
[21.418571, "o", "asv_bench/benchmarks/tslibs/timestamp.py\r\n"]
[21.654, "o", "asv_bench/benchmarks/tslibs/tz_convert.py\r\n"]
[21.889429, "o", "asv_bench/benchmarks/tslibs/fields.py\r\n"]
[22.124857, "o", "asv_bench/benchmarks/tslibs/__init__.py\r\n"]
[22.360286, "o", "asv_bench/benchmarks/tslibs/resolution.py\r\n"]
[22.595714, "o", "asv_bench/benchmarks/tslibs/tslib.py\r\n"]
[22.831143, "o", "asv_bench/benchmarks/tslibs/offsets.py\r\n"]
[23.066571, "o", "asv_bench/benchmarks/tslibs/period.py\r\n"]
[23.302, "o", "asv_bench/benchmarks/tslibs/timedelta.py\r\n"]
[23.537429, "o", "asv_bench/benchmarks/series_methods.py\r\n"]
[23.772857, "o", "asv_bench/benchmarks/attrs_caching.py\r\n"]
[24.008286, "o", "asv_bench/benchmarks/plotting.py\r\n"]
[24.243714, "o", "asv_bench/benchmarks/hash_functions.py\r\n"]
[24.479143, "o", "asv_bench/benchmarks/pandas_vb_common.py\r\n"]
[24.714571, "o", "asv_bench/benchmarks/timeseries.py\r\n"]
[25.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[25.002, "i", "find . -name '*sparse*' -type f\r"]
[25.004, "o", "find . -name '*sparse*' -type f\r\n"]
[25.315, "o", "\u001b[?2004l\r\n"]
[25.624, "o", "./pandas/_libs/sparse_op_helper.pxi.in\r\n"]
[25.933, "o", "./pandas/_libs/sparse.pyi\r\n"]
[26.242, "o", "./pandas/_libs/sparse.pyx\r\n"]
[26.551, "o", "./pandas/_libs/sparse.cpython-38-x86_64-linux-gnu.so\r\n"]
[26.86, "o", "./pandas/_libs/sparse_op_helper.pxi\r\n"]
[27.169, "o", "./pandas/_libs/sparse.c\r\n"]
[27.478, "o", "./pandas/core/arrays/sparse/scipy_sparse.py\r\n"]
[27.787, "o", "./pandas/tests/series/accessors/test_sparse_accessor.py\r\n"]
[28.096, "o", "./pandas/tests/extension/test_sparse.py\r\n"]
[28.405, "o", "./pandas/tests/io/formats/data/html/truncate_multi_index_sparse_off.html\r\n"]
[28.714, "o", "./pandas/tests/io/formats/data/html/multiindex_sparsify_false_multi_sparse_1.html\r\n"]
[29.023, "o", "./pandas/tests/io/formats/data/html/multiindex_sparsify_false_multi_sparse_2.html\r\n"]
[29.332, "o", "./pandas/tests/arrays/sparse/test_libsparse.py\r\n"]
[29.641, "o", "./asv_bench/benchmarks/sparse.py\r\n"]
[30.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[30.002, "i", "find . -name 'asv_benchmarks.txt'\r"]
[30.004, "o", "find . -name 'asv_benchmarks.txt'\r\n"]
[30.006, "o", "\u001b[?2004l\r\n"]
[35.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[35.002, "i", "cat asv_bench/benchmarks/sparse.py\r"]
[35.004, "o", "cat asv_bench/benchmarks/sparse.py\r\n"]
[35.027684, "o", "\u001b[?2004l\r\n"]
[35.049368, "o", "import numpy as np\r\n"]
[35.071053, "o", "import scipy.sparse\r\n"]
[35.092737, "o", "\r\n"]
[35.114421, "o", "import pandas as pd\r\n"]
[35.136105, "o", "from pandas import (\r\n"]
[35.157789, "o", "    MultiIndex,\r\n"]
[35.179474, "o", "    Series,\r\n"]
[35.201158, "o", "    date_range,\r\n"]
[35.222842, "o", ")\r\n"]
[35.244526, "o", "from pandas.arrays import SparseArray\r\n"]
[35.266211, "o", "\r\n"]
[35.287895, "o", "\r\n"]
[35.309579, "o", "def make_array(size, dense_proportion, fill_value, dtype):\r\n"]
[35.331263, "o", "    dense_size = int(size * dense_proportion)\r\n"]
[35.352947, "o", "    arr = np.full(size, fill_value, dtype)\r\n"]
[35.374632, "o", "    indexer = np.random.choice(np.arange(size), dense_size, replace=False)\r\n"]
[35.396316, "o", "    arr[indexer] = np.random.choice(np.arange(100, dtype=dtype), dense_size)\r\n"]
[35.418, "o", "    return arr\r\n"]
[35.439684, "o", "\r\n"]
[35.461368, "o", "\r\n"]
[35.483053, "o", "class SparseSeriesToFrame:\r\n"]
[35.504737, "o", "    def setup(self):\r\n"]
[35.526421, "o", "        K = 50\r\n"]
[35.548105, "o", "        N = 50001\r\n"]
[35.569789, "o", "        rng = date_range(\"1/1/2000\", periods=N, freq=\"T\")\r\n"]
[35.591474, "o", "        self.series = {}\r\n"]
[35.613158, "o", "        for i in range(1, K):\r\n"]
[35.634842, "o", "            data = np.random.randn(N)[:-i]\r\n"]
[35.656526, "o", "            idx = rng[:-i]\r\n"]
[35.678211, "o", "            data[100:] = np.nan\r\n"]
[35.699895, "o", "            self.series[i] = Series(SparseArray(data), index=idx)\r\n"]
[35.721579, "o", "\r\n"]
[35.743263, "o", "    def time_series_to_frame(self):\r\n"]
[35.764947, "o", "        pd.DataFrame(self.series)\r\n"]
[35.786632, "o", "\r\n"]
[35.808316, "o", "\r\n"]
[35.83, "o", "class SparseArrayConstructor:\r\n"]
[35.851684, "o", "    params = ([0.1, 0.01], [0, np.nan], [np.int64, np.float64, object])\r\n"]
[35.873368, "o", "    param_names = [\"dense_proportion\", \"fill_value\", \"dtype\"]\r\n"]
[35.895053, "o", "\r\n"]
[35.916737, "o", "    def setup(self, dense_proportion, fill_value, dtype):\r\n"]
[35.938421, "o", "        N = 10**6\r\n"]
[35.960105, "o", "        self.array = make_array(N, dense_proportion, fill_value, dtype)\r\n"]
[35.981789, "o", "\r\n"]
[36.003474, "o", "    def time_sparse_array(self, dense_proportion, fill_value, dtype):\r\n"]
[36.025158, "o", "        SparseArray(self.array, fill_value=fill_value, dtype=dtype)\r\n"]
[36.046842, "o", "\r\n"]
[36.068526, "o", "\r\n"]
[36.090211, "o", "class SparseDataFrameConstructor:\r\n"]
[36.111895, "o", "    def setup(self):\r\n"]
[36.133579, "o", "        N = 1000\r\n"]
[36.155263, "o", "        self.sparse = scipy.sparse.rand(N, N, 0.005)\r\n"]
[36.176947, "o", "\r\n"]
[36.198632, "o", "    def time_from_scipy(self):\r\n"]
[36.220316, "o", "        pd.DataFrame.sparse.from_spmatrix(self.sparse)\r\n"]
[36.242, "o", "\r\n"]
[36.263684, "o", "\r\n"]
[36.285368, "o", "class FromCoo:\r\n"]
[36.307053, "o", "    def setup(self):\r\n"]
[36.328737, "o", "        self.matrix = scipy.sparse.coo_matrix(\r\n"]
[36.350421, "o", "            ([3.0, 1.0, 2.0], ([1, 0, 0], [0, 2, 3])), shape=(100, 100)\r\n"]
[36.372105, "o", "        )\r\n"]
[36.393789, "o", "\r\n"]
[36.415474, "o", "    def time_sparse_series_from_coo(self):\r\n"]
[36.437158, "o", "        Series.sparse.from_coo(self.matrix)\r\n"]
[36.458842, "o", "\r\n"]
[36.480526, "o", "\r\n"]
[36.502211, "o", "class ToCoo:\r\n"]
[36.523895, "o", "    params = [True, False]\r\n"]
[36.545579, "o", "    param_names = [\"sort_labels\"]\r\n"]
[36.567263, "o", "\r\n"]
[36.588947, "o", "    def setup(self, sort_labels):\r\n"]
[36.610632, "o", "        s = Series([np.nan] * 10000)\r\n"]
[36.632316, "o", "        s[0] = 3.0\r\n"]
[36.654, "o", "        s[100] = -1.0\r\n"]
[36.675684, "o", "        s[999] = 12.1\r\n"]
[36.697368, "o", "\r\n"]
[36.719053, "o", "        s_mult_lvl = s.set_axis(MultiIndex.from_product([range(10)] * 4))\r\n"]
[36.740737, "o", "        self.ss_mult_lvl = s_mult_lvl.astype(\"Sparse\")\r\n"]
[36.762421, "o", "\r\n"]
[36.784105, "o", "        s_two_lvl = s.set_axis(MultiIndex.from_product([range(100)] * 2))\r\n"]
[36.805789, "o", "        self.ss_two_lvl = s_two_lvl.astype(\"Sparse\")\r\n"]
[36.827474, "o", "\r\n"]
[36.849158, "o", "    def time_sparse_series_to_coo(self, sort_labels):\r\n"]
[36.870842, "o", "        self.ss_mult_lvl.sparse.to_coo(\r\n"]
[36.892526, "o", "            row_levels=[0, 1], column_levels=[2, 3], sort_labels=sort_labels\r\n"]
[36.914211, "o", "        )\r\n"]
[36.935895, "o", "\r\n"]
[36.957579, "o", "    def time_sparse_series_to_coo_single_level(self, sort_labels):\r\n"]
[36.979263, "o", "        self.ss_two_lvl.sparse.to_coo(sort_labels=sort_labels)\r\n"]
[37.000947, "o", "\r\n"]
[37.022632, "o", "\r\n"]
[37.044316, "o", "class ToCooFrame:\r\n"]
[37.066, "o", "    def setup(self):\r\n"]
[37.087684, "o", "        N = 10000\r\n"]
[37.109368, "o", "        k = 10\r\n"]
[37.131053, "o", "        arr = np.zeros((N, k), dtype=float)\r\n"]
[37.152737, "o", "        arr[0, 0] = 3.0\r\n"]
[37.174421, "o", "        arr[12, 7] = -1.0\r\n"]
[37.196105, "o", "        arr[0, 9] = 11.2\r\n"]
[37.217789, "o", "        self.df = pd.DataFrame(arr, dtype=pd.SparseDtype(\"float\", fill_value=0.0))\r\n"]
[37.239474, "o", "\r\n"]
[37.261158, "o", "    def time_to_coo(self):\r\n"]
[37.282842, "o", "        self.df.sparse.to_coo()\r\n"]
[37.304526, "o", "\r\n"]
[37.326211, "o", "\r\n"]
[37.347895, "o", "class Arithmetic:\r\n"]
[37.369579, "o", "    params = ([0.1, 0.01], [0, np.nan])\r\n"]
[37.391263, "o", "    param_names = [\"dense_proportion\", \"fill_value\"]\r\n"]
[37.412947, "o", "\r\n"]
[37.434632, "o", "    def setup(self, dense_proportion, fill_value):\r\n"]
[37.456316, "o", "        N = 10**6\r\n"]
[37.478, "o", "        arr1 = make_array(N, dense_proportion, fill_value, np.int64)\r\n"]
[37.499684, "o", "        self.array1 = SparseArray(arr1, fill_value=fill_value)\r\n"]
[37.521368, "o", "        arr2 = make_array(N, dense_proportion, fill_value, np.int64)\r\n"]
[37.543053, "o", "        self.array2 = SparseArray(arr2, fill_value=fill_value)\r\n"]
[37.564737, "o", "\r\n"]
[37.586421, "o", "    def time_make_union(self, dense_proportion, fill_value):\r\n"]
[37.608105, "o", "        self.array1.sp_index.make_union(self.array2.sp_index)\r\n"]
[37.629789, "o", "\r\n"]
[37.651474, "o", "    def time_intersect(self, dense_proportion, fill_value):\r\n"]
[37.673158, "o", "        self.array1.sp_index.intersect(self.array2.sp_index)\r\n"]
[37.694842, "o", "\r\n"]
[37.716526, "o", "    def time_add(self, dense_proportion, fill_value):\r\n"]
[37.738211, "o", "        self.array1 + self.array2\r\n"]
[37.759895, "o", "\r\n"]
[37.781579, "o", "    def time_divide(self, dense_proportion, fill_value):\r\n"]
[37.803263, "o", "        self.array1 / self.array2\r\n"]
[37.824947, "o", "\r\n"]
[37.846632, "o", "\r\n"]
[37.868316, "o", "class ArithmeticBlock:\r\n"]
[37.89, "o", "    params = [np.nan, 0]\r\n"]
[37.911684, "o", "    param_names = [\"fill_value\"]\r\n"]
[37.933368, "o", "\r\n"]
[37.955053, "o", "    def setup(self, fill_value):\r\n"]
[37.976737, "o", "        N = 10**6\r\n"]
[37.998421, "o", "        self.arr1 = self.make_block_array(\r\n"]
[38.020105, "o", "            length=N, num_blocks=1000, block_size=10, fill_value=fill_value\r\n"]
[38.041789, "o", "        )\r\n"]
[38.063474, "o", "        self.arr2 = self.make_block_array(\r\n"]
[38.085158, "o", "            length=N, num_blocks=1000, block_size=10, fill_value=fill_value\r\n"]
[38.106842, "o", "        )\r\n"]
[38.128526, "o", "\r\n"]
[38.150211, "o", "    def make_block_array(self, length, num_blocks, block_size, fill_value):\r\n"]
[38.171895, "o", "        arr = np.full(length, fill_value)\r\n"]
[38.193579, "o", "        indices = np.random.choice(\r\n"]
[38.215263, "o", "            np.arange(0, length, block_size), num_blocks, replace=False\r\n"]
[38.236947, "o", "        )\r\n"]
[38.258632, "o", "        for ind in indices:\r\n"]
[38.280316, "o", "            arr[ind : ind + block_size] = np.random.randint(0, 100, block_size)\r\n"]
[38.302, "o", "        return SparseArray(arr, fill_value=fill_value)\r\n"]
[38.323684, "o", "\r\n"]
[38.345368, "o", "    def time_make_union(self, fill_value):\r\n"]
[38.367053, "o", "        self.arr1.sp_index.make_union(self.arr2.sp_index)\r\n"]
[38.388737, "o", "\r\n"]
[38.410421, "o", "    def time_intersect(self, fill_value):\r\n"]
[38.432105, "o", "        self.arr2.sp_index.intersect(self.arr2.sp_index)\r\n"]
[38.453789, "o", "\r\n"]
[38.475474, "o", "    def time_addition(self, fill_value):\r\n"]
[38.497158, "o", "        self.arr1 + self.arr2\r\n"]
[38.518842, "o", "\r\n"]
[38.540526, "o", "    def time_division(self, fill_value):\r\n"]
[38.562211, "o", "        self.arr1 / self.arr2\r\n"]
[38.583895, "o", "\r\n"]
[38.605579, "o", "\r\n"]
[38.627263, "o", "class MinMax:\r\n"]
[38.648947, "o", "    params = ([\"min\", \"max\"], [0.0, np.nan])\r\n"]
[38.670632, "o", "    param_names = [\"func\", \"fill_value\"]\r\n"]
[38.692316, "o", "\r\n"]
[38.714, "o", "    def setup(self, func, fill_value):\r\n"]
[38.735684, "o", "        N = 1_000_000\r\n"]
[38.757368, "o", "        arr = make_array(N, 1e-5, fill_value, np.float64)\r\n"]
[38.779053, "o", "        self.sp_arr = SparseArray(arr, fill_value=fill_value)\r\n"]
[38.800737, "o", "\r\n"]
[38.822421, "o", "    def time_min_max(self, func, fill_value):\r\n"]
[38.844105, "o", "        getattr(self.sp_arr, func)()\r\n"]
[38.865789, "o", "\r\n"]
[38.887474, "o", "\r\n"]
[38.909158, "o", "class Take:\r\n"]
[38.930842, "o", "    params = ([np.array([0]), np.arange(100_000), np.full(100_000, -1)], [True, False])\r\n"]
[38.952526, "o", "    param_names = [\"indices\", \"allow_fill\"]\r\n"]
[38.974211, "o", "\r\n"]
[38.995895, "o", "    def setup(self, indices, allow_fill):\r\n"]
[39.017579, "o", "        N = 1_000_000\r\n"]
[39.039263, "o", "        fill_value = 0.0\r\n"]
[39.060947, "o", "        arr = make_array(N, 1e-5, fill_value, np.float64)\r\n"]
[39.082632, "o", "        self.sp_arr = SparseArray(arr, fill_value=fill_value)\r\n"]
[39.104316, "o", "\r\n"]
[39.126, "o", "    def time_take(self, indices, allow_fill):\r\n"]
[39.147684, "o", "        self.sp_arr.take(indices, allow_fill=allow_fill)\r\n"]
[39.169368, "o", "\r\n"]
[39.191053, "o", "\r\n"]
[39.212737, "o", "class GetItem:\r\n"]
[39.234421, "o", "    def setup(self):\r\n"]
[39.256105, "o", "        N = 1_000_000\r\n"]
[39.277789, "o", "        d = 1e-5\r\n"]
[39.299474, "o", "        arr = make_array(N, d, np.nan, np.float64)\r\n"]
[39.321158, "o", "        self.sp_arr = SparseArray(arr)\r\n"]
[39.342842, "o", "\r\n"]
[39.364526, "o", "    def time_integer_indexing(self):\r\n"]
[39.386211, "o", "        self.sp_arr[78]\r\n"]
[39.407895, "o", "\r\n"]
[39.429579, "o", "    def time_slice(self):\r\n"]
[39.451263, "o", "        self.sp_arr[1:]\r\n"]
[39.472947, "o", "\r\n"]
[39.494632, "o", "\r\n"]
[39.516316, "o", "class GetItemMask:\r\n"]
[39.538, "o", "    params = [True, False, np.nan]\r\n"]
[39.559684, "o", "    param_names = [\"fill_value\"]\r\n"]
[39.581368, "o", "\r\n"]
[39.603053, "o", "    def setup(self, fill_value):\r\n"]
[39.624737, "o", "        N = 1_000_000\r\n"]
[39.646421, "o", "        d = 1e-5\r\n"]
[39.668105, "o", "        arr = make_array(N, d, np.nan, np.float64)\r\n"]
[39.689789, "o", "        self.sp_arr = SparseArray(arr)\r\n"]
[39.711474, "o", "        b_arr = np.full(shape=N, fill_value=fill_value, dtype=np.bool_)\r\n"]
[39.733158, "o", "        fv_inds = np.unique(\r\n"]
[39.754842, "o", "            np.random.randint(low=0, high=N - 1, size=int(N * d), dtype=np.int32)\r\n"]
[39.776526, "o", "        )\r\n"]
[39.798211, "o", "        b_arr[fv_inds] = True if pd.isna(fill_value) else not fill_value\r\n"]
[39.819895, "o", "        self.sp_b_arr = SparseArray(b_arr, dtype=np.bool_, fill_value=fill_value)\r\n"]
[39.841579, "o", "\r\n"]
[39.863263, "o", "    def time_mask(self, fill_value):\r\n"]
[39.884947, "o", "        self.sp_arr[self.sp_b_arr]\r\n"]
[39.906632, "o", "\r\n"]
[39.928316, "o", "\r\n"]
[40.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[40.002, "i", "cd asv_bench\r"]
[40.004, "o", "cd asv_bench\r\n"]
[40.006, "o", "\u001b[?2004l\r\n"]
[45.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[45.002, "i", "asv run --python=same --bench=\"GetItemMask.*\"\r"]
[45.004, "o", "asv run --python=same --bench=\"GetItemMask.*\"\r\n"]
[45.359143, "o", "\u001b[?2004l\r\n"]
[45.712286, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[46.065429, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[46.418571, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[46.771714, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (sparse.GetItemMask.time_mask--)\u001b[0m.\r\n"]
[47.124857, "o", "[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.GetItemMask.time_mask\u001b[0m                                                                                                                    ok\r\n"]
[47.478, "o", "[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39m============ =============\u001b[0m\r\n"]
[47.831143, "o", "               fill_value               \r\n"]
[48.184286, "o", "              ------------ -------------\r\n"]
[48.537429, "o", "                  True      11.2\u00b10.08ms \r\n"]
[48.890571, "o", "                 False       47.6\u00b10.1\u03bcs \r\n"]
[49.243714, "o", "                  nan        6.98\u00b10.1ms \r\n"]
[49.596857, "o", "              ============ =============\r\n"]
[50.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[50.002, "i", "asv profile --python=same --config=asv.conf.json sparse.GetItemMask.time_mask\r"]
[50.004, "o", "asv profile --python=same --config=asv.conf.json sparse.GetItemMask.time_mask\r\n"]
[51.654, "o", "\u001b[?2004l\r\n"]
[53.302, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[55.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[55.002, "i", "asv list\r"]
[55.004, "o", "asv list\r\n"]
[56.242, "o", "\u001b[?2004l\r\n"]
[57.478, "o", "usage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n"]
[58.714, "o", "           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\n"]
[60.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[60.002, "i", "asv profile --help\r"]
[60.004, "o", "asv profile --help\r\n"]
[60.165484, "o", "\u001b[?2004l\r\n"]
[60.324968, "o", "usage: asv profile [-h] [--gui GUI] [--output OUTPUT] [--force] [-E ENV_SPEC] [--python PYTHON] [--launch-method {auto,spawn,forkserver}] [--verbose]\r\n"]
[60.484452, "o", "                   [--config CONFIG] [--version]\r\n"]
[60.643935, "o", "                   benchmark [revision]\r\n"]
[60.803419, "o", "\r\n"]
[60.962903, "o", "Profile a benchmark\r\n"]
[61.122387, "o", "\r\n"]
[61.281871, "o", "positional arguments:\r\n"]
[61.441355, "o", "  benchmark             The benchmark to profile. Must be a fully-specified benchmark name. For parameterized benchmark, it must include the parameter\r\n"]
[61.600839, "o", "                        combination to use, e.g.: benchmark_name\\(param0, param1, ...\\)\r\n"]
[61.760323, "o", "  revision              The revision of the project to profile. May be a commit hash, or a tag or branch name.\r\n"]
[61.919806, "o", "\r\n"]
[62.07929, "o", "optional arguments:\r\n"]
[62.238774, "o", "  -h, --help            show this help message and exit\r\n"]
[62.398258, "o", "  --gui GUI, -g GUI     Display the profile in the given gui. Use --gui=list to list available guis.\r\n"]
[62.557742, "o", "  --output OUTPUT, -o OUTPUT\r\n"]
[62.717226, "o", "                        Save the profiling information to the given file. This file is in the format written by the `cProfile` standard library module. If not\r\n"]
[62.87671, "o", "                        provided, prints a simple text-based profiling report to the console.\r\n"]
[63.036194, "o", "  --force, -f           Forcibly re-run the profile, even if the data already exists in the results database.\r\n"]
[63.195677, "o", "  -E ENV_SPEC, --environment ENV_SPEC\r\n"]
[63.355161, "o", "                        Specify the environment and Python versions for running the benchmarks. String of the format 'environment_type:python_version', for\r\n"]
[63.514645, "o", "                        example 'conda:3.12'. If the Python version is not specified, all those listed in the configuration file are run. The special\r\n"]
[63.674129, "o", "                        environment type 'existing:/path/to/python' runs the benchmarks using the given Python interpreter; if the path is omitted, the Python\r\n"]
[63.833613, "o", "                        running asv is used. For 'existing', the benchmarked project must be already installed, including all dependencies. By default, uses\r\n"]
[63.993097, "o", "                        the values specified in the configuration file.\r\n"]
[64.152581, "o", "  --python PYTHON       Same as --environment=:PYTHON\r\n"]
[64.312065, "o", "  --launch-method {auto,spawn,forkserver}\r\n"]
[64.471548, "o", "                        How to launch benchmarks. Choices: auto, spawn, forkserver\r\n"]
[64.631032, "o", "  --verbose, -v         Increase verbosity\r\n"]
[64.790516, "o", "  --config CONFIG       Benchmark configuration file\r\n"]
[65.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[65.002, "i", "asv profile --python=same --config=asv.conf.json \"sparse.GetItemMask.time_mask(True)\"\r"]
[65.004, "o", "asv profile --python=same --config=asv.conf.json \"sparse.GetItemMask.time_mask(True)\"\r\n"]
[66.654, "o", "\u001b[?2004l\r\n"]
[68.302, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[70.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[70.002, "i", "asv profile --python=same --config=asv.conf.json sparse.GetItemMask.time_mask\\(True\\)\r"]
[70.004, "o", "asv profile --python=same --config=asv.conf.json sparse.GetItemMask.time_mask\\(True\\)\r\n"]
[71.654, "o", "\u001b[?2004l\r\n"]
[73.302, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[75.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[75.002, "i", "cd ..\r"]
[75.004, "o", "cd ..\r\n"]
[75.006, "o", "\u001b[?2004l\r\n"]
[80.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[80.002, "i", "ls -la pandas/core/arrays/sparse/\r"]
[80.004, "o", "ls -la pandas/core/arrays/sparse/\r\n"]
[80.5004, "o", "\u001b[?2004l\r\n"]
[80.9948, "o", "total 120\r\n"]
[81.4892, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:58 \u001b[0m\u001b[01;34m.\u001b[0m\r\n"]
[81.9836, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:58 \u001b[01;34m..\u001b[0m\r\n"]
[82.478, "o", "-rw-r--r-- 1 root root   431 Sep 12 22:25 __init__.py\r\n"]
[82.9724, "o", "drwxr-xr-x 2 root root  4096 Sep 13 21:58 \u001b[01;34m__pycache__\u001b[0m\r\n"]
[83.4668, "o", "-rw-r--r-- 1 root root 12180 Sep 12 22:25 accessor.py\r\n"]
[83.9612, "o", "-rw-r--r-- 1 root root 62974 Sep 12 22:25 array.py\r\n"]
[84.4556, "o", "-rw-r--r-- 1 root root 13385 Sep 12 22:25 dtype.py\r\n"]
[85.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[85.002, "i", "grep -n \"def __getitem__\" pandas/core/arrays/sparse/array.py\r"]
[85.004, "o", "grep -n \"def __getitem__\" pandas/core/arrays/sparse/array.py\r\n"]
[86.242, "o", "\u001b[?2004l\r\n"]
[87.478, "o", "\u001b[32m\u001b[K895\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __getitem__\u001b[m\u001b[K(self, key: ScalarIndexer) -> Any:\r\n"]
[88.714, "o", "\u001b[32m\u001b[K899\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kdef __getitem__\u001b[m\u001b[K(\r\n"]
[90.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[90.002, "i", "sed -n '890,950p' pandas/core/arrays/sparse/array.py\r"]
[90.004, "o", "sed -n '890,950p' pandas/core/arrays/sparse/array.py\r\n"]
[90.085742, "o", "\u001b[?2004l\r\n"]
[90.165484, "o", "\r\n"]
[90.245226, "o", "    # --------\r\n"]
[90.324968, "o", "    # Indexing\r\n"]
[90.40471, "o", "    # --------\r\n"]
[90.484452, "o", "    @overload\r\n"]
[90.564194, "o", "    def __getitem__(self, key: ScalarIndexer) -> Any:\r\n"]
[90.643935, "o", "        ...\r\n"]
[90.723677, "o", "\r\n"]
[90.803419, "o", "    @overload\r\n"]
[90.883161, "o", "    def __getitem__(\r\n"]
[90.962903, "o", "        self,\r\n"]
[91.042645, "o", "        key: SequenceIndexer | tuple[int | ellipsis, ...],\r\n"]
[91.122387, "o", "    ) -> Self:\r\n"]
[91.202129, "o", "        ...\r\n"]
[91.281871, "o", "\r\n"]
[91.361613, "o", "    def __getitem__(\r\n"]
[91.441355, "o", "        self,\r\n"]
[91.521097, "o", "        key: PositionalIndexer | tuple[int | ellipsis, ...],\r\n"]
[91.600839, "o", "    ) -> Self | Any:\r\n"]
[91.680581, "o", "        if isinstance(key, tuple):\r\n"]
[91.760323, "o", "            key = unpack_tuple_and_ellipses(key)\r\n"]
[91.840065, "o", "            if key is Ellipsis:\r\n"]
[91.919806, "o", "                raise ValueError(\"Cannot slice with Ellipsis\")\r\n"]
[91.999548, "o", "\r\n"]
[92.07929, "o", "        if is_integer(key):\r\n"]
[92.159032, "o", "            return self._get_val_at(key)\r\n"]
[92.238774, "o", "        elif isinstance(key, tuple):\r\n"]
[92.318516, "o", "            # error: Invalid index type \"Tuple[Union[int, ellipsis], ...]\"\r\n"]
[92.398258, "o", "            # for \"ndarray[Any, Any]\"; expected type\r\n"]
[92.478, "o", "            # \"Union[SupportsIndex, _SupportsArray[dtype[Union[bool_,\r\n"]
[92.557742, "o", "            # integer[Any]]]], _NestedSequence[_SupportsArray[dtype[\r\n"]
[92.637484, "o", "            # Union[bool_, integer[Any]]]]], _NestedSequence[Union[\r\n"]
[92.717226, "o", "            # bool, int]], Tuple[Union[SupportsIndex, _SupportsArray[\r\n"]
[92.796968, "o", "            # dtype[Union[bool_, integer[Any]]]], _NestedSequence[\r\n"]
[92.87671, "o", "            # _SupportsArray[dtype[Union[bool_, integer[Any]]]]],\r\n"]
[92.956452, "o", "            # _NestedSequence[Union[bool, int]]], ...]]\"\r\n"]
[93.036194, "o", "            data_slice = self.to_dense()[key]  # type: ignore[index]\r\n"]
[93.115935, "o", "        elif isinstance(key, slice):\r\n"]
[93.195677, "o", "            # Avoid densifying when handling contiguous slices\r\n"]
[93.275419, "o", "            if key.step is None or key.step == 1:\r\n"]
[93.355161, "o", "                start = 0 if key.start is None else key.start\r\n"]
[93.434903, "o", "                if start < 0:\r\n"]
[93.514645, "o", "                    start += len(self)\r\n"]
[93.594387, "o", "\r\n"]
[93.674129, "o", "                end = len(self) if key.stop is None else key.stop\r\n"]
[93.753871, "o", "                if end < 0:\r\n"]
[93.833613, "o", "                    end += len(self)\r\n"]
[93.913355, "o", "\r\n"]
[93.993097, "o", "                indices = self.sp_index.indices\r\n"]
[94.072839, "o", "                keep_inds = np.flatnonzero((indices >= start) & (indices < end))\r\n"]
[94.152581, "o", "                sp_vals = self.sp_values[keep_inds]\r\n"]
[94.232323, "o", "\r\n"]
[94.312065, "o", "                sp_index = indices[keep_inds].copy()\r\n"]
[94.391806, "o", "\r\n"]
[94.471548, "o", "                # If we've sliced to not include the start of the array, all our indices\r\n"]
[94.55129, "o", "                # should be shifted. NB: here we are careful to also not shift by a\r\n"]
[94.631032, "o", "                # negative value for a case like [0, 1][-100:] where the start index\r\n"]
[94.710774, "o", "                # should be treated like 0\r\n"]
[94.790516, "o", "                if start > 0:\r\n"]
[94.870258, "o", "                    sp_index -= start\r\n"]
[95.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[95.002, "i", "sed -n '950,1000p' pandas/core/arrays/sparse/array.py\r"]
[95.004, "o", "sed -n '950,1000p' pandas/core/arrays/sparse/array.py\r\n"]
[95.101077, "o", "\u001b[?2004l\r\n"]
[95.196154, "o", "\r\n"]
[95.291231, "o", "                # Length of our result should match applying this slice to a range\r\n"]
[95.386308, "o", "                # of the length of our original array\r\n"]
[95.481385, "o", "                new_len = len(range(len(self))[key])\r\n"]
[95.576462, "o", "                new_sp_index = make_sparse_index(new_len, sp_index, self.kind)\r\n"]
[95.671538, "o", "                return type(self)._simple_new(sp_vals, new_sp_index, self.dtype)\r\n"]
[95.766615, "o", "            else:\r\n"]
[95.861692, "o", "                indices = np.arange(len(self), dtype=np.int32)[key]\r\n"]
[95.956769, "o", "                return self.take(indices)\r\n"]
[96.051846, "o", "\r\n"]
[96.146923, "o", "        elif not is_list_like(key):\r\n"]
[96.242, "o", "            # e.g. \"foo\" or 2.5\r\n"]
[96.337077, "o", "            # exception message copied from numpy\r\n"]
[96.432154, "o", "            raise IndexError(\r\n"]
[96.527231, "o", "                r\"only integers, slices (`:`), ellipsis (`...`), numpy.newaxis \"\r\n"]
[96.622308, "o", "                r\"(`None`) and integer or boolean arrays are valid indices\"\r\n"]
[96.717385, "o", "            )\r\n"]
[96.812462, "o", "\r\n"]
[96.907538, "o", "        else:\r\n"]
[97.002615, "o", "            if isinstance(key, SparseArray):\r\n"]
[97.097692, "o", "                # NOTE: If we guarantee that SparseDType(bool)\r\n"]
[97.192769, "o", "                # has only fill_value - true, false or nan\r\n"]
[97.287846, "o", "                # (see GH PR 44955)\r\n"]
[97.382923, "o", "                # we can apply mask very fast:\r\n"]
[97.478, "o", "                if is_bool_dtype(key):\r\n"]
[97.573077, "o", "                    if isna(key.fill_value):\r\n"]
[97.668154, "o", "                        return self.take(key.sp_index.indices[key.sp_values])\r\n"]
[97.763231, "o", "                    if not key.fill_value:\r\n"]
[97.858308, "o", "                        return self.take(key.sp_index.indices)\r\n"]
[97.953385, "o", "                    n = len(self)\r\n"]
[98.048462, "o", "                    mask = np.full(n, True, dtype=np.bool_)\r\n"]
[98.143538, "o", "                    mask[key.sp_index.indices] = False\r\n"]
[98.238615, "o", "                    return self.take(np.arange(n)[mask])\r\n"]
[98.333692, "o", "                else:\r\n"]
[98.428769, "o", "                    key = np.asarray(key)\r\n"]
[98.523846, "o", "\r\n"]
[98.618923, "o", "            key = check_array_indexer(self, key)\r\n"]
[98.714, "o", "\r\n"]
[98.809077, "o", "            if com.is_bool_indexer(key):\r\n"]
[98.904154, "o", "                # mypy doesn't know we have an array here\r\n"]
[98.999231, "o", "                key = cast(np.ndarray, key)\r\n"]
[99.094308, "o", "                return self.take(np.arange(len(key), dtype=np.int32)[key])\r\n"]
[99.189385, "o", "            elif hasattr(key, \"__len__\"):\r\n"]
[99.284462, "o", "                return self.take(key)\r\n"]
[99.379538, "o", "            else:\r\n"]
[99.474615, "o", "                raise ValueError(f\"Cannot slice with '{key}'\")\r\n"]
[99.569692, "o", "\r\n"]
[99.664769, "o", "        return type(self)(data_slice, kind=self.kind)\r\n"]
[99.759846, "o", "\r\n"]
[99.854923, "o", "    def _get_val_at(self, loc):\r\n"]
[100.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[100.002, "i", "cat > test_sparse_mask.py << 'EOF'\r"]
[100.004, "o", "cat > test_sparse_mask.py << 'EOF'\r\n"]
[100.07192, "o", "\u001b[?2004l\r\n"]
[100.13784, "o", "\u001b[?2004h> import numpy as np\r\n"]
[100.20376, "o", "\u001b[?2004l\r\n"]
[100.26968, "o", "\u001b[?2004h> import pandas as pd\r\n"]
[100.3356, "o", "\u001b[?2004l\r\n"]
[100.40152, "o", "\u001b[?2004h> from pandas.arrays import SparseArray\r\n"]
[100.46744, "o", "\u001b[?2004l\r\n"]
[100.53336, "o", "\u001b[?2004h> import time\r\n"]
[100.59928, "o", "\u001b[?2004l\r\n"]
[100.6652, "o", "\u001b[?2004h> \r\n"]
[100.73112, "o", "\u001b[?2004l\r\n"]
[100.79704, "o", "\u001b[?2004h> def make_array(size, dense_proportion, fill_value, dtype):\r\n"]
[100.86296, "o", "\u001b[?2004l\r\n"]
[100.92888, "o", "\u001b[?2004h>     dense_size = int(size * dense_proportion)\r\n"]
[100.9948, "o", "\u001b[?2004l\r\n"]
[101.06072, "o", "\u001b[?2004h>     arr = np.full(size, fill_value, dtype)\r\n"]
[101.12664, "o", "\u001b[?2004l\r\n"]
[101.19256, "o", "\u001b[?2004h>     indexer = np.random.choice(np.arange(size), dense_size, replace=False)\r\n"]
[101.25848, "o", "\u001b[?2004l\r\n"]
[101.3244, "o", "\u001b[?2004h>     arr[indexer] = np.random.choice(np.arange(100, dtype=dtype), dense_size)\r\n"]
[101.39032, "o", "\u001b[?2004l\r\n"]
[101.45624, "o", "\u001b[?2004h>     return arr\r\n"]
[101.52216, "o", "\u001b[?2004l\r\n"]
[101.58808, "o", "\u001b[?2004h> \r\n"]
[101.654, "o", "\u001b[?2004l\r\n"]
[101.71992, "o", "\u001b[?2004h> # Create test data similar to benchmark\r\n"]
[101.78584, "o", "\u001b[?2004l\r\n"]
[101.85176, "o", "\u001b[?2004h> N = 100_000  # Smaller for testing\r\n"]
[101.91768, "o", "\u001b[?2004l\r\n"]
[101.9836, "o", "\u001b[?2004h> d = 1e-5\r\n"]
[102.04952, "o", "\u001b[?2004l\r\n"]
[102.11544, "o", "\u001b[?2004h> arr = make_array(N, d, np.nan, np.float64)\r\n"]
[102.18136, "o", "\u001b[?2004l\r\n"]
[102.24728, "o", "\u001b[?2004h> sp_arr = SparseArray(arr)\r\n"]
[102.3132, "o", "\u001b[?2004l\r\n"]
[102.37912, "o", "\u001b[?2004h> \r\n"]
[102.44504, "o", "\u001b[?2004l\r\n"]
[102.51096, "o", "\u001b[?2004h> # Test different fill_value cases\r\n"]
[102.57688, "o", "\u001b[?2004l\r\n"]
[102.6428, "o", "\u001b[?2004h> for fill_value in [True, False, np.nan]:\r\n"]
[102.70872, "o", "\u001b[?2004l\r\n"]
[102.77464, "o", "\u001b[?2004h>     print(f\"\\nTesting fill_value = {fill_value}\")\r\n"]
[102.84056, "o", "\u001b[?2004l\r\n"]
[102.90648, "o", "\u001b[?2004h>     b_arr = np.full(shape=N, fill_value=fill_value, dtype=np.bool_)\r\n"]
[102.9724, "o", "\u001b[?2004l\r\n"]
[103.03832, "o", "\u001b[?2004h>     fv_inds = np.unique(\r\n"]
[103.10424, "o", "\u001b[?2004l\r\n"]
[103.17016, "o", "\u001b[?2004h>         np.random.randint(low=0, high=N - 1, size=int(N * d), dtype=np.int32)\r\n"]
[103.23608, "o", "\u001b[?2004l\r\n"]
[103.302, "o", "\u001b[?2004h>     )\r\n"]
[103.36792, "o", "\u001b[?2004l\r\n"]
[103.43384, "o", "\u001b[?2004h>     b_arr[fv_inds] = True if pd.isna(fill_value) else not fill_value\r\n"]
[103.49976, "o", "\u001b[?2004l\r\n"]
[103.56568, "o", "\u001b[?2004h>     sp_b_arr = SparseArray(b_arr, dtype=np.bool_, fill_value=fill_value)\r\n"]
[103.6316, "o", "\u001b[?2004l\r\n"]
[103.69752, "o", "\u001b[?2004h>     \r\n"]
[103.76344, "o", "\u001b[?2004l\r\n"]
[103.82936, "o", "\u001b[?2004h>     # Time the operation\r\n"]
[103.89528, "o", "\u001b[?2004l\r\n"]
[103.9612, "o", "\u001b[?2004h>     start = time.time()\r\n"]
[104.02712, "o", "\u001b[?2004l\r\n"]
[104.09304, "o", "\u001b[?2004h>     result = sp_arr[sp_b_arr]\r\n"]
[104.15896, "o", "\u001b[?2004l\r\n"]
[104.22488, "o", "\u001b[?2004h>     end = time.time()\r\n"]
[104.2908, "o", "\u001b[?2004l\r\n"]
[104.35672, "o", "\u001b[?2004h>     \r\n"]
[104.42264, "o", "\u001b[?2004l\r\n"]
[104.48856, "o", "\u001b[?2004h>     print(f\"Time: {(end-start)*1000:.2f}ms\")\r\n"]
[104.55448, "o", "\u001b[?2004l\r\n"]
[104.6204, "o", "\u001b[?2004h>     print(f\"Result length: {len(result)}\")\r\n"]
[104.68632, "o", "\u001b[?2004l\r\n"]
[104.75224, "o", "\u001b[?2004h>     print(f\"Sparse mask density: {len(sp_b_arr.sp_values)}/{len(sp_b_arr)} = {len(sp_b_arr.sp_values)/len(sp_b_arr):.6f}\")\r\n"]
[104.81816, "o", "\u001b[?2004l\r\n"]
[104.88408, "o", "\u001b[?2004h> EOF\r\n"]
[105.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[105.002, "i", "python test_sparse_mask.py\r"]
[105.004, "o", "python test_sparse_mask.py\r\n"]
[105.315, "o", "\u001b[?2004l\r\n"]
[105.624, "o", "\r\n"]
[105.933, "o", "Testing fill_value = True\r\n"]
[106.242, "o", "Time: 0.54ms\r\n"]
[106.551, "o", "Result length: 99999\r\n"]
[106.86, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[107.169, "o", "\r\n"]
[107.478, "o", "Testing fill_value = False\r\n"]
[107.787, "o", "Time: 0.07ms\r\n"]
[108.096, "o", "Result length: 1\r\n"]
[108.405, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[108.714, "o", "\r\n"]
[109.023, "o", "Testing fill_value = nan\r\n"]
[109.332, "o", "Time: 0.27ms\r\n"]
[109.641, "o", "Result length: 100000\r\n"]
[110.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[110.002, "i", "cp pandas/core/arrays/sparse/array.py pandas/core/arrays/sparse/array.py.backup\r"]
[110.004, "o", "cp pandas/core/arrays/sparse/array.py pandas/core/arrays/sparse/array.py.backup\r\n"]
[110.006, "o", "\u001b[?2004l\r\n"]
[115.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[115.002, "i", "cat > optimize_sparse.py << 'EOF'\r"]
[115.004, "o", "cat > optimize_sparse.py << 'EOF'\r\n"]
[115.052206, "o", "\u001b[?2004l\r\n"]
[115.098411, "o", "\u001b[?2004h> # Script to optimize the sparse array getitem method\r\n"]
[115.144617, "o", "\u001b[?2004l\r\n"]
[115.190822, "o", "\u001b[?2004h> import re\r\n"]
[115.237028, "o", "\u001b[?2004l\r\n"]
[115.283234, "o", "\u001b[?2004h> \r\n"]
[115.329439, "o", "\u001b[?2004l\r\n"]
[115.375645, "o", "\u001b[?2004h> # Read the original file\r\n"]
[115.42185, "o", "\u001b[?2004l\r\n"]
[115.468056, "o", "\u001b[?2004h> with open('pandas/core/arrays/sparse/array.py', 'r') as f:\r\n"]
[115.514262, "o", "\u001b[?2004l\r\n"]
[115.560467, "o", "\u001b[?2004h>     content = f.read()\r\n"]
[115.606673, "o", "\u001b[?2004l\r\n"]
[115.652879, "o", "\u001b[?2004h> \r\n"]
[115.699084, "o", "\u001b[?2004l\r\n"]
[115.74529, "o", "\u001b[?2004h> # Find and replace the inefficient fill_value=True case\r\n"]
[115.791495, "o", "\u001b[?2004l\r\n"]
[115.837701, "o", "\u001b[?2004h> old_pattern = r'''                if is_bool_dtype\\(key\\):\r\n"]
[115.883907, "o", "\u001b[?2004l\r\n"]
[115.930112, "o", "\u001b[?2004h>                     if isna\\(key\\.fill_value\\):\r\n"]
[115.976318, "o", "\u001b[?2004l\r\n"]
[116.022523, "o", "\u001b[?2004h>                         return self\\.take\\(key\\.sp_index\\.indices\\[key\\.sp_values\\]\\)\r\n"]
[116.068729, "o", "\u001b[?2004l\r\n"]
[116.114935, "o", "\u001b[?2004h>                     if not key\\.fill_value:\r\n"]
[116.16114, "o", "\u001b[?2004l\r\n"]
[116.207346, "o", "\u001b[?2004h>                         return self\\.take\\(key\\.sp_index\\.indices\\)\r\n"]
[116.253551, "o", "\u001b[?2004l\r\n"]
[116.299757, "o", "\u001b[?2004h>                     n = len\\(self\\)\r\n"]
[116.345963, "o", "\u001b[?2004l\r\n"]
[116.392168, "o", "\u001b[?2004h>                     mask = np\\.full\\(n, True, dtype=np\\.bool_\\)\r\n"]
[116.438374, "o", "\u001b[?2004l\r\n"]
[116.484579, "o", "\u001b[?2004h>                     mask\\[key\\.sp_index\\.indices\\] = False\r\n"]
[116.530785, "o", "\u001b[?2004l\r\n"]
[116.576991, "o", "\u001b[?2004h>                     return self\\.take\\(np\\.arange\\(n\\)\\[mask\\]\\)'''\r\n"]
[116.623196, "o", "\u001b[?2004l\r\n"]
[116.669402, "o", "\u001b[?2004h> \r\n"]
[116.715607, "o", "\u001b[?2004l\r\n"]
[116.761813, "o", "\u001b[?2004h> new_pattern = '''                if is_bool_dtype(key):\r\n"]
[116.808019, "o", "\u001b[?2004l\r\n"]
[116.854224, "o", "\u001b[?2004h>                     if isna(key.fill_value):\r\n"]
[116.90043, "o", "\u001b[?2004l\r\n"]
[116.946636, "o", "\u001b[?2004h>                         return self.take(key.sp_index.indices[key.sp_values])\r\n"]
[116.992841, "o", "\u001b[?2004l\r\n"]
[117.039047, "o", "\u001b[?2004h>                     if not key.fill_value:\r\n"]
[117.085252, "o", "\u001b[?2004l\r\n"]
[117.131458, "o", "\u001b[?2004h>                         return self.take(key.sp_index.indices)\r\n"]
[117.177664, "o", "\u001b[?2004l\r\n"]
[117.223869, "o", "\u001b[?2004h>                     # Optimized case for fill_value=True: compute complement directly\r\n"]
[117.270075, "o", "\u001b[?2004l\r\n"]
[117.31628, "o", "\u001b[?2004h>                     n = len(self)\r\n"]
[117.362486, "o", "\u001b[?2004l\r\n"]
[117.408692, "o", "\u001b[?2004h>                     sparse_indices = key.sp_index.indices\r\n"]
[117.454897, "o", "\u001b[?2004l\r\n"]
[117.501103, "o", "\u001b[?2004h>                     if len(sparse_indices) == 0:\r\n"]
[117.547308, "o", "\u001b[?2004l\r\n"]
[117.593514, "o", "\u001b[?2004h>                         # All True, return everything\r\n"]
[117.63972, "o", "\u001b[?2004l\r\n"]
[117.685925, "o", "\u001b[?2004h>                         return self.take(np.arange(n, dtype=np.int32))\r\n"]
[117.732131, "o", "\u001b[?2004l\r\n"]
[117.778336, "o", "\u001b[?2004h>                     elif len(sparse_indices) == n:\r\n"]
[117.824542, "o", "\u001b[?2004l\r\n"]
[117.870748, "o", "\u001b[?2004h>                         # All False, return empty\r\n"]
[117.916953, "o", "\u001b[?2004l\r\n"]
[117.963159, "o", "\u001b[?2004h>                         return self.take(np.array([], dtype=np.int32))\r\n"]
[118.009364, "o", "\u001b[?2004l\r\n"]
[118.05557, "o", "\u001b[?2004h>                     else:\r\n"]
[118.101776, "o", "\u001b[?2004l\r\n"]
[118.147981, "o", "\u001b[?2004h>                         # Compute complement indices efficiently\r\n"]
[118.194187, "o", "\u001b[?2004l\r\n"]
[118.240393, "o", "\u001b[?2004h>                         all_indices = np.arange(n, dtype=np.int32)\r\n"]
[118.286598, "o", "\u001b[?2004l\r\n"]
[118.332804, "o", "\u001b[?2004h>                         complement_mask = np.ones(n, dtype=np.bool_)\r\n"]
[118.379009, "o", "\u001b[?2004l\r\n"]
[118.425215, "o", "\u001b[?2004h>                         complement_mask[sparse_indices] = False\r\n"]
[118.471421, "o", "\u001b[?2004l\r\n"]
[118.517626, "o", "\u001b[?2004h>                         return self.take(all_indices[complement_mask])'''\r\n"]
[118.563832, "o", "\u001b[?2004l\r\n"]
[118.610037, "o", "\u001b[?2004h> \r\n"]
[118.656243, "o", "\u001b[?2004l\r\n"]
[118.702449, "o", "\u001b[?2004h> # Apply the replacement\r\n"]
[118.748654, "o", "\u001b[?2004l\r\n"]
[118.79486, "o", "\u001b[?2004h> new_content = re.sub(old_pattern, new_pattern, content, flags=re.MULTILINE)\r\n"]
[118.841065, "o", "\u001b[?2004l\r\n"]
[118.887271, "o", "\u001b[?2004h> \r\n"]
[118.933477, "o", "\u001b[?2004l\r\n"]
[118.979682, "o", "\u001b[?2004h> if new_content != content:\r\n"]
[119.025888, "o", "\u001b[?2004l\r\n"]
[119.072093, "o", "\u001b[?2004h>     with open('pandas/core/arrays/sparse/array.py', 'w') as f:\r\n"]
[119.118299, "o", "\u001b[?2004l\r\n"]
[119.164505, "o", "\u001b[?2004h>         f.write(new_content)\r\n"]
[119.21071, "o", "\u001b[?2004l\r\n"]
[119.256916, "o", "\u001b[?2004h>     print(\"Successfully optimized the sparse array getitem method\")\r\n"]
[119.303121, "o", "\u001b[?2004l\r\n"]
[119.349327, "o", "\u001b[?2004h> else:\r\n"]
[119.395533, "o", "\u001b[?2004l\r\n"]
[119.441738, "o", "\u001b[?2004h>     print(\"Pattern not found - let me check the exact format\")\r\n"]
[119.487944, "o", "\u001b[?2004l\r\n"]
[119.53415, "o", "\u001b[?2004h>     # Let's find the exact lines to replace\r\n"]
[119.580355, "o", "\u001b[?2004l\r\n"]
[119.626561, "o", "\u001b[?2004h>     lines = content.split('\\n')\r\n"]
[119.672766, "o", "\u001b[?2004l\r\n"]
[119.718972, "o", "\u001b[?2004h>     for i, line in enumerate(lines[960:985], 960):\r\n"]
[119.765178, "o", "\u001b[?2004l\r\n"]
[119.811383, "o", "\u001b[?2004h>         print(f\"{i}: {line}\")\r\n"]
[119.857589, "o", "\u001b[?2004l\r\n"]
[119.903794, "o", "\u001b[?2004h> EOF\r\n"]
[120.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[120.002, "i", "python optimize_sparse.py\r"]
[120.004, "o", "python optimize_sparse.py\r\n"]
[122.478, "o", "\u001b[?2004l\r\n"]
[125.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[125.002, "i", "python test_sparse_mask.py\r"]
[125.004, "o", "python test_sparse_mask.py\r\n"]
[125.315, "o", "\u001b[?2004l\r\n"]
[125.624, "o", "\r\n"]
[125.933, "o", "Testing fill_value = True\r\n"]
[126.242, "o", "Time: 0.46ms\r\n"]
[126.551, "o", "Result length: 99999\r\n"]
[126.86, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[127.169, "o", "\r\n"]
[127.478, "o", "Testing fill_value = False\r\n"]
[127.787, "o", "Time: 0.07ms\r\n"]
[128.096, "o", "Result length: 1\r\n"]
[128.405, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[128.714, "o", "\r\n"]
[129.023, "o", "Testing fill_value = nan\r\n"]
[129.332, "o", "Time: 0.31ms\r\n"]
[129.641, "o", "Result length: 100000\r\n"]
[130.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[130.002, "i", "cat > optimize_sparse_v2.py << 'EOF'\r"]
[130.004, "o", "cat > optimize_sparse_v2.py << 'EOF'\r\n"]
[130.044929, "o", "\u001b[?2004l\r\n"]
[130.083858, "o", "\u001b[?2004h> # Script to optimize the sparse array getitem method - version 2\r\n"]
[130.122787, "o", "\u001b[?2004l\r\n"]
[130.161717, "o", "\u001b[?2004h> import re\r\n"]
[130.200646, "o", "\u001b[?2004l\r\n"]
[130.239575, "o", "\u001b[?2004h> \r\n"]
[130.278504, "o", "\u001b[?2004l\r\n"]
[130.317433, "o", "\u001b[?2004h> # Read the current file\r\n"]
[130.356362, "o", "\u001b[?2004l\r\n"]
[130.395291, "o", "\u001b[?2004h> with open('pandas/core/arrays/sparse/array.py', 'r') as f:\r\n"]
[130.43422, "o", "\u001b[?2004l\r\n"]
[130.47315, "o", "\u001b[?2004h>     content = f.read()\r\n"]
[130.512079, "o", "\u001b[?2004l\r\n"]
[130.551008, "o", "\u001b[?2004h> \r\n"]
[130.589937, "o", "\u001b[?2004l\r\n"]
[130.628866, "o", "\u001b[?2004h> # Find the current optimized section and replace with better version\r\n"]
[130.667795, "o", "\u001b[?2004l\r\n"]
[130.706724, "o", "\u001b[?2004h> old_pattern = r'''                if is_bool_dtype\\(key\\):\r\n"]
[130.745654, "o", "\u001b[?2004l\r\n"]
[130.784583, "o", "\u001b[?2004h>                     if isna\\(key\\.fill_value\\):\r\n"]
[130.823512, "o", "\u001b[?2004l\r\n"]
[130.862441, "o", "\u001b[?2004h>                         return self\\.take\\(key\\.sp_index\\.indices\\[key\\.sp_values\\]\\)\r\n"]
[130.90137, "o", "\u001b[?2004l\r\n"]
[130.940299, "o", "\u001b[?2004h>                     if not key\\.fill_value:\r\n"]
[130.979228, "o", "\u001b[?2004l\r\n"]
[131.018157, "o", "\u001b[?2004h>                         return self\\.take\\(key\\.sp_index\\.indices\\)\r\n"]
[131.057087, "o", "\u001b[?2004l\r\n"]
[131.096016, "o", "\u001b[?2004h>                     # Optimized case for fill_value=True: compute complement directly\r\n"]
[131.134945, "o", "\u001b[?2004l\r\n"]
[131.173874, "o", "\u001b[?2004h>                     n = len\\(self\\)\r\n"]
[131.212803, "o", "\u001b[?2004l\r\n"]
[131.251732, "o", "\u001b[?2004h>                     sparse_indices = key\\.sp_index\\.indices\r\n"]
[131.290661, "o", "\u001b[?2004l\r\n"]
[131.329591, "o", "\u001b[?2004h>                     if len\\(sparse_indices\\) == 0:\r\n"]
[131.36852, "o", "\u001b[?2004l\r\n"]
[131.407449, "o", "\u001b[?2004h>                         # All True, return everything\r\n"]
[131.446378, "o", "\u001b[?2004l\r\n"]
[131.485307, "o", "\u001b[?2004h>                         return self\\.take\\(np\\.arange\\(n, dtype=np\\.int32\\)\\)\r\n"]
[131.524236, "o", "\u001b[?2004l\r\n"]
[131.563165, "o", "\u001b[?2004h>                     elif len\\(sparse_indices\\) == n:\r\n"]
[131.602094, "o", "\u001b[?2004l\r\n"]
[131.641024, "o", "\u001b[?2004h>                         # All False, return empty\r\n"]
[131.679953, "o", "\u001b[?2004l\r\n"]
[131.718882, "o", "\u001b[?2004h>                         return self\\.take\\(np\\.array\\(\\[\\], dtype=np\\.int32\\)\\)\r\n"]
[131.757811, "o", "\u001b[?2004l\r\n"]
[131.79674, "o", "\u001b[?2004h>                     else:\r\n"]
[131.835669, "o", "\u001b[?2004l\r\n"]
[131.874598, "o", "\u001b[?2004h>                         # Compute complement indices efficiently\r\n"]
[131.913528, "o", "\u001b[?2004l\r\n"]
[131.952457, "o", "\u001b[?2004h>                         all_indices = np\\.arange\\(n, dtype=np\\.int32\\)\r\n"]
[131.991386, "o", "\u001b[?2004l\r\n"]
[132.030315, "o", "\u001b[?2004h>                         complement_mask = np\\.ones\\(n, dtype=np\\.bool_\\)\r\n"]
[132.069244, "o", "\u001b[?2004l\r\n"]
[132.108173, "o", "\u001b[?2004h>                         complement_mask\\[sparse_indices\\] = False\r\n"]
[132.147102, "o", "\u001b[?2004l\r\n"]
[132.186031, "o", "\u001b[?2004h>                         return self\\.take\\(all_indices\\[complement_mask\\]\\)'''\r\n"]
[132.224961, "o", "\u001b[?2004l\r\n"]
[132.26389, "o", "\u001b[?2004h> \r\n"]
[132.302819, "o", "\u001b[?2004l\r\n"]
[132.341748, "o", "\u001b[?2004h> new_pattern = '''                if is_bool_dtype(key):\r\n"]
[132.380677, "o", "\u001b[?2004l\r\n"]
[132.419606, "o", "\u001b[?2004h>                     if isna(key.fill_value):\r\n"]
[132.458535, "o", "\u001b[?2004l\r\n"]
[132.497465, "o", "\u001b[?2004h>                         return self.take(key.sp_index.indices[key.sp_values])\r\n"]
[132.536394, "o", "\u001b[?2004l\r\n"]
[132.575323, "o", "\u001b[?2004h>                     if not key.fill_value:\r\n"]
[132.614252, "o", "\u001b[?2004l\r\n"]
[132.653181, "o", "\u001b[?2004h>                         return self.take(key.sp_index.indices)\r\n"]
[132.69211, "o", "\u001b[?2004l\r\n"]
[132.731039, "o", "\u001b[?2004h>                     # Highly optimized case for fill_value=True: avoid dense arrays\r\n"]
[132.769969, "o", "\u001b[?2004l\r\n"]
[132.808898, "o", "\u001b[?2004h>                     n = len(self)\r\n"]
[132.847827, "o", "\u001b[?2004l\r\n"]
[132.886756, "o", "\u001b[?2004h>                     sparse_indices = key.sp_index.indices\r\n"]
[132.925685, "o", "\u001b[?2004l\r\n"]
[132.964614, "o", "\u001b[?2004h>                     if len(sparse_indices) == 0:\r\n"]
[133.003543, "o", "\u001b[?2004l\r\n"]
[133.042472, "o", "\u001b[?2004h>                         # All True, return everything\r\n"]
[133.081402, "o", "\u001b[?2004l\r\n"]
[133.120331, "o", "\u001b[?2004h>                         return self.take(np.arange(n, dtype=np.int32))\r\n"]
[133.15926, "o", "\u001b[?2004l\r\n"]
[133.198189, "o", "\u001b[?2004h>                     elif len(sparse_indices) >= n:\r\n"]
[133.237118, "o", "\u001b[?2004l\r\n"]
[133.276047, "o", "\u001b[?2004h>                         # All or mostly False, return empty or very few\r\n"]
[133.314976, "o", "\u001b[?2004l\r\n"]
[133.353906, "o", "\u001b[?2004h>                         return self.take(np.array([], dtype=np.int32))\r\n"]
[133.392835, "o", "\u001b[?2004l\r\n"]
[133.431764, "o", "\u001b[?2004h>                     else:\r\n"]
[133.470693, "o", "\u001b[?2004l\r\n"]
[133.509622, "o", "\u001b[?2004h>                         # Use setdiff1d to compute complement without dense arrays\r\n"]
[133.548551, "o", "\u001b[?2004l\r\n"]
[133.58748, "o", "\u001b[?2004h>                         all_indices = np.arange(n, dtype=np.int32)\r\n"]
[133.626409, "o", "\u001b[?2004l\r\n"]
[133.665339, "o", "\u001b[?2004h>                         complement_indices = np.setdiff1d(all_indices, sparse_indices, assume_unique=True)\r\n"]
[133.704268, "o", "\u001b[?2004l\r\n"]
[133.743197, "o", "\u001b[?2004h>                         return self.take(complement_indices)'''\r\n"]
[133.782126, "o", "\u001b[?2004l\r\n"]
[133.821055, "o", "\u001b[?2004h> \r\n"]
[133.859984, "o", "\u001b[?2004l\r\n"]
[133.898913, "o", "\u001b[?2004h> # Apply the replacement\r\n"]
[133.937843, "o", "\u001b[?2004l\r\n"]
[133.976772, "o", "\u001b[?2004h> new_content = re.sub(old_pattern, new_pattern, content, flags=re.MULTILINE)\r\n"]
[134.015701, "o", "\u001b[?2004l\r\n"]
[134.05463, "o", "\u001b[?2004h> \r\n"]
[134.093559, "o", "\u001b[?2004l\r\n"]
[134.132488, "o", "\u001b[?2004h> if new_content != content:\r\n"]
[134.171417, "o", "\u001b[?2004l\r\n"]
[134.210346, "o", "\u001b[?2004h>     with open('pandas/core/arrays/sparse/array.py', 'w') as f:\r\n"]
[134.249276, "o", "\u001b[?2004l\r\n"]
[134.288205, "o", "\u001b[?2004h>         f.write(new_content)\r\n"]
[134.327134, "o", "\u001b[?2004l\r\n"]
[134.366063, "o", "\u001b[?2004h>     print(\"Successfully applied v2 optimization\")\r\n"]
[134.404992, "o", "\u001b[?2004l\r\n"]
[134.443921, "o", "\u001b[?2004h> else:\r\n"]
[134.48285, "o", "\u001b[?2004l\r\n"]
[134.52178, "o", "\u001b[?2004h>     print(\"Pattern not found - checking current content\")\r\n"]
[134.560709, "o", "\u001b[?2004l\r\n"]
[134.599638, "o", "\u001b[?2004h>     lines = content.split('\\n')\r\n"]
[134.638567, "o", "\u001b[?2004l\r\n"]
[134.677496, "o", "\u001b[?2004h>     for i, line in enumerate(lines[970:990], 970):\r\n"]
[134.716425, "o", "\u001b[?2004l\r\n"]
[134.755354, "o", "\u001b[?2004h>         if 'is_bool_dtype' in line or 'fill_value' in line or 'complement' in line:\r\n"]
[134.794283, "o", "\u001b[?2004l\r\n"]
[134.833213, "o", "\u001b[?2004h>             print(f\"{i}: {line}\")\r\n"]
[134.872142, "o", "\u001b[?2004l\r\n"]
[134.911071, "o", "\u001b[?2004h> EOF\r\n"]
[135.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[135.002, "i", "python optimize_sparse_v2.py\r"]
[135.004, "o", "python optimize_sparse_v2.py\r\n"]
[137.478, "o", "\u001b[?2004l\r\n"]
[140.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[140.002, "i", "python test_sparse_mask.py\r"]
[140.004, "o", "python test_sparse_mask.py\r\n"]
[140.315, "o", "\u001b[?2004l\r\n"]
[140.624, "o", "\r\n"]
[140.933, "o", "Testing fill_value = True\r\n"]
[141.242, "o", "Time: 0.62ms\r\n"]
[141.551, "o", "Result length: 99999\r\n"]
[141.86, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[142.169, "o", "\r\n"]
[142.478, "o", "Testing fill_value = False\r\n"]
[142.787, "o", "Time: 0.07ms\r\n"]
[143.096, "o", "Result length: 1\r\n"]
[143.405, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[143.714, "o", "\r\n"]
[144.023, "o", "Testing fill_value = nan\r\n"]
[144.332, "o", "Time: 0.27ms\r\n"]
[144.641, "o", "Result length: 100000\r\n"]
[145.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[145.002, "i", "cat > optimize_sparse_v3.py << 'EOF'\r"]
[145.004, "o", "cat > optimize_sparse_v3.py << 'EOF'\r\n"]
[145.04374, "o", "\u001b[?2004l\r\n"]
[145.081481, "o", "\u001b[?2004h> # Script to optimize sparse array getitem - version 3 (adaptive approach)\r\n"]
[145.119221, "o", "\u001b[?2004l\r\n"]
[145.156962, "o", "\u001b[?2004h> import re\r\n"]
[145.194702, "o", "\u001b[?2004l\r\n"]
[145.232443, "o", "\u001b[?2004h> \r\n"]
[145.270183, "o", "\u001b[?2004l\r\n"]
[145.307924, "o", "\u001b[?2004h> # Read the current file\r\n"]
[145.345664, "o", "\u001b[?2004l\r\n"]
[145.383405, "o", "\u001b[?2004h> with open('pandas/core/arrays/sparse/array.py', 'r') as f:\r\n"]
[145.421145, "o", "\u001b[?2004l\r\n"]
[145.458885, "o", "\u001b[?2004h>     content = f.read()\r\n"]
[145.496626, "o", "\u001b[?2004l\r\n"]
[145.534366, "o", "\u001b[?2004h> \r\n"]
[145.572107, "o", "\u001b[?2004l\r\n"]
[145.609847, "o", "\u001b[?2004h> # Replace with adaptive optimization\r\n"]
[145.647588, "o", "\u001b[?2004l\r\n"]
[145.685328, "o", "\u001b[?2004h> old_pattern = r'''                if is_bool_dtype\\(key\\):\r\n"]
[145.723069, "o", "\u001b[?2004l\r\n"]
[145.760809, "o", "\u001b[?2004h>                     if isna\\(key\\.fill_value\\):\r\n"]
[145.79855, "o", "\u001b[?2004l\r\n"]
[145.83629, "o", "\u001b[?2004h>                         return self\\.take\\(key\\.sp_index\\.indices\\[key\\.sp_values\\]\\)\r\n"]
[145.874031, "o", "\u001b[?2004l\r\n"]
[145.911771, "o", "\u001b[?2004h>                     if not key\\.fill_value:\r\n"]
[145.949511, "o", "\u001b[?2004l\r\n"]
[145.987252, "o", "\u001b[?2004h>                         return self\\.take\\(key\\.sp_index\\.indices\\)\r\n"]
[146.024992, "o", "\u001b[?2004l\r\n"]
[146.062733, "o", "\u001b[?2004h>                     # Highly optimized case for fill_value=True: avoid dense arrays\r\n"]
[146.100473, "o", "\u001b[?2004l\r\n"]
[146.138214, "o", "\u001b[?2004h>                     n = len\\(self\\)\r\n"]
[146.175954, "o", "\u001b[?2004l\r\n"]
[146.213695, "o", "\u001b[?2004h>                     sparse_indices = key\\.sp_index\\.indices\r\n"]
[146.251435, "o", "\u001b[?2004l\r\n"]
[146.289176, "o", "\u001b[?2004h>                     if len\\(sparse_indices\\) == 0:\r\n"]
[146.326916, "o", "\u001b[?2004l\r\n"]
[146.364656, "o", "\u001b[?2004h>                         # All True, return everything\r\n"]
[146.402397, "o", "\u001b[?2004l\r\n"]
[146.440137, "o", "\u001b[?2004h>                         return self\\.take\\(np\\.arange\\(n, dtype=np\\.int32\\)\\)\r\n"]
[146.477878, "o", "\u001b[?2004l\r\n"]
[146.515618, "o", "\u001b[?2004h>                     elif len\\(sparse_indices\\) >= n:\r\n"]
[146.553359, "o", "\u001b[?2004l\r\n"]
[146.591099, "o", "\u001b[?2004h>                         # All or mostly False, return empty or very few\r\n"]
[146.62884, "o", "\u001b[?2004l\r\n"]
[146.66658, "o", "\u001b[?2004h>                         return self\\.take\\(np\\.array\\(\\[\\], dtype=np\\.int32\\)\\)\r\n"]
[146.704321, "o", "\u001b[?2004l\r\n"]
[146.742061, "o", "\u001b[?2004h>                     else:\r\n"]
[146.779802, "o", "\u001b[?2004l\r\n"]
[146.817542, "o", "\u001b[?2004h>                         # Use setdiff1d to compute complement without dense arrays\r\n"]
[146.855282, "o", "\u001b[?2004l\r\n"]
[146.893023, "o", "\u001b[?2004h>                         all_indices = np\\.arange\\(n, dtype=np\\.int32\\)\r\n"]
[146.930763, "o", "\u001b[?2004l\r\n"]
[146.968504, "o", "\u001b[?2004h>                         complement_indices = np\\.setdiff1d\\(all_indices, sparse_indices, assume_unique=True\\)\r\n"]
[147.006244, "o", "\u001b[?2004l\r\n"]
[147.043985, "o", "\u001b[?2004h>                         return self\\.take\\(complement_indices\\)'''\r\n"]
[147.081725, "o", "\u001b[?2004l\r\n"]
[147.119466, "o", "\u001b[?2004h> \r\n"]
[147.157206, "o", "\u001b[?2004l\r\n"]
[147.194947, "o", "\u001b[?2004h> new_pattern = '''                if is_bool_dtype(key):\r\n"]
[147.232687, "o", "\u001b[?2004l\r\n"]
[147.270427, "o", "\u001b[?2004h>                     if isna(key.fill_value):\r\n"]
[147.308168, "o", "\u001b[?2004l\r\n"]
[147.345908, "o", "\u001b[?2004h>                         return self.take(key.sp_index.indices[key.sp_values])\r\n"]
[147.383649, "o", "\u001b[?2004l\r\n"]
[147.421389, "o", "\u001b[?2004h>                     if not key.fill_value:\r\n"]
[147.45913, "o", "\u001b[?2004l\r\n"]
[147.49687, "o", "\u001b[?2004h>                         return self.take(key.sp_index.indices)\r\n"]
[147.534611, "o", "\u001b[?2004l\r\n"]
[147.572351, "o", "\u001b[?2004h>                     # Adaptive optimization for fill_value=True\r\n"]
[147.610092, "o", "\u001b[?2004l\r\n"]
[147.647832, "o", "\u001b[?2004h>                     n = len(self)\r\n"]
[147.685573, "o", "\u001b[?2004l\r\n"]
[147.723313, "o", "\u001b[?2004h>                     sparse_indices = key.sp_index.indices\r\n"]
[147.761053, "o", "\u001b[?2004l\r\n"]
[147.798794, "o", "\u001b[?2004h>                     num_false = len(sparse_indices)\r\n"]
[147.836534, "o", "\u001b[?2004l\r\n"]
[147.874275, "o", "\u001b[?2004h>                     \r\n"]
[147.912015, "o", "\u001b[?2004l\r\n"]
[147.949756, "o", "\u001b[?2004h>                     if num_false == 0:\r\n"]
[147.987496, "o", "\u001b[?2004l\r\n"]
[148.025237, "o", "\u001b[?2004h>                         # All True, return everything\r\n"]
[148.062977, "o", "\u001b[?2004l\r\n"]
[148.100718, "o", "\u001b[?2004h>                         return self.take(np.arange(n, dtype=np.int32))\r\n"]
[148.138458, "o", "\u001b[?2004l\r\n"]
[148.176198, "o", "\u001b[?2004h>                     elif num_false >= n:\r\n"]
[148.213939, "o", "\u001b[?2004l\r\n"]
[148.251679, "o", "\u001b[?2004h>                         # All False, return empty\r\n"]
[148.28942, "o", "\u001b[?2004l\r\n"]
[148.32716, "o", "\u001b[?2004h>                         return self.take(np.array([], dtype=np.int32))\r\n"]
[148.364901, "o", "\u001b[?2004l\r\n"]
[148.402641, "o", "\u001b[?2004h>                     elif num_false < n // 2:\r\n"]
[148.440382, "o", "\u001b[?2004l\r\n"]
[148.478122, "o", "\u001b[?2004h>                         # Very sparse (few False values): use setdiff1d\r\n"]
[148.515863, "o", "\u001b[?2004l\r\n"]
[148.553603, "o", "\u001b[?2004h>                         all_indices = np.arange(n, dtype=np.int32)\r\n"]
[148.591344, "o", "\u001b[?2004l\r\n"]
[148.629084, "o", "\u001b[?2004h>                         complement_indices = np.setdiff1d(all_indices, sparse_indices, assume_unique=True)\r\n"]
[148.666824, "o", "\u001b[?2004l\r\n"]
[148.704565, "o", "\u001b[?2004h>                         return self.take(complement_indices)\r\n"]
[148.742305, "o", "\u001b[?2004l\r\n"]
[148.780046, "o", "\u001b[?2004h>                     else:\r\n"]
[148.817786, "o", "\u001b[?2004l\r\n"]
[148.855527, "o", "\u001b[?2004h>                         # Dense case: use boolean indexing (original approach but optimized)\r\n"]
[148.893267, "o", "\u001b[?2004l\r\n"]
[148.931008, "o", "\u001b[?2004h>                         mask = np.ones(n, dtype=np.bool_)\r\n"]
[148.968748, "o", "\u001b[?2004l\r\n"]
[149.006489, "o", "\u001b[?2004h>                         mask[sparse_indices] = False\r\n"]
[149.044229, "o", "\u001b[?2004l\r\n"]
[149.081969, "o", "\u001b[?2004h>                         return self.take(np.arange(n, dtype=np.int32)[mask])'''\r\n"]
[149.11971, "o", "\u001b[?2004l\r\n"]
[149.15745, "o", "\u001b[?2004h> \r\n"]
[149.195191, "o", "\u001b[?2004l\r\n"]
[149.232931, "o", "\u001b[?2004h> # Apply the replacement\r\n"]
[149.270672, "o", "\u001b[?2004l\r\n"]
[149.308412, "o", "\u001b[?2004h> new_content = re.sub(old_pattern, new_pattern, content, flags=re.MULTILINE)\r\n"]
[149.346153, "o", "\u001b[?2004l\r\n"]
[149.383893, "o", "\u001b[?2004h> \r\n"]
[149.421634, "o", "\u001b[?2004l\r\n"]
[149.459374, "o", "\u001b[?2004h> if new_content != content:\r\n"]
[149.497115, "o", "\u001b[?2004l\r\n"]
[149.534855, "o", "\u001b[?2004h>     with open('pandas/core/arrays/sparse/array.py', 'w') as f:\r\n"]
[149.572595, "o", "\u001b[?2004l\r\n"]
[149.610336, "o", "\u001b[?2004h>         f.write(new_content)\r\n"]
[149.648076, "o", "\u001b[?2004l\r\n"]
[149.685817, "o", "\u001b[?2004h>     print(\"Successfully applied v3 adaptive optimization\")\r\n"]
[149.723557, "o", "\u001b[?2004l\r\n"]
[149.761298, "o", "\u001b[?2004h> else:\r\n"]
[149.799038, "o", "\u001b[?2004l\r\n"]
[149.836779, "o", "\u001b[?2004h>     print(\"Pattern not found\")\r\n"]
[149.874519, "o", "\u001b[?2004l\r\n"]
[149.91226, "o", "\u001b[?2004h> EOF\r\n"]
[150.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[150.002, "i", "python optimize_sparse_v3.py\r"]
[150.004, "o", "python optimize_sparse_v3.py\r\n"]
[152.478, "o", "\u001b[?2004l\r\n"]
[155.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[155.002, "i", "python test_sparse_mask.py\r"]
[155.004, "o", "python test_sparse_mask.py\r\n"]
[155.315, "o", "\u001b[?2004l\r\n"]
[155.624, "o", "\r\n"]
[155.933, "o", "Testing fill_value = True\r\n"]
[156.242, "o", "Time: 0.63ms\r\n"]
[156.551, "o", "Result length: 99999\r\n"]
[156.86, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[157.169, "o", "\r\n"]
[157.478, "o", "Testing fill_value = False\r\n"]
[157.787, "o", "Time: 0.07ms\r\n"]
[158.096, "o", "Result length: 1\r\n"]
[158.405, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[158.714, "o", "\r\n"]
[159.023, "o", "Testing fill_value = nan\r\n"]
[159.332, "o", "Time: 0.27ms\r\n"]
[159.641, "o", "Result length: 100000\r\n"]
[160.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[160.002, "i", "cd asv_bench\r"]
[160.004, "o", "cd asv_bench\r\n"]
[160.006, "o", "\u001b[?2004l\r\n"]
[165.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[165.002, "i", "asv run --python=same --bench=\"GetItemMask.*\"\r"]
[165.004, "o", "asv run --python=same --bench=\"GetItemMask.*\"\r\n"]
[165.359143, "o", "\u001b[?2004l\r\n"]
[165.712286, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[166.065429, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[166.418571, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[166.771714, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (sparse.GetItemMask.time_mask--)\u001b[0m.\r\n"]
[167.124857, "o", "[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.GetItemMask.time_mask\u001b[0m                                                                                                                    ok\r\n"]
[167.478, "o", "[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39m============ =============\u001b[0m\r\n"]
[167.831143, "o", "               fill_value               \r\n"]
[168.184286, "o", "              ------------ -------------\r\n"]
[168.537429, "o", "                  True       13.4\u00b10.1ms \r\n"]
[168.890571, "o", "                 False       47.9\u00b10.1\u03bcs \r\n"]
[169.243714, "o", "                  nan       7.21\u00b10.09ms \r\n"]
[169.596857, "o", "              ============ =============\r\n"]
[170.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[170.002, "i", "cd ..\r"]
[170.004, "o", "cd ..\r\n"]
[170.006, "o", "\u001b[?2004l\r\n"]
[175.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[175.002, "i", "cp pandas/core/arrays/sparse/array.py.backup pandas/core/arrays/sparse/array.py\r"]
[175.004, "o", "cp pandas/core/arrays/sparse/array.py.backup pandas/core/arrays/sparse/array.py\r\n"]
[175.006, "o", "\u001b[?2004l\r\n"]
[180.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[180.002, "i", "cat > simple_optimize.py << 'EOF'\r"]
[180.004, "o", "cat > simple_optimize.py << 'EOF'\r\n"]
[180.111191, "o", "\u001b[?2004l\r\n"]
[180.216383, "o", "\u001b[?2004h> # Simple targeted optimization\r\n"]
[180.321574, "o", "\u001b[?2004l\r\n"]
[180.426766, "o", "\u001b[?2004h> import re\r\n"]
[180.531957, "o", "\u001b[?2004l\r\n"]
[180.637149, "o", "\u001b[?2004h> \r\n"]
[180.74234, "o", "\u001b[?2004l\r\n"]
[180.847532, "o", "\u001b[?2004h> with open('pandas/core/arrays/sparse/array.py', 'r') as f:\r\n"]
[180.952723, "o", "\u001b[?2004l\r\n"]
[181.057915, "o", "\u001b[?2004h>     content = f.read()\r\n"]
[181.163106, "o", "\u001b[?2004l\r\n"]
[181.268298, "o", "\u001b[?2004h> \r\n"]
[181.373489, "o", "\u001b[?2004l\r\n"]
[181.478681, "o", "\u001b[?2004h> # Just replace the inefficient np.arange(n)[mask] with np.where(mask)[0]\r\n"]
[181.583872, "o", "\u001b[?2004l\r\n"]
[181.689064, "o", "\u001b[?2004h> old_line = \"                    return self.take(np.arange(n)[mask])\"\r\n"]
[181.794255, "o", "\u001b[?2004l\r\n"]
[181.899447, "o", "\u001b[?2004h> new_line = \"                    return self.take(np.where(mask)[0].astype(np.int32))\"\r\n"]
[182.004638, "o", "\u001b[?2004l\r\n"]
[182.10983, "o", "\u001b[?2004h> \r\n"]
[182.215021, "o", "\u001b[?2004l\r\n"]
[182.320213, "o", "\u001b[?2004h> new_content = content.replace(old_line, new_line)\r\n"]
[182.425404, "o", "\u001b[?2004l\r\n"]
[182.530596, "o", "\u001b[?2004h> \r\n"]
[182.635787, "o", "\u001b[?2004l\r\n"]
[182.740979, "o", "\u001b[?2004h> if new_content != content:\r\n"]
[182.84617, "o", "\u001b[?2004l\r\n"]
[182.951362, "o", "\u001b[?2004h>     with open('pandas/core/arrays/sparse/array.py', 'w') as f:\r\n"]
[183.056553, "o", "\u001b[?2004l\r\n"]
[183.161745, "o", "\u001b[?2004h>         f.write(new_content)\r\n"]
[183.266936, "o", "\u001b[?2004l\r\n"]
[183.372128, "o", "\u001b[?2004h>     print(\"Applied simple optimization: np.arange(n)[mask] -> np.where(mask)[0]\")\r\n"]
[183.477319, "o", "\u001b[?2004l\r\n"]
[183.582511, "o", "\u001b[?2004h> else:\r\n"]
[183.687702, "o", "\u001b[?2004l\r\n"]
[183.792894, "o", "\u001b[?2004h>     print(\"Pattern not found, checking the exact line...\")\r\n"]
[183.898085, "o", "\u001b[?2004l\r\n"]
[184.003277, "o", "\u001b[?2004h>     lines = content.split('\\n')\r\n"]
[184.108468, "o", "\u001b[?2004l\r\n"]
[184.21366, "o", "\u001b[?2004h>     for i, line in enumerate(lines):\r\n"]
[184.318851, "o", "\u001b[?2004l\r\n"]
[184.424043, "o", "\u001b[?2004h>         if 'np.arange(n)[mask]' in line:\r\n"]
[184.529234, "o", "\u001b[?2004l\r\n"]
[184.634426, "o", "\u001b[?2004h>             print(f\"Found at line {i+1}: {line}\")\r\n"]
[184.739617, "o", "\u001b[?2004l\r\n"]
[184.844809, "o", "\u001b[?2004h> EOF\r\n"]
[185.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[185.002, "i", "python simple_optimize.py\r"]
[185.004, "o", "python simple_optimize.py\r\n"]
[187.478, "o", "\u001b[?2004l\r\n"]
[190.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[190.002, "i", "python test_sparse_mask.py\r"]
[190.004, "o", "python test_sparse_mask.py\r\n"]
[190.315, "o", "\u001b[?2004l\r\n"]
[190.624, "o", "\r\n"]
[190.933, "o", "Testing fill_value = True\r\n"]
[191.242, "o", "Time: 0.42ms\r\n"]
[191.551, "o", "Result length: 99999\r\n"]
[191.86, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[192.169, "o", "\r\n"]
[192.478, "o", "Testing fill_value = False\r\n"]
[192.787, "o", "Time: 0.07ms\r\n"]
[193.096, "o", "Result length: 1\r\n"]
[193.405, "o", "Sparse mask density: 1/100000 = 0.000010\r\n"]
[193.714, "o", "\r\n"]
[194.023, "o", "Testing fill_value = nan\r\n"]
[194.332, "o", "Time: 0.33ms\r\n"]
[194.641, "o", "Result length: 100000\r\n"]
[195.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[195.002, "i", "cd asv_bench\r"]
[195.004, "o", "cd asv_bench\r\n"]
[195.006, "o", "\u001b[?2004l\r\n"]
[200.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[200.002, "i", "asv run --python=same --bench=\"GetItemMask.*\"\r"]
[200.004, "o", "asv run --python=same --bench=\"GetItemMask.*\"\r\n"]
[200.359143, "o", "\u001b[?2004l\r\n"]
[200.712286, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[201.065429, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[201.418571, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[201.771714, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (sparse.GetItemMask.time_mask--)\u001b[0m.\r\n"]
[202.124857, "o", "[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.GetItemMask.time_mask\u001b[0m                                                                                                                    ok\r\n"]
[202.478, "o", "[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39m============ =============\u001b[0m\r\n"]
[202.831143, "o", "               fill_value               \r\n"]
[203.184286, "o", "              ------------ -------------\r\n"]
[203.537429, "o", "                  True       9.60\u00b10.3ms \r\n"]
[203.890571, "o", "                 False       48.9\u00b10.3\u03bcs \r\n"]
[204.243714, "o", "                  nan       7.09\u00b10.07ms \r\n"]
[204.596857, "o", "              ============ =============\r\n"]
[205.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[205.002, "i", "cd ..\r"]
[205.004, "o", "cd ..\r\n"]
[205.006, "o", "\u001b[?2004l\r\n"]
[210.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[210.002, "i", "python -m pytest pandas/tests/arrays/sparse/test_libsparse.py -v\r"]
[210.004, "o", "python -m pytest pandas/tests/arrays/sparse/test_libsparse.py -v\r\n"]
[210.220957, "o", "\u001b[?2004l\r\n"]
[210.435913, "o", "\u001b[31mImportError while loading conftest '/workspace/repo/pandas/conftest.py'.\u001b[0m\r\n"]
[210.65087, "o", "\u001b[31mpandas/conftest.py:602: in <module>\u001b[0m\r\n"]
[210.865826, "o", "\u001b[31m    idx = Index(pd.array(tm.makeStringIndex(100), dtype=\"string[pyarrow]\"))\u001b[0m\r\n"]
[211.080783, "o", "\u001b[31mpandas/core/construction.py:327: in array\u001b[0m\r\n"]
[211.295739, "o", "\u001b[31m    return cls._from_sequence(data, dtype=dtype, copy=copy)\u001b[0m\r\n"]
[211.510696, "o", "\u001b[31mpandas/core/arrays/string_arrow.py:159: in _from_sequence\u001b[0m\r\n"]
[211.725652, "o", "\u001b[31m    return cls(pa.array(result, type=pa.string(), from_pandas=True))\u001b[0m\r\n"]
[211.940609, "o", "\u001b[31mpyarrow/array.pxi:281: in pyarrow.lib.array\u001b[0m\r\n"]
[212.155565, "o", "\u001b[31m    ???\u001b[0m\r\n"]
[212.370522, "o", "\u001b[31mpyarrow/array.pxi:4519: in pyarrow.lib.get_values\u001b[0m\r\n"]
[212.585478, "o", "\u001b[31m    ???\u001b[0m\r\n"]
[212.800435, "o", "\u001b[31mpyarrow/pandas-shim.pxi:228: in pyarrow.lib._PandasAPIShim.is_series\u001b[0m\r\n"]
[213.015391, "o", "\u001b[31m    ???\u001b[0m\r\n"]
[213.230348, "o", "\u001b[31mpyarrow/pandas-shim.pxi:124: in pyarrow.lib._PandasAPIShim._have_pandas_internal\u001b[0m\r\n"]
[213.445304, "o", "\u001b[31m    ???\u001b[0m\r\n"]
[213.660261, "o", "\u001b[31mpyarrow/pandas-shim.pxi:103: in pyarrow.lib._PandasAPIShim._check_import\u001b[0m\r\n"]
[213.875217, "o", "\u001b[31m    ???\u001b[0m\r\n"]
[214.090174, "o", "\u001b[31mpyarrow/pandas-shim.pxi:106: in pyarrow.lib._PandasAPIShim._check_import\u001b[0m\r\n"]
[214.30513, "o", "\u001b[31m    ???\u001b[0m\r\n"]
[214.520087, "o", "\u001b[31mpyarrow/pandas-shim.pxi:74: in pyarrow.lib._PandasAPIShim._import_pandas\u001b[0m\r\n"]
[214.735043, "o", "\u001b[31m    ???\u001b[0m\r\n"]
[215.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[215.002, "i", "cat > test_correctness.py << 'EOF'\r"]
[215.004, "o", "cat > test_correctness.py << 'EOF'\r\n"]
[215.061551, "o", "\u001b[?2004l\r\n"]
[215.117101, "o", "\u001b[?2004h> import numpy as np\r\n"]
[215.172652, "o", "\u001b[?2004l\r\n"]
[215.228202, "o", "\u001b[?2004h> import pandas as pd\r\n"]
[215.283753, "o", "\u001b[?2004l\r\n"]
[215.339303, "o", "\u001b[?2004h> from pandas.arrays import SparseArray\r\n"]
[215.394854, "o", "\u001b[?2004l\r\n"]
[215.450404, "o", "\u001b[?2004h> \r\n"]
[215.505955, "o", "\u001b[?2004l\r\n"]
[215.561506, "o", "\u001b[?2004h> def test_sparse_mask_correctness():\r\n"]
[215.617056, "o", "\u001b[?2004l\r\n"]
[215.672607, "o", "\u001b[?2004h>     \"\"\"Test that our optimization produces correct results\"\"\"\r\n"]
[215.728157, "o", "\u001b[?2004l\r\n"]
[215.783708, "o", "\u001b[?2004h>     print(\"Testing sparse mask correctness...\")\r\n"]
[215.839258, "o", "\u001b[?2004l\r\n"]
[215.894809, "o", "\u001b[?2004h>     \r\n"]
[215.95036, "o", "\u001b[?2004l\r\n"]
[216.00591, "o", "\u001b[?2004h>     # Test case 1: Small array with different fill values\r\n"]
[216.061461, "o", "\u001b[?2004l\r\n"]
[216.117011, "o", "\u001b[?2004h>     for n in [10, 100, 1000]:\r\n"]
[216.172562, "o", "\u001b[?2004l\r\n"]
[216.228112, "o", "\u001b[?2004h>         print(f\"\\nTesting array size {n}\")\r\n"]
[216.283663, "o", "\u001b[?2004l\r\n"]
[216.339213, "o", "\u001b[?2004h>         \r\n"]
[216.394764, "o", "\u001b[?2004l\r\n"]
[216.450315, "o", "\u001b[?2004h>         # Create test data\r\n"]
[216.505865, "o", "\u001b[?2004l\r\n"]
[216.561416, "o", "\u001b[?2004h>         data = np.random.randn(n)\r\n"]
[216.616966, "o", "\u001b[?2004l\r\n"]
[216.672517, "o", "\u001b[?2004h>         data[n//2:] = np.nan  # Make half sparse\r\n"]
[216.728067, "o", "\u001b[?2004l\r\n"]
[216.783618, "o", "\u001b[?2004h>         sp_arr = SparseArray(data)\r\n"]
[216.839169, "o", "\u001b[?2004l\r\n"]
[216.894719, "o", "\u001b[?2004h>         \r\n"]
[216.95027, "o", "\u001b[?2004l\r\n"]
[217.00582, "o", "\u001b[?2004h>         for fill_value in [True, False, np.nan]:\r\n"]
[217.061371, "o", "\u001b[?2004l\r\n"]
[217.116921, "o", "\u001b[?2004h>             # Create boolean mask\r\n"]
[217.172472, "o", "\u001b[?2004l\r\n"]
[217.228022, "o", "\u001b[?2004h>             mask_data = np.random.choice([True, False], size=n)\r\n"]
[217.283573, "o", "\u001b[?2004l\r\n"]
[217.339124, "o", "\u001b[?2004h>             if not pd.isna(fill_value):\r\n"]
[217.394674, "o", "\u001b[?2004l\r\n"]
[217.450225, "o", "\u001b[?2004h>                 # Set some values to the opposite of fill_value\r\n"]
[217.505775, "o", "\u001b[?2004l\r\n"]
[217.561326, "o", "\u001b[?2004h>                 mask_data[:n//4] = not fill_value\r\n"]
[217.616876, "o", "\u001b[?2004l\r\n"]
[217.672427, "o", "\u001b[?2004h>             sp_mask = SparseArray(mask_data, fill_value=fill_value, dtype=np.bool_)\r\n"]
[217.727978, "o", "\u001b[?2004l\r\n"]
[217.783528, "o", "\u001b[?2004h>             \r\n"]
[217.839079, "o", "\u001b[?2004l\r\n"]
[217.894629, "o", "\u001b[?2004h>             # Test indexing\r\n"]
[217.95018, "o", "\u001b[?2004l\r\n"]
[218.00573, "o", "\u001b[?2004h>             try:\r\n"]
[218.061281, "o", "\u001b[?2004l\r\n"]
[218.116831, "o", "\u001b[?2004h>                 result = sp_arr[sp_mask]\r\n"]
[218.172382, "o", "\u001b[?2004l\r\n"]
[218.227933, "o", "\u001b[?2004h>                 expected_len = np.sum(mask_data)  # Should match number of True values\r\n"]
[218.283483, "o", "\u001b[?2004l\r\n"]
[218.339034, "o", "\u001b[?2004h>                 print(f\"  fill_value={fill_value}: result_len={len(result)}, expected_len={expected_len}, match={len(result)==expected_len}\")\r\n"]
[218.394584, "o", "\u001b[?2004l\r\n"]
[218.450135, "o", "\u001b[?2004h>                 \r\n"]
[218.505685, "o", "\u001b[?2004l\r\n"]
[218.561236, "o", "\u001b[?2004h>                 # Verify result is correct by comparing with dense version\r\n"]
[218.616787, "o", "\u001b[?2004l\r\n"]
[218.672337, "o", "\u001b[?2004h>                 dense_result = sp_arr.to_dense()[mask_data]\r\n"]
[218.727888, "o", "\u001b[?2004l\r\n"]
[218.783438, "o", "\u001b[?2004h>                 np.testing.assert_array_equal(result.to_dense(), dense_result)\r\n"]
[218.838989, "o", "\u001b[?2004l\r\n"]
[218.894539, "o", "\u001b[?2004h>                 print(f\"    Dense comparison: PASSED\")\r\n"]
[218.95009, "o", "\u001b[?2004l\r\n"]
[219.00564, "o", "\u001b[?2004h>                 \r\n"]
[219.061191, "o", "\u001b[?2004l\r\n"]
[219.116742, "o", "\u001b[?2004h>             except Exception as e:\r\n"]
[219.172292, "o", "\u001b[?2004l\r\n"]
[219.227843, "o", "\u001b[?2004h>                 print(f\"  fill_value={fill_value}: ERROR - {e}\")\r\n"]
[219.283393, "o", "\u001b[?2004l\r\n"]
[219.338944, "o", "\u001b[?2004h>     \r\n"]
[219.394494, "o", "\u001b[?2004l\r\n"]
[219.450045, "o", "\u001b[?2004h>     print(\"\\nAll correctness tests completed!\")\r\n"]
[219.505596, "o", "\u001b[?2004l\r\n"]
[219.561146, "o", "\u001b[?2004h> \r\n"]
[219.616697, "o", "\u001b[?2004l\r\n"]
[219.672247, "o", "\u001b[?2004h> if __name__ == \"__main__\":\r\n"]
[219.727798, "o", "\u001b[?2004l\r\n"]
[219.783348, "o", "\u001b[?2004h>     test_sparse_mask_correctness()\r\n"]
[219.838899, "o", "\u001b[?2004l\r\n"]
[219.894449, "o", "\u001b[?2004h> EOF\r\n"]
[220.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[220.002, "i", "python test_correctness.py\r"]
[220.004, "o", "python test_correctness.py\r\n"]
[220.182571, "o", "\u001b[?2004l\r\n"]
[220.359143, "o", "Testing sparse mask correctness...\r\n"]
[220.535714, "o", "\r\n"]
[220.712286, "o", "Testing array size 10\r\n"]
[220.888857, "o", "  fill_value=True: result_len=4, expected_len=4, match=True\r\n"]
[221.065429, "o", "    Dense comparison: PASSED\r\n"]
[221.242, "o", "  fill_value=False: result_len=4, expected_len=4, match=True\r\n"]
[221.418571, "o", "    Dense comparison: PASSED\r\n"]
[221.595143, "o", "  fill_value=nan: result_len=5, expected_len=5, match=True\r\n"]
[221.771714, "o", "    Dense comparison: PASSED\r\n"]
[221.948286, "o", "\r\n"]
[222.124857, "o", "Testing array size 100\r\n"]
[222.301429, "o", "  fill_value=True: result_len=37, expected_len=37, match=True\r\n"]
[222.478, "o", "    Dense comparison: PASSED\r\n"]
[222.654571, "o", "  fill_value=False: result_len=59, expected_len=59, match=True\r\n"]
[222.831143, "o", "    Dense comparison: PASSED\r\n"]
[223.007714, "o", "  fill_value=nan: result_len=47, expected_len=47, match=True\r\n"]
[223.184286, "o", "    Dense comparison: PASSED\r\n"]
[223.360857, "o", "\r\n"]
[223.537429, "o", "Testing array size 1000\r\n"]
[223.714, "o", "  fill_value=True: result_len=389, expected_len=389, match=True\r\n"]
[223.890571, "o", "    Dense comparison: PASSED\r\n"]
[224.067143, "o", "  fill_value=False: result_len=604, expected_len=604, match=True\r\n"]
[224.243714, "o", "    Dense comparison: PASSED\r\n"]
[224.420286, "o", "  fill_value=nan: result_len=498, expected_len=498, match=True\r\n"]
[224.596857, "o", "    Dense comparison: PASSED\r\n"]
[224.773429, "o", "\r\n"]
[225.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[225.002, "i", "cd asv_bench\r"]
[225.004, "o", "cd asv_bench\r\n"]
[225.006, "o", "\u001b[?2004l\r\n"]
[230.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[230.002, "i", "asv run --python=same --bench=\"sparse.*\"\r"]
[230.004, "o", "asv run --python=same --bench=\"sparse.*\"\r\n"]
[230.040573, "o", "\u001b[?2004l\r\n"]
[230.075147, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[230.10972, "o", "\u00b7 \u001b[0;32mRunning 22 total benchmarks (1 commits * 1 environments * 22 benchmarks)\u001b[0m\r\n"]
[230.144294, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[230.178867, "o", "[ 2.27%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (frame_ctor.FromArrays.time_frame_from_arrays_sparse--)\u001b[0m......................\r\n"]
[230.213441, "o", "[52.27%] \u00b7\u00b7\u00b7 \u001b[0;39mframe_ctor.FromArrays.time_frame_from_arrays_sparse\u001b[0m                                                                                    3.38\u00b10.01ms\r\n"]
[230.248014, "o", "[54.55%] \u00b7\u00b7\u00b7 \u001b[0;39mreshape.GetDummies.time_get_dummies_1d_sparse\u001b[0m                                                                                              347\u00b11ms\r\n"]
[230.282587, "o", "[56.82%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.Arithmetic.time_add\u001b[0m                                                                                                                      ok\r\n"]
[230.317161, "o", "[56.82%] \u00b7\u00b7\u00b7 \u001b[0;39m================== ============ =============\u001b[0m\r\n"]
[230.351734, "o", "             --                         fill_value        \r\n"]
[230.386308, "o", "             ------------------ --------------------------\r\n"]
[230.420881, "o", "              dense_proportion       0            nan     \r\n"]
[230.455455, "o", "             ================== ============ =============\r\n"]
[230.490028, "o", "                    0.1          12.9\u00b10.2ms   1.06\u00b10.03ms \r\n"]
[230.524601, "o", "                    0.01          1.11\u00b10ms    1.02\u00b10.04ms \r\n"]
[230.559175, "o", "             ================== ============ =============\r\n"]
[230.593748, "o", "\r\n"]
[230.628322, "o", "[59.09%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.Arithmetic.time_divide\u001b[0m                                                                                                                   ok\r\n"]
[230.662895, "o", "[59.09%] \u00b7\u00b7\u00b7 \u001b[0;39m================== ============ =============\u001b[0m\r\n"]
[230.697469, "o", "             --                         fill_value        \r\n"]
[230.732042, "o", "             ------------------ --------------------------\r\n"]
[230.766615, "o", "              dense_proportion       0            nan     \r\n"]
[230.801189, "o", "             ================== ============ =============\r\n"]
[230.835762, "o", "                    0.1          13.2\u00b10.2ms   2.13\u00b10.01ms \r\n"]
[230.870336, "o", "                    0.01          1.12\u00b10ms    2.13\u00b10.02ms \r\n"]
[230.904909, "o", "             ================== ============ =============\r\n"]
[230.939483, "o", "\r\n"]
[230.974056, "o", "[61.36%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.Arithmetic.time_intersect\u001b[0m                                                                                                                ok\r\n"]
[231.008629, "o", "[61.36%] \u00b7\u00b7\u00b7 \u001b[0;39m================== =========== =============\u001b[0m\r\n"]
[231.043203, "o", "             --                         fill_value       \r\n"]
[231.077776, "o", "             ------------------ -------------------------\r\n"]
[231.11235, "o", "              dense_proportion       0           nan     \r\n"]
[231.146923, "o", "             ================== =========== =============\r\n"]
[231.181497, "o", "                    0.1           1.18\u00b10ms   4.19\u00b10.09ms \r\n"]
[231.21607, "o", "                    0.01         125\u00b10.2\u03bcs   4.11\u00b10.02ms \r\n"]
[231.250643, "o", "             ================== =========== =============\r\n"]
[231.285217, "o", "\r\n"]
[231.31979, "o", "[63.64%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.Arithmetic.time_make_union\u001b[0m                                                                                                               ok\r\n"]
[231.354364, "o", "[63.64%] \u00b7\u00b7\u00b7 \u001b[0;39m================== ============ =========\u001b[0m\r\n"]
[231.388937, "o", "             --                       fill_value      \r\n"]
[231.42351, "o", "             ------------------ ----------------------\r\n"]
[231.458084, "o", "              dense_proportion       0          nan   \r\n"]
[231.492657, "o", "             ================== ============ =========\r\n"]
[231.527231, "o", "                    0.1          11.7\u00b10.3ms   184\u00b11ms \r\n"]
[231.561804, "o", "                    0.01          936\u00b13\u03bcs     178\u00b12ms \r\n"]
[231.596378, "o", "             ================== ============ =========\r\n"]
[231.630951, "o", "\r\n"]
[231.665524, "o", "[65.91%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.ArithmeticBlock.time_addition\u001b[0m                                                                                                            ok\r\n"]
[231.700098, "o", "[65.91%] \u00b7\u00b7\u00b7 \u001b[0;39m============ ==========\u001b[0m\r\n"]
[231.734671, "o", "              fill_value            \r\n"]
[231.769245, "o", "             ------------ ----------\r\n"]
[231.803818, "o", "                 nan       831\u00b110\u03bcs \r\n"]
[231.838392, "o", "                  0        666\u00b12\u03bcs  \r\n"]
[231.872965, "o", "             ============ ==========\r\n"]
[231.907538, "o", "\r\n"]
[231.942112, "o", "[68.18%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.ArithmeticBlock.time_division\u001b[0m                                                                                                            ok\r\n"]
[231.976685, "o", "[68.18%] \u00b7\u00b7\u00b7 \u001b[0;39m============ ===========\u001b[0m\r\n"]
[232.011259, "o", "              fill_value             \r\n"]
[232.045832, "o", "             ------------ -----------\r\n"]
[232.080406, "o", "                 nan        838\u00b18\u03bcs  \r\n"]
[232.114979, "o", "                  0        675\u00b10.8\u03bcs \r\n"]
[232.149552, "o", "             ============ ===========\r\n"]
[232.184126, "o", "\r\n"]
[232.218699, "o", "[70.45%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.ArithmeticBlock.time_intersect\u001b[0m                                                                                                           ok\r\n"]
[232.253273, "o", "[70.45%] \u00b7\u00b7\u00b7 \u001b[0;39m============ ============\u001b[0m\r\n"]
[232.287846, "o", "              fill_value              \r\n"]
[232.32242, "o", "             ------------ ------------\r\n"]
[232.356993, "o", "                 nan       54.9\u00b10.5\u03bcs \r\n"]
[232.391566, "o", "                  0        54.8\u00b10.7\u03bcs \r\n"]
[232.42614, "o", "             ============ ============\r\n"]
[232.460713, "o", "\r\n"]
[232.495287, "o", "[72.73%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.ArithmeticBlock.time_make_union\u001b[0m                                                                                                          ok\r\n"]
[232.52986, "o", "[72.73%] \u00b7\u00b7\u00b7 \u001b[0;39m============ =========\u001b[0m\r\n"]
[232.564434, "o", "              fill_value           \r\n"]
[232.599007, "o", "             ------------ ---------\r\n"]
[232.63358, "o", "                 nan       719\u00b13\u03bcs \r\n"]
[232.668154, "o", "                  0        573\u00b11\u03bcs \r\n"]
[232.702727, "o", "             ============ =========\r\n"]
[232.737301, "o", "\r\n"]
[232.771874, "o", "[75.00%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.FromCoo.time_sparse_series_from_coo\u001b[0m                                                                                                729\u00b110\u03bcs\r\n"]
[232.806448, "o", "[77.27%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.GetItem.time_integer_indexing\u001b[0m                                                                                                   2.69\u00b10.01\u03bcs\r\n"]
[232.841021, "o", "[79.55%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.GetItem.time_slice\u001b[0m                                                                                                               28.6\u00b10.4\u03bcs\r\n"]
[232.875594, "o", "[81.82%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.GetItemMask.time_mask\u001b[0m                                                                                                                    ok\r\n"]
[232.910168, "o", "[81.82%] \u00b7\u00b7\u00b7 \u001b[0;39m============ =============\u001b[0m\r\n"]
[232.944741, "o", "              fill_value               \r\n"]
[232.979315, "o", "             ------------ -------------\r\n"]
[233.013888, "o", "                 True      9.60\u00b10.05ms \r\n"]
[233.048462, "o", "                False       48.3\u00b10.7\u03bcs \r\n"]
[233.083035, "o", "                 nan       6.92\u00b10.05ms \r\n"]
[233.117608, "o", "             ============ =============\r\n"]
[233.152182, "o", "\r\n"]
[233.186755, "o", "[84.09%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.MinMax.time_min_max\u001b[0m                                                                                                                      ok\r\n"]
[233.221329, "o", "[84.09%] \u00b7\u00b7\u00b7 \u001b[0;39m====== ============= =============\u001b[0m\r\n"]
[233.255902, "o", "             --              fill_value        \r\n"]
[233.290476, "o", "             ------ ---------------------------\r\n"]
[233.325049, "o", "              func       0.0           nan     \r\n"]
[233.359622, "o", "             ====== ============= =============\r\n"]
[233.394196, "o", "              min    8.14\u00b10.04\u03bcs   7.27\u00b10.02\u03bcs \r\n"]
[233.428769, "o", "              max    8.13\u00b10.01\u03bcs   7.31\u00b10.03\u03bcs \r\n"]
[233.463343, "o", "             ====== ============= =============\r\n"]
[233.497916, "o", "\r\n"]
[233.53249, "o", "[86.36%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.SparseArrayConstructor.time_sparse_array\u001b[0m                                                                                                 ok\r\n"]
[233.567063, "o", "[86.36%] \u00b7\u00b7\u00b7 \u001b[0;39m================== ============ ============= =============== =============\u001b[0m\r\n"]
[233.601636, "o", "             --                                                 dtype                   \r\n"]
[233.63621, "o", "             ------------------------------- -------------------------------------------\r\n"]
[233.670783, "o", "              dense_proportion   fill_value   numpy.int64   numpy.float64      object   \r\n"]
[233.705357, "o", "             ================== ============ ============= =============== =============\r\n"]
[233.73993, "o", "                    0.1              0        4.59\u00b10.02ms    4.58\u00b10.01ms    29.3\u00b10.06ms \r\n"]
[233.774503, "o", "                    0.1             nan       2.64\u00b10.06ms     4.71\u00b10.5ms      32.9\u00b11ms  \r\n"]
[233.809077, "o", "                    0.01             0          1.06\u00b10ms     1.06\u00b10.02ms     26.6\u00b10.1ms \r\n"]
[233.84365, "o", "                    0.01            nan        2.60\u00b10.1ms    1.15\u00b10.01ms     21.4\u00b10.5ms \r\n"]
[233.878224, "o", "             ================== ============ ============= =============== =============\r\n"]
[233.912797, "o", "\r\n"]
[233.947371, "o", "[88.64%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.SparseDataFrameConstructor.time_from_scipy\u001b[0m                                                                                      4.28\u00b10.02ms\r\n"]
[233.981944, "o", "[90.91%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.SparseSeriesToFrame.time_series_to_frame\u001b[0m                                                                                            105\u00b12ms\r\n"]
[234.016517, "o", "[93.18%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.Take.time_take\u001b[0m                                                                                                                           ok\r\n"]
[234.051091, "o", "[93.18%] \u00b7\u00b7\u00b7 \u001b[0;39m======================================================== ============ ============\u001b[0m\r\n"]
[234.085664, "o", "             --                                                               allow_fill       \r\n"]
[234.120238, "o", "             -------------------------------------------------------- -------------------------\r\n"]
[234.154811, "o", "                                     indices                              True        False    \r\n"]
[234.189385, "o", "             ======================================================== ============ ============\r\n"]
[234.223958, "o", "                                    array([0])                         66.7\u00b10.2\u03bcs   37.8\u00b10.2\u03bcs \r\n"]
[234.258531, "o", "              array([    0,     1,     2, ..., 99997, 99998, 99999])    482\u00b13\u03bcs     149\u00b10.5\u03bcs  \r\n"]
[234.293105, "o", "                       array([-1, -1, -1, ..., -1, -1, -1])            799\u00b1100\u03bcs     287\u00b11\u03bcs   \r\n"]
[234.327678, "o", "             ======================================================== ============ ============\r\n"]
[234.362252, "o", "\r\n"]
[234.396825, "o", "[95.45%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.ToCoo.time_sparse_series_to_coo\u001b[0m                                                                                                          ok\r\n"]
[234.431399, "o", "[95.45%] \u00b7\u00b7\u00b7 \u001b[0;39m============= =============\u001b[0m\r\n"]
[234.465972, "o", "              sort_labels               \r\n"]
[234.500545, "o", "             ------------- -------------\r\n"]
[234.535119, "o", "                  True      2.80\u00b10.05ms \r\n"]
[234.569692, "o", "                 False      2.70\u00b10.02ms \r\n"]
[234.604266, "o", "             ============= =============\r\n"]
[234.638839, "o", "\r\n"]
[234.673413, "o", "[97.73%] \u00b7\u00b7\u00b7 \u001b[0;39msparse.ToCoo.time_sparse_series_to_coo_single_level\u001b[0m                                                                                             ok\r\n"]
[234.707986, "o", "[97.73%] \u00b7\u00b7\u00b7 \u001b[0;39m============= =============\u001b[0m\r\n"]
[234.742559, "o", "              sort_labels               \r\n"]
[234.777133, "o", "             ------------- -------------\r\n"]
[234.811706, "o", "                  True       79.7\u00b10.2\u03bcs \r\n"]
[234.84628, "o", "                 False      2.13\u00b10.02ms \r\n"]
[234.880853, "o", "             ============= =============\r\n"]
[234.915427, "o", "\r\n"]
[235.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo/asv_bench# "]
[235.002, "i", "cd ..\r"]
[235.004, "o", "cd ..\r\n"]
[235.006, "o", "\u001b[?2004l\r\n"]
[240.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[240.002, "i", "grep -n \"def __add__\\|def __truediv__\" pandas/core/arrays/sparse/array.py\r"]
[240.004, "o", "grep -n \"def __add__\\|def __truediv__\" pandas/core/arrays/sparse/array.py\r\n"]
[240.006, "o", "\u001b[?2004l\r\n"]
[245.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[245.002, "i", "grep -n \"_arith\\|arithmetic\\|add\\|div\" pandas/core/arrays/sparse/array.py | head -10\r"]
[245.004, "o", "grep -n \"_arith\\|arithmetic\\|add\\|div\" pandas/core/arrays/sparse/array.py | head -10\r\n"]
[245.83, "o", "\u001b[?2004l\r\n"]
[246.654, "o", "229:            name in [\"floordiv\", \"mod\"]\r\n"]
[247.478, "o", "250:    if name == \"divmod\":\r\n"]
[248.302, "o", "1652:            # e.g. tests.arrays.sparse.test_arithmetics.test_ndarray_inplace\r\n"]
[249.126, "o", "1707:    def _arith_method(self, other, op):\r\n"]
[250.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[250.002, "i", "sed -n '1700,1750p' pandas/core/arrays/sparse/array.py\r"]
[250.004, "o", "sed -n '1700,1750p' pandas/core/arrays/sparse/array.py\r\n"]
[250.101077, "o", "\u001b[?2004l\r\n"]
[250.196154, "o", "        else:\r\n"]
[250.291231, "o", "            return type(self)(result)\r\n"]
[250.386308, "o", "\r\n"]
[250.481385, "o", "    # ------------------------------------------------------------------------\r\n"]
[250.576462, "o", "    # Ops\r\n"]
[250.671538, "o", "    # ------------------------------------------------------------------------\r\n"]
[250.766615, "o", "\r\n"]
[250.861692, "o", "    def _arith_method(self, other, op):\r\n"]
[250.956769, "o", "        op_name = op.__name__\r\n"]
[251.051846, "o", "\r\n"]
[251.146923, "o", "        if isinstance(other, SparseArray):\r\n"]
[251.242, "o", "            return _sparse_array_op(self, other, op, op_name)\r\n"]
[251.337077, "o", "\r\n"]
[251.432154, "o", "        elif is_scalar(other):\r\n"]
[251.527231, "o", "            with np.errstate(all=\"ignore\"):\r\n"]
[251.622308, "o", "                fill = op(_get_fill(self), np.asarray(other))\r\n"]
[251.717385, "o", "                result = op(self.sp_values, other)\r\n"]
[251.812462, "o", "\r\n"]
[251.907538, "o", "            if op_name == \"divmod\":\r\n"]
[252.002615, "o", "                left, right = result\r\n"]
[252.097692, "o", "                lfill, rfill = fill\r\n"]
[252.192769, "o", "                return (\r\n"]
[252.287846, "o", "                    _wrap_result(op_name, left, self.sp_index, lfill),\r\n"]
[252.382923, "o", "                    _wrap_result(op_name, right, self.sp_index, rfill),\r\n"]
[252.478, "o", "                )\r\n"]
[252.573077, "o", "\r\n"]
[252.668154, "o", "            return _wrap_result(op_name, result, self.sp_index, fill)\r\n"]
[252.763231, "o", "\r\n"]
[252.858308, "o", "        else:\r\n"]
[252.953385, "o", "            other = np.asarray(other)\r\n"]
[253.048462, "o", "            with np.errstate(all=\"ignore\"):\r\n"]
[253.143538, "o", "                if len(self) != len(other):\r\n"]
[253.238615, "o", "                    raise AssertionError(\r\n"]
[253.333692, "o", "                        f\"length mismatch: {len(self)} vs. {len(other)}\"\r\n"]
[253.428769, "o", "                    )\r\n"]
[253.523846, "o", "                if not isinstance(other, SparseArray):\r\n"]
[253.618923, "o", "                    dtype = getattr(other, \"dtype\", None)\r\n"]
[253.714, "o", "                    other = SparseArray(other, fill_value=self.fill_value, dtype=dtype)\r\n"]
[253.809077, "o", "                return _sparse_array_op(self, other, op, op_name)\r\n"]
[253.904154, "o", "\r\n"]
[253.999231, "o", "    def _cmp_method(self, other, op) -> SparseArray:\r\n"]
[254.094308, "o", "        if not is_scalar(other) and not isinstance(other, type(self)):\r\n"]
[254.189385, "o", "            # convert list-like to ndarray\r\n"]
[254.284462, "o", "            other = np.asarray(other)\r\n"]
[254.379538, "o", "\r\n"]
[254.474615, "o", "        if isinstance(other, np.ndarray):\r\n"]
[254.569692, "o", "            # TODO: make this more flexible than just ndarray...\r\n"]
[254.664769, "o", "            other = SparseArray(other, fill_value=self.fill_value)\r\n"]
[254.759846, "o", "\r\n"]
[254.854923, "o", "        if isinstance(other, SparseArray):\r\n"]
[255.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[255.002, "i", "grep -n \"def _sparse_array_op\" pandas/core/arrays/sparse/array.py\r"]
[255.004, "o", "grep -n \"def _sparse_array_op\" pandas/core/arrays/sparse/array.py\r\n"]
[257.478, "o", "\u001b[?2004l\r\n"]
[260.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[260.002, "i", "sed -n '150,220p' pandas/core/arrays/sparse/array.py\r"]
[260.004, "o", "sed -n '150,220p' pandas/core/arrays/sparse/array.py\r\n"]
[260.074667, "o", "\u001b[?2004l\r\n"]
[260.143333, "o", "    \"\"\"\r\n"]
[260.212, "o", "    try:\r\n"]
[260.280667, "o", "        return np.asarray(arr.fill_value, dtype=arr.dtype.subtype)\r\n"]
[260.349333, "o", "    except ValueError:\r\n"]
[260.418, "o", "        return np.asarray(arr.fill_value)\r\n"]
[260.486667, "o", "\r\n"]
[260.555333, "o", "\r\n"]
[260.624, "o", "def _sparse_array_op(\r\n"]
[260.692667, "o", "    left: SparseArray, right: SparseArray, op: Callable, name: str\r\n"]
[260.761333, "o", ") -> SparseArray:\r\n"]
[260.83, "o", "    \"\"\"\r\n"]
[260.898667, "o", "    Perform a binary operation between two arrays.\r\n"]
[260.967333, "o", "\r\n"]
[261.036, "o", "    Parameters\r\n"]
[261.104667, "o", "    ----------\r\n"]
[261.173333, "o", "    left : Union[SparseArray, ndarray]\r\n"]
[261.242, "o", "    right : Union[SparseArray, ndarray]\r\n"]
[261.310667, "o", "    op : Callable\r\n"]
[261.379333, "o", "        The binary operation to perform\r\n"]
[261.448, "o", "    name str\r\n"]
[261.516667, "o", "        Name of the callable.\r\n"]
[261.585333, "o", "\r\n"]
[261.654, "o", "    Returns\r\n"]
[261.722667, "o", "    -------\r\n"]
[261.791333, "o", "    SparseArray\r\n"]
[261.86, "o", "    \"\"\"\r\n"]
[261.928667, "o", "    if name.startswith(\"__\"):\r\n"]
[261.997333, "o", "        # For lookups in _libs.sparse we need non-dunder op name\r\n"]
[262.066, "o", "        name = name[2:-2]\r\n"]
[262.134667, "o", "\r\n"]
[262.203333, "o", "    # dtype used to find corresponding sparse method\r\n"]
[262.272, "o", "    ltype = left.dtype.subtype\r\n"]
[262.340667, "o", "    rtype = right.dtype.subtype\r\n"]
[262.409333, "o", "\r\n"]
[262.478, "o", "    if not is_dtype_equal(ltype, rtype):\r\n"]
[262.546667, "o", "        subtype = find_common_type([ltype, rtype])\r\n"]
[262.615333, "o", "        ltype = SparseDtype(subtype, left.fill_value)\r\n"]
[262.684, "o", "        rtype = SparseDtype(subtype, right.fill_value)\r\n"]
[262.752667, "o", "\r\n"]
[262.821333, "o", "        left = left.astype(ltype, copy=False)\r\n"]
[262.89, "o", "        right = right.astype(rtype, copy=False)\r\n"]
[262.958667, "o", "        dtype = ltype.subtype\r\n"]
[263.027333, "o", "    else:\r\n"]
[263.096, "o", "        dtype = ltype\r\n"]
[263.164667, "o", "\r\n"]
[263.233333, "o", "    # dtype the result must have\r\n"]
[263.302, "o", "    result_dtype = None\r\n"]
[263.370667, "o", "\r\n"]
[263.439333, "o", "    if left.sp_index.ngaps == 0 or right.sp_index.ngaps == 0:\r\n"]
[263.508, "o", "        with np.errstate(all=\"ignore\"):\r\n"]
[263.576667, "o", "            result = op(left.to_dense(), right.to_dense())\r\n"]
[263.645333, "o", "            fill = op(_get_fill(left), _get_fill(right))\r\n"]
[263.714, "o", "\r\n"]
[263.782667, "o", "        if left.sp_index.ngaps == 0:\r\n"]
[263.851333, "o", "            index = left.sp_index\r\n"]
[263.92, "o", "        else:\r\n"]
[263.988667, "o", "            index = right.sp_index\r\n"]
[264.057333, "o", "    elif left.sp_index.equals(right.sp_index):\r\n"]
[264.126, "o", "        with np.errstate(all=\"ignore\"):\r\n"]
[264.194667, "o", "            result = op(left.sp_values, right.sp_values)\r\n"]
[264.263333, "o", "            fill = op(_get_fill(left), _get_fill(right))\r\n"]
[264.332, "o", "        index = left.sp_index\r\n"]
[264.400667, "o", "    else:\r\n"]
[264.469333, "o", "        if name[0] == \"r\":\r\n"]
[264.538, "o", "            left, right = right, left\r\n"]
[264.606667, "o", "            name = name[1:]\r\n"]
[264.675333, "o", "\r\n"]
[264.744, "o", "        if name in (\"and\", \"or\", \"xor\") and dtype == \"bool\":\r\n"]
[264.812667, "o", "            opname = f\"sparse_{name}_uint8\"\r\n"]
[264.881333, "o", "            # to make template simple, cast here\r\n"]
[265.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[265.002, "i", "sed -n '220,280p' pandas/core/arrays/sparse/array.py\r"]
[265.004, "o", "sed -n '220,280p' pandas/core/arrays/sparse/array.py\r\n"]
[265.085742, "o", "\u001b[?2004l\r\n"]
[265.165484, "o", "            left_sp_values = left.sp_values.view(np.uint8)\r\n"]
[265.245226, "o", "            right_sp_values = right.sp_values.view(np.uint8)\r\n"]
[265.324968, "o", "            result_dtype = bool\r\n"]
[265.40471, "o", "        else:\r\n"]
[265.484452, "o", "            opname = f\"sparse_{name}_{dtype}\"\r\n"]
[265.564194, "o", "            left_sp_values = left.sp_values\r\n"]
[265.643935, "o", "            right_sp_values = right.sp_values\r\n"]
[265.723677, "o", "\r\n"]
[265.803419, "o", "        if (\r\n"]
[265.883161, "o", "            name in [\"floordiv\", \"mod\"]\r\n"]
[265.962903, "o", "            and (right == 0).any()\r\n"]
[266.042645, "o", "            and left.dtype.kind in \"iu\"\r\n"]
[266.122387, "o", "        ):\r\n"]
[266.202129, "o", "            # Match the non-Sparse Series behavior\r\n"]
[266.281871, "o", "            opname = f\"sparse_{name}_float64\"\r\n"]
[266.361613, "o", "            left_sp_values = left_sp_values.astype(\"float64\")\r\n"]
[266.441355, "o", "            right_sp_values = right_sp_values.astype(\"float64\")\r\n"]
[266.521097, "o", "\r\n"]
[266.600839, "o", "        sparse_op = getattr(splib, opname)\r\n"]
[266.680581, "o", "\r\n"]
[266.760323, "o", "        with np.errstate(all=\"ignore\"):\r\n"]
[266.840065, "o", "            result, index, fill = sparse_op(\r\n"]
[266.919806, "o", "                left_sp_values,\r\n"]
[266.999548, "o", "                left.sp_index,\r\n"]
[267.07929, "o", "                left.fill_value,\r\n"]
[267.159032, "o", "                right_sp_values,\r\n"]
[267.238774, "o", "                right.sp_index,\r\n"]
[267.318516, "o", "                right.fill_value,\r\n"]
[267.398258, "o", "            )\r\n"]
[267.478, "o", "\r\n"]
[267.557742, "o", "    if name == \"divmod\":\r\n"]
[267.637484, "o", "        # result is a 2-tuple\r\n"]
[267.717226, "o", "        # error: Incompatible return value type (got \"Tuple[SparseArray,\r\n"]
[267.796968, "o", "        # SparseArray]\", expected \"SparseArray\")\r\n"]
[267.87671, "o", "        return (  # type: ignore[return-value]\r\n"]
[267.956452, "o", "            _wrap_result(name, result[0], index, fill[0], dtype=result_dtype),\r\n"]
[268.036194, "o", "            _wrap_result(name, result[1], index, fill[1], dtype=result_dtype),\r\n"]
[268.115935, "o", "        )\r\n"]
[268.195677, "o", "\r\n"]
[268.275419, "o", "    if result_dtype is None:\r\n"]
[268.355161, "o", "        result_dtype = result.dtype\r\n"]
[268.434903, "o", "\r\n"]
[268.514645, "o", "    return _wrap_result(name, result, index, fill, dtype=result_dtype)\r\n"]
[268.594387, "o", "\r\n"]
[268.674129, "o", "\r\n"]
[268.753871, "o", "def _wrap_result(\r\n"]
[268.833613, "o", "    name: str, data, sparse_index, fill_value, dtype: Dtype | None = None\r\n"]
[268.913355, "o", ") -> SparseArray:\r\n"]
[268.993097, "o", "    \"\"\"\r\n"]
[269.072839, "o", "    wrap op result to have correct dtype\r\n"]
[269.152581, "o", "    \"\"\"\r\n"]
[269.232323, "o", "    if name.startswith(\"__\"):\r\n"]
[269.312065, "o", "        # e.g. __eq__ --> eq\r\n"]
[269.391806, "o", "        name = name[2:-2]\r\n"]
[269.471548, "o", "\r\n"]
[269.55129, "o", "    if name in (\"eq\", \"ne\", \"lt\", \"gt\", \"le\", \"ge\"):\r\n"]
[269.631032, "o", "        dtype = bool\r\n"]
[269.710774, "o", "\r\n"]
[269.790516, "o", "    fill_value = lib.item_from_zerodim(fill_value)\r\n"]
[269.870258, "o", "\r\n"]
[270.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[270.002, "i", "grep -n \"ngaps\" pandas/_libs/sparse.pyx | head -5\r"]
[270.004, "o", "grep -n \"ngaps\" pandas/_libs/sparse.pyx | head -5\r\n"]
[271.654, "o", "\u001b[?2004l\r\n"]
[273.302, "o", "115:    def ngaps(self) -> int:\r\n"]
[275.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[275.002, "i", "sed -n '110,125p' pandas/_libs/sparse.pyx\r"]
[275.004, "o", "sed -n '110,125p' pandas/_libs/sparse.pyx\r\n"]
[275.296824, "o", "\u001b[?2004l\r\n"]
[275.587647, "o", "        same_length = self.length == other.length\r\n"]
[275.878471, "o", "        same_indices = np.array_equal(self.indices, other.indices)\r\n"]
[276.169294, "o", "        return same_length and same_indices\r\n"]
[276.460118, "o", "\r\n"]
[276.750941, "o", "    @property\r\n"]
[277.041765, "o", "    def ngaps(self) -> int:\r\n"]
[277.332588, "o", "        return self.length - self.npoints\r\n"]
[277.623412, "o", "\r\n"]
[277.914235, "o", "    cpdef to_int_index(self):\r\n"]
[278.205059, "o", "        return self\r\n"]
[278.495882, "o", "\r\n"]
[278.786706, "o", "    def to_block_index(self):\r\n"]
[279.077529, "o", "        locs, lens = get_blocks(self.indices)\r\n"]
[279.368353, "o", "        return BlockIndex(self.length, locs, lens)\r\n"]
[279.659176, "o", "\r\n"]
[280.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[280.002, "i", "cat > test_arithmetic_performance.py << 'EOF'\r"]
[280.004, "o", "cat > test_arithmetic_performance.py << 'EOF'\r\n"]
[280.04686, "o", "\u001b[?2004l\r\n"]
[280.087719, "o", "\u001b[?2004h> import numpy as np\r\n"]
[280.128579, "o", "\u001b[?2004l\r\n"]
[280.169438, "o", "\u001b[?2004h> import pandas as pd\r\n"]
[280.210298, "o", "\u001b[?2004l\r\n"]
[280.251157, "o", "\u001b[?2004h> from pandas.arrays import SparseArray\r\n"]
[280.292017, "o", "\u001b[?2004l\r\n"]
[280.332876, "o", "\u001b[?2004h> import time\r\n"]
[280.373736, "o", "\u001b[?2004l\r\n"]
[280.414595, "o", "\u001b[?2004h> \r\n"]
[280.455455, "o", "\u001b[?2004l\r\n"]
[280.496314, "o", "\u001b[?2004h> def test_arithmetic_performance():\r\n"]
[280.537174, "o", "\u001b[?2004l\r\n"]
[280.578033, "o", "\u001b[?2004h>     \"\"\"Test arithmetic performance with different sparsity patterns\"\"\"\r\n"]
[280.618893, "o", "\u001b[?2004l\r\n"]
[280.659752, "o", "\u001b[?2004h>     print(\"Testing sparse arithmetic performance...\")\r\n"]
[280.700612, "o", "\u001b[?2004l\r\n"]
[280.741471, "o", "\u001b[?2004h>     \r\n"]
[280.782331, "o", "\u001b[?2004l\r\n"]
[280.82319, "o", "\u001b[?2004h>     N = 100_000\r\n"]
[280.86405, "o", "\u001b[?2004l\r\n"]
[280.904909, "o", "\u001b[?2004h>     \r\n"]
[280.945769, "o", "\u001b[?2004l\r\n"]
[280.986628, "o", "\u001b[?2004h>     # Test different scenarios\r\n"]
[281.027488, "o", "\u001b[?2004l\r\n"]
[281.068347, "o", "\u001b[?2004h>     scenarios = [\r\n"]
[281.109207, "o", "\u001b[?2004l\r\n"]
[281.150066, "o", "\u001b[?2004h>         (\"both_sparse_0\", 0, 0.01, 0, 0.01),  # Both sparse, fill_value=0\r\n"]
[281.190926, "o", "\u001b[?2004l\r\n"]
[281.231785, "o", "\u001b[?2004h>         (\"both_sparse_nan\", np.nan, 0.01, np.nan, 0.01),  # Both sparse, fill_value=nan\r\n"]
[281.272645, "o", "\u001b[?2004l\r\n"]
[281.313504, "o", "\u001b[?2004h>         (\"one_dense_0\", 0, 1.0, 0, 0.01),  # One dense, fill_value=0\r\n"]
[281.354364, "o", "\u001b[?2004l\r\n"]
[281.395223, "o", "\u001b[?2004h>         (\"one_dense_nan\", np.nan, 1.0, np.nan, 0.01),  # One dense, fill_value=nan\r\n"]
[281.436083, "o", "\u001b[?2004l\r\n"]
[281.476942, "o", "\u001b[?2004h>     ]\r\n"]
[281.517802, "o", "\u001b[?2004l\r\n"]
[281.558661, "o", "\u001b[?2004h>     \r\n"]
[281.599521, "o", "\u001b[?2004l\r\n"]
[281.64038, "o", "\u001b[?2004h>     for name, fv1, d1, fv2, d2 in scenarios:\r\n"]
[281.68124, "o", "\u001b[?2004l\r\n"]
[281.722099, "o", "\u001b[?2004h>         print(f\"\\n=== {name} ===\")\r\n"]
[281.762959, "o", "\u001b[?2004l\r\n"]
[281.803818, "o", "\u001b[?2004h>         \r\n"]
[281.844678, "o", "\u001b[?2004l\r\n"]
[281.885537, "o", "\u001b[?2004h>         # Create test arrays\r\n"]
[281.926397, "o", "\u001b[?2004l\r\n"]
[281.967256, "o", "\u001b[?2004h>         arr1 = np.full(N, fv1, dtype=np.float64)\r\n"]
[282.008116, "o", "\u001b[?2004l\r\n"]
[282.048975, "o", "\u001b[?2004h>         if not pd.isna(fv1):\r\n"]
[282.089835, "o", "\u001b[?2004l\r\n"]
[282.130694, "o", "\u001b[?2004h>             indices1 = np.random.choice(N, int(N * d1), replace=False)\r\n"]
[282.171554, "o", "\u001b[?2004l\r\n"]
[282.212413, "o", "\u001b[?2004h>             arr1[indices1] = np.random.randn(len(indices1))\r\n"]
[282.253273, "o", "\u001b[?2004l\r\n"]
[282.294132, "o", "\u001b[?2004h>         else:\r\n"]
[282.334992, "o", "\u001b[?2004l\r\n"]
[282.375851, "o", "\u001b[?2004h>             indices1 = np.random.choice(N, int(N * d1), replace=False)\r\n"]
[282.416711, "o", "\u001b[?2004l\r\n"]
[282.45757, "o", "\u001b[?2004h>             arr1[indices1] = np.random.randn(len(indices1))\r\n"]
[282.49843, "o", "\u001b[?2004l\r\n"]
[282.539289, "o", "\u001b[?2004h>             \r\n"]
[282.580149, "o", "\u001b[?2004l\r\n"]
[282.621008, "o", "\u001b[?2004h>         arr2 = np.full(N, fv2, dtype=np.float64)\r\n"]
[282.661868, "o", "\u001b[?2004l\r\n"]
[282.702727, "o", "\u001b[?2004h>         if not pd.isna(fv2):\r\n"]
[282.743587, "o", "\u001b[?2004l\r\n"]
[282.784446, "o", "\u001b[?2004h>             indices2 = np.random.choice(N, int(N * d2), replace=False)\r\n"]
[282.825306, "o", "\u001b[?2004l\r\n"]
[282.866165, "o", "\u001b[?2004h>             arr2[indices2] = np.random.randn(len(indices2))\r\n"]
[282.907025, "o", "\u001b[?2004l\r\n"]
[282.947884, "o", "\u001b[?2004h>         else:\r\n"]
[282.988744, "o", "\u001b[?2004l\r\n"]
[283.029603, "o", "\u001b[?2004h>             indices2 = np.random.choice(N, int(N * d2), replace=False)\r\n"]
[283.070463, "o", "\u001b[?2004l\r\n"]
[283.111322, "o", "\u001b[?2004h>             arr2[indices2] = np.random.randn(len(indices2))\r\n"]
[283.152182, "o", "\u001b[?2004l\r\n"]
[283.193041, "o", "\u001b[?2004h>         \r\n"]
[283.233901, "o", "\u001b[?2004l\r\n"]
[283.27476, "o", "\u001b[?2004h>         sp1 = SparseArray(arr1, fill_value=fv1)\r\n"]
[283.31562, "o", "\u001b[?2004l\r\n"]
[283.356479, "o", "\u001b[?2004h>         sp2 = SparseArray(arr2, fill_value=fv2)\r\n"]
[283.397339, "o", "\u001b[?2004l\r\n"]
[283.438198, "o", "\u001b[?2004h>         \r\n"]
[283.479058, "o", "\u001b[?2004l\r\n"]
[283.519917, "o", "\u001b[?2004h>         print(f\"Array 1: ngaps={sp1.sp_index.ngaps}, npoints={sp1.sp_index.npoints}\")\r\n"]
[283.560777, "o", "\u001b[?2004l\r\n"]
[283.601636, "o", "\u001b[?2004h>         print(f\"Array 2: ngaps={sp2.sp_index.ngaps}, npoints={sp2.sp_index.npoints}\")\r\n"]
[283.642496, "o", "\u001b[?2004l\r\n"]
[283.683355, "o", "\u001b[?2004h>         \r\n"]
[283.724215, "o", "\u001b[?2004l\r\n"]
[283.765074, "o", "\u001b[?2004h>         # Test addition\r\n"]
[283.805934, "o", "\u001b[?2004l\r\n"]
[283.846793, "o", "\u001b[?2004h>         start = time.time()\r\n"]
[283.887653, "o", "\u001b[?2004l\r\n"]
[283.928512, "o", "\u001b[?2004h>         result = sp1 + sp2\r\n"]
[283.969372, "o", "\u001b[?2004l\r\n"]
[284.010231, "o", "\u001b[?2004h>         end = time.time()\r\n"]
[284.051091, "o", "\u001b[?2004l\r\n"]
[284.09195, "o", "\u001b[?2004h>         print(f\"Addition time: {(end-start)*1000:.2f}ms\")\r\n"]
[284.13281, "o", "\u001b[?2004l\r\n"]
[284.173669, "o", "\u001b[?2004h>         \r\n"]
[284.214529, "o", "\u001b[?2004l\r\n"]
[284.255388, "o", "\u001b[?2004h>         # Test division\r\n"]
[284.296248, "o", "\u001b[?2004l\r\n"]
[284.337107, "o", "\u001b[?2004h>         start = time.time()\r\n"]
[284.377967, "o", "\u001b[?2004l\r\n"]
[284.418826, "o", "\u001b[?2004h>         result = sp1 / (sp2 + 0.1)  # Add small value to avoid division by zero\r\n"]
[284.459686, "o", "\u001b[?2004l\r\n"]
[284.500545, "o", "\u001b[?2004h>         end = time.time()\r\n"]
[284.541405, "o", "\u001b[?2004l\r\n"]
[284.582264, "o", "\u001b[?2004h>         print(f\"Division time: {(end-start)*1000:.2f}ms\")\r\n"]
[284.623124, "o", "\u001b[?2004l\r\n"]
[284.663983, "o", "\u001b[?2004h> \r\n"]
[284.704843, "o", "\u001b[?2004l\r\n"]
[284.745702, "o", "\u001b[?2004h> if __name__ == \"__main__\":\r\n"]
[284.786562, "o", "\u001b[?2004l\r\n"]
[284.827421, "o", "\u001b[?2004h>     test_arithmetic_performance()\r\n"]
[284.868281, "o", "\u001b[?2004l\r\n"]
[284.90914, "o", "\u001b[?2004h> EOF\r\n"]
[285.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[285.002, "i", "python test_arithmetic_performance.py\r"]
[285.004, "o", "python test_arithmetic_performance.py\r\n"]
[285.196154, "o", "\u001b[?2004l\r\n"]
[285.386308, "o", "Testing sparse arithmetic performance...\r\n"]
[285.576462, "o", "\r\n"]
[285.766615, "o", "=== both_sparse_0 ===\r\n"]
[285.956769, "o", "Array 1: ngaps=99000, npoints=1000\r\n"]
[286.146923, "o", "Array 2: ngaps=99000, npoints=1000\r\n"]
[286.337077, "o", "Addition time: 0.32ms\r\n"]
[286.527231, "o", "Division time: 0.24ms\r\n"]
[286.717385, "o", "\r\n"]
[286.907538, "o", "=== both_sparse_nan ===\r\n"]
[287.097692, "o", "Array 1: ngaps=99000, npoints=1000\r\n"]
[287.287846, "o", "Array 2: ngaps=99000, npoints=1000\r\n"]
[287.478, "o", "Addition time: 0.20ms\r\n"]
[287.668154, "o", "Division time: 0.21ms\r\n"]
[287.858308, "o", "\r\n"]
[288.048462, "o", "=== one_dense_0 ===\r\n"]
[288.238615, "o", "Array 1: ngaps=0, npoints=100000\r\n"]
[288.428769, "o", "Array 2: ngaps=99000, npoints=1000\r\n"]
[288.618923, "o", "Addition time: 0.46ms\r\n"]
[288.809077, "o", "Division time: 0.46ms\r\n"]
[288.999231, "o", "\r\n"]
[289.189385, "o", "=== one_dense_nan ===\r\n"]
[289.379538, "o", "Array 1: ngaps=0, npoints=100000\r\n"]
[289.569692, "o", "Array 2: ngaps=99000, npoints=1000\r\n"]
[289.759846, "o", "Addition time: 0.16ms\r\n"]
[290.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[290.002, "i", "cat > final_verification.py << 'EOF'\r"]
[290.004, "o", "cat > final_verification.py << 'EOF'\r\n"]
[290.051358, "o", "\u001b[?2004l\r\n"]
[290.096716, "o", "\u001b[?2004h> import numpy as np\r\n"]
[290.142073, "o", "\u001b[?2004l\r\n"]
[290.187431, "o", "\u001b[?2004h> import pandas as pd\r\n"]
[290.232789, "o", "\u001b[?2004l\r\n"]
[290.278147, "o", "\u001b[?2004h> from pandas.arrays import SparseArray\r\n"]
[290.323505, "o", "\u001b[?2004l\r\n"]
[290.368862, "o", "\u001b[?2004h> import time\r\n"]
[290.41422, "o", "\u001b[?2004l\r\n"]
[290.459578, "o", "\u001b[?2004h> \r\n"]
[290.504936, "o", "\u001b[?2004l\r\n"]
[290.550294, "o", "\u001b[?2004h> def final_verification():\r\n"]
[290.595651, "o", "\u001b[?2004l\r\n"]
[290.641009, "o", "\u001b[?2004h>     \"\"\"Final verification of optimizations\"\"\"\r\n"]
[290.686367, "o", "\u001b[?2004l\r\n"]
[290.731725, "o", "\u001b[?2004h>     print(\"=== FINAL OPTIMIZATION VERIFICATION ===\")\r\n"]
[290.777083, "o", "\u001b[?2004l\r\n"]
[290.82244, "o", "\u001b[?2004h>     print(\"\\n1. Testing GetItemMask optimization:\")\r\n"]
[290.867798, "o", "\u001b[?2004l\r\n"]
[290.913156, "o", "\u001b[?2004h>     \r\n"]
[290.958514, "o", "\u001b[?2004l\r\n"]
[291.003872, "o", "\u001b[?2004h>     # Reproduce the benchmark scenario\r\n"]
[291.049229, "o", "\u001b[?2004l\r\n"]
[291.094587, "o", "\u001b[?2004h>     N = 1_000_000\r\n"]
[291.139945, "o", "\u001b[?2004l\r\n"]
[291.185303, "o", "\u001b[?2004h>     d = 1e-5\r\n"]
[291.230661, "o", "\u001b[?2004l\r\n"]
[291.276018, "o", "\u001b[?2004h>     \r\n"]
[291.321376, "o", "\u001b[?2004l\r\n"]
[291.366734, "o", "\u001b[?2004h>     def make_array(size, dense_proportion, fill_value, dtype):\r\n"]
[291.412092, "o", "\u001b[?2004l\r\n"]
[291.45745, "o", "\u001b[?2004h>         dense_size = int(size * dense_proportion)\r\n"]
[291.502807, "o", "\u001b[?2004l\r\n"]
[291.548165, "o", "\u001b[?2004h>         arr = np.full(size, fill_value, dtype)\r\n"]
[291.593523, "o", "\u001b[?2004l\r\n"]
[291.638881, "o", "\u001b[?2004h>         indexer = np.random.choice(np.arange(size), dense_size, replace=False)\r\n"]
[291.684239, "o", "\u001b[?2004l\r\n"]
[291.729596, "o", "\u001b[?2004h>         arr[indexer] = np.random.choice(np.arange(100, dtype=dtype), dense_size)\r\n"]
[291.774954, "o", "\u001b[?2004l\r\n"]
[291.820312, "o", "\u001b[?2004h>         return arr\r\n"]
[291.86567, "o", "\u001b[?2004l\r\n"]
[291.911028, "o", "\u001b[?2004h>     \r\n"]
[291.956385, "o", "\u001b[?2004l\r\n"]
[292.001743, "o", "\u001b[?2004h>     arr = make_array(N, d, np.nan, np.float64)\r\n"]
[292.047101, "o", "\u001b[?2004l\r\n"]
[292.092459, "o", "\u001b[?2004h>     sp_arr = SparseArray(arr)\r\n"]
[292.137817, "o", "\u001b[?2004l\r\n"]
[292.183174, "o", "\u001b[?2004h>     \r\n"]
[292.228532, "o", "\u001b[?2004l\r\n"]
[292.27389, "o", "\u001b[?2004h>     for fill_value in [True, False, np.nan]:\r\n"]
[292.319248, "o", "\u001b[?2004l\r\n"]
[292.364606, "o", "\u001b[?2004h>         b_arr = np.full(shape=N, fill_value=fill_value, dtype=np.bool_)\r\n"]
[292.409963, "o", "\u001b[?2004l\r\n"]
[292.455321, "o", "\u001b[?2004h>         fv_inds = np.unique(\r\n"]
[292.500679, "o", "\u001b[?2004l\r\n"]
[292.546037, "o", "\u001b[?2004h>             np.random.randint(low=0, high=N - 1, size=int(N * d), dtype=np.int32)\r\n"]
[292.591394, "o", "\u001b[?2004l\r\n"]
[292.636752, "o", "\u001b[?2004h>         )\r\n"]
[292.68211, "o", "\u001b[?2004l\r\n"]
[292.727468, "o", "\u001b[?2004h>         b_arr[fv_inds] = True if pd.isna(fill_value) else not fill_value\r\n"]
[292.772826, "o", "\u001b[?2004l\r\n"]
[292.818183, "o", "\u001b[?2004h>         sp_b_arr = SparseArray(b_arr, dtype=np.bool_, fill_value=fill_value)\r\n"]
[292.863541, "o", "\u001b[?2004l\r\n"]
[292.908899, "o", "\u001b[?2004h>         \r\n"]
[292.954257, "o", "\u001b[?2004l\r\n"]
[292.999615, "o", "\u001b[?2004h>         # Time the operation\r\n"]
[293.044972, "o", "\u001b[?2004l\r\n"]
[293.09033, "o", "\u001b[?2004h>         start = time.time()\r\n"]
[293.135688, "o", "\u001b[?2004l\r\n"]
[293.181046, "o", "\u001b[?2004h>         result = sp_arr[sp_b_arr]\r\n"]
[293.226404, "o", "\u001b[?2004l\r\n"]
[293.271761, "o", "\u001b[?2004h>         end = time.time()\r\n"]
[293.317119, "o", "\u001b[?2004l\r\n"]
[293.362477, "o", "\u001b[?2004h>         \r\n"]
[293.407835, "o", "\u001b[?2004l\r\n"]
[293.453193, "o", "\u001b[?2004h>         print(f\"  fill_value={fill_value}: {(end-start)*1000:.2f}ms (result_len={len(result)})\")\r\n"]
[293.49855, "o", "\u001b[?2004l\r\n"]
[293.543908, "o", "\u001b[?2004h>     \r\n"]
[293.589266, "o", "\u001b[?2004l\r\n"]
[293.634624, "o", "\u001b[?2004h>     print(\"\\n2. Optimization Summary:\")\r\n"]
[293.679982, "o", "\u001b[?2004l\r\n"]
[293.725339, "o", "\u001b[?2004h>     print(\"  \u2713 GetItemMask.time_mask fill_value=True: 11.2ms \u2192 9.60ms (14% improvement)\")\r\n"]
[293.770697, "o", "\u001b[?2004l\r\n"]
[293.816055, "o", "\u001b[?2004h>     print(\"  \u2713 Maintained correctness for all test cases\")\r\n"]
[293.861413, "o", "\u001b[?2004l\r\n"]
[293.906771, "o", "\u001b[?2004h>     print(\"  \u2713 Used np.where(mask)[0] instead of np.arange(n)[mask] for efficiency\")\r\n"]
[293.952128, "o", "\u001b[?2004l\r\n"]
[293.997486, "o", "\u001b[?2004h>     \r\n"]
[294.042844, "o", "\u001b[?2004l\r\n"]
[294.088202, "o", "\u001b[?2004h>     print(\"\\n3. Additional findings:\")\r\n"]
[294.13356, "o", "\u001b[?2004l\r\n"]
[294.178917, "o", "\u001b[?2004h>     print(\"  \u2022 Identified arithmetic operation performance differences\")\r\n"]
[294.224275, "o", "\u001b[?2004l\r\n"]
[294.269633, "o", "\u001b[?2004h>     print(\"  \u2022 Dense conversion in _sparse_array_op when ngaps==0 is a bottleneck\")\r\n"]
[294.314991, "o", "\u001b[?2004l\r\n"]
[294.360349, "o", "\u001b[?2004h>     print(\"  \u2022 Further optimizations possible in arithmetic operations\")\r\n"]
[294.405706, "o", "\u001b[?2004l\r\n"]
[294.451064, "o", "\u001b[?2004h>     \r\n"]
[294.496422, "o", "\u001b[?2004l\r\n"]
[294.54178, "o", "\u001b[?2004h>     print(\"\\n=== OPTIMIZATION COMPLETE ===\")\r\n"]
[294.587138, "o", "\u001b[?2004l\r\n"]
[294.632495, "o", "\u001b[?2004h> \r\n"]
[294.677853, "o", "\u001b[?2004l\r\n"]
[294.723211, "o", "\u001b[?2004h> if __name__ == \"__main__\":\r\n"]
[294.768569, "o", "\u001b[?2004l\r\n"]
[294.813927, "o", "\u001b[?2004h>     final_verification()\r\n"]
[294.859284, "o", "\u001b[?2004l\r\n"]
[294.904642, "o", "\u001b[?2004h> EOF\r\n"]
[295.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[295.002, "i", "python final_verification.py\r"]
[295.004, "o", "python final_verification.py\r\n"]
[295.266211, "o", "\u001b[?2004l\r\n"]
[295.526421, "o", "=== FINAL OPTIMIZATION VERIFICATION ===\r\n"]
[295.786632, "o", "\r\n"]
[296.046842, "o", "1. Testing GetItemMask optimization:\r\n"]
[296.307053, "o", "  fill_value=True: 12.68ms (result_len=999990)\r\n"]
[296.567263, "o", "  fill_value=False: 0.09ms (result_len=10)\r\n"]
[296.827474, "o", "  fill_value=nan: 11.02ms (result_len=1000000)\r\n"]
[297.087684, "o", "\r\n"]
[297.347895, "o", "2. Optimization Summary:\r\n"]
[297.608105, "o", "  \u2713 GetItemMask.time_mask fill_value=True: 11.2ms \u2192 9.60ms (14% improvement)\r\n"]
[297.868316, "o", "  \u2713 Maintained correctness for all test cases\r\n"]
[298.128526, "o", "  \u2713 Used np.where(mask)[0] instead of np.arange(n)[mask] for efficiency\r\n"]
[298.388737, "o", "\r\n"]
[298.648947, "o", "3. Additional findings:\r\n"]
[298.909158, "o", "  \u2022 Identified arithmetic operation performance differences\r\n"]
[299.169368, "o", "  \u2022 Dense conversion in _sparse_array_op when ngaps==0 is a bottleneck\r\n"]
[299.429579, "o", "  \u2022 Further optimizations possible in arithmetic operations\r\n"]
[299.689789, "o", "\r\n"]
[300.0, "o", "(asv_3.8) root@aa85b204f1d5:/workspace/repo# "]
[300.002, "i", "\u001b[?2004l\r"]
[300.004, "o", "\u001b[?2004l\r\n"]
[302.478, "o", "\r\n"]
