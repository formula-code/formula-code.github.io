{"version": 2, "width": 160, "height": 40, "timestamp": 1762995203, "env": {"SHELL": "/bin/bash", "TERM": "screen"}}
[0.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[0.002, "i", "asciinema rec --stdin /logs/agent.cast\r"]
[0.004, "o", "asciinema rec --stdin /logs/agent.cast\r\n"]
[1.242, "o", "\u001b[?2004l\r\n"]
[2.478, "o", "\u001b[0;31masciinema: /logs/agent.cast already exists, aborting\u001b[0m\r\n"]
[3.714, "o", "\u001b[0;31masciinema: use --overwrite option if you want to overwrite existing recording\u001b[0m\r\n"]
[5.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[5.002, "i", "clear\r"]
[5.004, "o", "clear\r\n"]
[7.478, "o", "\u001b[?2004l\r\n"]
[10.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[10.002, "i", "ls -la\r"]
[10.004, "o", "ls -la\r\n"]
[10.136105, "o", "\u001b[?2004l\r\n"]
[10.266211, "o", "total 216\r\n"]
[10.396316, "o", "drwxr-xr-x 1 root root  4096 Oct  1 17:04 \u001b[0m\u001b[01;34m.\u001b[0m\r\n"]
[10.526421, "o", "drwxr-xr-x 1 root root  4096 Sep 15 17:17 \u001b[01;34m..\u001b[0m\r\n"]
[10.656526, "o", "drwxr-xr-x 2 root root  4096 Sep 13 21:47 \u001b[01;34m.circleci\u001b[0m\r\n"]
[10.786632, "o", "-rw-r--r-- 1 root root  1021 Sep 13 21:47 .devcontainer.json\r\n"]
[10.916737, "o", "drwxr-xr-x 1 root root  4096 Oct  1 16:57 \u001b[01;34m.git\u001b[0m\r\n"]
[11.046842, "o", "-rw-r--r-- 1 root root  1670 Sep 13 21:47 .gitattributes\r\n"]
[11.176947, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34m.github\u001b[0m\r\n"]
[11.307053, "o", "-rw-r--r-- 1 root root  1919 Sep 13 21:47 .gitignore\r\n"]
[11.437158, "o", "-rw-r--r-- 1 root root  2296 Sep 13 21:47 .gitpod.yml\r\n"]
[11.567263, "o", "-rw-r--r-- 1 root root 10674 Sep 13 21:47 .pre-commit-config.yaml\r\n"]
[11.697368, "o", "-rw-r--r-- 1 root root  2284 Sep 13 21:47 AUTHORS.md\r\n"]
[11.827474, "o", "-rw-r--r-- 1 root root  1541 Sep 13 21:47 CITATION.cff\r\n"]
[11.957579, "o", "-rw-r--r-- 1 root root   455 Sep 13 21:47 Dockerfile\r\n"]
[12.087684, "o", "-rw-r--r-- 1 root root  1634 Sep 13 21:47 LICENSE\r\n"]
[12.217789, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mLICENSES\u001b[0m\r\n"]
[12.347895, "o", "-rw-r--r-- 1 root root  1335 Sep 13 21:47 MANIFEST.in\r\n"]
[12.478, "o", "-rw-r--r-- 1 root root 11670 Sep 13 21:47 README.md\r\n"]
[12.608105, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34masv_bench\u001b[0m\r\n"]
[12.738211, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:48 \u001b[01;34mbuild\u001b[0m\r\n"]
[12.868316, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mci\u001b[0m\r\n"]
[12.998421, "o", "-rw-r--r-- 1 root root   256 Sep 13 21:47 codecov.yml\r\n"]
[13.128526, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mdoc\u001b[0m\r\n"]
[13.258632, "o", "-rw-r--r-- 1 root root  2612 Sep 13 21:47 environment.yml\r\n"]
[13.388737, "o", "-rw-r--r-- 1 root root   866 Sep 13 21:47 generate_pxi.py\r\n"]
[13.518842, "o", "-rw-r--r-- 1 root root  1715 Sep 13 21:47 generate_version.py\r\n"]
[13.648947, "o", "drwxr-xr-x 2 root root  4096 Sep 13 21:47 \u001b[01;34mgitpod\u001b[0m\r\n"]
[13.779053, "o", "-rw-r--r-- 1 root root  1646 Sep 13 21:47 meson.build\r\n"]
[13.909158, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mpandas\u001b[0m\r\n"]
[14.039263, "o", "-rw-r--r-- 1 root root 21652 Sep 13 21:47 pyproject.toml\r\n"]
[14.169368, "o", "-rw-r--r-- 1 root root  4307 Sep 13 21:47 pyright_reportGeneralTypeIssues.json\r\n"]
[14.299474, "o", "-rw-r--r-- 1 root root  1398 Sep 13 21:47 requirements-dev.txt\r\n"]
[14.429579, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mscripts\u001b[0m\r\n"]
[14.559684, "o", "-rwxr-xr-x 1 root root 21960 Sep 13 21:47 \u001b[01;32msetup.py\u001b[0m\r\n"]
[14.689789, "o", "drwxr-xr-x 3 root root  4096 Sep 13 21:47 \u001b[01;34mtooling\u001b[0m\r\n"]
[14.819895, "o", "drwxr-xr-x 2 root root  4096 Sep 13 21:47 \u001b[01;34mtypings\u001b[0m\r\n"]
[15.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[15.002, "i", "ls -la asv.conf.json asv.conf.* 2>/dev/null || true\r"]
[15.004, "o", "ls -la asv.conf.json asv.conf.* 2>/dev/null || true\r\n"]
[15.006, "o", "\u001b[?2004l\r\n"]
[20.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[20.002, "i", "git status -sb\r"]
[20.004, "o", "git status -sb\r\n"]
[22.478, "o", "\u001b[?2004l\r\n"]
[25.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[25.002, "i", "grep -R \"class .*DataFrameStringIndexing\" -n . || true\r"]
[25.004, "o", "grep -R \"class .*DataFrameStringIndexing\" -n . || true\r\n"]
[27.478, "o", "\u001b[?2004l\r\n"]
[30.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[30.002, "i", "grep -R \"indexing\\.DataFrameStringIndexing\" -n . || true\r"]
[30.004, "o", "grep -R \"indexing\\.DataFrameStringIndexing\" -n . || true\r\n"]
[30.006, "o", "\u001b[?2004l\r\n"]
[35.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[35.002, "i", "fd -H \"asv\" . 2>/dev/null || (apt-get update && apt-get install -y fd-find && ln -s $(command -v fdfind) /usr/local\r"]
[35.004, "o", "fd -H \"asv\" . 2>/dev/null || (apt-get update && apt-get install -y fd-find && ln -s $(command -v fdfind) /usr/local\r\n"]
[35.02817, "o", "l/bin/fd && fd -H \"asv\" .)\r\n"]
[35.050341, "o", "\u001b[?2004l\r\n"]
[35.072511, "o", "\r\n"]
[35.094682, "o", "0% [Working]\r\n"]
[35.116852, "o", "            \r\n"]
[35.139022, "o", "Hit:1 http://security.ubuntu.com/ubuntu jammy-security InRelease\r\n"]
[35.161193, "o", "\r\n"]
[35.183363, "o", "0% [Waiting for headers]\r\n"]
[35.205534, "o", "                        \r\n"]
[35.227704, "o", "Hit:2 http://archive.ubuntu.com/ubuntu jammy InRelease\r\n"]
[35.249874, "o", "\r\n"]
[35.272045, "o", "0% [Waiting for headers]\r\n"]
[35.294215, "o", "                        \r\n"]
[35.316386, "o", "Hit:3 http://archive.ubuntu.com/ubuntu jammy-updates InRelease\r\n"]
[35.338556, "o", "\r\n"]
[35.360726, "o", "                        \r\n"]
[35.382897, "o", "0% [Working]\r\n"]
[35.405067, "o", "            \r\n"]
[35.427238, "o", "Hit:4 http://archive.ubuntu.com/ubuntu jammy-backports InRelease\r\n"]
[35.449408, "o", "\r\n"]
[35.471578, "o", "0% [Working]\r\n"]
[35.493749, "o", "0% [Working]\r\n"]
[35.515919, "o", "0% [Working]\r\n"]
[35.53809, "o", "0% [Working]\r\n"]
[35.56026, "o", "20% [Working]\r\n"]
[35.58243, "o", "             \r\n"]
[35.604601, "o", "\r\n"]
[35.626771, "o", "Reading package lists... 0%\r\n"]
[35.648942, "o", "\r\n"]
[35.671112, "o", "Reading package lists... 0%\r\n"]
[35.693283, "o", "\r\n"]
[35.715453, "o", "Reading package lists... 0%\r\n"]
[35.737623, "o", "\r\n"]
[35.759794, "o", "Reading package lists... 3%\r\n"]
[35.781964, "o", "\r\n"]
[35.804135, "o", "Reading package lists... 3%\r\n"]
[35.826305, "o", "\r\n"]
[35.848475, "o", "Reading package lists... 4%\r\n"]
[35.870646, "o", "\r\n"]
[35.892816, "o", "Reading package lists... 4%\r\n"]
[35.914987, "o", "\r\n"]
[35.937157, "o", "Reading package lists... 41%\r\n"]
[35.959327, "o", "\r\n"]
[35.981498, "o", "Reading package lists... 41%\r\n"]
[36.003668, "o", "\r\n"]
[36.025839, "o", "Reading package lists... 41%\r\n"]
[36.048009, "o", "\r\n"]
[36.070179, "o", "Reading package lists... 41%\r\n"]
[36.09235, "o", "\r\n"]
[36.11452, "o", "Reading package lists... 51%\r\n"]
[36.136691, "o", "\r\n"]
[36.158861, "o", "Reading package lists... 51%\r\n"]
[36.181031, "o", "\r\n"]
[36.203202, "o", "Reading package lists... 57%\r\n"]
[36.225372, "o", "\r\n"]
[36.247543, "o", "Reading package lists... 67%\r\n"]
[36.269713, "o", "\r\n"]
[36.291883, "o", "Reading package lists... 67%\r\n"]
[36.314054, "o", "\r\n"]
[36.336224, "o", "Reading package lists... 71%\r\n"]
[36.358395, "o", "\r\n"]
[36.380565, "o", "Reading package lists... 71%\r\n"]
[36.402735, "o", "\r\n"]
[36.424906, "o", "Reading package lists... 71%\r\n"]
[36.447076, "o", "\r\n"]
[36.469247, "o", "Reading package lists... 71%\r\n"]
[36.491417, "o", "\r\n"]
[36.513587, "o", "Reading package lists... 72%\r\n"]
[36.535758, "o", "\r\n"]
[36.557928, "o", "Reading package lists... 72%\r\n"]
[36.580099, "o", "\r\n"]
[36.602269, "o", "Reading package lists... 72%\r\n"]
[36.624439, "o", "\r\n"]
[36.64661, "o", "Reading package lists... 72%\r\n"]
[36.66878, "o", "\r\n"]
[36.690951, "o", "Reading package lists... 80%\r\n"]
[36.713121, "o", "\r\n"]
[36.735291, "o", "Reading package lists... 80%\r\n"]
[36.757462, "o", "\r\n"]
[36.779632, "o", "Reading package lists... 96%\r\n"]
[36.801803, "o", "\r\n"]
[36.823973, "o", "Reading package lists... 96%\r\n"]
[36.846143, "o", "\r\n"]
[36.868314, "o", "Reading package lists... 99%\r\n"]
[36.890484, "o", "\r\n"]
[36.912655, "o", "Reading package lists... 99%\r\n"]
[36.934825, "o", "\r\n"]
[36.956996, "o", "Reading package lists... 99%\r\n"]
[36.979166, "o", "\r\n"]
[37.001336, "o", "Reading package lists... 99%\r\n"]
[37.023507, "o", "\r\n"]
[37.045677, "o", "Reading package lists... Done\r\n"]
[37.067848, "o", "\r\n"]
[37.090018, "o", "\r\n"]
[37.112188, "o", "Reading package lists... 0%\r\n"]
[37.134359, "o", "\r\n"]
[37.156529, "o", "Reading package lists... 0%\r\n"]
[37.1787, "o", "\r\n"]
[37.20087, "o", "Reading package lists... 0%\r\n"]
[37.22304, "o", "\r\n"]
[37.245211, "o", "Reading package lists... 3%\r\n"]
[37.267381, "o", "\r\n"]
[37.289552, "o", "Reading package lists... 3%\r\n"]
[37.311722, "o", "\r\n"]
[37.333892, "o", "Reading package lists... 4%\r\n"]
[37.356063, "o", "\r\n"]
[37.378233, "o", "Reading package lists... 4%\r\n"]
[37.400404, "o", "\r\n"]
[37.422574, "o", "Reading package lists... 41%\r\n"]
[37.444744, "o", "\r\n"]
[37.466915, "o", "Reading package lists... 41%\r\n"]
[37.489085, "o", "\r\n"]
[37.511256, "o", "Reading package lists... 41%\r\n"]
[37.533426, "o", "\r\n"]
[37.555596, "o", "Reading package lists... 41%\r\n"]
[37.577767, "o", "\r\n"]
[37.599937, "o", "Reading package lists... 51%\r\n"]
[37.622108, "o", "\r\n"]
[37.644278, "o", "Reading package lists... 51%\r\n"]
[37.666448, "o", "\r\n"]
[37.688619, "o", "Reading package lists... 55%\r\n"]
[37.710789, "o", "\r\n"]
[37.73296, "o", "Reading package lists... 67%\r\n"]
[37.75513, "o", "\r\n"]
[37.7773, "o", "Reading package lists... 67%\r\n"]
[37.799471, "o", "\r\n"]
[37.821641, "o", "Reading package lists... 71%\r\n"]
[37.843812, "o", "\r\n"]
[37.865982, "o", "Reading package lists... 71%\r\n"]
[37.888152, "o", "\r\n"]
[37.910323, "o", "Reading package lists... 71%\r\n"]
[37.932493, "o", "\r\n"]
[37.954664, "o", "Reading package lists... 71%\r\n"]
[37.976834, "o", "\r\n"]
[37.999004, "o", "Reading package lists... 72%\r\n"]
[38.021175, "o", "\r\n"]
[38.043345, "o", "Reading package lists... 72%\r\n"]
[38.065516, "o", "\r\n"]
[38.087686, "o", "Reading package lists... 72%\r\n"]
[38.109857, "o", "\r\n"]
[38.132027, "o", "Reading package lists... 72%\r\n"]
[38.154197, "o", "\r\n"]
[38.176368, "o", "Reading package lists... 80%\r\n"]
[38.198538, "o", "\r\n"]
[38.220709, "o", "Reading package lists... 80%\r\n"]
[38.242879, "o", "\r\n"]
[38.265049, "o", "Reading package lists... 96%\r\n"]
[38.28722, "o", "\r\n"]
[38.30939, "o", "Reading package lists... 96%\r\n"]
[38.331561, "o", "\r\n"]
[38.353731, "o", "Reading package lists... 99%\r\n"]
[38.375901, "o", "\r\n"]
[38.398072, "o", "Reading package lists... 99%\r\n"]
[38.420242, "o", "\r\n"]
[38.442413, "o", "Reading package lists... 99%\r\n"]
[38.464583, "o", "\r\n"]
[38.486753, "o", "Reading package lists... 99%\r\n"]
[38.508924, "o", "\r\n"]
[38.531094, "o", "Reading package lists... Done\r\n"]
[38.553265, "o", "\r\n"]
[38.575435, "o", "\r\n"]
[38.597605, "o", "Building dependency tree... 0%\r\n"]
[38.619776, "o", "\r\n"]
[38.641946, "o", "Building dependency tree... 0%\r\n"]
[38.664117, "o", "\r\n"]
[38.686287, "o", "Building dependency tree... 50%\r\n"]
[38.708457, "o", "\r\n"]
[38.730628, "o", "Building dependency tree... 50%\r\n"]
[38.752798, "o", "\r\n"]
[38.774969, "o", "Building dependency tree... Done\r\n"]
[38.797139, "o", "\r\n"]
[38.819309, "o", "\r\n"]
[38.84148, "o", "Reading state information... 0% \r\n"]
[38.86365, "o", "\r\n"]
[38.885821, "o", "Reading state information... 0%\r\n"]
[38.907991, "o", "\r\n"]
[38.930161, "o", "Reading state information... Done\r\n"]
[38.952332, "o", "\r\n"]
[38.974502, "o", "The following NEW packages will be installed:\r\n"]
[38.996673, "o", "  fd-find\r\n"]
[39.018843, "o", "0 upgraded, 1 newly installed, 0 to remove and 26 not upgraded.\r\n"]
[39.041013, "o", "Need to get 832 kB of archives.\r\n"]
[39.063184, "o", "After this operation, 2570 kB of additional disk space will be used.\r\n"]
[39.085354, "o", "\r\n"]
[39.107525, "o", "0% [Working]\r\n"]
[39.129695, "o", "            \r\n"]
[39.151865, "o", "Get:1 http://archive.ubuntu.com/ubuntu jammy-updates/universe amd64 fd-find amd64 8.3.1-1ubuntu0.1 [832 kB]\r\n"]
[39.174036, "o", "\r\n"]
[39.196206, "o", "1% [1 fd-find 14.2 kB/832 kB 2%]\r\n"]
[39.218377, "o", "                                \r\n"]
[39.240547, "o", "100% [Working]\r\n"]
[39.262717, "o", "              \r\n"]
[39.284888, "o", "Fetched 832 kB in 1s (1325 kB/s)\r\n"]
[39.307058, "o", "debconf: delaying package configuration, since apt-utils is not installed\r\n"]
[39.329229, "o", "Selecting previously unselected package fd-find.\r\n"]
[39.351399, "o", "(Reading database ... \r\n"]
[39.37357, "o", "(Reading database ... 5%\r\n"]
[39.39574, "o", "(Reading database ... 10%\r\n"]
[39.41791, "o", "(Reading database ... 15%\r\n"]
[39.440081, "o", "(Reading database ... 20%\r\n"]
[39.462251, "o", "(Reading database ... 25%\r\n"]
[39.484422, "o", "(Reading database ... 30%\r\n"]
[39.506592, "o", "(Reading database ... 35%\r\n"]
[39.528762, "o", "(Reading database ... 40%\r\n"]
[39.550933, "o", "(Reading database ... 45%\r\n"]
[39.573103, "o", "(Reading database ... 50%\r\n"]
[39.595274, "o", "(Reading database ... 55%\r\n"]
[39.617444, "o", "(Reading database ... 60%\r\n"]
[39.639614, "o", "(Reading database ... 65%\r\n"]
[39.661785, "o", "(Reading database ... 70%\r\n"]
[39.683955, "o", "(Reading database ... 75%\r\n"]
[39.706126, "o", "(Reading database ... 80%\r\n"]
[39.728296, "o", "(Reading database ... 85%\r\n"]
[39.750466, "o", "(Reading database ... 90%\r\n"]
[39.772637, "o", "(Reading database ... 95%\r\n"]
[39.794807, "o", "(Reading database ... 100%\r\n"]
[39.816978, "o", "(Reading database ... 25084 files and directories currently installed.)\r\n"]
[39.839148, "o", "Preparing to unpack .../fd-find_8.3.1-1ubuntu0.1_amd64.deb ...\r\n"]
[39.861318, "o", "Unpacking fd-find (8.3.1-1ubuntu0.1) ...\r\n"]
[39.883489, "o", "Setting up fd-find (8.3.1-1ubuntu0.1) ...\r\n"]
[39.905659, "o", "\u001b[1;34m./\u001b[0m\u001b[1;34masv_bench\u001b[0m\r\n"]
[39.92783, "o", "\u001b[1;34m./asv_bench/\u001b[0masv.conf.json\r\n"]
[40.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[40.002, "i", "find . -maxdepth 3 -type d -iname \"bench*\" -o -iname \"asv*\"\r"]
[40.004, "o", "find . -maxdepth 3 -type d -iname \"bench*\" -o -iname \"asv*\"\r\n"]
[41.242, "o", "\u001b[?2004l\r\n"]
[42.478, "o", "./asv_bench\r\n"]
[43.714, "o", "./asv_bench/benchmarks\r\n"]
[45.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[45.002, "i", "git grep -n \"asv\" -- :/ || true\r"]
[45.004, "o", "git grep -n \"asv\" -- :/ || true\r\n"]
[46.654, "o", "\u001b[?2004l\r\n"]
[48.302, "o", "error: cannot run less: No such file or directory\r\n"]
[50.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[50.002, "i", "ls -la benchmarks bench asv_bench asv_benchmarks 2>/dev/null || true\r"]
[50.004, "o", "ls -la benchmarks bench asv_bench asv_benchmarks 2>/dev/null || true\r\n"]
[50.712286, "o", "\u001b[?2004l\r\n"]
[51.418571, "o", "asv_bench:\r\n"]
[52.124857, "o", "total 24\r\n"]
[52.831143, "o", "drwxr-xr-x 1 root root 4096 Sep 13 21:47 \u001b[0m\u001b[01;34m.\u001b[0m\r\n"]
[53.537429, "o", "drwxr-xr-x 1 root root 4096 Oct  1 17:04 \u001b[01;34m..\u001b[0m\r\n"]
[54.243714, "o", "-rw-r--r-- 1 root root 5194 Sep 13 21:47 asv.conf.json\r\n"]
[55.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[55.002, "i", "grep -R \"class .*Indexing\" -n benchmarks asv_bench asv_benchmarks 2>/dev/null || true\r"]
[55.004, "o", "grep -R \"class .*Indexing\" -n benchmarks asv_bench asv_benchmarks 2>/dev/null || true\r\n"]
[55.2532, "o", "\u001b[?2004l\r\n"]
[55.5004, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/categoricals.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K291\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Indexing\u001b[m\u001b[K:\r\n"]
[55.7476, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/timedelta.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K35\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass TimedeltaIndexing\u001b[m\u001b[K:\r\n"]
[55.9948, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/index_object.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K154\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Indexing\u001b[m\u001b[K:\r\n"]
[56.242, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/period.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K85\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass Indexing\u001b[m\u001b[K:\r\n"]
[56.4892, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing_engines.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K58\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass NumericEngineIndexing\u001b[m\u001b[K:\r\n"]
[56.7364, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing_engines.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K105\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass MaskedNumericEngineIndexing\u001b[m\u001b[K:\r\n"]
[56.9836, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing_engines.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K158\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass ObjectEngineIndexing\u001b[m\u001b[K:\r\n"]
[57.2308, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/hash_functions.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K57\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass NumericSeriesIndexing\u001b[m\u001b[K:\r\n"]
[57.478, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/hash_functions.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K74\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass NumericSeriesIndexing\u001b[m\u001b[KShuffled:\r\n"]
[57.7252, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K27\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass NumericSeriesIndexing\u001b[m\u001b[K:\r\n"]
[57.9724, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K86\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass NumericMaskedIndexing\u001b[m\u001b[K:\r\n"]
[58.2196, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K114\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass NonNumericSeriesIndexing\u001b[m\u001b[K:\r\n"]
[58.4668, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K154\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass DataFrameStringIndexing\u001b[m\u001b[K:\r\n"]
[58.714, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K188\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass DataFrameNumericIndexing\u001b[m\u001b[K:\r\n"]
[58.9612, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K242\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass MultiIndexing\u001b[m\u001b[K:\r\n"]
[59.2084, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K323\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass IntervalIndexing\u001b[m\u001b[K:\r\n"]
[59.4556, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K342\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass DatetimeIndexIndexing\u001b[m\u001b[K:\r\n"]
[59.7028, "o", "\u001b[35m\u001b[Kasv_bench/benchmarks/indexing.py\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[32m\u001b[K374\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K\u001b[01;31m\u001b[Kclass CategoricalIndexIndexing\u001b[m\u001b[K:\r\n"]
[60.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[60.002, "i", "sed -n '1,200p' asv.conf.json 2>/dev/null || true\r"]
[60.004, "o", "sed -n '1,200p' asv.conf.json 2>/dev/null || true\r\n"]
[60.006, "o", "\u001b[?2004l\r\n"]
[65.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[65.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[65.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[67.478, "o", "\u001b[?2004l\r\n"]
[70.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[70.002, "i", "sed -n '1,260p' asv_bench/benchmarks/indexing.py\r"]
[70.004, "o", "sed -n '1,260p' asv_bench/benchmarks/indexing.py\r\n"]
[70.024943, "o", "\u001b[?2004l\r\n"]
[70.043885, "o", "\"\"\"\r\n"]
[70.062828, "o", "These benchmarks are for Series and DataFrame indexing methods.  For the\r\n"]
[70.08177, "o", "lower-level methods directly on Index and subclasses, see index_object.py,\r\n"]
[70.100713, "o", "indexing_engine.py, and index_cached.py\r\n"]
[70.119655, "o", "\"\"\"\r\n"]
[70.138598, "o", "\r\n"]
[70.15754, "o", "from datetime import datetime\r\n"]
[70.176483, "o", "import warnings\r\n"]
[70.195425, "o", "\r\n"]
[70.214368, "o", "import numpy as np\r\n"]
[70.23331, "o", "\r\n"]
[70.252253, "o", "from pandas import (\r\n"]
[70.271195, "o", "    NA,\r\n"]
[70.290138, "o", "    CategoricalIndex,\r\n"]
[70.30908, "o", "    DataFrame,\r\n"]
[70.328023, "o", "    Index,\r\n"]
[70.346966, "o", "    IntervalIndex,\r\n"]
[70.365908, "o", "    MultiIndex,\r\n"]
[70.384851, "o", "    Series,\r\n"]
[70.403793, "o", "    concat,\r\n"]
[70.422736, "o", "    date_range,\r\n"]
[70.441678, "o", "    option_context,\r\n"]
[70.460621, "o", "    period_range,\r\n"]
[70.479563, "o", ")\r\n"]
[70.498506, "o", "\r\n"]
[70.517448, "o", "\r\n"]
[70.536391, "o", "class NumericSeriesIndexing:\r\n"]
[70.555333, "o", "    params = [\r\n"]
[70.574276, "o", "        (np.int64, np.uint64, np.float64),\r\n"]
[70.593218, "o", "        (\"unique_monotonic_inc\", \"nonunique_monotonic_inc\"),\r\n"]
[70.612161, "o", "    ]\r\n"]
[70.631103, "o", "    param_names = [\"dtype\", \"index_structure\"]\r\n"]
[70.650046, "o", "\r\n"]
[70.668989, "o", "    def setup(self, dtype, index_structure):\r\n"]
[70.687931, "o", "        N = 10**6\r\n"]
[70.706874, "o", "        indices = {\r\n"]
[70.725816, "o", "            \"unique_monotonic_inc\": Index(range(N), dtype=dtype),\r\n"]
[70.744759, "o", "            \"nonunique_monotonic_inc\": Index(\r\n"]
[70.763701, "o", "                list(range(55)) + [54] + list(range(55, N - 1)), dtype=dtype\r\n"]
[70.782644, "o", "            ),\r\n"]
[70.801586, "o", "        }\r\n"]
[70.820529, "o", "        self.data = Series(np.random.rand(N), index=indices[index_structure])\r\n"]
[70.839471, "o", "        self.array = np.arange(10000)\r\n"]
[70.858414, "o", "        self.array_list = self.array.tolist()\r\n"]
[70.877356, "o", "\r\n"]
[70.896299, "o", "    def time_getitem_scalar(self, index, index_structure):\r\n"]
[70.915241, "o", "        self.data[800000]\r\n"]
[70.934184, "o", "\r\n"]
[70.953126, "o", "    def time_getitem_slice(self, index, index_structure):\r\n"]
[70.972069, "o", "        self.data[:800000]\r\n"]
[70.991011, "o", "\r\n"]
[71.009954, "o", "    def time_getitem_list_like(self, index, index_structure):\r\n"]
[71.028897, "o", "        self.data[[800000]]\r\n"]
[71.047839, "o", "\r\n"]
[71.066782, "o", "    def time_getitem_array(self, index, index_structure):\r\n"]
[71.085724, "o", "        self.data[self.array]\r\n"]
[71.104667, "o", "\r\n"]
[71.123609, "o", "    def time_getitem_lists(self, index, index_structure):\r\n"]
[71.142552, "o", "        self.data[self.array_list]\r\n"]
[71.161494, "o", "\r\n"]
[71.180437, "o", "    def time_iloc_array(self, index, index_structure):\r\n"]
[71.199379, "o", "        self.data.iloc[self.array]\r\n"]
[71.218322, "o", "\r\n"]
[71.237264, "o", "    def time_iloc_list_like(self, index, index_structure):\r\n"]
[71.256207, "o", "        self.data.iloc[[800000]]\r\n"]
[71.275149, "o", "\r\n"]
[71.294092, "o", "    def time_iloc_scalar(self, index, index_structure):\r\n"]
[71.313034, "o", "        self.data.iloc[800000]\r\n"]
[71.331977, "o", "\r\n"]
[71.35092, "o", "    def time_iloc_slice(self, index, index_structure):\r\n"]
[71.369862, "o", "        self.data.iloc[:800000]\r\n"]
[71.388805, "o", "\r\n"]
[71.407747, "o", "    def time_loc_array(self, index, index_structure):\r\n"]
[71.42669, "o", "        self.data.loc[self.array]\r\n"]
[71.445632, "o", "\r\n"]
[71.464575, "o", "    def time_loc_list_like(self, index, index_structure):\r\n"]
[71.483517, "o", "        self.data.loc[[800000]]\r\n"]
[71.50246, "o", "\r\n"]
[71.521402, "o", "    def time_loc_scalar(self, index, index_structure):\r\n"]
[71.540345, "o", "        self.data.loc[800000]\r\n"]
[71.559287, "o", "\r\n"]
[71.57823, "o", "    def time_loc_slice(self, index, index_structure):\r\n"]
[71.597172, "o", "        self.data.loc[:800000]\r\n"]
[71.616115, "o", "\r\n"]
[71.635057, "o", "\r\n"]
[71.654, "o", "class NumericMaskedIndexing:\r\n"]
[71.672943, "o", "    monotonic_list = list(range(10**6))\r\n"]
[71.691885, "o", "    non_monotonic_list = list(range(50)) + [54, 53, 52, 51] + list(range(55, 10**6 - 1))\r\n"]
[71.710828, "o", "\r\n"]
[71.72977, "o", "    params = [\r\n"]
[71.748713, "o", "        (\"Int64\", \"UInt64\", \"Float64\"),\r\n"]
[71.767655, "o", "        (True, False),\r\n"]
[71.786598, "o", "    ]\r\n"]
[71.80554, "o", "    param_names = [\"dtype\", \"monotonic\"]\r\n"]
[71.824483, "o", "\r\n"]
[71.843425, "o", "    def setup(self, dtype, monotonic):\r\n"]
[71.862368, "o", "        indices = {\r\n"]
[71.88131, "o", "            True: Index(self.monotonic_list, dtype=dtype),\r\n"]
[71.900253, "o", "            False: Index(self.non_monotonic_list, dtype=dtype).append(\r\n"]
[71.919195, "o", "                Index([NA], dtype=dtype)\r\n"]
[71.938138, "o", "            ),\r\n"]
[71.95708, "o", "        }\r\n"]
[71.976023, "o", "        self.data = indices[monotonic]\r\n"]
[71.994966, "o", "        self.indexer = np.arange(300, 1_000)\r\n"]
[72.013908, "o", "        self.data_dups = self.data.append(self.data)\r\n"]
[72.032851, "o", "\r\n"]
[72.051793, "o", "    def time_get_indexer(self, dtype, monotonic):\r\n"]
[72.070736, "o", "        self.data.get_indexer(self.indexer)\r\n"]
[72.089678, "o", "\r\n"]
[72.108621, "o", "    def time_get_indexer_dups(self, dtype, monotonic):\r\n"]
[72.127563, "o", "        self.data.get_indexer_for(self.indexer)\r\n"]
[72.146506, "o", "\r\n"]
[72.165448, "o", "\r\n"]
[72.184391, "o", "class NonNumericSeriesIndexing:\r\n"]
[72.203333, "o", "    params = [\r\n"]
[72.222276, "o", "        (\"string\", \"datetime\", \"period\"),\r\n"]
[72.241218, "o", "        (\"unique_monotonic_inc\", \"nonunique_monotonic_inc\", \"non_monotonic\"),\r\n"]
[72.260161, "o", "    ]\r\n"]
[72.279103, "o", "    param_names = [\"index_dtype\", \"index_structure\"]\r\n"]
[72.298046, "o", "\r\n"]
[72.316989, "o", "    def setup(self, index, index_structure):\r\n"]
[72.335931, "o", "        N = 10**6\r\n"]
[72.354874, "o", "        if index == \"string\":\r\n"]
[72.373816, "o", "            index = Index([f\"i-{i}\" for i in range(N)], dtype=object)\r\n"]
[72.392759, "o", "        elif index == \"datetime\":\r\n"]
[72.411701, "o", "            index = date_range(\"1900\", periods=N, freq=\"s\")\r\n"]
[72.430644, "o", "        elif index == \"period\":\r\n"]
[72.449586, "o", "            index = period_range(\"1900\", periods=N, freq=\"s\")\r\n"]
[72.468529, "o", "        index = index.sort_values()\r\n"]
[72.487471, "o", "        assert index.is_unique and index.is_monotonic_increasing\r\n"]
[72.506414, "o", "        if index_structure == \"nonunique_monotonic_inc\":\r\n"]
[72.525356, "o", "            index = index.insert(item=index[2], loc=2)[:-1]\r\n"]
[72.544299, "o", "        elif index_structure == \"non_monotonic\":\r\n"]
[72.563241, "o", "            index = index[::2].append(index[1::2])\r\n"]
[72.582184, "o", "            assert len(index) == N\r\n"]
[72.601126, "o", "        self.s = Series(np.random.rand(N), index=index)\r\n"]
[72.620069, "o", "        self.lbl = index[80000]\r\n"]
[72.639011, "o", "        # warm up index mapping\r\n"]
[72.657954, "o", "        self.s[self.lbl]\r\n"]
[72.676897, "o", "\r\n"]
[72.695839, "o", "    def time_getitem_label_slice(self, index, index_structure):\r\n"]
[72.714782, "o", "        self.s[: self.lbl]\r\n"]
[72.733724, "o", "\r\n"]
[72.752667, "o", "    def time_getitem_pos_slice(self, index, index_structure):\r\n"]
[72.771609, "o", "        self.s[:80000]\r\n"]
[72.790552, "o", "\r\n"]
[72.809494, "o", "    def time_getitem_scalar(self, index, index_structure):\r\n"]
[72.828437, "o", "        self.s[self.lbl]\r\n"]
[72.847379, "o", "\r\n"]
[72.866322, "o", "    def time_getitem_list_like(self, index, index_structure):\r\n"]
[72.885264, "o", "        self.s[[self.lbl]]\r\n"]
[72.904207, "o", "\r\n"]
[72.923149, "o", "\r\n"]
[72.942092, "o", "class DataFrameStringIndexing:\r\n"]
[72.961034, "o", "    def setup(self):\r\n"]
[72.979977, "o", "        index = Index([f\"i-{i}\" for i in range(1000)], dtype=object)\r\n"]
[72.99892, "o", "        columns = Index([f\"i-{i}\" for i in range(30)], dtype=object)\r\n"]
[73.017862, "o", "        with warnings.catch_warnings(record=True):\r\n"]
[73.036805, "o", "            self.df = DataFrame(np.random.randn(1000, 30), index=index, columns=columns)\r\n"]
[73.055747, "o", "        self.idx_scalar = index[100]\r\n"]
[73.07469, "o", "        self.col_scalar = columns[10]\r\n"]
[73.093632, "o", "        self.bool_indexer = self.df[self.col_scalar] > 0\r\n"]
[73.112575, "o", "        self.bool_obj_indexer = self.bool_indexer.astype(object)\r\n"]
[73.131517, "o", "        self.boolean_indexer = (self.df[self.col_scalar] > 0).astype(\"boolean\")\r\n"]
[73.15046, "o", "\r\n"]
[73.169402, "o", "    def time_loc(self):\r\n"]
[73.188345, "o", "        self.df.loc[self.idx_scalar, self.col_scalar]\r\n"]
[73.207287, "o", "\r\n"]
[73.22623, "o", "    def time_at(self):\r\n"]
[73.245172, "o", "        self.df.at[self.idx_scalar, self.col_scalar]\r\n"]
[73.264115, "o", "\r\n"]
[73.283057, "o", "    def time_at_setitem(self):\r\n"]
[73.302, "o", "        self.df.at[self.idx_scalar, self.col_scalar] = 0.0\r\n"]
[73.320943, "o", "\r\n"]
[73.339885, "o", "    def time_getitem_scalar(self):\r\n"]
[73.358828, "o", "        self.df[self.col_scalar][self.idx_scalar]\r\n"]
[73.37777, "o", "\r\n"]
[73.396713, "o", "    def time_boolean_rows(self):\r\n"]
[73.415655, "o", "        self.df[self.bool_indexer]\r\n"]
[73.434598, "o", "\r\n"]
[73.45354, "o", "    def time_boolean_rows_object(self):\r\n"]
[73.472483, "o", "        self.df[self.bool_obj_indexer]\r\n"]
[73.491425, "o", "\r\n"]
[73.510368, "o", "    def time_boolean_rows_boolean(self):\r\n"]
[73.52931, "o", "        self.df[self.boolean_indexer]\r\n"]
[73.548253, "o", "\r\n"]
[73.567195, "o", "\r\n"]
[73.586138, "o", "class DataFrameNumericIndexing:\r\n"]
[73.60508, "o", "    params = [\r\n"]
[73.624023, "o", "        (np.int64, np.uint64, np.float64),\r\n"]
[73.642966, "o", "        (\"unique_monotonic_inc\", \"nonunique_monotonic_inc\"),\r\n"]
[73.661908, "o", "    ]\r\n"]
[73.680851, "o", "    param_names = [\"dtype\", \"index_structure\"]\r\n"]
[73.699793, "o", "\r\n"]
[73.718736, "o", "    def setup(self, dtype, index_structure):\r\n"]
[73.737678, "o", "        N = 10**5\r\n"]
[73.756621, "o", "        indices = {\r\n"]
[73.775563, "o", "            \"unique_monotonic_inc\": Index(range(N), dtype=dtype),\r\n"]
[73.794506, "o", "            \"nonunique_monotonic_inc\": Index(\r\n"]
[73.813448, "o", "                list(range(55)) + [54] + list(range(55, N - 1)), dtype=dtype\r\n"]
[73.832391, "o", "            ),\r\n"]
[73.851333, "o", "        }\r\n"]
[73.870276, "o", "        self.idx_dupe = np.array(range(30)) * 99\r\n"]
[73.889218, "o", "        self.df = DataFrame(np.random.randn(N, 5), index=indices[index_structure])\r\n"]
[73.908161, "o", "        self.df_dup = concat([self.df, 2 * self.df, 3 * self.df])\r\n"]
[73.927103, "o", "        self.bool_indexer = [True] * (N // 2) + [False] * (N - N // 2)\r\n"]
[73.946046, "o", "\r\n"]
[73.964989, "o", "    def time_iloc_dups(self, index, index_structure):\r\n"]
[73.983931, "o", "        self.df_dup.iloc[self.idx_dupe]\r\n"]
[74.002874, "o", "\r\n"]
[74.021816, "o", "    def time_loc_dups(self, index, index_structure):\r\n"]
[74.040759, "o", "        self.df_dup.loc[self.idx_dupe]\r\n"]
[74.059701, "o", "\r\n"]
[74.078644, "o", "    def time_iloc(self, index, index_structure):\r\n"]
[74.097586, "o", "        self.df.iloc[:100, 0]\r\n"]
[74.116529, "o", "\r\n"]
[74.135471, "o", "    def time_loc(self, index, index_structure):\r\n"]
[74.154414, "o", "        self.df.loc[:100, 0]\r\n"]
[74.173356, "o", "\r\n"]
[74.192299, "o", "    def time_bool_indexer(self, index, index_structure):\r\n"]
[74.211241, "o", "        self.df[self.bool_indexer]\r\n"]
[74.230184, "o", "\r\n"]
[74.249126, "o", "\r\n"]
[74.268069, "o", "class Take:\r\n"]
[74.287011, "o", "    params = [\"int\", \"datetime\"]\r\n"]
[74.305954, "o", "    param_names = [\"index\"]\r\n"]
[74.324897, "o", "\r\n"]
[74.343839, "o", "    def setup(self, index):\r\n"]
[74.362782, "o", "        N = 100000\r\n"]
[74.381724, "o", "        indexes = {\r\n"]
[74.400667, "o", "            \"int\": Index(np.arange(N), dtype=np.int64),\r\n"]
[74.419609, "o", "            \"datetime\": date_range(\"2011-01-01\", freq=\"s\", periods=N),\r\n"]
[74.438552, "o", "        }\r\n"]
[74.457494, "o", "        index = indexes[index]\r\n"]
[74.476437, "o", "        self.s = Series(np.random.rand(N), index=index)\r\n"]
[74.495379, "o", "        self.indexer = np.random.randint(0, N, size=N)\r\n"]
[74.514322, "o", "\r\n"]
[74.533264, "o", "    def time_take(self, index):\r\n"]
[74.552207, "o", "        self.s.take(self.indexer)\r\n"]
[74.571149, "o", "\r\n"]
[74.590092, "o", "\r\n"]
[74.609034, "o", "class MultiIndexing:\r\n"]
[74.627977, "o", "    params = [True, False]\r\n"]
[74.64692, "o", "    param_names = [\"unique_levels\"]\r\n"]
[74.665862, "o", "\r\n"]
[74.684805, "o", "    def setup(self, unique_levels):\r\n"]
[74.703747, "o", "        self.nlevels = 2\r\n"]
[74.72269, "o", "        if unique_levels:\r\n"]
[74.741632, "o", "            mi = MultiIndex.from_arrays([range(1000000)] * self.nlevels)\r\n"]
[74.760575, "o", "        else:\r\n"]
[74.779517, "o", "            mi = MultiIndex.from_product([range(1000)] * self.nlevels)\r\n"]
[74.79846, "o", "        self.df = DataFrame(np.random.randn(len(mi)), index=mi)\r\n"]
[74.817402, "o", "\r\n"]
[74.836345, "o", "        self.tgt_slice = slice(200, 800)\r\n"]
[74.855287, "o", "        self.tgt_null_slice = slice(None)\r\n"]
[74.87423, "o", "        self.tgt_list = list(range(0, 1000, 10))\r\n"]
[74.893172, "o", "        self.tgt_scalar = 500\r\n"]
[74.912115, "o", "\r\n"]
[74.931057, "o", "        bool_indexer = np.zeros(len(mi), dtype=np.bool_)\r\n"]
[75.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[75.002, "i", "sed -n '1,200p' asv_bench/asv.conf.json\r"]
[75.004, "o", "sed -n '1,200p' asv_bench/asv.conf.json\r\n"]
[75.043173, "o", "\u001b[?2004l\r\n"]
[75.080346, "o", "{\r\n"]
[75.117519, "o", "    // The version of the config file format.  Do not change, unless\r\n"]
[75.154692, "o", "    // you know what you are doing.\r\n"]
[75.191865, "o", "    \"version\": 1,\r\n"]
[75.229038, "o", "\r\n"]
[75.266211, "o", "    // The name of the project being benchmarked\r\n"]
[75.303383, "o", "    \"project\": \"pandas\",\r\n"]
[75.340556, "o", "\r\n"]
[75.377729, "o", "    // The project's homepage\r\n"]
[75.414902, "o", "    \"project_url\": \"https://pandas.pydata.org/\",\r\n"]
[75.452075, "o", "\r\n"]
[75.489248, "o", "    // The URL of the source code repository for the project being\r\n"]
[75.526421, "o", "    // benchmarked\r\n"]
[75.563594, "o", "    \"repo\": \"..\",\r\n"]
[75.600767, "o", "\r\n"]
[75.63794, "o", "    // List of branches to benchmark. If not provided, defaults to \"master\"\r\n"]
[75.675113, "o", "    // (for git) or \"default\" (for mercurial).\r\n"]
[75.712286, "o", "    \"branches\": [\"main\"],\r\n"]
[75.749459, "o", "\r\n"]
[75.786632, "o", "    // The tool to use to create environments.  May be \"conda\",\r\n"]
[75.823805, "o", "    // \"virtualenv\" or other value depending on the plugins in use.\r\n"]
[75.860977, "o", "    // If missing or the empty string, the tool will be automatically\r\n"]
[75.89815, "o", "    // determined by looking for tools on the PATH environment\r\n"]
[75.935323, "o", "    // variable.\r\n"]
[75.972496, "o", "    \"environment_type\": \"conda\",\r\n"]
[76.009669, "o", "\r\n"]
[76.046842, "o", "    // the base URL to show a commit for the project.\r\n"]
[76.084015, "o", "    \"show_commit_url\": \"https://github.com/pandas-dev/pandas/commit/\",\r\n"]
[76.121188, "o", "\r\n"]
[76.158361, "o", "    // The Pythons you'd like to test against.  If not provided, defaults\r\n"]
[76.195534, "o", "    // to the current version of Python used to run `asv`.\r\n"]
[76.232707, "o", "    \"pythons\": [\"3.10\"],\r\n"]
[76.26988, "o", "\r\n"]
[76.307053, "o", "    // The matrix of dependencies to test.  Each key is the name of a\r\n"]
[76.344226, "o", "    // package (in PyPI) and the values are version numbers.  An empty\r\n"]
[76.381398, "o", "    // list or empty string indicates to just test against the default\r\n"]
[76.418571, "o", "    // (latest) version. null indicates that the package is to not be\r\n"]
[76.455744, "o", "    // installed. If the package to be tested is only available from\r\n"]
[76.492917, "o", "    // PyPi, and the 'environment_type' is conda, then you can preface\r\n"]
[76.53009, "o", "    // the package name by 'pip+', and the package will be installed via\r\n"]
[76.567263, "o", "    // pip (with all the conda available packages installed first,\r\n"]
[76.604436, "o", "    // followed by the pip installed packages).\r\n"]
[76.641609, "o", "    \"matrix\": {\r\n"]
[76.678782, "o", "        \"pip+build\": [],\r\n"]
[76.715955, "o", "        \"Cython\": [\"3.0\"],\r\n"]
[76.753128, "o", "        \"matplotlib\": [],\r\n"]
[76.790301, "o", "        \"sqlalchemy\": [],\r\n"]
[76.827474, "o", "        \"scipy\": [],\r\n"]
[76.864647, "o", "        \"numba\": [],\r\n"]
[76.90182, "o", "        \"numexpr\": [],\r\n"]
[76.938992, "o", "        \"pytables\": [null, \"\"],  // platform dependent, see excludes below\r\n"]
[76.976165, "o", "        \"pyarrow\": [],\r\n"]
[77.013338, "o", "        \"tables\": [null, \"\"],\r\n"]
[77.050511, "o", "        \"openpyxl\": [],\r\n"]
[77.087684, "o", "        \"xlsxwriter\": [],\r\n"]
[77.124857, "o", "        \"xlrd\": [],\r\n"]
[77.16203, "o", "        \"odfpy\": [],\r\n"]
[77.199203, "o", "        \"jinja2\": [],\r\n"]
[77.236376, "o", "        \"meson\": [],\r\n"]
[77.273549, "o", "        \"meson-python\": [],\r\n"]
[77.310722, "o", "        \"python-build\": [],\r\n"]
[77.347895, "o", "    },\r\n"]
[77.385068, "o", "    \"conda_channels\": [\"conda-forge\"],\r\n"]
[77.422241, "o", "    // Combinations of libraries/python versions can be excluded/included\r\n"]
[77.459414, "o", "    // from the set to test. Each entry is a dictionary containing additional\r\n"]
[77.496586, "o", "    // key-value pairs to include/exclude.\r\n"]
[77.533759, "o", "    //\r\n"]
[77.570932, "o", "    // An exclude entry excludes entries where all values match. The\r\n"]
[77.608105, "o", "    // values are regexps that should match the whole string.\r\n"]
[77.645278, "o", "    //\r\n"]
[77.682451, "o", "    // An include entry adds an environment. Only the packages listed\r\n"]
[77.719624, "o", "    // are installed. The 'python' key is required. The exclude rules\r\n"]
[77.756797, "o", "    // do not apply to includes.\r\n"]
[77.79397, "o", "    //\r\n"]
[77.831143, "o", "    // In addition to package names, the following keys are available:\r\n"]
[77.868316, "o", "    //\r\n"]
[77.905489, "o", "    // - python\r\n"]
[77.942662, "o", "    //     Python version, as in the *pythons* variable above.\r\n"]
[77.979835, "o", "    // - environment_type\r\n"]
[78.017008, "o", "    //     Environment type, as above.\r\n"]
[78.05418, "o", "    // - sys_platform\r\n"]
[78.091353, "o", "    //     Platform, as in sys.platform. Possible values for the common\r\n"]
[78.128526, "o", "    //     cases: 'linux2', 'win32', 'cygwin', 'darwin'.\r\n"]
[78.165699, "o", "    \"exclude\": [\r\n"]
[78.202872, "o", "        // On conda install pytables, otherwise tables\r\n"]
[78.240045, "o", "        {\"environment_type\": \"conda\", \"tables\": \"\"},\r\n"]
[78.277218, "o", "        {\"environment_type\": \"conda\", \"pytables\": null},\r\n"]
[78.314391, "o", "        {\"environment_type\": \"(?!conda).*\", \"tables\": null},\r\n"]
[78.351564, "o", "        {\"environment_type\": \"(?!conda).*\", \"pytables\": \"\"},\r\n"]
[78.388737, "o", "    ],\r\n"]
[78.42591, "o", "    \"include\": [],\r\n"]
[78.463083, "o", "\r\n"]
[78.500256, "o", "    // The directory (relative to the current directory) that benchmarks are\r\n"]
[78.537429, "o", "    // stored in.  If not provided, defaults to \"benchmarks\"\r\n"]
[78.574602, "o", "    // \"benchmark_dir\": \"benchmarks\",\r\n"]
[78.611774, "o", "\r\n"]
[78.648947, "o", "    // The directory (relative to the current directory) to cache the Python\r\n"]
[78.68612, "o", "    // environments in.  If not provided, defaults to \"env\"\r\n"]
[78.723293, "o", "    // \"env_dir\": \"env\",\r\n"]
[78.760466, "o", "\r\n"]
[78.797639, "o", "    // The directory (relative to the current directory) that raw benchmark\r\n"]
[78.834812, "o", "    // results are stored in.  If not provided, defaults to \"results\".\r\n"]
[78.871985, "o", "    // \"results_dir\": \"results\",\r\n"]
[78.909158, "o", "\r\n"]
[78.946331, "o", "    // The directory (relative to the current directory) that the html tree\r\n"]
[78.983504, "o", "    // should be written to.  If not provided, defaults to \"html\".\r\n"]
[79.020677, "o", "    // \"html_dir\": \"html\",\r\n"]
[79.05785, "o", "\r\n"]
[79.095023, "o", "    // The number of characters to retain in the commit hashes.\r\n"]
[79.132195, "o", "    // \"hash_length\": 8,\r\n"]
[79.169368, "o", "\r\n"]
[79.206541, "o", "    // `asv` will cache wheels of the recent builds in each\r\n"]
[79.243714, "o", "    // environment, making them faster to install next time.  This is\r\n"]
[79.280887, "o", "    // number of builds to keep, per environment.\r\n"]
[79.31806, "o", "    \"build_cache_size\": 8,\r\n"]
[79.355233, "o", "\r\n"]
[79.392406, "o", "    // The commits after which the regression search in `asv publish`\r\n"]
[79.429579, "o", "    // should start looking for regressions. Dictionary whose keys are\r\n"]
[79.466752, "o", "    // regexps matching to benchmark names, and values corresponding to\r\n"]
[79.503925, "o", "    // the commit (exclusive) after which to start looking for\r\n"]
[79.541098, "o", "    // regressions.  The default is to start from the first commit\r\n"]
[79.578271, "o", "    // with results. If the commit is `null`, regression detection is\r\n"]
[79.615444, "o", "    // skipped for the matching benchmark.\r\n"]
[79.652617, "o", "    //\r\n"]
[79.689789, "o", "    \"regressions_first_commits\": {\r\n"]
[79.726962, "o", "        \".*\": \"0409521665\"\r\n"]
[79.764135, "o", "    },\r\n"]
[79.801308, "o", "    \"regression_thresholds\": {\r\n"]
[79.838481, "o", "    },\r\n"]
[79.875654, "o", "    \"build_command\":\r\n"]
[79.912827, "o", "    [\"python -m build -Cbuilddir=builddir --wheel --outdir {build_cache_dir} {build_dir}\"]\r\n"]
[80.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[80.002, "i", "asv run --python=same --config=asv_bench/asv.conf.json --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[80.004, "o", "asv run --python=same --config=asv_bench/asv.conf.json --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[82.478, "o", "\u001b[?2004l\r\n"]
[85.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[85.002, "i", "ls -la pandas\r"]
[85.004, "o", "ls -la pandas\r\n"]
[85.220957, "o", "\u001b[?2004l\r\n"]
[85.435913, "o", "total 176\r\n"]
[85.65087, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[0m\u001b[01;34m.\u001b[0m\r\n"]
[85.865826, "o", "drwxr-xr-x 1 root root  4096 Oct  1 17:04 \u001b[01;34m..\u001b[0m\r\n"]
[86.080783, "o", "-rw-r--r-- 1 root root  8202 Sep 13 21:47 __init__.py\r\n"]
[86.295739, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34m_config\u001b[0m\r\n"]
[86.510696, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34m_libs\u001b[0m\r\n"]
[86.725652, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34m_testing\u001b[0m\r\n"]
[86.940609, "o", "-rw-r--r-- 1 root root 14590 Sep 13 21:47 _typing.py\r\n"]
[87.155565, "o", "-rw-r--r-- 1 root root 23611 Sep 13 21:47 _version.py\r\n"]
[87.370522, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mapi\u001b[0m\r\n"]
[87.585478, "o", "drwxr-xr-x 2 root root  4096 Sep 13 21:47 \u001b[01;34marrays\u001b[0m\r\n"]
[87.800435, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mcompat\u001b[0m\r\n"]
[88.015391, "o", "-rw-r--r-- 1 root root 49704 Sep 13 21:47 conftest.py\r\n"]
[88.230348, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mcore\u001b[0m\r\n"]
[88.445304, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34merrors\u001b[0m\r\n"]
[88.660261, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mio\u001b[0m\r\n"]
[88.875217, "o", "-rw-r--r-- 1 root root   994 Sep 13 21:47 meson.build\r\n"]
[89.090174, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mplotting\u001b[0m\r\n"]
[89.30513, "o", "-rw-r--r-- 1 root root   312 Sep 13 21:47 testing.py\r\n"]
[89.520087, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mtests\u001b[0m\r\n"]
[89.735043, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:47 \u001b[01;34mtseries\u001b[0m\r\n"]
[90.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[90.002, "i", "find pandas -maxdepth 2 -type d -name \"core\" -o -name \"_libs\"\r"]
[90.004, "o", "find pandas -maxdepth 2 -type d -name \"core\" -o -name \"_libs\"\r\n"]
[91.654, "o", "\u001b[?2004l\r\n"]
[93.302, "o", "pandas/core\r\n"]
[95.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[95.002, "i", "sed -n '140,230p' asv_bench/benchmarks/indexing.py\r"]
[95.004, "o", "sed -n '140,230p' asv_bench/benchmarks/indexing.py\r\n"]
[95.059739, "o", "\u001b[?2004l\r\n"]
[95.113478, "o", "\r\n"]
[95.167217, "o", "    def time_getitem_label_slice(self, index, index_structure):\r\n"]
[95.220957, "o", "        self.s[: self.lbl]\r\n"]
[95.274696, "o", "\r\n"]
[95.328435, "o", "    def time_getitem_pos_slice(self, index, index_structure):\r\n"]
[95.382174, "o", "        self.s[:80000]\r\n"]
[95.435913, "o", "\r\n"]
[95.489652, "o", "    def time_getitem_scalar(self, index, index_structure):\r\n"]
[95.543391, "o", "        self.s[self.lbl]\r\n"]
[95.59713, "o", "\r\n"]
[95.65087, "o", "    def time_getitem_list_like(self, index, index_structure):\r\n"]
[95.704609, "o", "        self.s[[self.lbl]]\r\n"]
[95.758348, "o", "\r\n"]
[95.812087, "o", "\r\n"]
[95.865826, "o", "class DataFrameStringIndexing:\r\n"]
[95.919565, "o", "    def setup(self):\r\n"]
[95.973304, "o", "        index = Index([f\"i-{i}\" for i in range(1000)], dtype=object)\r\n"]
[96.027043, "o", "        columns = Index([f\"i-{i}\" for i in range(30)], dtype=object)\r\n"]
[96.080783, "o", "        with warnings.catch_warnings(record=True):\r\n"]
[96.134522, "o", "            self.df = DataFrame(np.random.randn(1000, 30), index=index, columns=columns)\r\n"]
[96.188261, "o", "        self.idx_scalar = index[100]\r\n"]
[96.242, "o", "        self.col_scalar = columns[10]\r\n"]
[96.295739, "o", "        self.bool_indexer = self.df[self.col_scalar] > 0\r\n"]
[96.349478, "o", "        self.bool_obj_indexer = self.bool_indexer.astype(object)\r\n"]
[96.403217, "o", "        self.boolean_indexer = (self.df[self.col_scalar] > 0).astype(\"boolean\")\r\n"]
[96.456957, "o", "\r\n"]
[96.510696, "o", "    def time_loc(self):\r\n"]
[96.564435, "o", "        self.df.loc[self.idx_scalar, self.col_scalar]\r\n"]
[96.618174, "o", "\r\n"]
[96.671913, "o", "    def time_at(self):\r\n"]
[96.725652, "o", "        self.df.at[self.idx_scalar, self.col_scalar]\r\n"]
[96.779391, "o", "\r\n"]
[96.83313, "o", "    def time_at_setitem(self):\r\n"]
[96.88687, "o", "        self.df.at[self.idx_scalar, self.col_scalar] = 0.0\r\n"]
[96.940609, "o", "\r\n"]
[96.994348, "o", "    def time_getitem_scalar(self):\r\n"]
[97.048087, "o", "        self.df[self.col_scalar][self.idx_scalar]\r\n"]
[97.101826, "o", "\r\n"]
[97.155565, "o", "    def time_boolean_rows(self):\r\n"]
[97.209304, "o", "        self.df[self.bool_indexer]\r\n"]
[97.263043, "o", "\r\n"]
[97.316783, "o", "    def time_boolean_rows_object(self):\r\n"]
[97.370522, "o", "        self.df[self.bool_obj_indexer]\r\n"]
[97.424261, "o", "\r\n"]
[97.478, "o", "    def time_boolean_rows_boolean(self):\r\n"]
[97.531739, "o", "        self.df[self.boolean_indexer]\r\n"]
[97.585478, "o", "\r\n"]
[97.639217, "o", "\r\n"]
[97.692957, "o", "class DataFrameNumericIndexing:\r\n"]
[97.746696, "o", "    params = [\r\n"]
[97.800435, "o", "        (np.int64, np.uint64, np.float64),\r\n"]
[97.854174, "o", "        (\"unique_monotonic_inc\", \"nonunique_monotonic_inc\"),\r\n"]
[97.907913, "o", "    ]\r\n"]
[97.961652, "o", "    param_names = [\"dtype\", \"index_structure\"]\r\n"]
[98.015391, "o", "\r\n"]
[98.06913, "o", "    def setup(self, dtype, index_structure):\r\n"]
[98.12287, "o", "        N = 10**5\r\n"]
[98.176609, "o", "        indices = {\r\n"]
[98.230348, "o", "            \"unique_monotonic_inc\": Index(range(N), dtype=dtype),\r\n"]
[98.284087, "o", "            \"nonunique_monotonic_inc\": Index(\r\n"]
[98.337826, "o", "                list(range(55)) + [54] + list(range(55, N - 1)), dtype=dtype\r\n"]
[98.391565, "o", "            ),\r\n"]
[98.445304, "o", "        }\r\n"]
[98.499043, "o", "        self.idx_dupe = np.array(range(30)) * 99\r\n"]
[98.552783, "o", "        self.df = DataFrame(np.random.randn(N, 5), index=indices[index_structure])\r\n"]
[98.606522, "o", "        self.df_dup = concat([self.df, 2 * self.df, 3 * self.df])\r\n"]
[98.660261, "o", "        self.bool_indexer = [True] * (N // 2) + [False] * (N - N // 2)\r\n"]
[98.714, "o", "\r\n"]
[98.767739, "o", "    def time_iloc_dups(self, index, index_structure):\r\n"]
[98.821478, "o", "        self.df_dup.iloc[self.idx_dupe]\r\n"]
[98.875217, "o", "\r\n"]
[98.928957, "o", "    def time_loc_dups(self, index, index_structure):\r\n"]
[98.982696, "o", "        self.df_dup.loc[self.idx_dupe]\r\n"]
[99.036435, "o", "\r\n"]
[99.090174, "o", "    def time_iloc(self, index, index_structure):\r\n"]
[99.143913, "o", "        self.df.iloc[:100, 0]\r\n"]
[99.197652, "o", "\r\n"]
[99.251391, "o", "    def time_loc(self, index, index_structure):\r\n"]
[99.30513, "o", "        self.df.loc[:100, 0]\r\n"]
[99.35887, "o", "\r\n"]
[99.412609, "o", "    def time_bool_indexer(self, index, index_structure):\r\n"]
[99.466348, "o", "        self.df[self.bool_indexer]\r\n"]
[99.520087, "o", "\r\n"]
[99.573826, "o", "\r\n"]
[99.627565, "o", "class Take:\r\n"]
[99.681304, "o", "    params = [\"int\", \"datetime\"]\r\n"]
[99.735043, "o", "    param_names = [\"index\"]\r\n"]
[99.788783, "o", "\r\n"]
[99.842522, "o", "    def setup(self, index):\r\n"]
[99.896261, "o", "        N = 100000\r\n"]
[100.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo# "]
[100.002, "i", "cd asv_bench\r"]
[100.004, "o", "cd asv_bench\r\n"]
[100.006, "o", "\u001b[?2004l\r\n"]
[105.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[105.002, "i", "ls -la\r"]
[105.004, "o", "ls -la\r\n"]
[105.83, "o", "\u001b[?2004l\r\n"]
[106.654, "o", "total 24\r\n"]
[107.478, "o", "drwxr-xr-x 1 root root 4096 Sep 13 21:47 \u001b[0m\u001b[01;34m.\u001b[0m\r\n"]
[108.302, "o", "drwxr-xr-x 1 root root 4096 Oct  1 17:04 \u001b[01;34m..\u001b[0m\r\n"]
[109.126, "o", "-rw-r--r-- 1 root root 5194 Sep 13 21:47 asv.conf.json\r\n"]
[110.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[110.002, "i", "sed -n '1,120p' asv.conf.json\r"]
[110.004, "o", "sed -n '1,120p' asv.conf.json\r\n"]
[110.04686, "o", "\u001b[?2004l\r\n"]
[110.087719, "o", "{\r\n"]
[110.128579, "o", "    // The version of the config file format.  Do not change, unless\r\n"]
[110.169438, "o", "    // you know what you are doing.\r\n"]
[110.210298, "o", "    \"version\": 1,\r\n"]
[110.251157, "o", "\r\n"]
[110.292017, "o", "    // The name of the project being benchmarked\r\n"]
[110.332876, "o", "    \"project\": \"pandas\",\r\n"]
[110.373736, "o", "\r\n"]
[110.414595, "o", "    // The project's homepage\r\n"]
[110.455455, "o", "    \"project_url\": \"https://pandas.pydata.org/\",\r\n"]
[110.496314, "o", "\r\n"]
[110.537174, "o", "    // The URL of the source code repository for the project being\r\n"]
[110.578033, "o", "    // benchmarked\r\n"]
[110.618893, "o", "    \"repo\": \"..\",\r\n"]
[110.659752, "o", "\r\n"]
[110.700612, "o", "    // List of branches to benchmark. If not provided, defaults to \"master\"\r\n"]
[110.741471, "o", "    // (for git) or \"default\" (for mercurial).\r\n"]
[110.782331, "o", "    \"branches\": [\"main\"],\r\n"]
[110.82319, "o", "\r\n"]
[110.86405, "o", "    // The tool to use to create environments.  May be \"conda\",\r\n"]
[110.904909, "o", "    // \"virtualenv\" or other value depending on the plugins in use.\r\n"]
[110.945769, "o", "    // If missing or the empty string, the tool will be automatically\r\n"]
[110.986628, "o", "    // determined by looking for tools on the PATH environment\r\n"]
[111.027488, "o", "    // variable.\r\n"]
[111.068347, "o", "    \"environment_type\": \"conda\",\r\n"]
[111.109207, "o", "\r\n"]
[111.150066, "o", "    // the base URL to show a commit for the project.\r\n"]
[111.190926, "o", "    \"show_commit_url\": \"https://github.com/pandas-dev/pandas/commit/\",\r\n"]
[111.231785, "o", "\r\n"]
[111.272645, "o", "    // The Pythons you'd like to test against.  If not provided, defaults\r\n"]
[111.313504, "o", "    // to the current version of Python used to run `asv`.\r\n"]
[111.354364, "o", "    \"pythons\": [\"3.10\"],\r\n"]
[111.395223, "o", "\r\n"]
[111.436083, "o", "    // The matrix of dependencies to test.  Each key is the name of a\r\n"]
[111.476942, "o", "    // package (in PyPI) and the values are version numbers.  An empty\r\n"]
[111.517802, "o", "    // list or empty string indicates to just test against the default\r\n"]
[111.558661, "o", "    // (latest) version. null indicates that the package is to not be\r\n"]
[111.599521, "o", "    // installed. If the package to be tested is only available from\r\n"]
[111.64038, "o", "    // PyPi, and the 'environment_type' is conda, then you can preface\r\n"]
[111.68124, "o", "    // the package name by 'pip+', and the package will be installed via\r\n"]
[111.722099, "o", "    // pip (with all the conda available packages installed first,\r\n"]
[111.762959, "o", "    // followed by the pip installed packages).\r\n"]
[111.803818, "o", "    \"matrix\": {\r\n"]
[111.844678, "o", "        \"pip+build\": [],\r\n"]
[111.885537, "o", "        \"Cython\": [\"3.0\"],\r\n"]
[111.926397, "o", "        \"matplotlib\": [],\r\n"]
[111.967256, "o", "        \"sqlalchemy\": [],\r\n"]
[112.008116, "o", "        \"scipy\": [],\r\n"]
[112.048975, "o", "        \"numba\": [],\r\n"]
[112.089835, "o", "        \"numexpr\": [],\r\n"]
[112.130694, "o", "        \"pytables\": [null, \"\"],  // platform dependent, see excludes below\r\n"]
[112.171554, "o", "        \"pyarrow\": [],\r\n"]
[112.212413, "o", "        \"tables\": [null, \"\"],\r\n"]
[112.253273, "o", "        \"openpyxl\": [],\r\n"]
[112.294132, "o", "        \"xlsxwriter\": [],\r\n"]
[112.334992, "o", "        \"xlrd\": [],\r\n"]
[112.375851, "o", "        \"odfpy\": [],\r\n"]
[112.416711, "o", "        \"jinja2\": [],\r\n"]
[112.45757, "o", "        \"meson\": [],\r\n"]
[112.49843, "o", "        \"meson-python\": [],\r\n"]
[112.539289, "o", "        \"python-build\": [],\r\n"]
[112.580149, "o", "    },\r\n"]
[112.621008, "o", "    \"conda_channels\": [\"conda-forge\"],\r\n"]
[112.661868, "o", "    // Combinations of libraries/python versions can be excluded/included\r\n"]
[112.702727, "o", "    // from the set to test. Each entry is a dictionary containing additional\r\n"]
[112.743587, "o", "    // key-value pairs to include/exclude.\r\n"]
[112.784446, "o", "    //\r\n"]
[112.825306, "o", "    // An exclude entry excludes entries where all values match. The\r\n"]
[112.866165, "o", "    // values are regexps that should match the whole string.\r\n"]
[112.907025, "o", "    //\r\n"]
[112.947884, "o", "    // An include entry adds an environment. Only the packages listed\r\n"]
[112.988744, "o", "    // are installed. The 'python' key is required. The exclude rules\r\n"]
[113.029603, "o", "    // do not apply to includes.\r\n"]
[113.070463, "o", "    //\r\n"]
[113.111322, "o", "    // In addition to package names, the following keys are available:\r\n"]
[113.152182, "o", "    //\r\n"]
[113.193041, "o", "    // - python\r\n"]
[113.233901, "o", "    //     Python version, as in the *pythons* variable above.\r\n"]
[113.27476, "o", "    // - environment_type\r\n"]
[113.31562, "o", "    //     Environment type, as above.\r\n"]
[113.356479, "o", "    // - sys_platform\r\n"]
[113.397339, "o", "    //     Platform, as in sys.platform. Possible values for the common\r\n"]
[113.438198, "o", "    //     cases: 'linux2', 'win32', 'cygwin', 'darwin'.\r\n"]
[113.479058, "o", "    \"exclude\": [\r\n"]
[113.519917, "o", "        // On conda install pytables, otherwise tables\r\n"]
[113.560777, "o", "        {\"environment_type\": \"conda\", \"tables\": \"\"},\r\n"]
[113.601636, "o", "        {\"environment_type\": \"conda\", \"pytables\": null},\r\n"]
[113.642496, "o", "        {\"environment_type\": \"(?!conda).*\", \"tables\": null},\r\n"]
[113.683355, "o", "        {\"environment_type\": \"(?!conda).*\", \"pytables\": \"\"},\r\n"]
[113.724215, "o", "    ],\r\n"]
[113.765074, "o", "    \"include\": [],\r\n"]
[113.805934, "o", "\r\n"]
[113.846793, "o", "    // The directory (relative to the current directory) that benchmarks are\r\n"]
[113.887653, "o", "    // stored in.  If not provided, defaults to \"benchmarks\"\r\n"]
[113.928512, "o", "    // \"benchmark_dir\": \"benchmarks\",\r\n"]
[113.969372, "o", "\r\n"]
[114.010231, "o", "    // The directory (relative to the current directory) to cache the Python\r\n"]
[114.051091, "o", "    // environments in.  If not provided, defaults to \"env\"\r\n"]
[114.09195, "o", "    // \"env_dir\": \"env\",\r\n"]
[114.13281, "o", "\r\n"]
[114.173669, "o", "    // The directory (relative to the current directory) that raw benchmark\r\n"]
[114.214529, "o", "    // results are stored in.  If not provided, defaults to \"results\".\r\n"]
[114.255388, "o", "    // \"results_dir\": \"results\",\r\n"]
[114.296248, "o", "\r\n"]
[114.337107, "o", "    // The directory (relative to the current directory) that the html tree\r\n"]
[114.377967, "o", "    // should be written to.  If not provided, defaults to \"html\".\r\n"]
[114.418826, "o", "    // \"html_dir\": \"html\",\r\n"]
[114.459686, "o", "\r\n"]
[114.500545, "o", "    // The number of characters to retain in the commit hashes.\r\n"]
[114.541405, "o", "    // \"hash_length\": 8,\r\n"]
[114.582264, "o", "\r\n"]
[114.623124, "o", "    // `asv` will cache wheels of the recent builds in each\r\n"]
[114.663983, "o", "    // environment, making them faster to install next time.  This is\r\n"]
[114.704843, "o", "    // number of builds to keep, per environment.\r\n"]
[114.745702, "o", "    \"build_cache_size\": 8,\r\n"]
[114.786562, "o", "\r\n"]
[114.827421, "o", "    // The commits after which the regression search in `asv publish`\r\n"]
[114.868281, "o", "    // should start looking for regressions. Dictionary whose keys are\r\n"]
[114.90914, "o", "    // regexps matching to benchmark names, and values corresponding to\r\n"]
[115.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[115.002, "i", "asv dev -b \"indexing.DataFrameStringIndexing.*\"\r"]
[115.004, "o", "asv dev -b \"indexing.DataFrameStringIndexing.*\"\r\n"]
[116.242, "o", "\u001b[?2004l\r\n"]
[117.478, "o", "usage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n"]
[118.714, "o", "           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\n"]
[120.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[120.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[120.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[120.418, "o", "\u001b[?2004l\r\n"]
[120.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[121.242, "o", "\u00b7 \u001b[0;32mRunning 7 total benchmarks (1 commits * 1 environments * 7 benchmarks)\u001b[0m\r\n"]
[121.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[122.066, "o", "[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_at--)\u001b[0m.......\r\n"]
[122.478, "o", "[57.14%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at\u001b[0m                                                                                                12.6\u00b10.2\u03bcs\r\n"]
[122.89, "o", "[64.29%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at_setitem\u001b[0m                                                                                        12.3\u00b10.5\u03bcs\r\n"]
[123.302, "o", "[71.43%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows\u001b[0m                                                                                         120\u00b12\u03bcs\r\n"]
[123.714, "o", "[78.57%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_boolean\u001b[0m                                                                               116\u00b10.6\u03bcs\r\n"]
[124.126, "o", "[85.71%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                  170\u00b11\u03bcs\r\n"]
[124.538, "o", "[92.86%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_getitem_scalar\u001b[0m                                                                                    14.2\u00b10.2\u03bcs\r\n"]
[125.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[125.002, "i", "asv profile --python=same indexing.DataFrameStringIndexing.time_boolean_rows_object\r"]
[125.004, "o", "asv profile --python=same indexing.DataFrameStringIndexing.time_boolean_rows_object\r\n"]
[125.042896, "o", "\u001b[?2004l\r\n"]
[125.079791, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[125.116687, "o", "\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n"]
[125.153582, "o", "\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[125.190478, "o", "\u00b7\u00b7\u00b7 \u001b[0;39mImporting benchmark suite produced output:\u001b[0m\r\n"]
[125.227373, "o", "\u00b7\u00b7\u00b7\u00b7 \u001b[0;31m[1/1] Generating write_version_file with a custom command\u001b[0m\r\n"]
[125.264269, "o", "     + /opt/conda/envs/asv_3.10/bin/ninja\r\n"]
[125.301164, "o", "\r\n"]
[125.33806, "o", "\u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_boolean_rows_object--)\u001b[0m.\r\n"]
[125.374955, "o", "\u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                  169\u00b12\u03bcs\r\n"]
[125.411851, "o", "\r\n"]
[125.448746, "o", "Wed Oct  1 17:11:58 2025    /tmp/tmp7pjmy_pp\r\n"]
[125.485642, "o", "\r\n"]
[125.522537, "o", "         280 function calls (266 primitive calls) in 0.000 seconds\r\n"]
[125.559433, "o", "\r\n"]
[125.596328, "o", "   Ordered by: cumulative time\r\n"]
[125.633224, "o", "\r\n"]
[125.670119, "o", "   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n"]
[125.707015, "o", "        1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}\r\n"]
[125.74391, "o", "        1    0.000    0.000    0.000    0.000 _base.py:689(method_caller)\r\n"]
[125.780806, "o", "        1    0.000    0.000    0.000    0.000 indexing.py:181(time_boolean_rows_object)\r\n"]
[125.817701, "o", "        1    0.000    0.000    0.000    0.000 frame.py:3861(__getitem__)\r\n"]
[125.854597, "o", "        1    0.000    0.000    0.000    0.000 frame.py:3931(_getitem_bool_array)\r\n"]
[125.891493, "o", "      7/5    0.000    0.000    0.000    0.000 {built-in method numpy.asarray}\r\n"]
[125.928388, "o", "        1    0.000    0.000    0.000    0.000 generic.py:3870(take)\r\n"]
[125.965284, "o", "        1    0.000    0.000    0.000    0.000 common.py:101(is_bool_indexer)\r\n"]
[126.002179, "o", "        1    0.000    0.000    0.000    0.000 managers.py:1013(take)\r\n"]
[126.039075, "o", "        4    0.000    0.000    0.000    0.000 generic.py:6022(__getattr__)\r\n"]
[126.07597, "o", "        4    0.000    0.000    0.000    0.000 base.py:5058(_can_hold_identifiers_and_holds_name)\r\n"]
[126.112866, "o", "        4    0.000    0.000    0.000    0.000 base.py:4944(__contains__)\r\n"]
[126.149761, "o", "        1    0.000    0.000    0.000    0.000 indexing.py:2612(check_bool_indexer)\r\n"]
[126.186657, "o", "        1    0.000    0.000    0.000    0.000 managers.py:775(reindex_indexer)\r\n"]
[126.223552, "o", "        1    0.000    0.000    0.000    0.000 base.py:1138(take)\r\n"]
[126.260448, "o", "        1    0.000    0.000    0.000    0.000 managers.py:828(<listcomp>)\r\n"]
[126.297343, "o", "        2    0.000    0.000    0.000    0.000 series.py:799(__array__)\r\n"]
[126.334239, "o", "        1    0.000    0.000    0.000    0.000 blocks.py:988(take_nd)\r\n"]
[126.371134, "o", "        1    0.000    0.000    0.000    0.000 take.py:57(take_nd)\r\n"]
[126.40803, "o", "        1    0.000    0.000    0.000    0.000 take.py:118(_take_nd_ndarray)\r\n"]
[126.444925, "o", "        1    0.000    0.000    0.000    0.000 base.py:837(_engine)\r\n"]
[126.481821, "o", "        1    0.000    0.000    0.000    0.000 base.py:644(_simple_new)\r\n"]
[126.518716, "o", "    51/49    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n"]
[126.555612, "o", "        6    0.000    0.000    0.000    0.000 common.py:137(is_object_dtype)\r\n"]
[126.592507, "o", "        1    0.000    0.000    0.000    0.000 utils.py:240(maybe_convert_indices)\r\n"]
[126.629403, "o", "        6    0.000    0.000    0.000    0.000 common.py:1438(_is_dtype_type)\r\n"]
[126.666299, "o", "        1    0.000    0.000    0.000    0.000 utils.py:420(check_array_indexer)\r\n"]
[126.703194, "o", "        1    0.000    0.000    0.000    0.000 {method 'all' of 'numpy.ndarray' objects}\r\n"]
[126.74009, "o", "        1    0.000    0.000    0.000    0.000 _methods.py:68(_all)\r\n"]
[126.776985, "o", "        3    0.000    0.000    0.000    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n"]
[126.813881, "o", "     19/9    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n"]
[126.850776, "o", "        1    0.000    0.000    0.000    0.000 algorithms.py:1074(take)\r\n"]
[126.887672, "o", "        1    0.000    0.000    0.000    0.000 base.py:4790(_get_engine_target)\r\n"]
[126.924567, "o", "        1    0.000    0.000    0.000    0.000 take.py:516(_take_preprocess_indexer_and_fill_value)\r\n"]
[126.961463, "o", "        1    0.000    0.000    0.000    0.000 generic.py:5974(__finalize__)\r\n"]
[126.998358, "o", "        1    0.000    0.000    0.000    0.000 {method 'take' of 'numpy.ndarray' objects}\r\n"]
[127.035254, "o", "        2    0.000    0.000    0.000    0.000 {method 'any' of 'numpy.ndarray' objects}\r\n"]
[127.072149, "o", "        1    0.000    0.000    0.000    0.000 cast.py:549(maybe_promote)\r\n"]
[127.109045, "o", "        4    0.000    0.000    0.000    0.000 generic.py:43(_instancecheck)\r\n"]
[127.14594, "o", "        1    0.000    0.000    0.000    0.000 frame.py:658(_constructor_from_mgr)\r\n"]
[127.182836, "o", "        1    0.000    0.000    0.000    0.000 managers.py:212(shape)\r\n"]
[127.219731, "o", "        2    0.000    0.000    0.000    0.000 _methods.py:59(_any)\r\n"]
[127.256627, "o", "        3    0.000    0.000    0.000    0.000 series.py:619(dtype)\r\n"]
[127.293522, "o", "        1    0.000    0.000    0.000    0.000 generic.py:290(_from_mgr)\r\n"]
[127.330418, "o", "        3    0.000    0.000    0.000    0.000 abc.py:117(__instancecheck__)\r\n"]
[127.367313, "o", "        1    0.000    0.000    0.000    0.000 common.py:536(is_string_dtype)\r\n"]
[127.404209, "o", "        1    0.000    0.000    0.000    0.000 common.py:1202(is_bool_dtype)\r\n"]
[127.441104, "o", "        2    0.000    0.000    0.000    0.000 astype.py:246(astype_is_view)\r\n"]
[127.478, "o", "        3    0.000    0.000    0.000    0.000 managers.py:2124(dtype)\r\n"]
[127.514896, "o", "        1    0.000    0.000    0.000    0.000 generic.py:254(__init__)\r\n"]
[127.551791, "o", "        1    0.000    0.000    0.000    0.000 blocks.py:204(fill_value)\r\n"]
[127.588687, "o", "        4    0.000    0.000    0.000    0.000 generic.py:38(_check)\r\n"]
[127.625582, "o", "        1    0.000    0.000    0.000    0.000 inference.py:333(is_hashable)\r\n"]
[127.662478, "o", "        1    0.000    0.000    0.000    0.000 series.py:791(__len__)\r\n"]
[127.699373, "o", "        4    0.000    0.000    0.000    0.000 generic.py:609(_info_axis)\r\n"]
[127.736269, "o", "        6    0.000    0.000    0.000    0.000 common.py:123(<lambda>)\r\n"]
[127.773164, "o", "        7    0.000    0.000    0.000    0.000 base.py:906(__len__)\r\n"]
[127.81006, "o", "        1    0.000    0.000    0.000    0.000 indexing.py:2745(check_dict_or_set_indexers)\r\n"]
[127.846955, "o", "        1    0.000    0.000    0.000    0.000 common.py:1379(_is_dtype)\r\n"]
[127.883851, "o", "        1    0.000    0.000    0.000    0.000 base.py:451(_engine_type)\r\n"]
[127.920746, "o", "        3    0.000    0.000    0.000    0.000 managers.py:214(<genexpr>)\r\n"]
[127.957642, "o", "        1    0.000    0.000    0.000    0.000 {method 'nonzero' of 'numpy.ndarray' objects}\r\n"]
[127.994537, "o", "        1    0.000    0.000    0.000    0.000 managers.py:208(__len__)\r\n"]
[128.031433, "o", "        1    0.000    0.000    0.000    0.000 base.py:2401(_na_value)\r\n"]
[128.068328, "o", "        2    0.000    0.000    0.000    0.000 series.py:747(_values)\r\n"]
[128.105224, "o", "        1    0.000    0.000    0.000    0.000 blocks.py:243(make_block_same_class)\r\n"]
[128.142119, "o", "        1    0.000    0.000    0.000    0.000 managers.py:1091(from_blocks)\r\n"]
[128.179015, "o", "        8    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n"]
[128.21591, "o", "        1    0.000    0.000    0.000    0.000 generic.py:534(_get_block_manager_axis)\r\n"]
[128.252806, "o", "        3    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n"]
[128.289701, "o", "        6    0.000    0.000    0.000    0.000 common.py:121(classes)\r\n"]
[128.326597, "o", "        1    0.000    0.000    0.000    0.000 frame.py:1589(__len__)\r\n"]
[128.363493, "o", "        2    0.000    0.000    0.000    0.000 {method 'copy' of 'numpy.ndarray' objects}\r\n"]
[128.400388, "o", "        2    0.000    0.000    0.000    0.000 common.py:1403(_get_dtype)\r\n"]
[128.437284, "o", "        1    0.000    0.000    0.000    0.000 common.py:1600(pandas_dtype)\r\n"]
[128.474179, "o", "        2    0.000    0.000    0.000    0.000 base.py:5173(equals)\r\n"]
[128.511075, "o", "        1    0.000    0.000    0.000    0.000 missing.py:600(na_value_for_dtype)\r\n"]
[128.54797, "o", "        3    0.000    0.000    0.000    0.000 {built-in method _abc._abc_instancecheck}\r\n"]
[128.584866, "o", "        1    0.000    0.000    0.000    0.000 {built-in method numpy.empty}\r\n"]
[128.621761, "o", "        1    0.000    0.000    0.000    0.000 flags.py:96(allows_duplicate_labels)\r\n"]
[128.658657, "o", "        2    0.000    0.000    0.000    0.000 managers.py:2135(internal_values)\r\n"]
[128.695552, "o", "        2    0.000    0.000    0.000    0.000 blocks.py:565(dtype)\r\n"]
[128.732448, "o", "        1    0.000    0.000    0.000    0.000 common.py:1044(needs_i8_conversion)\r\n"]
[128.769343, "o", "        1    0.000    0.000    0.000    0.000 flags.py:60(__init__)\r\n"]
[128.806239, "o", "        1    0.000    0.000    0.000    0.000 common.py:375(apply_if_callable)\r\n"]
[128.843134, "o", "        5    0.000    0.000    0.000    0.000 {built-in method builtins.hash}\r\n"]
[128.88003, "o", "        1    0.000    0.000    0.000    0.000 common.py:572(condition)\r\n"]
[128.916925, "o", "        7    0.000    0.000    0.000    0.000 {built-in method builtins.issubclass}\r\n"]
[128.953821, "o", "        1    0.000    0.000    0.000    0.000 take.py:265(_get_take_nd_function)\r\n"]
[128.990716, "o", "        4    0.000    0.000    0.000    0.000 base.py:4764(_values)\r\n"]
[129.027612, "o", "        2    0.000    0.000    0.000    0.000 {built-in method __new__ of type object at 0x55f519bb5640}\r\n"]
[129.064507, "o", "        1    0.000    0.000    0.000    0.000 inference.py:193(is_array_like)\r\n"]
[129.101403, "o", "        1    0.000    0.000    0.000    0.000 base.py:826(_reset_identity)\r\n"]
[129.138299, "o", "        1    0.000    0.000    0.000    0.000 generic.py:512(_get_axis_number)\r\n"]
[129.175194, "o", "        1    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n"]
[129.21209, "o", "        1    0.000    0.000    0.000    0.000 function.py:65(__call__)\r\n"]
[129.248985, "o", "        1    0.000    0.000    0.000    0.000 base.py:1640(name)\r\n"]
[129.285881, "o", "        1    0.000    0.000    0.000    0.000 base.py:1171(_maybe_disallow_fill)\r\n"]
[129.322776, "o", "        2    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n"]
[129.359672, "o", "        1    0.000    0.000    0.000    0.000 managers.py:297(items)\r\n"]
[129.396567, "o", "        1    0.000    0.000    0.000    0.000 base.py:687(_constructor)\r\n"]
[129.433463, "o", "        2    0.000    0.000    0.000    0.000 base.py:786(is_)\r\n"]
[129.470358, "o", "        1    0.000    0.000    0.000    0.000 common.py:529(is_string_or_object_np_dtype)\r\n"]
[129.507254, "o", "        1    0.000    0.000    0.000    0.000 managers.py:2061(_block)\r\n"]
[129.544149, "o", "        1    0.000    0.000    0.000    0.000 managers.py:220(blknos)\r\n"]
[129.581045, "o", "        2    0.000    0.000    0.000    0.000 generic.py:356(flags)\r\n"]
[129.61794, "o", "        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n"]
[129.654836, "o", "        1    0.000    0.000    0.000    0.000 managers.py:236(blklocs)\r\n"]
[129.691731, "o", "        1    0.000    0.000    0.000    0.000 base.py:974(dtype)\r\n"]
[129.728627, "o", "        1    0.000    0.000    0.000    0.000 generic.py:314(attrs)\r\n"]
[129.765522, "o", "        1    0.000    0.000    0.000    0.000 flags.py:64(allows_duplicate_labels)\r\n"]
[129.802418, "o", "        1    0.000    0.000    0.000    0.000 managers.py:1056(__init__)\r\n"]
[129.839313, "o", "        1    0.000    0.000    0.000    0.000 typing.py:1737(cast)\r\n"]
[129.876209, "o", "        1    0.000    0.000    0.000    0.000 {built-in method builtins.callable}\r\n"]
[129.913104, "o", "\r\n"]
[130.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[130.002, "i", "sed -n '3800,3980p' ../pandas/core/frame.py\r"]
[130.004, "o", "sed -n '3800,3980p' ../pandas/core/frame.py\r\n"]
[130.033165, "o", "\u001b[?2004l\r\n"]
[130.06033, "o", "        >>> df = pd.DataFrame({\"col1\": [1, 2], \"col2\": [3, 4]})\r\n"]
[130.087495, "o", "        >>> df\r\n"]
[130.114659, "o", "           col1  col2\r\n"]
[130.141824, "o", "        0     1     3\r\n"]
[130.168989, "o", "        1     2     4\r\n"]
[130.196154, "o", "\r\n"]
[130.223319, "o", "        >>> df.T\r\n"]
[130.250484, "o", "              0  1\r\n"]
[130.277648, "o", "        col1  1  2\r\n"]
[130.304813, "o", "        col2  3  4\r\n"]
[130.331978, "o", "        \"\"\"\r\n"]
[130.359143, "o", "        return self.transpose()\r\n"]
[130.386308, "o", "\r\n"]
[130.413473, "o", "    # ----------------------------------------------------------------------\r\n"]
[130.440637, "o", "    # Indexing Methods\r\n"]
[130.467802, "o", "\r\n"]
[130.494967, "o", "    def _ixs(self, i: int, axis: AxisInt = 0) -> Series:\r\n"]
[130.522132, "o", "        \"\"\"\r\n"]
[130.549297, "o", "        Parameters\r\n"]
[130.576462, "o", "        ----------\r\n"]
[130.603626, "o", "        i : int\r\n"]
[130.630791, "o", "        axis : int\r\n"]
[130.657956, "o", "\r\n"]
[130.685121, "o", "        Returns\r\n"]
[130.712286, "o", "        -------\r\n"]
[130.739451, "o", "        Series\r\n"]
[130.766615, "o", "        \"\"\"\r\n"]
[130.79378, "o", "        # irow\r\n"]
[130.820945, "o", "        if axis == 0:\r\n"]
[130.84811, "o", "            new_mgr = self._mgr.fast_xs(i)\r\n"]
[130.875275, "o", "\r\n"]
[130.90244, "o", "            result = self._constructor_sliced_from_mgr(new_mgr, axes=new_mgr.axes)\r\n"]
[130.929604, "o", "            result._name = self.index[i]\r\n"]
[130.956769, "o", "            return result.__finalize__(self)\r\n"]
[130.983934, "o", "\r\n"]
[131.011099, "o", "        # icol\r\n"]
[131.038264, "o", "        else:\r\n"]
[131.065429, "o", "            col_mgr = self._mgr.iget(i)\r\n"]
[131.092593, "o", "            return self._box_col_values(col_mgr, i)\r\n"]
[131.119758, "o", "\r\n"]
[131.146923, "o", "    def _get_column_array(self, i: int) -> ArrayLike:\r\n"]
[131.174088, "o", "        \"\"\"\r\n"]
[131.201253, "o", "        Get the values of the i'th column (ndarray or ExtensionArray, as stored\r\n"]
[131.228418, "o", "        in the Block)\r\n"]
[131.255582, "o", "\r\n"]
[131.282747, "o", "        Warning! The returned array is a view but doesn't handle Copy-on-Write,\r\n"]
[131.309912, "o", "        so this should be used with caution (for read-only purposes).\r\n"]
[131.337077, "o", "        \"\"\"\r\n"]
[131.364242, "o", "        return self._mgr.iget_values(i)\r\n"]
[131.391407, "o", "\r\n"]
[131.418571, "o", "    def _iter_column_arrays(self) -> Iterator[ArrayLike]:\r\n"]
[131.445736, "o", "        \"\"\"\r\n"]
[131.472901, "o", "        Iterate over the arrays of all columns in order.\r\n"]
[131.500066, "o", "        This returns the values as stored in the Block (ndarray or ExtensionArray).\r\n"]
[131.527231, "o", "\r\n"]
[131.554396, "o", "        Warning! The returned array is a view but doesn't handle Copy-on-Write,\r\n"]
[131.58156, "o", "        so this should be used with caution (for read-only purposes).\r\n"]
[131.608725, "o", "        \"\"\"\r\n"]
[131.63589, "o", "        for i in range(len(self.columns)):\r\n"]
[131.663055, "o", "            yield self._get_column_array(i)\r\n"]
[131.69022, "o", "\r\n"]
[131.717385, "o", "    def __getitem__(self, key):\r\n"]
[131.744549, "o", "        check_dict_or_set_indexers(key)\r\n"]
[131.771714, "o", "        key = lib.item_from_zerodim(key)\r\n"]
[131.798879, "o", "        key = com.apply_if_callable(key, self)\r\n"]
[131.826044, "o", "\r\n"]
[131.853209, "o", "        if is_hashable(key) and not is_iterator(key) and not isinstance(key, slice):\r\n"]
[131.880374, "o", "            # is_iterator to exclude generator e.g. test_getitem_listlike\r\n"]
[131.907538, "o", "            # As of Python 3.12, slice is hashable which breaks MultiIndex (GH#57500)\r\n"]
[131.934703, "o", "\r\n"]
[131.961868, "o", "            # shortcut if the key is in columns\r\n"]
[131.989033, "o", "            is_mi = isinstance(self.columns, MultiIndex)\r\n"]
[132.016198, "o", "            # GH#45316 Return view if key is not duplicated\r\n"]
[132.043363, "o", "            # Only use drop_duplicates with duplicates for performance\r\n"]
[132.070527, "o", "            if not is_mi and (\r\n"]
[132.097692, "o", "                self.columns.is_unique\r\n"]
[132.124857, "o", "                and key in self.columns\r\n"]
[132.152022, "o", "                or key in self.columns.drop_duplicates(keep=False)\r\n"]
[132.179187, "o", "            ):\r\n"]
[132.206352, "o", "                return self._get_item(key)\r\n"]
[132.233516, "o", "\r\n"]
[132.260681, "o", "            elif is_mi and self.columns.is_unique and key in self.columns:\r\n"]
[132.287846, "o", "                return self._getitem_multilevel(key)\r\n"]
[132.315011, "o", "\r\n"]
[132.342176, "o", "        # Do we have a slicer (on rows)?\r\n"]
[132.369341, "o", "        if isinstance(key, slice):\r\n"]
[132.396505, "o", "            return self._getitem_slice(key)\r\n"]
[132.42367, "o", "\r\n"]
[132.450835, "o", "        # Do we have a (boolean) DataFrame?\r\n"]
[132.478, "o", "        if isinstance(key, DataFrame):\r\n"]
[132.505165, "o", "            return self.where(key)\r\n"]
[132.53233, "o", "\r\n"]
[132.559495, "o", "        # Do we have a (boolean) 1d indexer?\r\n"]
[132.586659, "o", "        if com.is_bool_indexer(key):\r\n"]
[132.613824, "o", "            return self._getitem_bool_array(key)\r\n"]
[132.640989, "o", "\r\n"]
[132.668154, "o", "        # We are left with two options: a single key, and a collection of keys,\r\n"]
[132.695319, "o", "        # We interpret tuples as collections only for non-MultiIndex\r\n"]
[132.722484, "o", "        is_single_key = isinstance(key, tuple) or not is_list_like(key)\r\n"]
[132.749648, "o", "\r\n"]
[132.776813, "o", "        if is_single_key:\r\n"]
[132.803978, "o", "            if self.columns.nlevels > 1:\r\n"]
[132.831143, "o", "                return self._getitem_multilevel(key)\r\n"]
[132.858308, "o", "            indexer = self.columns.get_loc(key)\r\n"]
[132.885473, "o", "            if is_integer(indexer):\r\n"]
[132.912637, "o", "                indexer = [indexer]\r\n"]
[132.939802, "o", "        else:\r\n"]
[132.966967, "o", "            if is_iterator(key):\r\n"]
[132.994132, "o", "                key = list(key)\r\n"]
[133.021297, "o", "            indexer = self.columns._get_indexer_strict(key, \"columns\")[1]\r\n"]
[133.048462, "o", "\r\n"]
[133.075626, "o", "        # take() does not accept boolean indexers\r\n"]
[133.102791, "o", "        if getattr(indexer, \"dtype\", None) == bool:\r\n"]
[133.129956, "o", "            indexer = np.where(indexer)[0]\r\n"]
[133.157121, "o", "\r\n"]
[133.184286, "o", "        if isinstance(indexer, slice):\r\n"]
[133.211451, "o", "            return self._slice(indexer, axis=1)\r\n"]
[133.238615, "o", "\r\n"]
[133.26578, "o", "        data = self.take(indexer, axis=1)\r\n"]
[133.292945, "o", "\r\n"]
[133.32011, "o", "        if is_single_key:\r\n"]
[133.347275, "o", "            # What does looking for a single key in a non-unique index return?\r\n"]
[133.37444, "o", "            # The behavior is inconsistent. It returns a Series, except when\r\n"]
[133.401604, "o", "            # - the key itself is repeated (test on data.shape, #9519), or\r\n"]
[133.428769, "o", "            # - we have a MultiIndex on columns (test on self.columns, #21309)\r\n"]
[133.455934, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[133.483099, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[133.510264, "o", "                return data._get_item(key)\r\n"]
[133.537429, "o", "\r\n"]
[133.564593, "o", "        return data\r\n"]
[133.591758, "o", "\r\n"]
[133.618923, "o", "    def _getitem_bool_array(self, key):\r\n"]
[133.646088, "o", "        # also raises Exception if object array with NA values\r\n"]
[133.673253, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[133.700418, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[133.727582, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[133.754747, "o", "        # with all other indexing behavior\r\n"]
[133.781912, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[133.809077, "o", "            warnings.warn(\r\n"]
[133.836242, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[133.863407, "o", "                UserWarning,\r\n"]
[133.890571, "o", "                stacklevel=find_stack_level(),\r\n"]
[133.917736, "o", "            )\r\n"]
[133.944901, "o", "        elif len(key) != len(self.index):\r\n"]
[133.972066, "o", "            raise ValueError(\r\n"]
[133.999231, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[134.026396, "o", "            )\r\n"]
[134.05356, "o", "\r\n"]
[134.080725, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[134.10789, "o", "        # be reindexed to match DataFrame rows\r\n"]
[134.135055, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[134.16222, "o", "\r\n"]
[134.189385, "o", "        if key.all():\r\n"]
[134.216549, "o", "            return self.copy(deep=False)\r\n"]
[134.243714, "o", "\r\n"]
[134.270879, "o", "        indexer = key.nonzero()[0]\r\n"]
[134.298044, "o", "        return self.take(indexer, axis=0)\r\n"]
[134.325209, "o", "\r\n"]
[134.352374, "o", "    def _getitem_multilevel(self, key):\r\n"]
[134.379538, "o", "        # self.columns is a MultiIndex\r\n"]
[134.406703, "o", "        loc = self.columns.get_loc(key)\r\n"]
[134.433868, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[134.461033, "o", "            new_columns = self.columns[loc]\r\n"]
[134.488198, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[134.515363, "o", "            result = self.iloc[:, loc]\r\n"]
[134.542527, "o", "            result.columns = result_columns\r\n"]
[134.569692, "o", "\r\n"]
[134.596857, "o", "            # If there is only one column being returned, and its name is\r\n"]
[134.624022, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[134.651187, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[134.678352, "o", "            # and return the column as if the user had provided that empty\r\n"]
[134.705516, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[134.732681, "o", "            # implied empty string from its name.\r\n"]
[134.759846, "o", "            if len(result.columns) == 1:\r\n"]
[134.787011, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[134.814176, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[134.841341, "o", "                top = result.columns[0]\r\n"]
[134.868505, "o", "                if isinstance(top, tuple):\r\n"]
[134.89567, "o", "                    top = top[0]\r\n"]
[134.922835, "o", "                if top == \"\":\r\n"]
[135.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[135.002, "i", "sed -n '2550,2660p' ../pandas/core/indexing.py\r"]
[135.004, "o", "sed -n '2550,2660p' ../pandas/core/indexing.py\r\n"]
[135.050143, "o", "\u001b[?2004l\r\n"]
[135.094286, "o", "            # GH#33041 fall back to .loc\r\n"]
[135.138429, "o", "            if not isinstance(key, tuple) or not all(is_scalar(x) for x in key):\r\n"]
[135.182571, "o", "                raise ValueError(\"Invalid call for scalar access (getting)!\")\r\n"]
[135.226714, "o", "            return self.obj.loc[key]\r\n"]
[135.270857, "o", "\r\n"]
[135.315, "o", "        return super().__getitem__(key)\r\n"]
[135.359143, "o", "\r\n"]
[135.403286, "o", "    def __setitem__(self, key, value) -> None:\r\n"]
[135.447429, "o", "        if self.ndim == 2 and not self._axes_are_unique:\r\n"]
[135.491571, "o", "            # GH#33041 fall back to .loc\r\n"]
[135.535714, "o", "            if not isinstance(key, tuple) or not all(is_scalar(x) for x in key):\r\n"]
[135.579857, "o", "                raise ValueError(\"Invalid call for scalar access (setting)!\")\r\n"]
[135.624, "o", "\r\n"]
[135.668143, "o", "            self.obj.loc[key] = value\r\n"]
[135.712286, "o", "            return\r\n"]
[135.756429, "o", "\r\n"]
[135.800571, "o", "        return super().__setitem__(key, value)\r\n"]
[135.844714, "o", "\r\n"]
[135.888857, "o", "\r\n"]
[135.933, "o", "@doc(IndexingMixin.iat)\r\n"]
[135.977143, "o", "class _iAtIndexer(_ScalarAccessIndexer):\r\n"]
[136.021286, "o", "    _takeable = True\r\n"]
[136.065429, "o", "\r\n"]
[136.109571, "o", "    def _convert_key(self, key):\r\n"]
[136.153714, "o", "        \"\"\"\r\n"]
[136.197857, "o", "        Require integer args. (and convert to label arguments)\r\n"]
[136.242, "o", "        \"\"\"\r\n"]
[136.286143, "o", "        for i in key:\r\n"]
[136.330286, "o", "            if not is_integer(i):\r\n"]
[136.374429, "o", "                raise ValueError(\"iAt based indexing can only have integer indexers\")\r\n"]
[136.418571, "o", "        return key\r\n"]
[136.462714, "o", "\r\n"]
[136.506857, "o", "\r\n"]
[136.551, "o", "def _tuplify(ndim: int, loc: Hashable) -> tuple[Hashable | slice, ...]:\r\n"]
[136.595143, "o", "    \"\"\"\r\n"]
[136.639286, "o", "    Given an indexer for the first dimension, create an equivalent tuple\r\n"]
[136.683429, "o", "    for indexing over all dimensions.\r\n"]
[136.727571, "o", "\r\n"]
[136.771714, "o", "    Parameters\r\n"]
[136.815857, "o", "    ----------\r\n"]
[136.86, "o", "    ndim : int\r\n"]
[136.904143, "o", "    loc : object\r\n"]
[136.948286, "o", "\r\n"]
[136.992429, "o", "    Returns\r\n"]
[137.036571, "o", "    -------\r\n"]
[137.080714, "o", "    tuple\r\n"]
[137.124857, "o", "    \"\"\"\r\n"]
[137.169, "o", "    _tup: list[Hashable | slice]\r\n"]
[137.213143, "o", "    _tup = [slice(None, None) for _ in range(ndim)]\r\n"]
[137.257286, "o", "    _tup[0] = loc\r\n"]
[137.301429, "o", "    return tuple(_tup)\r\n"]
[137.345571, "o", "\r\n"]
[137.389714, "o", "\r\n"]
[137.433857, "o", "def _tupleize_axis_indexer(ndim: int, axis: AxisInt, key) -> tuple:\r\n"]
[137.478, "o", "    \"\"\"\r\n"]
[137.522143, "o", "    If we have an axis, adapt the given key to be axis-independent.\r\n"]
[137.566286, "o", "    \"\"\"\r\n"]
[137.610429, "o", "    new_key = [slice(None)] * ndim\r\n"]
[137.654571, "o", "    new_key[axis] = key\r\n"]
[137.698714, "o", "    return tuple(new_key)\r\n"]
[137.742857, "o", "\r\n"]
[137.787, "o", "\r\n"]
[137.831143, "o", "def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[137.875286, "o", "    \"\"\"\r\n"]
[137.919429, "o", "    Check if key is a valid boolean indexer for an object with such index and\r\n"]
[137.963571, "o", "    perform reindexing or conversion if needed.\r\n"]
[138.007714, "o", "\r\n"]
[138.051857, "o", "    This function assumes that is_bool_indexer(key) == True.\r\n"]
[138.096, "o", "\r\n"]
[138.140143, "o", "    Parameters\r\n"]
[138.184286, "o", "    ----------\r\n"]
[138.228429, "o", "    index : Index\r\n"]
[138.272571, "o", "        Index of the object on which the indexing is done.\r\n"]
[138.316714, "o", "    key : list-like\r\n"]
[138.360857, "o", "        Boolean indexer to check.\r\n"]
[138.405, "o", "\r\n"]
[138.449143, "o", "    Returns\r\n"]
[138.493286, "o", "    -------\r\n"]
[138.537429, "o", "    np.array\r\n"]
[138.581571, "o", "        Resulting key.\r\n"]
[138.625714, "o", "\r\n"]
[138.669857, "o", "    Raises\r\n"]
[138.714, "o", "    ------\r\n"]
[138.758143, "o", "    IndexError\r\n"]
[138.802286, "o", "        If the key does not have the same length as index.\r\n"]
[138.846429, "o", "    IndexingError\r\n"]
[138.890571, "o", "        If the index of the key is unalignable to index.\r\n"]
[138.934714, "o", "    \"\"\"\r\n"]
[138.978857, "o", "    result = key\r\n"]
[139.023, "o", "    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[139.067143, "o", "        indexer = result.index.get_indexer_for(index)\r\n"]
[139.111286, "o", "        if -1 in indexer:\r\n"]
[139.155429, "o", "            raise IndexingError(\r\n"]
[139.199571, "o", "                \"Unalignable boolean Series provided as \"\r\n"]
[139.243714, "o", "                \"indexer (index of the boolean Series and of \"\r\n"]
[139.287857, "o", "                \"the indexed object do not match).\"\r\n"]
[139.332, "o", "            )\r\n"]
[139.376143, "o", "\r\n"]
[139.420286, "o", "        result = result.take(indexer)\r\n"]
[139.464429, "o", "\r\n"]
[139.508571, "o", "        # fall through for boolean\r\n"]
[139.552714, "o", "        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[139.596857, "o", "            return result.astype(bool)._values\r\n"]
[139.641, "o", "\r\n"]
[139.685143, "o", "    if is_object_dtype(key):\r\n"]
[139.729286, "o", "        # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[139.773429, "o", "        result = np.asarray(result, dtype=bool)\r\n"]
[139.817571, "o", "    elif not is_array_like(result):\r\n"]
[139.861714, "o", "        # GH 33924\r\n"]
[139.905857, "o", "        # key may contain nan elements, check_array_indexer needs bool array\r\n"]
[140.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[140.002, "i", "sed -n '1,240p' ../pandas/core/common.py\r"]
[140.004, "o", "sed -n '1,240p' ../pandas/core/common.py\r\n"]
[140.026515, "o", "\u001b[?2004l\r\n"]
[140.047029, "o", "\"\"\"\r\n"]
[140.067544, "o", "Misc tools for implementing data structures\r\n"]
[140.088058, "o", "\r\n"]
[140.108573, "o", "Note: pandas.core.common is *not* part of the public API.\r\n"]
[140.129087, "o", "\"\"\"\r\n"]
[140.149602, "o", "\r\n"]
[140.170116, "o", "from __future__ import annotations\r\n"]
[140.190631, "o", "\r\n"]
[140.211145, "o", "import builtins\r\n"]
[140.23166, "o", "from collections import (\r\n"]
[140.252174, "o", "    abc,\r\n"]
[140.272689, "o", "    defaultdict,\r\n"]
[140.293203, "o", ")\r\n"]
[140.313718, "o", "from collections.abc import (\r\n"]
[140.334232, "o", "    Collection,\r\n"]
[140.354747, "o", "    Generator,\r\n"]
[140.375261, "o", "    Hashable,\r\n"]
[140.395776, "o", "    Iterable,\r\n"]
[140.41629, "o", "    Sequence,\r\n"]
[140.436805, "o", ")\r\n"]
[140.45732, "o", "import contextlib\r\n"]
[140.477834, "o", "from functools import partial\r\n"]
[140.498349, "o", "import inspect\r\n"]
[140.518863, "o", "from typing import (\r\n"]
[140.539378, "o", "    TYPE_CHECKING,\r\n"]
[140.559892, "o", "    Any,\r\n"]
[140.580407, "o", "    Callable,\r\n"]
[140.600921, "o", "    TypeVar,\r\n"]
[140.621436, "o", "    cast,\r\n"]
[140.64195, "o", "    overload,\r\n"]
[140.662465, "o", ")\r\n"]
[140.682979, "o", "import warnings\r\n"]
[140.703494, "o", "\r\n"]
[140.724008, "o", "import numpy as np\r\n"]
[140.744523, "o", "\r\n"]
[140.765037, "o", "from pandas._libs import lib\r\n"]
[140.785552, "o", "from pandas.compat.numpy import np_version_gte1p24\r\n"]
[140.806066, "o", "\r\n"]
[140.826581, "o", "from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\r\n"]
[140.847095, "o", "from pandas.core.dtypes.common import (\r\n"]
[140.86761, "o", "    is_bool_dtype,\r\n"]
[140.888124, "o", "    is_integer,\r\n"]
[140.908639, "o", ")\r\n"]
[140.929154, "o", "from pandas.core.dtypes.generic import (\r\n"]
[140.949668, "o", "    ABCExtensionArray,\r\n"]
[140.970183, "o", "    ABCIndex,\r\n"]
[140.990697, "o", "    ABCMultiIndex,\r\n"]
[141.011212, "o", "    ABCSeries,\r\n"]
[141.031726, "o", ")\r\n"]
[141.052241, "o", "from pandas.core.dtypes.inference import iterable_not_string\r\n"]
[141.072755, "o", "\r\n"]
[141.09327, "o", "if TYPE_CHECKING:\r\n"]
[141.113784, "o", "    from pandas._typing import (\r\n"]
[141.134299, "o", "        AnyArrayLike,\r\n"]
[141.154813, "o", "        ArrayLike,\r\n"]
[141.175328, "o", "        Concatenate,\r\n"]
[141.195842, "o", "        NpDtype,\r\n"]
[141.216357, "o", "        P,\r\n"]
[141.236871, "o", "        RandomState,\r\n"]
[141.257386, "o", "        T,\r\n"]
[141.2779, "o", "    )\r\n"]
[141.298415, "o", "\r\n"]
[141.318929, "o", "    from pandas import Index\r\n"]
[141.339444, "o", "\r\n"]
[141.359959, "o", "\r\n"]
[141.380473, "o", "def flatten(line):\r\n"]
[141.400988, "o", "    \"\"\"\r\n"]
[141.421502, "o", "    Flatten an arbitrarily nested sequence.\r\n"]
[141.442017, "o", "\r\n"]
[141.462531, "o", "    Parameters\r\n"]
[141.483046, "o", "    ----------\r\n"]
[141.50356, "o", "    line : sequence\r\n"]
[141.524075, "o", "        The non string sequence to flatten\r\n"]
[141.544589, "o", "\r\n"]
[141.565104, "o", "    Notes\r\n"]
[141.585618, "o", "    -----\r\n"]
[141.606133, "o", "    This doesn't consider strings sequences.\r\n"]
[141.626647, "o", "\r\n"]
[141.647162, "o", "    Returns\r\n"]
[141.667676, "o", "    -------\r\n"]
[141.688191, "o", "    flattened : generator\r\n"]
[141.708705, "o", "    \"\"\"\r\n"]
[141.72922, "o", "    for element in line:\r\n"]
[141.749734, "o", "        if iterable_not_string(element):\r\n"]
[141.770249, "o", "            yield from flatten(element)\r\n"]
[141.790763, "o", "        else:\r\n"]
[141.811278, "o", "            yield element\r\n"]
[141.831793, "o", "\r\n"]
[141.852307, "o", "\r\n"]
[141.872822, "o", "def consensus_name_attr(objs):\r\n"]
[141.893336, "o", "    name = objs[0].name\r\n"]
[141.913851, "o", "    for obj in objs[1:]:\r\n"]
[141.934365, "o", "        try:\r\n"]
[141.95488, "o", "            if obj.name != name:\r\n"]
[141.975394, "o", "                name = None\r\n"]
[141.995909, "o", "        except ValueError:\r\n"]
[142.016423, "o", "            name = None\r\n"]
[142.036938, "o", "    return name\r\n"]
[142.057452, "o", "\r\n"]
[142.077967, "o", "\r\n"]
[142.098481, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[142.118996, "o", "    \"\"\"\r\n"]
[142.13951, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[142.160025, "o", "\r\n"]
[142.180539, "o", "    Parameters\r\n"]
[142.201054, "o", "    ----------\r\n"]
[142.221568, "o", "    key : Any\r\n"]
[142.242083, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[142.262598, "o", "        All other types are not considered a boolean indexer.\r\n"]
[142.283112, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[142.303627, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[142.324141, "o", "\r\n"]
[142.344656, "o", "    Returns\r\n"]
[142.36517, "o", "    -------\r\n"]
[142.385685, "o", "    bool\r\n"]
[142.406199, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[142.426714, "o", "\r\n"]
[142.447228, "o", "    Raises\r\n"]
[142.467743, "o", "    ------\r\n"]
[142.488257, "o", "    ValueError\r\n"]
[142.508772, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[142.529286, "o", "        and contains missing values.\r\n"]
[142.549801, "o", "\r\n"]
[142.570315, "o", "    See Also\r\n"]
[142.59083, "o", "    --------\r\n"]
[142.611344, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[142.631859, "o", "        and convert to an ndarray.\r\n"]
[142.652373, "o", "    \"\"\"\r\n"]
[142.672888, "o", "    if isinstance(\r\n"]
[142.693402, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[142.713917, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[142.734432, "o", "        if key.dtype == np.object_:\r\n"]
[142.754946, "o", "            key_array = np.asarray(key)\r\n"]
[142.775461, "o", "\r\n"]
[142.795975, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[142.81649, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[142.837004, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[142.857519, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[142.878033, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[142.898548, "o", "                    raise ValueError(na_msg)\r\n"]
[142.919062, "o", "                return False\r\n"]
[142.939577, "o", "            return True\r\n"]
[142.960091, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[142.980606, "o", "            return True\r\n"]
[143.00112, "o", "    elif isinstance(key, list):\r\n"]
[143.021635, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[143.042149, "o", "        if len(key) > 0:\r\n"]
[143.062664, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[143.083178, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[143.103693, "o", "                key = list(key)\r\n"]
[143.124207, "o", "            return lib.is_bool_list(key)\r\n"]
[143.144722, "o", "\r\n"]
[143.165237, "o", "    return False\r\n"]
[143.185751, "o", "\r\n"]
[143.206266, "o", "\r\n"]
[143.22678, "o", "def cast_scalar_indexer(val):\r\n"]
[143.247295, "o", "    \"\"\"\r\n"]
[143.267809, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[143.288324, "o", "\r\n"]
[143.308838, "o", "    Parameters\r\n"]
[143.329353, "o", "    ----------\r\n"]
[143.349867, "o", "    val : scalar\r\n"]
[143.370382, "o", "\r\n"]
[143.390896, "o", "    Returns\r\n"]
[143.411411, "o", "    -------\r\n"]
[143.431925, "o", "    outval : scalar\r\n"]
[143.45244, "o", "    \"\"\"\r\n"]
[143.472954, "o", "    # assumes lib.is_scalar(val)\r\n"]
[143.493469, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[143.513983, "o", "        raise IndexError(\r\n"]
[143.534498, "o", "            # GH#34193\r\n"]
[143.555012, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[143.575527, "o", "            \"to an integer key instead.\"\r\n"]
[143.596041, "o", "        )\r\n"]
[143.616556, "o", "    return val\r\n"]
[143.637071, "o", "\r\n"]
[143.657585, "o", "\r\n"]
[143.6781, "o", "def not_none(*args):\r\n"]
[143.698614, "o", "    \"\"\"\r\n"]
[143.719129, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[143.739643, "o", "    \"\"\"\r\n"]
[143.760158, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[143.780672, "o", "\r\n"]
[143.801187, "o", "\r\n"]
[143.821701, "o", "def any_none(*args) -> bool:\r\n"]
[143.842216, "o", "    \"\"\"\r\n"]
[143.86273, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[143.883245, "o", "    \"\"\"\r\n"]
[143.903759, "o", "    return any(arg is None for arg in args)\r\n"]
[143.924274, "o", "\r\n"]
[143.944788, "o", "\r\n"]
[143.965303, "o", "def all_none(*args) -> bool:\r\n"]
[143.985817, "o", "    \"\"\"\r\n"]
[144.006332, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[144.026846, "o", "    \"\"\"\r\n"]
[144.047361, "o", "    return all(arg is None for arg in args)\r\n"]
[144.067876, "o", "\r\n"]
[144.08839, "o", "\r\n"]
[144.108905, "o", "def any_not_none(*args) -> bool:\r\n"]
[144.129419, "o", "    \"\"\"\r\n"]
[144.149934, "o", "    Returns a boolean indicating if any argument is not None.\r\n"]
[144.170448, "o", "    \"\"\"\r\n"]
[144.190963, "o", "    return any(arg is not None for arg in args)\r\n"]
[144.211477, "o", "\r\n"]
[144.231992, "o", "\r\n"]
[144.252506, "o", "def all_not_none(*args) -> bool:\r\n"]
[144.273021, "o", "    \"\"\"\r\n"]
[144.293535, "o", "    Returns a boolean indicating if all arguments are not None.\r\n"]
[144.31405, "o", "    \"\"\"\r\n"]
[144.334564, "o", "    return all(arg is not None for arg in args)\r\n"]
[144.355079, "o", "\r\n"]
[144.375593, "o", "\r\n"]
[144.396108, "o", "def count_not_none(*args) -> int:\r\n"]
[144.416622, "o", "    \"\"\"\r\n"]
[144.437137, "o", "    Returns the count of arguments that are not None.\r\n"]
[144.457651, "o", "    \"\"\"\r\n"]
[144.478166, "o", "    return sum(x is not None for x in args)\r\n"]
[144.49868, "o", "\r\n"]
[144.519195, "o", "\r\n"]
[144.53971, "o", "@overload\r\n"]
[144.560224, "o", "def asarray_tuplesafe(\r\n"]
[144.580739, "o", "    values: ArrayLike | list | tuple | zip, dtype: NpDtype | None = ...\r\n"]
[144.601253, "o", ") -> np.ndarray:\r\n"]
[144.621768, "o", "    # ExtensionArray can only be returned when values is an Index, all other iterables\r\n"]
[144.642282, "o", "    # will return np.ndarray. Unfortunately \"all other\" cannot be encoded in a type\r\n"]
[144.662797, "o", "    # signature, so instead we special-case some common types.\r\n"]
[144.683311, "o", "    ...\r\n"]
[144.703826, "o", "\r\n"]
[144.72434, "o", "\r\n"]
[144.744855, "o", "@overload\r\n"]
[144.765369, "o", "def asarray_tuplesafe(values: Iterable, dtype: NpDtype | None = ...) -> ArrayLike: ...\r\n"]
[144.785884, "o", "\r\n"]
[144.806398, "o", "\r\n"]
[144.826913, "o", "def asarray_tuplesafe(values: Iterable, dtype: NpDtype | None = None) -> ArrayLike:\r\n"]
[144.847427, "o", "    if not (isinstance(values, (list, tuple)) or hasattr(values, \"__array__\")):\r\n"]
[144.867942, "o", "        values = list(values)\r\n"]
[144.888456, "o", "    elif isinstance(values, ABCIndex):\r\n"]
[144.908971, "o", "        return values._values\r\n"]
[144.929485, "o", "    elif isinstance(values, ABCSeries):\r\n"]
[145.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[145.002, "i", "sed -n '240,420p' ../pandas/core/common.py\r"]
[145.004, "o", "sed -n '240,420p' ../pandas/core/common.py\r\n"]
[145.033165, "o", "\u001b[?2004l\r\n"]
[145.06033, "o", "        return values._values\r\n"]
[145.087495, "o", "\r\n"]
[145.114659, "o", "    if isinstance(values, list) and dtype in [np.object_, object]:\r\n"]
[145.141824, "o", "        return construct_1d_object_array_from_listlike(values)\r\n"]
[145.168989, "o", "\r\n"]
[145.196154, "o", "    try:\r\n"]
[145.223319, "o", "        with warnings.catch_warnings():\r\n"]
[145.250484, "o", "            # Can remove warning filter once NumPy 1.24 is min version\r\n"]
[145.277648, "o", "            if not np_version_gte1p24:\r\n"]
[145.304813, "o", "                warnings.simplefilter(\"ignore\", np.VisibleDeprecationWarning)\r\n"]
[145.331978, "o", "            result = np.asarray(values, dtype=dtype)\r\n"]
[145.359143, "o", "    except ValueError:\r\n"]
[145.386308, "o", "        # Using try/except since it's more performant than checking is_list_like\r\n"]
[145.413473, "o", "        # over each element\r\n"]
[145.440637, "o", "        # error: Argument 1 to \"construct_1d_object_array_from_listlike\"\r\n"]
[145.467802, "o", "        # has incompatible type \"Iterable[Any]\"; expected \"Sized\"\r\n"]
[145.494967, "o", "        return construct_1d_object_array_from_listlike(values)  # type: ignore[arg-type]\r\n"]
[145.522132, "o", "\r\n"]
[145.549297, "o", "    if issubclass(result.dtype.type, str):\r\n"]
[145.576462, "o", "        result = np.asarray(values, dtype=object)\r\n"]
[145.603626, "o", "\r\n"]
[145.630791, "o", "    if result.ndim == 2:\r\n"]
[145.657956, "o", "        # Avoid building an array of arrays:\r\n"]
[145.685121, "o", "        values = [tuple(x) for x in values]\r\n"]
[145.712286, "o", "        result = construct_1d_object_array_from_listlike(values)\r\n"]
[145.739451, "o", "\r\n"]
[145.766615, "o", "    return result\r\n"]
[145.79378, "o", "\r\n"]
[145.820945, "o", "\r\n"]
[145.84811, "o", "def index_labels_to_array(\r\n"]
[145.875275, "o", "    labels: np.ndarray | Iterable, dtype: NpDtype | None = None\r\n"]
[145.90244, "o", ") -> np.ndarray:\r\n"]
[145.929604, "o", "    \"\"\"\r\n"]
[145.956769, "o", "    Transform label or iterable of labels to array, for use in Index.\r\n"]
[145.983934, "o", "\r\n"]
[146.011099, "o", "    Parameters\r\n"]
[146.038264, "o", "    ----------\r\n"]
[146.065429, "o", "    dtype : dtype\r\n"]
[146.092593, "o", "        If specified, use as dtype of the resulting array, otherwise infer.\r\n"]
[146.119758, "o", "\r\n"]
[146.146923, "o", "    Returns\r\n"]
[146.174088, "o", "    -------\r\n"]
[146.201253, "o", "    array\r\n"]
[146.228418, "o", "    \"\"\"\r\n"]
[146.255582, "o", "    if isinstance(labels, (str, tuple)):\r\n"]
[146.282747, "o", "        labels = [labels]\r\n"]
[146.309912, "o", "\r\n"]
[146.337077, "o", "    if not isinstance(labels, (list, np.ndarray)):\r\n"]
[146.364242, "o", "        try:\r\n"]
[146.391407, "o", "            labels = list(labels)\r\n"]
[146.418571, "o", "        except TypeError:  # non-iterable\r\n"]
[146.445736, "o", "            labels = [labels]\r\n"]
[146.472901, "o", "\r\n"]
[146.500066, "o", "    labels = asarray_tuplesafe(labels, dtype=dtype)\r\n"]
[146.527231, "o", "\r\n"]
[146.554396, "o", "    return labels\r\n"]
[146.58156, "o", "\r\n"]
[146.608725, "o", "\r\n"]
[146.63589, "o", "def maybe_make_list(obj):\r\n"]
[146.663055, "o", "    if obj is not None and not isinstance(obj, (tuple, list)):\r\n"]
[146.69022, "o", "        return [obj]\r\n"]
[146.717385, "o", "    return obj\r\n"]
[146.744549, "o", "\r\n"]
[146.771714, "o", "\r\n"]
[146.798879, "o", "def maybe_iterable_to_list(obj: Iterable[T] | T) -> Collection[T] | T:\r\n"]
[146.826044, "o", "    \"\"\"\r\n"]
[146.853209, "o", "    If obj is Iterable but not list-like, consume into list.\r\n"]
[146.880374, "o", "    \"\"\"\r\n"]
[146.907538, "o", "    if isinstance(obj, abc.Iterable) and not isinstance(obj, abc.Sized):\r\n"]
[146.934703, "o", "        return list(obj)\r\n"]
[146.961868, "o", "    obj = cast(Collection, obj)\r\n"]
[146.989033, "o", "    return obj\r\n"]
[147.016198, "o", "\r\n"]
[147.043363, "o", "\r\n"]
[147.070527, "o", "def is_null_slice(obj) -> bool:\r\n"]
[147.097692, "o", "    \"\"\"\r\n"]
[147.124857, "o", "    We have a null slice.\r\n"]
[147.152022, "o", "    \"\"\"\r\n"]
[147.179187, "o", "    return (\r\n"]
[147.206352, "o", "        isinstance(obj, slice)\r\n"]
[147.233516, "o", "        and obj.start is None\r\n"]
[147.260681, "o", "        and obj.stop is None\r\n"]
[147.287846, "o", "        and obj.step is None\r\n"]
[147.315011, "o", "    )\r\n"]
[147.342176, "o", "\r\n"]
[147.369341, "o", "\r\n"]
[147.396505, "o", "def is_empty_slice(obj) -> bool:\r\n"]
[147.42367, "o", "    \"\"\"\r\n"]
[147.450835, "o", "    We have an empty slice, e.g. no values are selected.\r\n"]
[147.478, "o", "    \"\"\"\r\n"]
[147.505165, "o", "    return (\r\n"]
[147.53233, "o", "        isinstance(obj, slice)\r\n"]
[147.559495, "o", "        and obj.start is not None\r\n"]
[147.586659, "o", "        and obj.stop is not None\r\n"]
[147.613824, "o", "        and obj.start == obj.stop\r\n"]
[147.640989, "o", "    )\r\n"]
[147.668154, "o", "\r\n"]
[147.695319, "o", "\r\n"]
[147.722484, "o", "def is_true_slices(line) -> list[bool]:\r\n"]
[147.749648, "o", "    \"\"\"\r\n"]
[147.776813, "o", "    Find non-trivial slices in \"line\": return a list of booleans with same length.\r\n"]
[147.803978, "o", "    \"\"\"\r\n"]
[147.831143, "o", "    return [isinstance(k, slice) and not is_null_slice(k) for k in line]\r\n"]
[147.858308, "o", "\r\n"]
[147.885473, "o", "\r\n"]
[147.912637, "o", "# TODO: used only once in indexing; belongs elsewhere?\r\n"]
[147.939802, "o", "def is_full_slice(obj, line: int) -> bool:\r\n"]
[147.966967, "o", "    \"\"\"\r\n"]
[147.994132, "o", "    We have a full length slice.\r\n"]
[148.021297, "o", "    \"\"\"\r\n"]
[148.048462, "o", "    return (\r\n"]
[148.075626, "o", "        isinstance(obj, slice)\r\n"]
[148.102791, "o", "        and obj.start == 0\r\n"]
[148.129956, "o", "        and obj.stop == line\r\n"]
[148.157121, "o", "        and obj.step is None\r\n"]
[148.184286, "o", "    )\r\n"]
[148.211451, "o", "\r\n"]
[148.238615, "o", "\r\n"]
[148.26578, "o", "def get_callable_name(obj):\r\n"]
[148.292945, "o", "    # typical case has name\r\n"]
[148.32011, "o", "    if hasattr(obj, \"__name__\"):\r\n"]
[148.347275, "o", "        return getattr(obj, \"__name__\")\r\n"]
[148.37444, "o", "    # some objects don't; could recurse\r\n"]
[148.401604, "o", "    if isinstance(obj, partial):\r\n"]
[148.428769, "o", "        return get_callable_name(obj.func)\r\n"]
[148.455934, "o", "    # fall back to class name\r\n"]
[148.483099, "o", "    if callable(obj):\r\n"]
[148.510264, "o", "        return type(obj).__name__\r\n"]
[148.537429, "o", "    # everything failed (probably because the argument\r\n"]
[148.564593, "o", "    # wasn't actually callable); we return None\r\n"]
[148.591758, "o", "    # instead of the empty string in this case to allow\r\n"]
[148.618923, "o", "    # distinguishing between no name and a name of ''\r\n"]
[148.646088, "o", "    return None\r\n"]
[148.673253, "o", "\r\n"]
[148.700418, "o", "\r\n"]
[148.727582, "o", "def apply_if_callable(maybe_callable, obj, **kwargs):\r\n"]
[148.754747, "o", "    \"\"\"\r\n"]
[148.781912, "o", "    Evaluate possibly callable input using obj and kwargs if it is callable,\r\n"]
[148.809077, "o", "    otherwise return as it is.\r\n"]
[148.836242, "o", "\r\n"]
[148.863407, "o", "    Parameters\r\n"]
[148.890571, "o", "    ----------\r\n"]
[148.917736, "o", "    maybe_callable : possibly a callable\r\n"]
[148.944901, "o", "    obj : NDFrame\r\n"]
[148.972066, "o", "    **kwargs\r\n"]
[148.999231, "o", "    \"\"\"\r\n"]
[149.026396, "o", "    if callable(maybe_callable):\r\n"]
[149.05356, "o", "        return maybe_callable(obj, **kwargs)\r\n"]
[149.080725, "o", "\r\n"]
[149.10789, "o", "    return maybe_callable\r\n"]
[149.135055, "o", "\r\n"]
[149.16222, "o", "\r\n"]
[149.189385, "o", "def standardize_mapping(into):\r\n"]
[149.216549, "o", "    \"\"\"\r\n"]
[149.243714, "o", "    Helper function to standardize a supplied mapping.\r\n"]
[149.270879, "o", "\r\n"]
[149.298044, "o", "    Parameters\r\n"]
[149.325209, "o", "    ----------\r\n"]
[149.352374, "o", "    into : instance or subclass of collections.abc.Mapping\r\n"]
[149.379538, "o", "        Must be a class, an initialized collections.defaultdict,\r\n"]
[149.406703, "o", "        or an instance of a collections.abc.Mapping subclass.\r\n"]
[149.433868, "o", "\r\n"]
[149.461033, "o", "    Returns\r\n"]
[149.488198, "o", "    -------\r\n"]
[149.515363, "o", "    mapping : a collections.abc.Mapping subclass or other constructor\r\n"]
[149.542527, "o", "        a callable object that can accept an iterator to create\r\n"]
[149.569692, "o", "        the desired Mapping.\r\n"]
[149.596857, "o", "\r\n"]
[149.624022, "o", "    See Also\r\n"]
[149.651187, "o", "    --------\r\n"]
[149.678352, "o", "    DataFrame.to_dict\r\n"]
[149.705516, "o", "    Series.to_dict\r\n"]
[149.732681, "o", "    \"\"\"\r\n"]
[149.759846, "o", "    if not inspect.isclass(into):\r\n"]
[149.787011, "o", "        if isinstance(into, defaultdict):\r\n"]
[149.814176, "o", "            return partial(defaultdict, into.default_factory)\r\n"]
[149.841341, "o", "        into = type(into)\r\n"]
[149.868505, "o", "    if not issubclass(into, abc.Mapping):\r\n"]
[149.89567, "o", "        raise TypeError(f\"unsupported type: {into}\")\r\n"]
[149.922835, "o", "    if into == defaultdict:\r\n"]
[150.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[150.002, "i", "sed -n '3920,4080p' ../pandas/core/frame.py\r"]
[150.004, "o", "sed -n '3920,4080p' ../pandas/core/frame.py\r\n"]
[150.036519, "o", "\u001b[?2004l\r\n"]
[150.067037, "o", "        if is_single_key:\r\n"]
[150.097556, "o", "            # What does looking for a single key in a non-unique index return?\r\n"]
[150.128074, "o", "            # The behavior is inconsistent. It returns a Series, except when\r\n"]
[150.158593, "o", "            # - the key itself is repeated (test on data.shape, #9519), or\r\n"]
[150.189111, "o", "            # - we have a MultiIndex on columns (test on self.columns, #21309)\r\n"]
[150.21963, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[150.250148, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[150.280667, "o", "                return data._get_item(key)\r\n"]
[150.311185, "o", "\r\n"]
[150.341704, "o", "        return data\r\n"]
[150.372222, "o", "\r\n"]
[150.402741, "o", "    def _getitem_bool_array(self, key):\r\n"]
[150.433259, "o", "        # also raises Exception if object array with NA values\r\n"]
[150.463778, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[150.494296, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[150.524815, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[150.555333, "o", "        # with all other indexing behavior\r\n"]
[150.585852, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[150.61637, "o", "            warnings.warn(\r\n"]
[150.646889, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[150.677407, "o", "                UserWarning,\r\n"]
[150.707926, "o", "                stacklevel=find_stack_level(),\r\n"]
[150.738444, "o", "            )\r\n"]
[150.768963, "o", "        elif len(key) != len(self.index):\r\n"]
[150.799481, "o", "            raise ValueError(\r\n"]
[150.83, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[150.860519, "o", "            )\r\n"]
[150.891037, "o", "\r\n"]
[150.921556, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[150.952074, "o", "        # be reindexed to match DataFrame rows\r\n"]
[150.982593, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[151.013111, "o", "\r\n"]
[151.04363, "o", "        if key.all():\r\n"]
[151.074148, "o", "            return self.copy(deep=False)\r\n"]
[151.104667, "o", "\r\n"]
[151.135185, "o", "        indexer = key.nonzero()[0]\r\n"]
[151.165704, "o", "        return self.take(indexer, axis=0)\r\n"]
[151.196222, "o", "\r\n"]
[151.226741, "o", "    def _getitem_multilevel(self, key):\r\n"]
[151.257259, "o", "        # self.columns is a MultiIndex\r\n"]
[151.287778, "o", "        loc = self.columns.get_loc(key)\r\n"]
[151.318296, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[151.348815, "o", "            new_columns = self.columns[loc]\r\n"]
[151.379333, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[151.409852, "o", "            result = self.iloc[:, loc]\r\n"]
[151.44037, "o", "            result.columns = result_columns\r\n"]
[151.470889, "o", "\r\n"]
[151.501407, "o", "            # If there is only one column being returned, and its name is\r\n"]
[151.531926, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[151.562444, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[151.592963, "o", "            # and return the column as if the user had provided that empty\r\n"]
[151.623481, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[151.654, "o", "            # implied empty string from its name.\r\n"]
[151.684519, "o", "            if len(result.columns) == 1:\r\n"]
[151.715037, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[151.745556, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[151.776074, "o", "                top = result.columns[0]\r\n"]
[151.806593, "o", "                if isinstance(top, tuple):\r\n"]
[151.837111, "o", "                    top = top[0]\r\n"]
[151.86763, "o", "                if top == \"\":\r\n"]
[151.898148, "o", "                    result = result[\"\"]\r\n"]
[151.928667, "o", "                    if isinstance(result, Series):\r\n"]
[151.959185, "o", "                        result = self._constructor_sliced(\r\n"]
[151.989704, "o", "                            result, index=self.index, name=key\r\n"]
[152.020222, "o", "                        )\r\n"]
[152.050741, "o", "\r\n"]
[152.081259, "o", "            return result\r\n"]
[152.111778, "o", "        else:\r\n"]
[152.142296, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[152.172815, "o", "            return self._ixs(loc, axis=1)\r\n"]
[152.203333, "o", "\r\n"]
[152.233852, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[152.26437, "o", "        \"\"\"\r\n"]
[152.294889, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[152.325407, "o", "\r\n"]
[152.355926, "o", "        Parameters\r\n"]
[152.386444, "o", "        ----------\r\n"]
[152.416963, "o", "        index : row label\r\n"]
[152.447481, "o", "        col : column label\r\n"]
[152.478, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[152.508519, "o", "\r\n"]
[152.539037, "o", "        Returns\r\n"]
[152.569556, "o", "        -------\r\n"]
[152.600074, "o", "        scalar\r\n"]
[152.630593, "o", "\r\n"]
[152.661111, "o", "        Notes\r\n"]
[152.69163, "o", "        -----\r\n"]
[152.722148, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[152.752667, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[152.783185, "o", "        \"\"\"\r\n"]
[152.813704, "o", "        if takeable:\r\n"]
[152.844222, "o", "            series = self._ixs(col, axis=1)\r\n"]
[152.874741, "o", "            return series._values[index]\r\n"]
[152.905259, "o", "\r\n"]
[152.935778, "o", "        series = self._get_item(col)\r\n"]
[152.966296, "o", "        engine = self.index._engine\r\n"]
[152.996815, "o", "\r\n"]
[153.027333, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[153.057852, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[153.08837, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[153.118889, "o", "            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[153.149407, "o", "            row = self.index.get_loc(index)\r\n"]
[153.179926, "o", "            return series._values[row]\r\n"]
[153.210444, "o", "\r\n"]
[153.240963, "o", "        # For MultiIndex going through engine effectively restricts us to\r\n"]
[153.271481, "o", "        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[153.302, "o", "        loc = engine.get_loc(index)\r\n"]
[153.332519, "o", "        return series._values[loc]\r\n"]
[153.363037, "o", "\r\n"]
[153.393556, "o", "    def isetitem(self, loc, value) -> None:\r\n"]
[153.424074, "o", "        \"\"\"\r\n"]
[153.454593, "o", "        Set the given value in the column with position `loc`.\r\n"]
[153.485111, "o", "\r\n"]
[153.51563, "o", "        This is a positional analogue to ``__setitem__``.\r\n"]
[153.546148, "o", "\r\n"]
[153.576667, "o", "        Parameters\r\n"]
[153.607185, "o", "        ----------\r\n"]
[153.637704, "o", "        loc : int or sequence of ints\r\n"]
[153.668222, "o", "            Index position for the column.\r\n"]
[153.698741, "o", "        value : scalar or arraylike\r\n"]
[153.729259, "o", "            Value(s) for the column.\r\n"]
[153.759778, "o", "\r\n"]
[153.790296, "o", "        See Also\r\n"]
[153.820815, "o", "        --------\r\n"]
[153.851333, "o", "        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[153.881852, "o", "            position.\r\n"]
[153.91237, "o", "\r\n"]
[153.942889, "o", "        Notes\r\n"]
[153.973407, "o", "        -----\r\n"]
[154.003926, "o", "        ``frame.isetitem(loc, value)`` is an in-place method as it will\r\n"]
[154.034444, "o", "        modify the DataFrame in place (not returning a new object). In contrast to\r\n"]
[154.064963, "o", "        ``frame.iloc[:, i] = value`` which will try to update the existing values in\r\n"]
[154.095481, "o", "        place, ``frame.isetitem(loc, value)`` will not update the values of the column\r\n"]
[154.126, "o", "        itself in place, it will instead insert a new array.\r\n"]
[154.156519, "o", "\r\n"]
[154.187037, "o", "        In cases where ``frame.columns`` is unique, this is equivalent to\r\n"]
[154.217556, "o", "        ``frame[frame.columns[i]] = value``.\r\n"]
[154.248074, "o", "\r\n"]
[154.278593, "o", "        Examples\r\n"]
[154.309111, "o", "        --------\r\n"]
[154.33963, "o", "        >>> df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\r\n"]
[154.370148, "o", "        >>> df.isetitem(1, [5, 6])\r\n"]
[154.400667, "o", "        >>> df\r\n"]
[154.431185, "o", "              A  B\r\n"]
[154.461704, "o", "        0     1  5\r\n"]
[154.492222, "o", "        1     2  6\r\n"]
[154.522741, "o", "        \"\"\"\r\n"]
[154.553259, "o", "        if isinstance(value, DataFrame):\r\n"]
[154.583778, "o", "            if is_integer(loc):\r\n"]
[154.614296, "o", "                loc = [loc]\r\n"]
[154.644815, "o", "\r\n"]
[154.675333, "o", "            if len(loc) != len(value.columns):\r\n"]
[154.705852, "o", "                raise ValueError(\r\n"]
[154.73637, "o", "                    f\"Got {len(loc)} positions but value has {len(value.columns)} \"\r\n"]
[154.766889, "o", "                    f\"columns.\"\r\n"]
[154.797407, "o", "                )\r\n"]
[154.827926, "o", "\r\n"]
[154.858444, "o", "            for i, idx in enumerate(loc):\r\n"]
[154.888963, "o", "                arraylike, refs = self._sanitize_column(value.iloc[:, i])\r\n"]
[154.919481, "o", "                self._iset_item_mgr(idx, arraylike, inplace=False, refs=refs)\r\n"]
[155.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[155.002, "i", "sed -n '4080,4280p' ../pandas/core/frame.py\r"]
[155.004, "o", "sed -n '4080,4280p' ../pandas/core/frame.py\r\n"]
[155.030475, "o", "\u001b[?2004l\r\n"]
[155.05495, "o", "            return\r\n"]
[155.079426, "o", "\r\n"]
[155.103901, "o", "        arraylike, refs = self._sanitize_column(value)\r\n"]
[155.128376, "o", "        self._iset_item_mgr(loc, arraylike, inplace=False, refs=refs)\r\n"]
[155.152851, "o", "\r\n"]
[155.177327, "o", "    def __setitem__(self, key, value) -> None:\r\n"]
[155.201802, "o", "        if not PYPY:\r\n"]
[155.226277, "o", "            if sys.getrefcount(self) <= 3:\r\n"]
[155.250752, "o", "                warnings.warn(\r\n"]
[155.275228, "o", "                    _chained_assignment_msg, ChainedAssignmentError, stacklevel=2\r\n"]
[155.299703, "o", "                )\r\n"]
[155.324178, "o", "\r\n"]
[155.348653, "o", "        key = com.apply_if_callable(key, self)\r\n"]
[155.373129, "o", "\r\n"]
[155.397604, "o", "        # see if we can slice the rows\r\n"]
[155.422079, "o", "        if isinstance(key, slice):\r\n"]
[155.446554, "o", "            slc = self.index._convert_slice_indexer(key, kind=\"getitem\")\r\n"]
[155.47103, "o", "            return self._setitem_slice(slc, value)\r\n"]
[155.495505, "o", "\r\n"]
[155.51998, "o", "        if isinstance(key, DataFrame) or getattr(key, \"ndim\", None) == 2:\r\n"]
[155.544455, "o", "            self._setitem_frame(key, value)\r\n"]
[155.568931, "o", "        elif isinstance(key, (Series, np.ndarray, list, Index)):\r\n"]
[155.593406, "o", "            self._setitem_array(key, value)\r\n"]
[155.617881, "o", "        elif isinstance(value, DataFrame):\r\n"]
[155.642356, "o", "            self._set_item_frame_value(key, value)\r\n"]
[155.666832, "o", "        elif (\r\n"]
[155.691307, "o", "            is_list_like(value)\r\n"]
[155.715782, "o", "            and not self.columns.is_unique\r\n"]
[155.740257, "o", "            and 1 < len(self.columns.get_indexer_for([key])) == len(value)\r\n"]
[155.764733, "o", "        ):\r\n"]
[155.789208, "o", "            # Column to set is duplicated\r\n"]
[155.813683, "o", "            self._setitem_array([key], value)\r\n"]
[155.838158, "o", "        else:\r\n"]
[155.862634, "o", "            # set column\r\n"]
[155.887109, "o", "            self._set_item(key, value)\r\n"]
[155.911584, "o", "\r\n"]
[155.936059, "o", "    def _setitem_slice(self, key: slice, value) -> None:\r\n"]
[155.960535, "o", "        # NB: we can't just use self.loc[key] = value because that\r\n"]
[155.98501, "o", "        #  operates on labels and we need to operate positional for\r\n"]
[156.009485, "o", "        #  backwards-compat, xref GH#31469\r\n"]
[156.03396, "o", "        self.iloc[key] = value\r\n"]
[156.058436, "o", "\r\n"]
[156.082911, "o", "    def _setitem_array(self, key, value) -> None:\r\n"]
[156.107386, "o", "        # also raises Exception if object array with NA values\r\n"]
[156.131861, "o", "        if com.is_bool_indexer(key):\r\n"]
[156.156337, "o", "            # bool indexer is indexing along rows\r\n"]
[156.180812, "o", "            if len(key) != len(self.index):\r\n"]
[156.205287, "o", "                raise ValueError(\r\n"]
[156.229762, "o", "                    f\"Item wrong length {len(key)} instead of {len(self.index)}!\"\r\n"]
[156.254238, "o", "                )\r\n"]
[156.278713, "o", "            key = check_bool_indexer(self.index, key)\r\n"]
[156.303188, "o", "            indexer = key.nonzero()[0]\r\n"]
[156.327663, "o", "            if isinstance(value, DataFrame):\r\n"]
[156.352139, "o", "                # GH#39931 reindex since iloc does not align\r\n"]
[156.376614, "o", "                value = value.reindex(self.index.take(indexer))\r\n"]
[156.401089, "o", "            self.iloc[indexer] = value\r\n"]
[156.425564, "o", "\r\n"]
[156.45004, "o", "        else:\r\n"]
[156.474515, "o", "            # Note: unlike self.iloc[:, indexer] = value, this will\r\n"]
[156.49899, "o", "            #  never try to overwrite values inplace\r\n"]
[156.523465, "o", "\r\n"]
[156.547941, "o", "            if isinstance(value, DataFrame):\r\n"]
[156.572416, "o", "                check_key_length(self.columns, key, value)\r\n"]
[156.596891, "o", "                for k1, k2 in zip(key, value.columns):\r\n"]
[156.621366, "o", "                    self[k1] = value[k2]\r\n"]
[156.645842, "o", "\r\n"]
[156.670317, "o", "            elif not is_list_like(value):\r\n"]
[156.694792, "o", "                for col in key:\r\n"]
[156.719267, "o", "                    self[col] = value\r\n"]
[156.743743, "o", "\r\n"]
[156.768218, "o", "            elif isinstance(value, np.ndarray) and value.ndim == 2:\r\n"]
[156.792693, "o", "                self._iset_not_inplace(key, value)\r\n"]
[156.817168, "o", "\r\n"]
[156.841644, "o", "            elif np.ndim(value) > 1:\r\n"]
[156.866119, "o", "                # list of lists\r\n"]
[156.890594, "o", "                value = DataFrame(value).values\r\n"]
[156.915069, "o", "                self._setitem_array(key, value)\r\n"]
[156.939545, "o", "\r\n"]
[156.96402, "o", "            else:\r\n"]
[156.988495, "o", "                self._iset_not_inplace(key, value)\r\n"]
[157.01297, "o", "\r\n"]
[157.037446, "o", "    def _iset_not_inplace(self, key, value) -> None:\r\n"]
[157.061921, "o", "        # GH#39510 when setting with df[key] = obj with a list-like key and\r\n"]
[157.086396, "o", "        #  list-like value, we iterate over those listlikes and set columns\r\n"]
[157.110871, "o", "        #  one at a time.  This is different from dispatching to\r\n"]
[157.135347, "o", "        #  `self.loc[:, key]= value`  because loc.__setitem__ may overwrite\r\n"]
[157.159822, "o", "        #  data inplace, whereas this will insert new arrays.\r\n"]
[157.184297, "o", "\r\n"]
[157.208772, "o", "        def igetitem(obj, i: int):\r\n"]
[157.233248, "o", "            # Note: we catch DataFrame obj before getting here, but\r\n"]
[157.257723, "o", "            #  hypothetically would return obj.iloc[:, i]\r\n"]
[157.282198, "o", "            if isinstance(obj, np.ndarray):\r\n"]
[157.306673, "o", "                return obj[..., i]\r\n"]
[157.331149, "o", "            else:\r\n"]
[157.355624, "o", "                return obj[i]\r\n"]
[157.380099, "o", "\r\n"]
[157.404574, "o", "        if self.columns.is_unique:\r\n"]
[157.42905, "o", "            if np.shape(value)[-1] != len(key):\r\n"]
[157.453525, "o", "                raise ValueError(\"Columns must be same length as key\")\r\n"]
[157.478, "o", "\r\n"]
[157.502475, "o", "            for i, col in enumerate(key):\r\n"]
[157.52695, "o", "                self[col] = igetitem(value, i)\r\n"]
[157.551426, "o", "\r\n"]
[157.575901, "o", "        else:\r\n"]
[157.600376, "o", "            ilocs = self.columns.get_indexer_non_unique(key)[0]\r\n"]
[157.624851, "o", "            if (ilocs < 0).any():\r\n"]
[157.649327, "o", "                # key entries not in self.columns\r\n"]
[157.673802, "o", "                raise NotImplementedError\r\n"]
[157.698277, "o", "\r\n"]
[157.722752, "o", "            if np.shape(value)[-1] != len(ilocs):\r\n"]
[157.747228, "o", "                raise ValueError(\"Columns must be same length as key\")\r\n"]
[157.771703, "o", "\r\n"]
[157.796178, "o", "            assert np.ndim(value) <= 2\r\n"]
[157.820653, "o", "\r\n"]
[157.845129, "o", "            orig_columns = self.columns\r\n"]
[157.869604, "o", "\r\n"]
[157.894079, "o", "            # Using self.iloc[:, i] = ... may set values inplace, which\r\n"]
[157.918554, "o", "            #  by convention we do not do in __setitem__\r\n"]
[157.94303, "o", "            try:\r\n"]
[157.967505, "o", "                self.columns = Index(range(len(self.columns)))\r\n"]
[157.99198, "o", "                for i, iloc in enumerate(ilocs):\r\n"]
[158.016455, "o", "                    self[iloc] = igetitem(value, i)\r\n"]
[158.040931, "o", "            finally:\r\n"]
[158.065406, "o", "                self.columns = orig_columns\r\n"]
[158.089881, "o", "\r\n"]
[158.114356, "o", "    def _setitem_frame(self, key, value) -> None:\r\n"]
[158.138832, "o", "        # support boolean setting with DataFrame input, e.g.\r\n"]
[158.163307, "o", "        # df[df > df2] = 0\r\n"]
[158.187782, "o", "        if isinstance(key, np.ndarray):\r\n"]
[158.212257, "o", "            if key.shape != self.shape:\r\n"]
[158.236733, "o", "                raise ValueError(\"Array conditional must be same shape as self\")\r\n"]
[158.261208, "o", "            key = self._constructor(key, **self._construct_axes_dict(), copy=False)\r\n"]
[158.285683, "o", "\r\n"]
[158.310158, "o", "        if key.size and not all(is_bool_dtype(dtype) for dtype in key.dtypes):\r\n"]
[158.334634, "o", "            raise TypeError(\r\n"]
[158.359109, "o", "                \"Must pass DataFrame or 2-d ndarray with boolean values only\"\r\n"]
[158.383584, "o", "            )\r\n"]
[158.408059, "o", "\r\n"]
[158.432535, "o", "        self._where(-key, value, inplace=True)\r\n"]
[158.45701, "o", "\r\n"]
[158.481485, "o", "    def _set_item_frame_value(self, key, value: DataFrame) -> None:\r\n"]
[158.50596, "o", "        self._ensure_valid_index(value)\r\n"]
[158.530436, "o", "\r\n"]
[158.554911, "o", "        # align columns\r\n"]
[158.579386, "o", "        if key in self.columns:\r\n"]
[158.603861, "o", "            loc = self.columns.get_loc(key)\r\n"]
[158.628337, "o", "            cols = self.columns[loc]\r\n"]
[158.652812, "o", "            len_cols = 1 if is_scalar(cols) or isinstance(cols, tuple) else len(cols)\r\n"]
[158.677287, "o", "            if len_cols != len(value.columns):\r\n"]
[158.701762, "o", "                raise ValueError(\"Columns must be same length as key\")\r\n"]
[158.726238, "o", "\r\n"]
[158.750713, "o", "            # align right-hand-side columns if self.columns\r\n"]
[158.775188, "o", "            # is multi-index and self[key] is a sub-frame\r\n"]
[158.799663, "o", "            if isinstance(self.columns, MultiIndex) and isinstance(\r\n"]
[158.824139, "o", "                loc, (slice, Series, np.ndarray, Index)\r\n"]
[158.848614, "o", "            ):\r\n"]
[158.873089, "o", "                cols_droplevel = maybe_droplevels(cols, key)\r\n"]
[158.897564, "o", "                if len(cols_droplevel) and not cols_droplevel.equals(value.columns):\r\n"]
[158.92204, "o", "                    value = value.reindex(cols_droplevel, axis=1)\r\n"]
[158.946515, "o", "\r\n"]
[158.97099, "o", "                for col, col_droplevel in zip(cols, cols_droplevel):\r\n"]
[158.995465, "o", "                    self[col] = value[col_droplevel]\r\n"]
[159.019941, "o", "                return\r\n"]
[159.044416, "o", "\r\n"]
[159.068891, "o", "            if is_scalar(cols):\r\n"]
[159.093366, "o", "                self[cols] = value[value.columns[0]]\r\n"]
[159.117842, "o", "                return\r\n"]
[159.142317, "o", "\r\n"]
[159.166792, "o", "            locs: np.ndarray | list\r\n"]
[159.191267, "o", "            if isinstance(loc, slice):\r\n"]
[159.215743, "o", "                locs = np.arange(loc.start, loc.stop, loc.step)\r\n"]
[159.240218, "o", "            elif is_scalar(loc):\r\n"]
[159.264693, "o", "                locs = [loc]\r\n"]
[159.289168, "o", "            else:\r\n"]
[159.313644, "o", "                locs = loc.nonzero()[0]\r\n"]
[159.338119, "o", "\r\n"]
[159.362594, "o", "            return self.isetitem(locs, value)\r\n"]
[159.387069, "o", "\r\n"]
[159.411545, "o", "        if len(value.columns) > 1:\r\n"]
[159.43602, "o", "            raise ValueError(\r\n"]
[159.460495, "o", "                \"Cannot set a DataFrame with multiple columns to the single \"\r\n"]
[159.48497, "o", "                f\"column {key}\"\r\n"]
[159.509446, "o", "            )\r\n"]
[159.533921, "o", "        elif len(value.columns) == 0:\r\n"]
[159.558396, "o", "            raise ValueError(\r\n"]
[159.582871, "o", "                f\"Cannot set a DataFrame without columns to the column {key}\"\r\n"]
[159.607347, "o", "            )\r\n"]
[159.631822, "o", "\r\n"]
[159.656297, "o", "        self[key] = value[value.columns[0]]\r\n"]
[159.680772, "o", "\r\n"]
[159.705248, "o", "    def _iset_item_mgr(\r\n"]
[159.729723, "o", "        self,\r\n"]
[159.754198, "o", "        loc: int | slice | np.ndarray,\r\n"]
[159.778673, "o", "        value,\r\n"]
[159.803149, "o", "        inplace: bool = False,\r\n"]
[159.827624, "o", "        refs: BlockValuesRefs | None = None,\r\n"]
[159.852099, "o", "    ) -> None:\r\n"]
[159.876574, "o", "        # when called from _set_item_mgr loc can be anything returned from get_loc\r\n"]
[159.90105, "o", "        self._mgr.iset(loc, value, inplace=inplace, refs=refs)\r\n"]
[159.925525, "o", "\r\n"]
[160.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[160.002, "i", "sed -n '1,260p' ../pandas/core/common.py\r"]
[160.004, "o", "sed -n '1,260p' ../pandas/core/common.py\r\n"]
[160.024943, "o", "\u001b[?2004l\r\n"]
[160.043885, "o", "\"\"\"\r\n"]
[160.062828, "o", "Misc tools for implementing data structures\r\n"]
[160.08177, "o", "\r\n"]
[160.100713, "o", "Note: pandas.core.common is *not* part of the public API.\r\n"]
[160.119655, "o", "\"\"\"\r\n"]
[160.138598, "o", "\r\n"]
[160.15754, "o", "from __future__ import annotations\r\n"]
[160.176483, "o", "\r\n"]
[160.195425, "o", "import builtins\r\n"]
[160.214368, "o", "from collections import (\r\n"]
[160.23331, "o", "    abc,\r\n"]
[160.252253, "o", "    defaultdict,\r\n"]
[160.271195, "o", ")\r\n"]
[160.290138, "o", "from collections.abc import (\r\n"]
[160.30908, "o", "    Collection,\r\n"]
[160.328023, "o", "    Generator,\r\n"]
[160.346966, "o", "    Hashable,\r\n"]
[160.365908, "o", "    Iterable,\r\n"]
[160.384851, "o", "    Sequence,\r\n"]
[160.403793, "o", ")\r\n"]
[160.422736, "o", "import contextlib\r\n"]
[160.441678, "o", "from functools import partial\r\n"]
[160.460621, "o", "import inspect\r\n"]
[160.479563, "o", "from typing import (\r\n"]
[160.498506, "o", "    TYPE_CHECKING,\r\n"]
[160.517448, "o", "    Any,\r\n"]
[160.536391, "o", "    Callable,\r\n"]
[160.555333, "o", "    TypeVar,\r\n"]
[160.574276, "o", "    cast,\r\n"]
[160.593218, "o", "    overload,\r\n"]
[160.612161, "o", ")\r\n"]
[160.631103, "o", "import warnings\r\n"]
[160.650046, "o", "\r\n"]
[160.668989, "o", "import numpy as np\r\n"]
[160.687931, "o", "\r\n"]
[160.706874, "o", "from pandas._libs import lib\r\n"]
[160.725816, "o", "from pandas.compat.numpy import np_version_gte1p24\r\n"]
[160.744759, "o", "\r\n"]
[160.763701, "o", "from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\r\n"]
[160.782644, "o", "from pandas.core.dtypes.common import (\r\n"]
[160.801586, "o", "    is_bool_dtype,\r\n"]
[160.820529, "o", "    is_integer,\r\n"]
[160.839471, "o", ")\r\n"]
[160.858414, "o", "from pandas.core.dtypes.generic import (\r\n"]
[160.877356, "o", "    ABCExtensionArray,\r\n"]
[160.896299, "o", "    ABCIndex,\r\n"]
[160.915241, "o", "    ABCMultiIndex,\r\n"]
[160.934184, "o", "    ABCSeries,\r\n"]
[160.953126, "o", ")\r\n"]
[160.972069, "o", "from pandas.core.dtypes.inference import iterable_not_string\r\n"]
[160.991011, "o", "\r\n"]
[161.009954, "o", "if TYPE_CHECKING:\r\n"]
[161.028897, "o", "    from pandas._typing import (\r\n"]
[161.047839, "o", "        AnyArrayLike,\r\n"]
[161.066782, "o", "        ArrayLike,\r\n"]
[161.085724, "o", "        Concatenate,\r\n"]
[161.104667, "o", "        NpDtype,\r\n"]
[161.123609, "o", "        P,\r\n"]
[161.142552, "o", "        RandomState,\r\n"]
[161.161494, "o", "        T,\r\n"]
[161.180437, "o", "    )\r\n"]
[161.199379, "o", "\r\n"]
[161.218322, "o", "    from pandas import Index\r\n"]
[161.237264, "o", "\r\n"]
[161.256207, "o", "\r\n"]
[161.275149, "o", "def flatten(line):\r\n"]
[161.294092, "o", "    \"\"\"\r\n"]
[161.313034, "o", "    Flatten an arbitrarily nested sequence.\r\n"]
[161.331977, "o", "\r\n"]
[161.35092, "o", "    Parameters\r\n"]
[161.369862, "o", "    ----------\r\n"]
[161.388805, "o", "    line : sequence\r\n"]
[161.407747, "o", "        The non string sequence to flatten\r\n"]
[161.42669, "o", "\r\n"]
[161.445632, "o", "    Notes\r\n"]
[161.464575, "o", "    -----\r\n"]
[161.483517, "o", "    This doesn't consider strings sequences.\r\n"]
[161.50246, "o", "\r\n"]
[161.521402, "o", "    Returns\r\n"]
[161.540345, "o", "    -------\r\n"]
[161.559287, "o", "    flattened : generator\r\n"]
[161.57823, "o", "    \"\"\"\r\n"]
[161.597172, "o", "    for element in line:\r\n"]
[161.616115, "o", "        if iterable_not_string(element):\r\n"]
[161.635057, "o", "            yield from flatten(element)\r\n"]
[161.654, "o", "        else:\r\n"]
[161.672943, "o", "            yield element\r\n"]
[161.691885, "o", "\r\n"]
[161.710828, "o", "\r\n"]
[161.72977, "o", "def consensus_name_attr(objs):\r\n"]
[161.748713, "o", "    name = objs[0].name\r\n"]
[161.767655, "o", "    for obj in objs[1:]:\r\n"]
[161.786598, "o", "        try:\r\n"]
[161.80554, "o", "            if obj.name != name:\r\n"]
[161.824483, "o", "                name = None\r\n"]
[161.843425, "o", "        except ValueError:\r\n"]
[161.862368, "o", "            name = None\r\n"]
[161.88131, "o", "    return name\r\n"]
[161.900253, "o", "\r\n"]
[161.919195, "o", "\r\n"]
[161.938138, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[161.95708, "o", "    \"\"\"\r\n"]
[161.976023, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[161.994966, "o", "\r\n"]
[162.013908, "o", "    Parameters\r\n"]
[162.032851, "o", "    ----------\r\n"]
[162.051793, "o", "    key : Any\r\n"]
[162.070736, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[162.089678, "o", "        All other types are not considered a boolean indexer.\r\n"]
[162.108621, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[162.127563, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[162.146506, "o", "\r\n"]
[162.165448, "o", "    Returns\r\n"]
[162.184391, "o", "    -------\r\n"]
[162.203333, "o", "    bool\r\n"]
[162.222276, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[162.241218, "o", "\r\n"]
[162.260161, "o", "    Raises\r\n"]
[162.279103, "o", "    ------\r\n"]
[162.298046, "o", "    ValueError\r\n"]
[162.316989, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[162.335931, "o", "        and contains missing values.\r\n"]
[162.354874, "o", "\r\n"]
[162.373816, "o", "    See Also\r\n"]
[162.392759, "o", "    --------\r\n"]
[162.411701, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[162.430644, "o", "        and convert to an ndarray.\r\n"]
[162.449586, "o", "    \"\"\"\r\n"]
[162.468529, "o", "    if isinstance(\r\n"]
[162.487471, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[162.506414, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[162.525356, "o", "        if key.dtype == np.object_:\r\n"]
[162.544299, "o", "            key_array = np.asarray(key)\r\n"]
[162.563241, "o", "\r\n"]
[162.582184, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[162.601126, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[162.620069, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[162.639011, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[162.657954, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[162.676897, "o", "                    raise ValueError(na_msg)\r\n"]
[162.695839, "o", "                return False\r\n"]
[162.714782, "o", "            return True\r\n"]
[162.733724, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[162.752667, "o", "            return True\r\n"]
[162.771609, "o", "    elif isinstance(key, list):\r\n"]
[162.790552, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[162.809494, "o", "        if len(key) > 0:\r\n"]
[162.828437, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[162.847379, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[162.866322, "o", "                key = list(key)\r\n"]
[162.885264, "o", "            return lib.is_bool_list(key)\r\n"]
[162.904207, "o", "\r\n"]
[162.923149, "o", "    return False\r\n"]
[162.942092, "o", "\r\n"]
[162.961034, "o", "\r\n"]
[162.979977, "o", "def cast_scalar_indexer(val):\r\n"]
[162.99892, "o", "    \"\"\"\r\n"]
[163.017862, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[163.036805, "o", "\r\n"]
[163.055747, "o", "    Parameters\r\n"]
[163.07469, "o", "    ----------\r\n"]
[163.093632, "o", "    val : scalar\r\n"]
[163.112575, "o", "\r\n"]
[163.131517, "o", "    Returns\r\n"]
[163.15046, "o", "    -------\r\n"]
[163.169402, "o", "    outval : scalar\r\n"]
[163.188345, "o", "    \"\"\"\r\n"]
[163.207287, "o", "    # assumes lib.is_scalar(val)\r\n"]
[163.22623, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[163.245172, "o", "        raise IndexError(\r\n"]
[163.264115, "o", "            # GH#34193\r\n"]
[163.283057, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[163.302, "o", "            \"to an integer key instead.\"\r\n"]
[163.320943, "o", "        )\r\n"]
[163.339885, "o", "    return val\r\n"]
[163.358828, "o", "\r\n"]
[163.37777, "o", "\r\n"]
[163.396713, "o", "def not_none(*args):\r\n"]
[163.415655, "o", "    \"\"\"\r\n"]
[163.434598, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[163.45354, "o", "    \"\"\"\r\n"]
[163.472483, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[163.491425, "o", "\r\n"]
[163.510368, "o", "\r\n"]
[163.52931, "o", "def any_none(*args) -> bool:\r\n"]
[163.548253, "o", "    \"\"\"\r\n"]
[163.567195, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[163.586138, "o", "    \"\"\"\r\n"]
[163.60508, "o", "    return any(arg is None for arg in args)\r\n"]
[163.624023, "o", "\r\n"]
[163.642966, "o", "\r\n"]
[163.661908, "o", "def all_none(*args) -> bool:\r\n"]
[163.680851, "o", "    \"\"\"\r\n"]
[163.699793, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[163.718736, "o", "    \"\"\"\r\n"]
[163.737678, "o", "    return all(arg is None for arg in args)\r\n"]
[163.756621, "o", "\r\n"]
[163.775563, "o", "\r\n"]
[163.794506, "o", "def any_not_none(*args) -> bool:\r\n"]
[163.813448, "o", "    \"\"\"\r\n"]
[163.832391, "o", "    Returns a boolean indicating if any argument is not None.\r\n"]
[163.851333, "o", "    \"\"\"\r\n"]
[163.870276, "o", "    return any(arg is not None for arg in args)\r\n"]
[163.889218, "o", "\r\n"]
[163.908161, "o", "\r\n"]
[163.927103, "o", "def all_not_none(*args) -> bool:\r\n"]
[163.946046, "o", "    \"\"\"\r\n"]
[163.964989, "o", "    Returns a boolean indicating if all arguments are not None.\r\n"]
[163.983931, "o", "    \"\"\"\r\n"]
[164.002874, "o", "    return all(arg is not None for arg in args)\r\n"]
[164.021816, "o", "\r\n"]
[164.040759, "o", "\r\n"]
[164.059701, "o", "def count_not_none(*args) -> int:\r\n"]
[164.078644, "o", "    \"\"\"\r\n"]
[164.097586, "o", "    Returns the count of arguments that are not None.\r\n"]
[164.116529, "o", "    \"\"\"\r\n"]
[164.135471, "o", "    return sum(x is not None for x in args)\r\n"]
[164.154414, "o", "\r\n"]
[164.173356, "o", "\r\n"]
[164.192299, "o", "@overload\r\n"]
[164.211241, "o", "def asarray_tuplesafe(\r\n"]
[164.230184, "o", "    values: ArrayLike | list | tuple | zip, dtype: NpDtype | None = ...\r\n"]
[164.249126, "o", ") -> np.ndarray:\r\n"]
[164.268069, "o", "    # ExtensionArray can only be returned when values is an Index, all other iterables\r\n"]
[164.287011, "o", "    # will return np.ndarray. Unfortunately \"all other\" cannot be encoded in a type\r\n"]
[164.305954, "o", "    # signature, so instead we special-case some common types.\r\n"]
[164.324897, "o", "    ...\r\n"]
[164.343839, "o", "\r\n"]
[164.362782, "o", "\r\n"]
[164.381724, "o", "@overload\r\n"]
[164.400667, "o", "def asarray_tuplesafe(values: Iterable, dtype: NpDtype | None = ...) -> ArrayLike: ...\r\n"]
[164.419609, "o", "\r\n"]
[164.438552, "o", "\r\n"]
[164.457494, "o", "def asarray_tuplesafe(values: Iterable, dtype: NpDtype | None = None) -> ArrayLike:\r\n"]
[164.476437, "o", "    if not (isinstance(values, (list, tuple)) or hasattr(values, \"__array__\")):\r\n"]
[164.495379, "o", "        values = list(values)\r\n"]
[164.514322, "o", "    elif isinstance(values, ABCIndex):\r\n"]
[164.533264, "o", "        return values._values\r\n"]
[164.552207, "o", "    elif isinstance(values, ABCSeries):\r\n"]
[164.571149, "o", "        return values._values\r\n"]
[164.590092, "o", "\r\n"]
[164.609034, "o", "    if isinstance(values, list) and dtype in [np.object_, object]:\r\n"]
[164.627977, "o", "        return construct_1d_object_array_from_listlike(values)\r\n"]
[164.64692, "o", "\r\n"]
[164.665862, "o", "    try:\r\n"]
[164.684805, "o", "        with warnings.catch_warnings():\r\n"]
[164.703747, "o", "            # Can remove warning filter once NumPy 1.24 is min version\r\n"]
[164.72269, "o", "            if not np_version_gte1p24:\r\n"]
[164.741632, "o", "                warnings.simplefilter(\"ignore\", np.VisibleDeprecationWarning)\r\n"]
[164.760575, "o", "            result = np.asarray(values, dtype=dtype)\r\n"]
[164.779517, "o", "    except ValueError:\r\n"]
[164.79846, "o", "        # Using try/except since it's more performant than checking is_list_like\r\n"]
[164.817402, "o", "        # over each element\r\n"]
[164.836345, "o", "        # error: Argument 1 to \"construct_1d_object_array_from_listlike\"\r\n"]
[164.855287, "o", "        # has incompatible type \"Iterable[Any]\"; expected \"Sized\"\r\n"]
[164.87423, "o", "        return construct_1d_object_array_from_listlike(values)  # type: ignore[arg-type]\r\n"]
[164.893172, "o", "\r\n"]
[164.912115, "o", "    if issubclass(result.dtype.type, str):\r\n"]
[164.931057, "o", "        result = np.asarray(values, dtype=object)\r\n"]
[165.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[165.002, "i", "sed -n '260,520p' ../pandas/core/common.py\r"]
[165.004, "o", "sed -n '260,520p' ../pandas/core/common.py\r\n"]
[165.02487, "o", "\u001b[?2004l\r\n"]
[165.04374, "o", "\r\n"]
[165.062611, "o", "    if result.ndim == 2:\r\n"]
[165.081481, "o", "        # Avoid building an array of arrays:\r\n"]
[165.100351, "o", "        values = [tuple(x) for x in values]\r\n"]
[165.119221, "o", "        result = construct_1d_object_array_from_listlike(values)\r\n"]
[165.138092, "o", "\r\n"]
[165.156962, "o", "    return result\r\n"]
[165.175832, "o", "\r\n"]
[165.194702, "o", "\r\n"]
[165.213573, "o", "def index_labels_to_array(\r\n"]
[165.232443, "o", "    labels: np.ndarray | Iterable, dtype: NpDtype | None = None\r\n"]
[165.251313, "o", ") -> np.ndarray:\r\n"]
[165.270183, "o", "    \"\"\"\r\n"]
[165.289053, "o", "    Transform label or iterable of labels to array, for use in Index.\r\n"]
[165.307924, "o", "\r\n"]
[165.326794, "o", "    Parameters\r\n"]
[165.345664, "o", "    ----------\r\n"]
[165.364534, "o", "    dtype : dtype\r\n"]
[165.383405, "o", "        If specified, use as dtype of the resulting array, otherwise infer.\r\n"]
[165.402275, "o", "\r\n"]
[165.421145, "o", "    Returns\r\n"]
[165.440015, "o", "    -------\r\n"]
[165.458885, "o", "    array\r\n"]
[165.477756, "o", "    \"\"\"\r\n"]
[165.496626, "o", "    if isinstance(labels, (str, tuple)):\r\n"]
[165.515496, "o", "        labels = [labels]\r\n"]
[165.534366, "o", "\r\n"]
[165.553237, "o", "    if not isinstance(labels, (list, np.ndarray)):\r\n"]
[165.572107, "o", "        try:\r\n"]
[165.590977, "o", "            labels = list(labels)\r\n"]
[165.609847, "o", "        except TypeError:  # non-iterable\r\n"]
[165.628718, "o", "            labels = [labels]\r\n"]
[165.647588, "o", "\r\n"]
[165.666458, "o", "    labels = asarray_tuplesafe(labels, dtype=dtype)\r\n"]
[165.685328, "o", "\r\n"]
[165.704198, "o", "    return labels\r\n"]
[165.723069, "o", "\r\n"]
[165.741939, "o", "\r\n"]
[165.760809, "o", "def maybe_make_list(obj):\r\n"]
[165.779679, "o", "    if obj is not None and not isinstance(obj, (tuple, list)):\r\n"]
[165.79855, "o", "        return [obj]\r\n"]
[165.81742, "o", "    return obj\r\n"]
[165.83629, "o", "\r\n"]
[165.85516, "o", "\r\n"]
[165.874031, "o", "def maybe_iterable_to_list(obj: Iterable[T] | T) -> Collection[T] | T:\r\n"]
[165.892901, "o", "    \"\"\"\r\n"]
[165.911771, "o", "    If obj is Iterable but not list-like, consume into list.\r\n"]
[165.930641, "o", "    \"\"\"\r\n"]
[165.949511, "o", "    if isinstance(obj, abc.Iterable) and not isinstance(obj, abc.Sized):\r\n"]
[165.968382, "o", "        return list(obj)\r\n"]
[165.987252, "o", "    obj = cast(Collection, obj)\r\n"]
[166.006122, "o", "    return obj\r\n"]
[166.024992, "o", "\r\n"]
[166.043863, "o", "\r\n"]
[166.062733, "o", "def is_null_slice(obj) -> bool:\r\n"]
[166.081603, "o", "    \"\"\"\r\n"]
[166.100473, "o", "    We have a null slice.\r\n"]
[166.119344, "o", "    \"\"\"\r\n"]
[166.138214, "o", "    return (\r\n"]
[166.157084, "o", "        isinstance(obj, slice)\r\n"]
[166.175954, "o", "        and obj.start is None\r\n"]
[166.194824, "o", "        and obj.stop is None\r\n"]
[166.213695, "o", "        and obj.step is None\r\n"]
[166.232565, "o", "    )\r\n"]
[166.251435, "o", "\r\n"]
[166.270305, "o", "\r\n"]
[166.289176, "o", "def is_empty_slice(obj) -> bool:\r\n"]
[166.308046, "o", "    \"\"\"\r\n"]
[166.326916, "o", "    We have an empty slice, e.g. no values are selected.\r\n"]
[166.345786, "o", "    \"\"\"\r\n"]
[166.364656, "o", "    return (\r\n"]
[166.383527, "o", "        isinstance(obj, slice)\r\n"]
[166.402397, "o", "        and obj.start is not None\r\n"]
[166.421267, "o", "        and obj.stop is not None\r\n"]
[166.440137, "o", "        and obj.start == obj.stop\r\n"]
[166.459008, "o", "    )\r\n"]
[166.477878, "o", "\r\n"]
[166.496748, "o", "\r\n"]
[166.515618, "o", "def is_true_slices(line) -> list[bool]:\r\n"]
[166.534489, "o", "    \"\"\"\r\n"]
[166.553359, "o", "    Find non-trivial slices in \"line\": return a list of booleans with same length.\r\n"]
[166.572229, "o", "    \"\"\"\r\n"]
[166.591099, "o", "    return [isinstance(k, slice) and not is_null_slice(k) for k in line]\r\n"]
[166.609969, "o", "\r\n"]
[166.62884, "o", "\r\n"]
[166.64771, "o", "# TODO: used only once in indexing; belongs elsewhere?\r\n"]
[166.66658, "o", "def is_full_slice(obj, line: int) -> bool:\r\n"]
[166.68545, "o", "    \"\"\"\r\n"]
[166.704321, "o", "    We have a full length slice.\r\n"]
[166.723191, "o", "    \"\"\"\r\n"]
[166.742061, "o", "    return (\r\n"]
[166.760931, "o", "        isinstance(obj, slice)\r\n"]
[166.779802, "o", "        and obj.start == 0\r\n"]
[166.798672, "o", "        and obj.stop == line\r\n"]
[166.817542, "o", "        and obj.step is None\r\n"]
[166.836412, "o", "    )\r\n"]
[166.855282, "o", "\r\n"]
[166.874153, "o", "\r\n"]
[166.893023, "o", "def get_callable_name(obj):\r\n"]
[166.911893, "o", "    # typical case has name\r\n"]
[166.930763, "o", "    if hasattr(obj, \"__name__\"):\r\n"]
[166.949634, "o", "        return getattr(obj, \"__name__\")\r\n"]
[166.968504, "o", "    # some objects don't; could recurse\r\n"]
[166.987374, "o", "    if isinstance(obj, partial):\r\n"]
[167.006244, "o", "        return get_callable_name(obj.func)\r\n"]
[167.025115, "o", "    # fall back to class name\r\n"]
[167.043985, "o", "    if callable(obj):\r\n"]
[167.062855, "o", "        return type(obj).__name__\r\n"]
[167.081725, "o", "    # everything failed (probably because the argument\r\n"]
[167.100595, "o", "    # wasn't actually callable); we return None\r\n"]
[167.119466, "o", "    # instead of the empty string in this case to allow\r\n"]
[167.138336, "o", "    # distinguishing between no name and a name of ''\r\n"]
[167.157206, "o", "    return None\r\n"]
[167.176076, "o", "\r\n"]
[167.194947, "o", "\r\n"]
[167.213817, "o", "def apply_if_callable(maybe_callable, obj, **kwargs):\r\n"]
[167.232687, "o", "    \"\"\"\r\n"]
[167.251557, "o", "    Evaluate possibly callable input using obj and kwargs if it is callable,\r\n"]
[167.270427, "o", "    otherwise return as it is.\r\n"]
[167.289298, "o", "\r\n"]
[167.308168, "o", "    Parameters\r\n"]
[167.327038, "o", "    ----------\r\n"]
[167.345908, "o", "    maybe_callable : possibly a callable\r\n"]
[167.364779, "o", "    obj : NDFrame\r\n"]
[167.383649, "o", "    **kwargs\r\n"]
[167.402519, "o", "    \"\"\"\r\n"]
[167.421389, "o", "    if callable(maybe_callable):\r\n"]
[167.44026, "o", "        return maybe_callable(obj, **kwargs)\r\n"]
[167.45913, "o", "\r\n"]
[167.478, "o", "    return maybe_callable\r\n"]
[167.49687, "o", "\r\n"]
[167.51574, "o", "\r\n"]
[167.534611, "o", "def standardize_mapping(into):\r\n"]
[167.553481, "o", "    \"\"\"\r\n"]
[167.572351, "o", "    Helper function to standardize a supplied mapping.\r\n"]
[167.591221, "o", "\r\n"]
[167.610092, "o", "    Parameters\r\n"]
[167.628962, "o", "    ----------\r\n"]
[167.647832, "o", "    into : instance or subclass of collections.abc.Mapping\r\n"]
[167.666702, "o", "        Must be a class, an initialized collections.defaultdict,\r\n"]
[167.685573, "o", "        or an instance of a collections.abc.Mapping subclass.\r\n"]
[167.704443, "o", "\r\n"]
[167.723313, "o", "    Returns\r\n"]
[167.742183, "o", "    -------\r\n"]
[167.761053, "o", "    mapping : a collections.abc.Mapping subclass or other constructor\r\n"]
[167.779924, "o", "        a callable object that can accept an iterator to create\r\n"]
[167.798794, "o", "        the desired Mapping.\r\n"]
[167.817664, "o", "\r\n"]
[167.836534, "o", "    See Also\r\n"]
[167.855405, "o", "    --------\r\n"]
[167.874275, "o", "    DataFrame.to_dict\r\n"]
[167.893145, "o", "    Series.to_dict\r\n"]
[167.912015, "o", "    \"\"\"\r\n"]
[167.930885, "o", "    if not inspect.isclass(into):\r\n"]
[167.949756, "o", "        if isinstance(into, defaultdict):\r\n"]
[167.968626, "o", "            return partial(defaultdict, into.default_factory)\r\n"]
[167.987496, "o", "        into = type(into)\r\n"]
[168.006366, "o", "    if not issubclass(into, abc.Mapping):\r\n"]
[168.025237, "o", "        raise TypeError(f\"unsupported type: {into}\")\r\n"]
[168.044107, "o", "    if into == defaultdict:\r\n"]
[168.062977, "o", "        raise TypeError(\"to_dict() only accepts initialized defaultdicts\")\r\n"]
[168.081847, "o", "    return into\r\n"]
[168.100718, "o", "\r\n"]
[168.119588, "o", "\r\n"]
[168.138458, "o", "@overload\r\n"]
[168.157328, "o", "def random_state(state: np.random.Generator) -> np.random.Generator: ...\r\n"]
[168.176198, "o", "\r\n"]
[168.195069, "o", "\r\n"]
[168.213939, "o", "@overload\r\n"]
[168.232809, "o", "def random_state(\r\n"]
[168.251679, "o", "    state: int | np.ndarray | np.random.BitGenerator | np.random.RandomState | None,\r\n"]
[168.27055, "o", ") -> np.random.RandomState: ...\r\n"]
[168.28942, "o", "\r\n"]
[168.30829, "o", "\r\n"]
[168.32716, "o", "def random_state(state: RandomState | None = None):\r\n"]
[168.346031, "o", "    \"\"\"\r\n"]
[168.364901, "o", "    Helper function for processing random_state arguments.\r\n"]
[168.383771, "o", "\r\n"]
[168.402641, "o", "    Parameters\r\n"]
[168.421511, "o", "    ----------\r\n"]
[168.440382, "o", "    state : int, array-like, BitGenerator, Generator, np.random.RandomState, None.\r\n"]
[168.459252, "o", "        If receives an int, array-like, or BitGenerator, passes to\r\n"]
[168.478122, "o", "        np.random.RandomState() as seed.\r\n"]
[168.496992, "o", "        If receives an np.random RandomState or Generator, just returns that unchanged.\r\n"]
[168.515863, "o", "        If receives `None`, returns np.random.\r\n"]
[168.534733, "o", "        If receives anything else, raises an informative ValueError.\r\n"]
[168.553603, "o", "\r\n"]
[168.572473, "o", "        Default None.\r\n"]
[168.591344, "o", "\r\n"]
[168.610214, "o", "    Returns\r\n"]
[168.629084, "o", "    -------\r\n"]
[168.647954, "o", "    np.random.RandomState or np.random.Generator. If state is None, returns np.random\r\n"]
[168.666824, "o", "\r\n"]
[168.685695, "o", "    \"\"\"\r\n"]
[168.704565, "o", "    if is_integer(state) or isinstance(state, (np.ndarray, np.random.BitGenerator)):\r\n"]
[168.723435, "o", "        return np.random.RandomState(state)\r\n"]
[168.742305, "o", "    elif isinstance(state, np.random.RandomState):\r\n"]
[168.761176, "o", "        return state\r\n"]
[168.780046, "o", "    elif isinstance(state, np.random.Generator):\r\n"]
[168.798916, "o", "        return state\r\n"]
[168.817786, "o", "    elif state is None:\r\n"]
[168.836656, "o", "        return np.random\r\n"]
[168.855527, "o", "    else:\r\n"]
[168.874397, "o", "        raise ValueError(\r\n"]
[168.893267, "o", "            \"random_state must be an integer, array-like, a BitGenerator, Generator, \"\r\n"]
[168.912137, "o", "            \"a numpy RandomState, or None\"\r\n"]
[168.931008, "o", "        )\r\n"]
[168.949878, "o", "\r\n"]
[168.968748, "o", "\r\n"]
[168.987618, "o", "_T = TypeVar(\"_T\")  # Secondary TypeVar for use in pipe's type hints\r\n"]
[169.006489, "o", "\r\n"]
[169.025359, "o", "\r\n"]
[169.044229, "o", "@overload\r\n"]
[169.063099, "o", "def pipe(\r\n"]
[169.081969, "o", "    obj: _T,\r\n"]
[169.10084, "o", "    func: Callable[Concatenate[_T, P], T],\r\n"]
[169.11971, "o", "    *args: P.args,\r\n"]
[169.13858, "o", "    **kwargs: P.kwargs,\r\n"]
[169.15745, "o", ") -> T: ...\r\n"]
[169.176321, "o", "\r\n"]
[169.195191, "o", "\r\n"]
[169.214061, "o", "@overload\r\n"]
[169.232931, "o", "def pipe(\r\n"]
[169.251802, "o", "    obj: Any,\r\n"]
[169.270672, "o", "    func: tuple[Callable[..., T], str],\r\n"]
[169.289542, "o", "    *args: Any,\r\n"]
[169.308412, "o", "    **kwargs: Any,\r\n"]
[169.327282, "o", ") -> T: ...\r\n"]
[169.346153, "o", "\r\n"]
[169.365023, "o", "\r\n"]
[169.383893, "o", "def pipe(\r\n"]
[169.402763, "o", "    obj: _T,\r\n"]
[169.421634, "o", "    func: Callable[Concatenate[_T, P], T] | tuple[Callable[..., T], str],\r\n"]
[169.440504, "o", "    *args: Any,\r\n"]
[169.459374, "o", "    **kwargs: Any,\r\n"]
[169.478244, "o", ") -> T:\r\n"]
[169.497115, "o", "    \"\"\"\r\n"]
[169.515985, "o", "    Apply a function ``func`` to object ``obj`` either by passing obj as the\r\n"]
[169.534855, "o", "    first argument to the function or, in the case that the func is a tuple,\r\n"]
[169.553725, "o", "    interpret the first element of the tuple as a function and pass the obj to\r\n"]
[169.572595, "o", "    that function as a keyword argument whose key is the value of the second\r\n"]
[169.591466, "o", "    element of the tuple.\r\n"]
[169.610336, "o", "\r\n"]
[169.629206, "o", "    Parameters\r\n"]
[169.648076, "o", "    ----------\r\n"]
[169.666947, "o", "    func : callable or tuple of (callable, str)\r\n"]
[169.685817, "o", "        Function to apply to this object or, alternatively, a\r\n"]
[169.704687, "o", "        ``(callable, data_keyword)`` tuple where ``data_keyword`` is a\r\n"]
[169.723557, "o", "        string indicating the keyword of ``callable`` that expects the\r\n"]
[169.742427, "o", "        object.\r\n"]
[169.761298, "o", "    *args : iterable, optional\r\n"]
[169.780168, "o", "        Positional arguments passed into ``func``.\r\n"]
[169.799038, "o", "    **kwargs : dict, optional\r\n"]
[169.817908, "o", "        A dictionary of keyword arguments passed into ``func``.\r\n"]
[169.836779, "o", "\r\n"]
[169.855649, "o", "    Returns\r\n"]
[169.874519, "o", "    -------\r\n"]
[169.893389, "o", "    object : the return type of ``func``.\r\n"]
[169.91226, "o", "    \"\"\"\r\n"]
[169.93113, "o", "    if isinstance(func, tuple):\r\n"]
[170.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[170.002, "i", "grep -n \"def _getitem_bool_array\" -n ../pandas/core/frame.py\r"]
[170.004, "o", "grep -n \"def _getitem_bool_array\" -n ../pandas/core/frame.py\r\n"]
[172.478, "o", "\u001b[?2004l\r\n"]
[175.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[175.002, "i", "grep -n \"def is_bool_indexer\" ../pandas/core/common.py\r"]
[175.004, "o", "grep -n \"def is_bool_indexer\" ../pandas/core/common.py\r\n"]
[177.478, "o", "\u001b[?2004l\r\n"]
[180.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[180.002, "i", "grep -n \"def check_bool_indexer\" ../pandas/core/indexing.py\r"]
[180.004, "o", "grep -n \"def check_bool_indexer\" ../pandas/core/indexing.py\r\n"]
[182.478, "o", "\u001b[?2004l\r\n"]
[185.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[185.002, "i", "sed -n '1,500p' ../pandas/core/indexing.py | sed -n '2400,2700p'\r"]
[185.004, "o", "sed -n '1,500p' ../pandas/core/indexing.py | sed -n '2400,2700p'\r\n"]
[185.006, "o", "\u001b[?2004l\r\n"]
[190.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[190.002, "i", "awk 'NR>=1 && NR<=12000 && /def _getitem_bool_array/{start=NR-5} NR>=start && NR<=start+120 {print NR\":\"$\r"]
[190.004, "o", "awk 'NR>=1 && NR<=12000 && /def _getitem_bool_array/{start=NR-5} NR>=start && NR<=start+120 {print NR\":\"$\r\n"]
[190.026773, "o", "$0}' ../pandas/core/frame.py\r\n"]
[190.047546, "o", "\u001b[?2004l\r\n"]
[190.068319, "o", "1:\"\"\"\r\n"]
[190.089092, "o", "2:DataFrame\r\n"]
[190.109866, "o", "3:---------\r\n"]
[190.130639, "o", "4:An efficient 2D container for potentially mixed-type time series or other\r\n"]
[190.151412, "o", "5:labeled data series.\r\n"]
[190.172185, "o", "6:\r\n"]
[190.192958, "o", "7:Similar to its R counterpart, data.frame, except providing automatic data\r\n"]
[190.213731, "o", "8:alignment and a host of useful data manipulation methods having to do with the\r\n"]
[190.234504, "o", "9:labeling information\r\n"]
[190.255277, "o", "10:\"\"\"\r\n"]
[190.27605, "o", "11:\r\n"]
[190.296824, "o", "12:from __future__ import annotations\r\n"]
[190.317597, "o", "13:\r\n"]
[190.33837, "o", "14:import collections\r\n"]
[190.359143, "o", "15:from collections import abc\r\n"]
[190.379916, "o", "16:from collections.abc import (\r\n"]
[190.400689, "o", "17:    Hashable,\r\n"]
[190.421462, "o", "18:    Iterable,\r\n"]
[190.442235, "o", "19:    Iterator,\r\n"]
[190.463008, "o", "20:    Mapping,\r\n"]
[190.483782, "o", "21:    Sequence,\r\n"]
[190.504555, "o", "22:)\r\n"]
[190.525328, "o", "23:import functools\r\n"]
[190.546101, "o", "24:from inspect import signature\r\n"]
[190.566874, "o", "25:from io import StringIO\r\n"]
[190.587647, "o", "26:import itertools\r\n"]
[190.60842, "o", "27:import operator\r\n"]
[190.629193, "o", "28:import sys\r\n"]
[190.649966, "o", "29:from textwrap import dedent\r\n"]
[190.670739, "o", "30:from typing import (\r\n"]
[190.691513, "o", "31:    TYPE_CHECKING,\r\n"]
[190.712286, "o", "32:    Any,\r\n"]
[190.733059, "o", "33:    Callable,\r\n"]
[190.753832, "o", "34:    Literal,\r\n"]
[190.774605, "o", "35:    cast,\r\n"]
[190.795378, "o", "36:    overload,\r\n"]
[190.816151, "o", "37:)\r\n"]
[190.836924, "o", "38:import warnings\r\n"]
[190.857697, "o", "39:\r\n"]
[190.878471, "o", "40:import numpy as np\r\n"]
[190.899244, "o", "41:from numpy import ma\r\n"]
[190.920017, "o", "42:\r\n"]
[190.94079, "o", "43:from pandas._config import get_option\r\n"]
[190.961563, "o", "44:\r\n"]
[190.982336, "o", "45:from pandas._libs import (\r\n"]
[191.003109, "o", "46:    algos as libalgos,\r\n"]
[191.023882, "o", "47:    lib,\r\n"]
[191.044655, "o", "48:    properties,\r\n"]
[191.065429, "o", "49:)\r\n"]
[191.086202, "o", "50:from pandas._libs.hashtable import duplicated\r\n"]
[191.106975, "o", "51:from pandas._libs.lib import is_range_indexer\r\n"]
[191.127748, "o", "52:from pandas.compat import PYPY\r\n"]
[191.148521, "o", "53:from pandas.compat._constants import REF_COUNT\r\n"]
[191.169294, "o", "54:from pandas.compat._optional import import_optional_dependency\r\n"]
[191.190067, "o", "55:from pandas.compat.numpy import function as nv\r\n"]
[191.21084, "o", "56:from pandas.errors import (\r\n"]
[191.231613, "o", "57:    ChainedAssignmentError,\r\n"]
[191.252387, "o", "58:    InvalidIndexError,\r\n"]
[191.27316, "o", "59:)\r\n"]
[191.293933, "o", "60:from pandas.errors.cow import (\r\n"]
[191.314706, "o", "61:    _chained_assignment_method_msg,\r\n"]
[191.335479, "o", "62:    _chained_assignment_msg,\r\n"]
[191.356252, "o", "63:)\r\n"]
[191.377025, "o", "64:from pandas.util._decorators import (\r\n"]
[191.397798, "o", "65:    Appender,\r\n"]
[191.418571, "o", "66:    Substitution,\r\n"]
[191.439345, "o", "67:    deprecate_nonkeyword_arguments,\r\n"]
[191.460118, "o", "68:    doc,\r\n"]
[191.480891, "o", "69:    set_module,\r\n"]
[191.501664, "o", "70:)\r\n"]
[191.522437, "o", "71:from pandas.util._exceptions import (\r\n"]
[191.54321, "o", "72:    find_stack_level,\r\n"]
[191.563983, "o", "73:    rewrite_warning,\r\n"]
[191.584756, "o", "74:)\r\n"]
[191.605529, "o", "75:from pandas.util._validators import (\r\n"]
[191.626303, "o", "76:    validate_ascending,\r\n"]
[191.647076, "o", "77:    validate_bool_kwarg,\r\n"]
[191.667849, "o", "78:    validate_percentile,\r\n"]
[191.688622, "o", "79:)\r\n"]
[191.709395, "o", "80:\r\n"]
[191.730168, "o", "81:from pandas.core.dtypes.cast import (\r\n"]
[191.750941, "o", "82:    LossySetitemError,\r\n"]
[191.771714, "o", "83:    can_hold_element,\r\n"]
[191.792487, "o", "84:    construct_1d_arraylike_from_scalar,\r\n"]
[191.813261, "o", "85:    construct_2d_arraylike_from_scalar,\r\n"]
[191.834034, "o", "86:    find_common_type,\r\n"]
[191.854807, "o", "87:    infer_dtype_from_scalar,\r\n"]
[191.87558, "o", "88:    invalidate_string_dtypes,\r\n"]
[191.896353, "o", "89:    maybe_downcast_to_dtype,\r\n"]
[191.917126, "o", "90:)\r\n"]
[191.937899, "o", "91:from pandas.core.dtypes.common import (\r\n"]
[191.958672, "o", "92:    infer_dtype_from_object,\r\n"]
[191.979445, "o", "93:    is_1d_only_ea_dtype,\r\n"]
[192.000218, "o", "94:    is_array_like,\r\n"]
[192.020992, "o", "95:    is_bool_dtype,\r\n"]
[192.041765, "o", "96:    is_dataclass,\r\n"]
[192.062538, "o", "97:    is_dict_like,\r\n"]
[192.083311, "o", "98:    is_float,\r\n"]
[192.104084, "o", "99:    is_float_dtype,\r\n"]
[192.124857, "o", "100:    is_hashable,\r\n"]
[192.14563, "o", "101:    is_integer,\r\n"]
[192.166403, "o", "102:    is_integer_dtype,\r\n"]
[192.187176, "o", "103:    is_iterator,\r\n"]
[192.20795, "o", "104:    is_list_like,\r\n"]
[192.228723, "o", "105:    is_scalar,\r\n"]
[192.249496, "o", "106:    is_sequence,\r\n"]
[192.270269, "o", "107:    needs_i8_conversion,\r\n"]
[192.291042, "o", "108:    pandas_dtype,\r\n"]
[192.311815, "o", "109:)\r\n"]
[192.332588, "o", "110:from pandas.core.dtypes.concat import concat_compat\r\n"]
[192.353361, "o", "111:from pandas.core.dtypes.dtypes import (\r\n"]
[192.374134, "o", "112:    ArrowDtype,\r\n"]
[192.394908, "o", "113:    BaseMaskedDtype,\r\n"]
[192.415681, "o", "114:    ExtensionDtype,\r\n"]
[192.436454, "o", "115:)\r\n"]
[192.457227, "o", "116:from pandas.core.dtypes.missing import (\r\n"]
[192.478, "o", "117:    isna,\r\n"]
[192.498773, "o", "118:    notna,\r\n"]
[192.519546, "o", "119:)\r\n"]
[192.540319, "o", "120:\r\n"]
[192.561092, "o", "3931:    def _getitem_bool_array(self, key):\r\n"]
[192.581866, "o", "3932:        # also raises Exception if object array with NA values\r\n"]
[192.602639, "o", "3933:        # warning here just in case -- previously __setitem__ was\r\n"]
[192.623412, "o", "3934:        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[192.644185, "o", "3935:        # go with the __setitem__ behavior since that is more consistent\r\n"]
[192.664958, "o", "3936:        # with all other indexing behavior\r\n"]
[192.685731, "o", "3937:        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[192.706504, "o", "3938:            warnings.warn(\r\n"]
[192.727277, "o", "3939:                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[192.74805, "o", "3940:                UserWarning,\r\n"]
[192.768824, "o", "3941:                stacklevel=find_stack_level(),\r\n"]
[192.789597, "o", "3942:            )\r\n"]
[192.81037, "o", "3943:        elif len(key) != len(self.index):\r\n"]
[192.831143, "o", "3944:            raise ValueError(\r\n"]
[192.851916, "o", "3945:                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[192.872689, "o", "3946:            )\r\n"]
[192.893462, "o", "3947:\r\n"]
[192.914235, "o", "3948:        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[192.935008, "o", "3949:        # be reindexed to match DataFrame rows\r\n"]
[192.955782, "o", "3950:        key = check_bool_indexer(self.index, key)\r\n"]
[192.976555, "o", "3951:\r\n"]
[192.997328, "o", "3952:        if key.all():\r\n"]
[193.018101, "o", "3953:            return self.copy(deep=False)\r\n"]
[193.038874, "o", "3954:\r\n"]
[193.059647, "o", "3955:        indexer = key.nonzero()[0]\r\n"]
[193.08042, "o", "3956:        return self.take(indexer, axis=0)\r\n"]
[193.101193, "o", "3957:\r\n"]
[193.121966, "o", "3958:    def _getitem_multilevel(self, key):\r\n"]
[193.142739, "o", "3959:        # self.columns is a MultiIndex\r\n"]
[193.163513, "o", "3960:        loc = self.columns.get_loc(key)\r\n"]
[193.184286, "o", "3961:        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[193.205059, "o", "3962:            new_columns = self.columns[loc]\r\n"]
[193.225832, "o", "3963:            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[193.246605, "o", "3964:            result = self.iloc[:, loc]\r\n"]
[193.267378, "o", "3965:            result.columns = result_columns\r\n"]
[193.288151, "o", "3966:\r\n"]
[193.308924, "o", "3967:            # If there is only one column being returned, and its name is\r\n"]
[193.329697, "o", "3968:            # either an empty string, or a tuple with an empty string as its\r\n"]
[193.350471, "o", "3969:            # first element, then treat the empty string as a placeholder\r\n"]
[193.371244, "o", "3970:            # and return the column as if the user had provided that empty\r\n"]
[193.392017, "o", "3971:            # string in the key. If the result is a Series, exclude the\r\n"]
[193.41279, "o", "3972:            # implied empty string from its name.\r\n"]
[193.433563, "o", "3973:            if len(result.columns) == 1:\r\n"]
[193.454336, "o", "3974:                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[193.475109, "o", "3975:                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[193.495882, "o", "3976:                top = result.columns[0]\r\n"]
[193.516655, "o", "3977:                if isinstance(top, tuple):\r\n"]
[193.537429, "o", "3978:                    top = top[0]\r\n"]
[193.558202, "o", "3979:                if top == \"\":\r\n"]
[193.578975, "o", "3980:                    result = result[\"\"]\r\n"]
[193.599748, "o", "3981:                    if isinstance(result, Series):\r\n"]
[193.620521, "o", "3982:                        result = self._constructor_sliced(\r\n"]
[193.641294, "o", "3983:                            result, index=self.index, name=key\r\n"]
[193.662067, "o", "3984:                        )\r\n"]
[193.68284, "o", "3985:\r\n"]
[193.703613, "o", "3986:            return result\r\n"]
[193.724387, "o", "3987:        else:\r\n"]
[193.74516, "o", "3988:            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[193.765933, "o", "3989:            return self._ixs(loc, axis=1)\r\n"]
[193.786706, "o", "3990:\r\n"]
[193.807479, "o", "3991:    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[193.828252, "o", "3992:        \"\"\"\r\n"]
[193.849025, "o", "3993:        Quickly retrieve single value at passed column and index.\r\n"]
[193.869798, "o", "3994:\r\n"]
[193.890571, "o", "3995:        Parameters\r\n"]
[193.911345, "o", "3996:        ----------\r\n"]
[193.932118, "o", "3997:        index : row label\r\n"]
[193.952891, "o", "3998:        col : column label\r\n"]
[193.973664, "o", "3999:        takeable : interpret the index/col as indexers, default False\r\n"]
[193.994437, "o", "4000:\r\n"]
[194.01521, "o", "4001:        Returns\r\n"]
[194.035983, "o", "4002:        -------\r\n"]
[194.056756, "o", "4003:        scalar\r\n"]
[194.077529, "o", "4004:\r\n"]
[194.098303, "o", "4005:        Notes\r\n"]
[194.119076, "o", "4006:        -----\r\n"]
[194.139849, "o", "4007:        Assumes that both `self.index._index_as_unique` and\r\n"]
[194.160622, "o", "4008:        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[194.181395, "o", "4009:        \"\"\"\r\n"]
[194.202168, "o", "4010:        if takeable:\r\n"]
[194.222941, "o", "4011:            series = self._ixs(col, axis=1)\r\n"]
[194.243714, "o", "4012:            return series._values[index]\r\n"]
[194.264487, "o", "4013:\r\n"]
[194.285261, "o", "4014:        series = self._get_item(col)\r\n"]
[194.306034, "o", "4015:        engine = self.index._engine\r\n"]
[194.326807, "o", "4016:\r\n"]
[194.34758, "o", "4017:        if not isinstance(self.index, MultiIndex):\r\n"]
[194.368353, "o", "4018:            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[194.389126, "o", "4019:            #  results if our categories are integers that dont match our codes\r\n"]
[194.409899, "o", "4020:            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[194.430672, "o", "4021:            row = self.index.get_loc(index)\r\n"]
[194.451445, "o", "4022:            return series._values[row]\r\n"]
[194.472218, "o", "4023:\r\n"]
[194.492992, "o", "4024:        # For MultiIndex going through engine effectively restricts us to\r\n"]
[194.513765, "o", "4025:        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[194.534538, "o", "4026:        loc = engine.get_loc(index)\r\n"]
[194.555311, "o", "4027:        return series._values[loc]\r\n"]
[194.576084, "o", "4028:\r\n"]
[194.596857, "o", "4029:    def isetitem(self, loc, value) -> None:\r\n"]
[194.61763, "o", "4030:        \"\"\"\r\n"]
[194.638403, "o", "4031:        Set the given value in the column with position `loc`.\r\n"]
[194.659176, "o", "4032:\r\n"]
[194.67995, "o", "4033:        This is a positional analogue to ``__setitem__``.\r\n"]
[194.700723, "o", "4034:\r\n"]
[194.721496, "o", "4035:        Parameters\r\n"]
[194.742269, "o", "4036:        ----------\r\n"]
[194.763042, "o", "4037:        loc : int or sequence of ints\r\n"]
[194.783815, "o", "4038:            Index position for the column.\r\n"]
[194.804588, "o", "4039:        value : scalar or arraylike\r\n"]
[194.825361, "o", "4040:            Value(s) for the column.\r\n"]
[194.846134, "o", "4041:\r\n"]
[194.866908, "o", "4042:        See Also\r\n"]
[194.887681, "o", "4043:        --------\r\n"]
[194.908454, "o", "4044:        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[194.929227, "o", "4045:            position.\r\n"]
[195.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[195.002, "i", "sed -n '1,600p' ../pandas/core/common.py | sed -n '80,220p'\r"]
[195.004, "o", "sed -n '1,600p' ../pandas/core/common.py | sed -n '80,220p'\r\n"]
[195.040817, "o", "\u001b[?2004l\r\n"]
[195.075634, "o", "    -------\r\n"]
[195.110451, "o", "    flattened : generator\r\n"]
[195.145268, "o", "    \"\"\"\r\n"]
[195.180085, "o", "    for element in line:\r\n"]
[195.214901, "o", "        if iterable_not_string(element):\r\n"]
[195.249718, "o", "            yield from flatten(element)\r\n"]
[195.284535, "o", "        else:\r\n"]
[195.319352, "o", "            yield element\r\n"]
[195.354169, "o", "\r\n"]
[195.388986, "o", "\r\n"]
[195.423803, "o", "def consensus_name_attr(objs):\r\n"]
[195.45862, "o", "    name = objs[0].name\r\n"]
[195.493437, "o", "    for obj in objs[1:]:\r\n"]
[195.528254, "o", "        try:\r\n"]
[195.56307, "o", "            if obj.name != name:\r\n"]
[195.597887, "o", "                name = None\r\n"]
[195.632704, "o", "        except ValueError:\r\n"]
[195.667521, "o", "            name = None\r\n"]
[195.702338, "o", "    return name\r\n"]
[195.737155, "o", "\r\n"]
[195.771972, "o", "\r\n"]
[195.806789, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[195.841606, "o", "    \"\"\"\r\n"]
[195.876423, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[195.911239, "o", "\r\n"]
[195.946056, "o", "    Parameters\r\n"]
[195.980873, "o", "    ----------\r\n"]
[196.01569, "o", "    key : Any\r\n"]
[196.050507, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[196.085324, "o", "        All other types are not considered a boolean indexer.\r\n"]
[196.120141, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[196.154958, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[196.189775, "o", "\r\n"]
[196.224592, "o", "    Returns\r\n"]
[196.259408, "o", "    -------\r\n"]
[196.294225, "o", "    bool\r\n"]
[196.329042, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[196.363859, "o", "\r\n"]
[196.398676, "o", "    Raises\r\n"]
[196.433493, "o", "    ------\r\n"]
[196.46831, "o", "    ValueError\r\n"]
[196.503127, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[196.537944, "o", "        and contains missing values.\r\n"]
[196.572761, "o", "\r\n"]
[196.607577, "o", "    See Also\r\n"]
[196.642394, "o", "    --------\r\n"]
[196.677211, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[196.712028, "o", "        and convert to an ndarray.\r\n"]
[196.746845, "o", "    \"\"\"\r\n"]
[196.781662, "o", "    if isinstance(\r\n"]
[196.816479, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[196.851296, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[196.886113, "o", "        if key.dtype == np.object_:\r\n"]
[196.92093, "o", "            key_array = np.asarray(key)\r\n"]
[196.955746, "o", "\r\n"]
[196.990563, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[197.02538, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[197.060197, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[197.095014, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[197.129831, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[197.164648, "o", "                    raise ValueError(na_msg)\r\n"]
[197.199465, "o", "                return False\r\n"]
[197.234282, "o", "            return True\r\n"]
[197.269099, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[197.303915, "o", "            return True\r\n"]
[197.338732, "o", "    elif isinstance(key, list):\r\n"]
[197.373549, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[197.408366, "o", "        if len(key) > 0:\r\n"]
[197.443183, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[197.478, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[197.512817, "o", "                key = list(key)\r\n"]
[197.547634, "o", "            return lib.is_bool_list(key)\r\n"]
[197.582451, "o", "\r\n"]
[197.617268, "o", "    return False\r\n"]
[197.652085, "o", "\r\n"]
[197.686901, "o", "\r\n"]
[197.721718, "o", "def cast_scalar_indexer(val):\r\n"]
[197.756535, "o", "    \"\"\"\r\n"]
[197.791352, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[197.826169, "o", "\r\n"]
[197.860986, "o", "    Parameters\r\n"]
[197.895803, "o", "    ----------\r\n"]
[197.93062, "o", "    val : scalar\r\n"]
[197.965437, "o", "\r\n"]
[198.000254, "o", "    Returns\r\n"]
[198.03507, "o", "    -------\r\n"]
[198.069887, "o", "    outval : scalar\r\n"]
[198.104704, "o", "    \"\"\"\r\n"]
[198.139521, "o", "    # assumes lib.is_scalar(val)\r\n"]
[198.174338, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[198.209155, "o", "        raise IndexError(\r\n"]
[198.243972, "o", "            # GH#34193\r\n"]
[198.278789, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[198.313606, "o", "            \"to an integer key instead.\"\r\n"]
[198.348423, "o", "        )\r\n"]
[198.383239, "o", "    return val\r\n"]
[198.418056, "o", "\r\n"]
[198.452873, "o", "\r\n"]
[198.48769, "o", "def not_none(*args):\r\n"]
[198.522507, "o", "    \"\"\"\r\n"]
[198.557324, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[198.592141, "o", "    \"\"\"\r\n"]
[198.626958, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[198.661775, "o", "\r\n"]
[198.696592, "o", "\r\n"]
[198.731408, "o", "def any_none(*args) -> bool:\r\n"]
[198.766225, "o", "    \"\"\"\r\n"]
[198.801042, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[198.835859, "o", "    \"\"\"\r\n"]
[198.870676, "o", "    return any(arg is None for arg in args)\r\n"]
[198.905493, "o", "\r\n"]
[198.94031, "o", "\r\n"]
[198.975127, "o", "def all_none(*args) -> bool:\r\n"]
[199.009944, "o", "    \"\"\"\r\n"]
[199.044761, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[199.079577, "o", "    \"\"\"\r\n"]
[199.114394, "o", "    return all(arg is None for arg in args)\r\n"]
[199.149211, "o", "\r\n"]
[199.184028, "o", "\r\n"]
[199.218845, "o", "def any_not_none(*args) -> bool:\r\n"]
[199.253662, "o", "    \"\"\"\r\n"]
[199.288479, "o", "    Returns a boolean indicating if any argument is not None.\r\n"]
[199.323296, "o", "    \"\"\"\r\n"]
[199.358113, "o", "    return any(arg is not None for arg in args)\r\n"]
[199.39293, "o", "\r\n"]
[199.427746, "o", "\r\n"]
[199.462563, "o", "def all_not_none(*args) -> bool:\r\n"]
[199.49738, "o", "    \"\"\"\r\n"]
[199.532197, "o", "    Returns a boolean indicating if all arguments are not None.\r\n"]
[199.567014, "o", "    \"\"\"\r\n"]
[199.601831, "o", "    return all(arg is not None for arg in args)\r\n"]
[199.636648, "o", "\r\n"]
[199.671465, "o", "\r\n"]
[199.706282, "o", "def count_not_none(*args) -> int:\r\n"]
[199.741099, "o", "    \"\"\"\r\n"]
[199.775915, "o", "    Returns the count of arguments that are not None.\r\n"]
[199.810732, "o", "    \"\"\"\r\n"]
[199.845549, "o", "    return sum(x is not None for x in args)\r\n"]
[199.880366, "o", "\r\n"]
[199.915183, "o", "\r\n"]
[200.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[200.002, "i", "grep -n \"def _getitem_bool_array\" ../pandas/core/frame.py\r"]
[200.004, "o", "grep -n \"def _getitem_bool_array\" ../pandas/core/frame.py\r\n"]
[202.478, "o", "\u001b[?2004l\r\n"]
[205.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[205.002, "i", "grep -n \"def is_bool_indexer\" ../pandas/core/common.py\r"]
[205.004, "o", "grep -n \"def is_bool_indexer\" ../pandas/core/common.py\r\n"]
[207.478, "o", "\u001b[?2004l\r\n"]
[210.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[210.002, "i", "grep -n \"def check_bool_indexer\" ../pandas/core/indexing.py\r"]
[210.004, "o", "grep -n \"def check_bool_indexer\" ../pandas/core/indexing.py\r\n"]
[212.478, "o", "\u001b[?2004l\r\n"]
[215.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[215.002, "i", "nl -ba ../pandas/core/frame.py | sed -n '1,9999p' | awk -F: '/def _getitem_bool_array/{ln=$1; print ln-10\r"]
[215.004, "o", "nl -ba ../pandas/core/frame.py | sed -n '1,9999p' | awk -F: '/def _getitem_bool_array/{ln=$1; print ln-10\r\n"]
[216.654, "o", "0\":\"; exit}' | xargs -I{} sh -lc 'start={}; end=$((start+160)); sed -n \"${start},${end}p\" ../pandas/core/frame.py'\r\n"]
[218.302, "o", "\u001b[?2004l\r\n"]
[220.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[220.002, "i", "nl -ba ../pandas/core/common.py | sed -n '1,9999p' | awk -F: '/def is_bool_indexer/{ln=$1; print ln-20\":\"\r"]
[220.004, "o", "nl -ba ../pandas/core/common.py | sed -n '1,9999p' | awk -F: '/def is_bool_indexer/{ln=$1; print ln-20\":\"\r\n"]
[221.654, "o", "\"; exit}' | xargs -I{} sh -lc 'start={}; end=$((start+200)); sed -n \"${start},${end}p\" ../pandas/core/common.py'\r\n"]
[223.302, "o", "\u001b[?2004l\r\n"]
[225.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[225.002, "i", "nl -ba ../pandas/core/indexing.py | sed -n '1,9999p' | awk -F: '/def check_bool_indexer/{ln=$1; print ln-\r"]
[225.004, "o", "nl -ba ../pandas/core/indexing.py | sed -n '1,9999p' | awk -F: '/def check_bool_indexer/{ln=$1; print ln-\r\n"]
[226.654, "o", "-20\":\"; exit}' | xargs -I{} sh -lc 'start={}; end=$((start+220)); sed -n \"${start},${end}p\" ../pandas/core/indexing.py'\r\n"]
[228.302, "o", "\u001b[?2004l\r\n"]
[230.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[230.002, "i", "sed -n '3920,4060p' ../pandas/core/frame.py\r"]
[230.004, "o", "sed -n '3920,4060p' ../pandas/core/frame.py\r\n"]
[230.040817, "o", "\u001b[?2004l\r\n"]
[230.075634, "o", "        if is_single_key:\r\n"]
[230.110451, "o", "            # What does looking for a single key in a non-unique index return?\r\n"]
[230.145268, "o", "            # The behavior is inconsistent. It returns a Series, except when\r\n"]
[230.180085, "o", "            # - the key itself is repeated (test on data.shape, #9519), or\r\n"]
[230.214901, "o", "            # - we have a MultiIndex on columns (test on self.columns, #21309)\r\n"]
[230.249718, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[230.284535, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[230.319352, "o", "                return data._get_item(key)\r\n"]
[230.354169, "o", "\r\n"]
[230.388986, "o", "        return data\r\n"]
[230.423803, "o", "\r\n"]
[230.45862, "o", "    def _getitem_bool_array(self, key):\r\n"]
[230.493437, "o", "        # also raises Exception if object array with NA values\r\n"]
[230.528254, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[230.56307, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[230.597887, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[230.632704, "o", "        # with all other indexing behavior\r\n"]
[230.667521, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[230.702338, "o", "            warnings.warn(\r\n"]
[230.737155, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[230.771972, "o", "                UserWarning,\r\n"]
[230.806789, "o", "                stacklevel=find_stack_level(),\r\n"]
[230.841606, "o", "            )\r\n"]
[230.876423, "o", "        elif len(key) != len(self.index):\r\n"]
[230.911239, "o", "            raise ValueError(\r\n"]
[230.946056, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[230.980873, "o", "            )\r\n"]
[231.01569, "o", "\r\n"]
[231.050507, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[231.085324, "o", "        # be reindexed to match DataFrame rows\r\n"]
[231.120141, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[231.154958, "o", "\r\n"]
[231.189775, "o", "        if key.all():\r\n"]
[231.224592, "o", "            return self.copy(deep=False)\r\n"]
[231.259408, "o", "\r\n"]
[231.294225, "o", "        indexer = key.nonzero()[0]\r\n"]
[231.329042, "o", "        return self.take(indexer, axis=0)\r\n"]
[231.363859, "o", "\r\n"]
[231.398676, "o", "    def _getitem_multilevel(self, key):\r\n"]
[231.433493, "o", "        # self.columns is a MultiIndex\r\n"]
[231.46831, "o", "        loc = self.columns.get_loc(key)\r\n"]
[231.503127, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[231.537944, "o", "            new_columns = self.columns[loc]\r\n"]
[231.572761, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[231.607577, "o", "            result = self.iloc[:, loc]\r\n"]
[231.642394, "o", "            result.columns = result_columns\r\n"]
[231.677211, "o", "\r\n"]
[231.712028, "o", "            # If there is only one column being returned, and its name is\r\n"]
[231.746845, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[231.781662, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[231.816479, "o", "            # and return the column as if the user had provided that empty\r\n"]
[231.851296, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[231.886113, "o", "            # implied empty string from its name.\r\n"]
[231.92093, "o", "            if len(result.columns) == 1:\r\n"]
[231.955746, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[231.990563, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[232.02538, "o", "                top = result.columns[0]\r\n"]
[232.060197, "o", "                if isinstance(top, tuple):\r\n"]
[232.095014, "o", "                    top = top[0]\r\n"]
[232.129831, "o", "                if top == \"\":\r\n"]
[232.164648, "o", "                    result = result[\"\"]\r\n"]
[232.199465, "o", "                    if isinstance(result, Series):\r\n"]
[232.234282, "o", "                        result = self._constructor_sliced(\r\n"]
[232.269099, "o", "                            result, index=self.index, name=key\r\n"]
[232.303915, "o", "                        )\r\n"]
[232.338732, "o", "\r\n"]
[232.373549, "o", "            return result\r\n"]
[232.408366, "o", "        else:\r\n"]
[232.443183, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[232.478, "o", "            return self._ixs(loc, axis=1)\r\n"]
[232.512817, "o", "\r\n"]
[232.547634, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[232.582451, "o", "        \"\"\"\r\n"]
[232.617268, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[232.652085, "o", "\r\n"]
[232.686901, "o", "        Parameters\r\n"]
[232.721718, "o", "        ----------\r\n"]
[232.756535, "o", "        index : row label\r\n"]
[232.791352, "o", "        col : column label\r\n"]
[232.826169, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[232.860986, "o", "\r\n"]
[232.895803, "o", "        Returns\r\n"]
[232.93062, "o", "        -------\r\n"]
[232.965437, "o", "        scalar\r\n"]
[233.000254, "o", "\r\n"]
[233.03507, "o", "        Notes\r\n"]
[233.069887, "o", "        -----\r\n"]
[233.104704, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[233.139521, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[233.174338, "o", "        \"\"\"\r\n"]
[233.209155, "o", "        if takeable:\r\n"]
[233.243972, "o", "            series = self._ixs(col, axis=1)\r\n"]
[233.278789, "o", "            return series._values[index]\r\n"]
[233.313606, "o", "\r\n"]
[233.348423, "o", "        series = self._get_item(col)\r\n"]
[233.383239, "o", "        engine = self.index._engine\r\n"]
[233.418056, "o", "\r\n"]
[233.452873, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[233.48769, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[233.522507, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[233.557324, "o", "            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[233.592141, "o", "            row = self.index.get_loc(index)\r\n"]
[233.626958, "o", "            return series._values[row]\r\n"]
[233.661775, "o", "\r\n"]
[233.696592, "o", "        # For MultiIndex going through engine effectively restricts us to\r\n"]
[233.731408, "o", "        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[233.766225, "o", "        loc = engine.get_loc(index)\r\n"]
[233.801042, "o", "        return series._values[loc]\r\n"]
[233.835859, "o", "\r\n"]
[233.870676, "o", "    def isetitem(self, loc, value) -> None:\r\n"]
[233.905493, "o", "        \"\"\"\r\n"]
[233.94031, "o", "        Set the given value in the column with position `loc`.\r\n"]
[233.975127, "o", "\r\n"]
[234.009944, "o", "        This is a positional analogue to ``__setitem__``.\r\n"]
[234.044761, "o", "\r\n"]
[234.079577, "o", "        Parameters\r\n"]
[234.114394, "o", "        ----------\r\n"]
[234.149211, "o", "        loc : int or sequence of ints\r\n"]
[234.184028, "o", "            Index position for the column.\r\n"]
[234.218845, "o", "        value : scalar or arraylike\r\n"]
[234.253662, "o", "            Value(s) for the column.\r\n"]
[234.288479, "o", "\r\n"]
[234.323296, "o", "        See Also\r\n"]
[234.358113, "o", "        --------\r\n"]
[234.39293, "o", "        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[234.427746, "o", "            position.\r\n"]
[234.462563, "o", "\r\n"]
[234.49738, "o", "        Notes\r\n"]
[234.532197, "o", "        -----\r\n"]
[234.567014, "o", "        ``frame.isetitem(loc, value)`` is an in-place method as it will\r\n"]
[234.601831, "o", "        modify the DataFrame in place (not returning a new object). In contrast to\r\n"]
[234.636648, "o", "        ``frame.iloc[:, i] = value`` which will try to update the existing values in\r\n"]
[234.671465, "o", "        place, ``frame.isetitem(loc, value)`` will not update the values of the column\r\n"]
[234.706282, "o", "        itself in place, it will instead insert a new array.\r\n"]
[234.741099, "o", "\r\n"]
[234.775915, "o", "        In cases where ``frame.columns`` is unique, this is equivalent to\r\n"]
[234.810732, "o", "        ``frame[frame.columns[i]] = value``.\r\n"]
[234.845549, "o", "\r\n"]
[234.880366, "o", "        Examples\r\n"]
[234.915183, "o", "        --------\r\n"]
[235.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[235.002, "i", "sed -n '80,180p' ../pandas/core/common.py\r"]
[235.004, "o", "sed -n '80,180p' ../pandas/core/common.py\r\n"]
[235.054471, "o", "\u001b[?2004l\r\n"]
[235.102941, "o", "    -------\r\n"]
[235.151412, "o", "    flattened : generator\r\n"]
[235.199882, "o", "    \"\"\"\r\n"]
[235.248353, "o", "    for element in line:\r\n"]
[235.296824, "o", "        if iterable_not_string(element):\r\n"]
[235.345294, "o", "            yield from flatten(element)\r\n"]
[235.393765, "o", "        else:\r\n"]
[235.442235, "o", "            yield element\r\n"]
[235.490706, "o", "\r\n"]
[235.539176, "o", "\r\n"]
[235.587647, "o", "def consensus_name_attr(objs):\r\n"]
[235.636118, "o", "    name = objs[0].name\r\n"]
[235.684588, "o", "    for obj in objs[1:]:\r\n"]
[235.733059, "o", "        try:\r\n"]
[235.781529, "o", "            if obj.name != name:\r\n"]
[235.83, "o", "                name = None\r\n"]
[235.878471, "o", "        except ValueError:\r\n"]
[235.926941, "o", "            name = None\r\n"]
[235.975412, "o", "    return name\r\n"]
[236.023882, "o", "\r\n"]
[236.072353, "o", "\r\n"]
[236.120824, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[236.169294, "o", "    \"\"\"\r\n"]
[236.217765, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[236.266235, "o", "\r\n"]
[236.314706, "o", "    Parameters\r\n"]
[236.363176, "o", "    ----------\r\n"]
[236.411647, "o", "    key : Any\r\n"]
[236.460118, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[236.508588, "o", "        All other types are not considered a boolean indexer.\r\n"]
[236.557059, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[236.605529, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[236.654, "o", "\r\n"]
[236.702471, "o", "    Returns\r\n"]
[236.750941, "o", "    -------\r\n"]
[236.799412, "o", "    bool\r\n"]
[236.847882, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[236.896353, "o", "\r\n"]
[236.944824, "o", "    Raises\r\n"]
[236.993294, "o", "    ------\r\n"]
[237.041765, "o", "    ValueError\r\n"]
[237.090235, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[237.138706, "o", "        and contains missing values.\r\n"]
[237.187176, "o", "\r\n"]
[237.235647, "o", "    See Also\r\n"]
[237.284118, "o", "    --------\r\n"]
[237.332588, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[237.381059, "o", "        and convert to an ndarray.\r\n"]
[237.429529, "o", "    \"\"\"\r\n"]
[237.478, "o", "    if isinstance(\r\n"]
[237.526471, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[237.574941, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[237.623412, "o", "        if key.dtype == np.object_:\r\n"]
[237.671882, "o", "            key_array = np.asarray(key)\r\n"]
[237.720353, "o", "\r\n"]
[237.768824, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[237.817294, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[237.865765, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[237.914235, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[237.962706, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[238.011176, "o", "                    raise ValueError(na_msg)\r\n"]
[238.059647, "o", "                return False\r\n"]
[238.108118, "o", "            return True\r\n"]
[238.156588, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[238.205059, "o", "            return True\r\n"]
[238.253529, "o", "    elif isinstance(key, list):\r\n"]
[238.302, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[238.350471, "o", "        if len(key) > 0:\r\n"]
[238.398941, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[238.447412, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[238.495882, "o", "                key = list(key)\r\n"]
[238.544353, "o", "            return lib.is_bool_list(key)\r\n"]
[238.592824, "o", "\r\n"]
[238.641294, "o", "    return False\r\n"]
[238.689765, "o", "\r\n"]
[238.738235, "o", "\r\n"]
[238.786706, "o", "def cast_scalar_indexer(val):\r\n"]
[238.835176, "o", "    \"\"\"\r\n"]
[238.883647, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[238.932118, "o", "\r\n"]
[238.980588, "o", "    Parameters\r\n"]
[239.029059, "o", "    ----------\r\n"]
[239.077529, "o", "    val : scalar\r\n"]
[239.126, "o", "\r\n"]
[239.174471, "o", "    Returns\r\n"]
[239.222941, "o", "    -------\r\n"]
[239.271412, "o", "    outval : scalar\r\n"]
[239.319882, "o", "    \"\"\"\r\n"]
[239.368353, "o", "    # assumes lib.is_scalar(val)\r\n"]
[239.416824, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[239.465294, "o", "        raise IndexError(\r\n"]
[239.513765, "o", "            # GH#34193\r\n"]
[239.562235, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[239.610706, "o", "            \"to an integer key instead.\"\r\n"]
[239.659176, "o", "        )\r\n"]
[239.707647, "o", "    return val\r\n"]
[239.756118, "o", "\r\n"]
[239.804588, "o", "\r\n"]
[239.853059, "o", "def not_none(*args):\r\n"]
[239.901529, "o", "    \"\"\"\r\n"]
[240.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[240.002, "i", "sed -n '2590,2660p' ../pandas/core/indexing.py\r"]
[240.004, "o", "sed -n '2590,2660p' ../pandas/core/indexing.py\r\n"]
[240.074667, "o", "\u001b[?2004l\r\n"]
[240.143333, "o", "    ndim : int\r\n"]
[240.212, "o", "    loc : object\r\n"]
[240.280667, "o", "\r\n"]
[240.349333, "o", "    Returns\r\n"]
[240.418, "o", "    -------\r\n"]
[240.486667, "o", "    tuple\r\n"]
[240.555333, "o", "    \"\"\"\r\n"]
[240.624, "o", "    _tup: list[Hashable | slice]\r\n"]
[240.692667, "o", "    _tup = [slice(None, None) for _ in range(ndim)]\r\n"]
[240.761333, "o", "    _tup[0] = loc\r\n"]
[240.83, "o", "    return tuple(_tup)\r\n"]
[240.898667, "o", "\r\n"]
[240.967333, "o", "\r\n"]
[241.036, "o", "def _tupleize_axis_indexer(ndim: int, axis: AxisInt, key) -> tuple:\r\n"]
[241.104667, "o", "    \"\"\"\r\n"]
[241.173333, "o", "    If we have an axis, adapt the given key to be axis-independent.\r\n"]
[241.242, "o", "    \"\"\"\r\n"]
[241.310667, "o", "    new_key = [slice(None)] * ndim\r\n"]
[241.379333, "o", "    new_key[axis] = key\r\n"]
[241.448, "o", "    return tuple(new_key)\r\n"]
[241.516667, "o", "\r\n"]
[241.585333, "o", "\r\n"]
[241.654, "o", "def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[241.722667, "o", "    \"\"\"\r\n"]
[241.791333, "o", "    Check if key is a valid boolean indexer for an object with such index and\r\n"]
[241.86, "o", "    perform reindexing or conversion if needed.\r\n"]
[241.928667, "o", "\r\n"]
[241.997333, "o", "    This function assumes that is_bool_indexer(key) == True.\r\n"]
[242.066, "o", "\r\n"]
[242.134667, "o", "    Parameters\r\n"]
[242.203333, "o", "    ----------\r\n"]
[242.272, "o", "    index : Index\r\n"]
[242.340667, "o", "        Index of the object on which the indexing is done.\r\n"]
[242.409333, "o", "    key : list-like\r\n"]
[242.478, "o", "        Boolean indexer to check.\r\n"]
[242.546667, "o", "\r\n"]
[242.615333, "o", "    Returns\r\n"]
[242.684, "o", "    -------\r\n"]
[242.752667, "o", "    np.array\r\n"]
[242.821333, "o", "        Resulting key.\r\n"]
[242.89, "o", "\r\n"]
[242.958667, "o", "    Raises\r\n"]
[243.027333, "o", "    ------\r\n"]
[243.096, "o", "    IndexError\r\n"]
[243.164667, "o", "        If the key does not have the same length as index.\r\n"]
[243.233333, "o", "    IndexingError\r\n"]
[243.302, "o", "        If the index of the key is unalignable to index.\r\n"]
[243.370667, "o", "    \"\"\"\r\n"]
[243.439333, "o", "    result = key\r\n"]
[243.508, "o", "    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[243.576667, "o", "        indexer = result.index.get_indexer_for(index)\r\n"]
[243.645333, "o", "        if -1 in indexer:\r\n"]
[243.714, "o", "            raise IndexingError(\r\n"]
[243.782667, "o", "                \"Unalignable boolean Series provided as \"\r\n"]
[243.851333, "o", "                \"indexer (index of the boolean Series and of \"\r\n"]
[243.92, "o", "                \"the indexed object do not match).\"\r\n"]
[243.988667, "o", "            )\r\n"]
[244.057333, "o", "\r\n"]
[244.126, "o", "        result = result.take(indexer)\r\n"]
[244.194667, "o", "\r\n"]
[244.263333, "o", "        # fall through for boolean\r\n"]
[244.332, "o", "        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[244.400667, "o", "            return result.astype(bool)._values\r\n"]
[244.469333, "o", "\r\n"]
[244.538, "o", "    if is_object_dtype(key):\r\n"]
[244.606667, "o", "        # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[244.675333, "o", "        result = np.asarray(result, dtype=bool)\r\n"]
[244.744, "o", "    elif not is_array_like(result):\r\n"]
[244.812667, "o", "        # GH 33924\r\n"]
[244.881333, "o", "        # key may contain nan elements, check_array_indexer needs bool array\r\n"]
[245.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[245.002, "i", "sed -n '3920,3985p' ../pandas/core/frame.py\r"]
[245.004, "o", "sed -n '3920,3985p' ../pandas/core/frame.py\r\n"]
[245.079791, "o", "\u001b[?2004l\r\n"]
[245.153582, "o", "        if is_single_key:\r\n"]
[245.227373, "o", "            # What does looking for a single key in a non-unique index return?\r\n"]
[245.301164, "o", "            # The behavior is inconsistent. It returns a Series, except when\r\n"]
[245.374955, "o", "            # - the key itself is repeated (test on data.shape, #9519), or\r\n"]
[245.448746, "o", "            # - we have a MultiIndex on columns (test on self.columns, #21309)\r\n"]
[245.522537, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[245.596328, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[245.670119, "o", "                return data._get_item(key)\r\n"]
[245.74391, "o", "\r\n"]
[245.817701, "o", "        return data\r\n"]
[245.891493, "o", "\r\n"]
[245.965284, "o", "    def _getitem_bool_array(self, key):\r\n"]
[246.039075, "o", "        # also raises Exception if object array with NA values\r\n"]
[246.112866, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[246.186657, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[246.260448, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[246.334239, "o", "        # with all other indexing behavior\r\n"]
[246.40803, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[246.481821, "o", "            warnings.warn(\r\n"]
[246.555612, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[246.629403, "o", "                UserWarning,\r\n"]
[246.703194, "o", "                stacklevel=find_stack_level(),\r\n"]
[246.776985, "o", "            )\r\n"]
[246.850776, "o", "        elif len(key) != len(self.index):\r\n"]
[246.924567, "o", "            raise ValueError(\r\n"]
[246.998358, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[247.072149, "o", "            )\r\n"]
[247.14594, "o", "\r\n"]
[247.219731, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[247.293522, "o", "        # be reindexed to match DataFrame rows\r\n"]
[247.367313, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[247.441104, "o", "\r\n"]
[247.514896, "o", "        if key.all():\r\n"]
[247.588687, "o", "            return self.copy(deep=False)\r\n"]
[247.662478, "o", "\r\n"]
[247.736269, "o", "        indexer = key.nonzero()[0]\r\n"]
[247.81006, "o", "        return self.take(indexer, axis=0)\r\n"]
[247.883851, "o", "\r\n"]
[247.957642, "o", "    def _getitem_multilevel(self, key):\r\n"]
[248.031433, "o", "        # self.columns is a MultiIndex\r\n"]
[248.105224, "o", "        loc = self.columns.get_loc(key)\r\n"]
[248.179015, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[248.252806, "o", "            new_columns = self.columns[loc]\r\n"]
[248.326597, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[248.400388, "o", "            result = self.iloc[:, loc]\r\n"]
[248.474179, "o", "            result.columns = result_columns\r\n"]
[248.54797, "o", "\r\n"]
[248.621761, "o", "            # If there is only one column being returned, and its name is\r\n"]
[248.695552, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[248.769343, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[248.843134, "o", "            # and return the column as if the user had provided that empty\r\n"]
[248.916925, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[248.990716, "o", "            # implied empty string from its name.\r\n"]
[249.064507, "o", "            if len(result.columns) == 1:\r\n"]
[249.138299, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[249.21209, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[249.285881, "o", "                top = result.columns[0]\r\n"]
[249.359672, "o", "                if isinstance(top, tuple):\r\n"]
[249.433463, "o", "                    top = top[0]\r\n"]
[249.507254, "o", "                if top == \"\":\r\n"]
[249.581045, "o", "                    result = result[\"\"]\r\n"]
[249.654836, "o", "                    if isinstance(result, Series):\r\n"]
[249.728627, "o", "                        result = self._constructor_sliced(\r\n"]
[249.802418, "o", "                            result, index=self.index, name=key\r\n"]
[249.876209, "o", "                        )\r\n"]
[250.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[250.002, "i", "sed -n '3985,4060p' ../pandas/core/frame.py\r"]
[250.004, "o", "sed -n '3985,4060p' ../pandas/core/frame.py\r\n"]
[250.070208, "o", "\u001b[?2004l\r\n"]
[250.134416, "o", "\r\n"]
[250.198623, "o", "            return result\r\n"]
[250.262831, "o", "        else:\r\n"]
[250.327039, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[250.391247, "o", "            return self._ixs(loc, axis=1)\r\n"]
[250.455455, "o", "\r\n"]
[250.519662, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[250.58387, "o", "        \"\"\"\r\n"]
[250.648078, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[250.712286, "o", "\r\n"]
[250.776494, "o", "        Parameters\r\n"]
[250.840701, "o", "        ----------\r\n"]
[250.904909, "o", "        index : row label\r\n"]
[250.969117, "o", "        col : column label\r\n"]
[251.033325, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[251.097532, "o", "\r\n"]
[251.16174, "o", "        Returns\r\n"]
[251.225948, "o", "        -------\r\n"]
[251.290156, "o", "        scalar\r\n"]
[251.354364, "o", "\r\n"]
[251.418571, "o", "        Notes\r\n"]
[251.482779, "o", "        -----\r\n"]
[251.546987, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[251.611195, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[251.675403, "o", "        \"\"\"\r\n"]
[251.73961, "o", "        if takeable:\r\n"]
[251.803818, "o", "            series = self._ixs(col, axis=1)\r\n"]
[251.868026, "o", "            return series._values[index]\r\n"]
[251.932234, "o", "\r\n"]
[251.996442, "o", "        series = self._get_item(col)\r\n"]
[252.060649, "o", "        engine = self.index._engine\r\n"]
[252.124857, "o", "\r\n"]
[252.189065, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[252.253273, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[252.317481, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[252.381688, "o", "            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[252.445896, "o", "            row = self.index.get_loc(index)\r\n"]
[252.510104, "o", "            return series._values[row]\r\n"]
[252.574312, "o", "\r\n"]
[252.638519, "o", "        # For MultiIndex going through engine effectively restricts us to\r\n"]
[252.702727, "o", "        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[252.766935, "o", "        loc = engine.get_loc(index)\r\n"]
[252.831143, "o", "        return series._values[loc]\r\n"]
[252.895351, "o", "\r\n"]
[252.959558, "o", "    def isetitem(self, loc, value) -> None:\r\n"]
[253.023766, "o", "        \"\"\"\r\n"]
[253.087974, "o", "        Set the given value in the column with position `loc`.\r\n"]
[253.152182, "o", "\r\n"]
[253.21639, "o", "        This is a positional analogue to ``__setitem__``.\r\n"]
[253.280597, "o", "\r\n"]
[253.344805, "o", "        Parameters\r\n"]
[253.409013, "o", "        ----------\r\n"]
[253.473221, "o", "        loc : int or sequence of ints\r\n"]
[253.537429, "o", "            Index position for the column.\r\n"]
[253.601636, "o", "        value : scalar or arraylike\r\n"]
[253.665844, "o", "            Value(s) for the column.\r\n"]
[253.730052, "o", "\r\n"]
[253.79426, "o", "        See Also\r\n"]
[253.858468, "o", "        --------\r\n"]
[253.922675, "o", "        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[253.986883, "o", "            position.\r\n"]
[254.051091, "o", "\r\n"]
[254.115299, "o", "        Notes\r\n"]
[254.179506, "o", "        -----\r\n"]
[254.243714, "o", "        ``frame.isetitem(loc, value)`` is an in-place method as it will\r\n"]
[254.307922, "o", "        modify the DataFrame in place (not returning a new object). In contrast to\r\n"]
[254.37213, "o", "        ``frame.iloc[:, i] = value`` which will try to update the existing values in\r\n"]
[254.436338, "o", "        place, ``frame.isetitem(loc, value)`` will not update the values of the column\r\n"]
[254.500545, "o", "        itself in place, it will instead insert a new array.\r\n"]
[254.564753, "o", "\r\n"]
[254.628961, "o", "        In cases where ``frame.columns`` is unique, this is equivalent to\r\n"]
[254.693169, "o", "        ``frame[frame.columns[i]] = value``.\r\n"]
[254.757377, "o", "\r\n"]
[254.821584, "o", "        Examples\r\n"]
[254.885792, "o", "        --------\r\n"]
[255.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[255.002, "i", "sed -n '90,150p' ../pandas/core/common.py\r"]
[255.004, "o", "sed -n '90,150p' ../pandas/core/common.py\r\n"]
[255.085742, "o", "\u001b[?2004l\r\n"]
[255.165484, "o", "def consensus_name_attr(objs):\r\n"]
[255.245226, "o", "    name = objs[0].name\r\n"]
[255.324968, "o", "    for obj in objs[1:]:\r\n"]
[255.40471, "o", "        try:\r\n"]
[255.484452, "o", "            if obj.name != name:\r\n"]
[255.564194, "o", "                name = None\r\n"]
[255.643935, "o", "        except ValueError:\r\n"]
[255.723677, "o", "            name = None\r\n"]
[255.803419, "o", "    return name\r\n"]
[255.883161, "o", "\r\n"]
[255.962903, "o", "\r\n"]
[256.042645, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[256.122387, "o", "    \"\"\"\r\n"]
[256.202129, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[256.281871, "o", "\r\n"]
[256.361613, "o", "    Parameters\r\n"]
[256.441355, "o", "    ----------\r\n"]
[256.521097, "o", "    key : Any\r\n"]
[256.600839, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[256.680581, "o", "        All other types are not considered a boolean indexer.\r\n"]
[256.760323, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[256.840065, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[256.919806, "o", "\r\n"]
[256.999548, "o", "    Returns\r\n"]
[257.07929, "o", "    -------\r\n"]
[257.159032, "o", "    bool\r\n"]
[257.238774, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[257.318516, "o", "\r\n"]
[257.398258, "o", "    Raises\r\n"]
[257.478, "o", "    ------\r\n"]
[257.557742, "o", "    ValueError\r\n"]
[257.637484, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[257.717226, "o", "        and contains missing values.\r\n"]
[257.796968, "o", "\r\n"]
[257.87671, "o", "    See Also\r\n"]
[257.956452, "o", "    --------\r\n"]
[258.036194, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[258.115935, "o", "        and convert to an ndarray.\r\n"]
[258.195677, "o", "    \"\"\"\r\n"]
[258.275419, "o", "    if isinstance(\r\n"]
[258.355161, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[258.434903, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[258.514645, "o", "        if key.dtype == np.object_:\r\n"]
[258.594387, "o", "            key_array = np.asarray(key)\r\n"]
[258.674129, "o", "\r\n"]
[258.753871, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[258.833613, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[258.913355, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[258.993097, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[259.072839, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[259.152581, "o", "                    raise ValueError(na_msg)\r\n"]
[259.232323, "o", "                return False\r\n"]
[259.312065, "o", "            return True\r\n"]
[259.391806, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[259.471548, "o", "            return True\r\n"]
[259.55129, "o", "    elif isinstance(key, list):\r\n"]
[259.631032, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[259.710774, "o", "        if len(key) > 0:\r\n"]
[259.790516, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[259.870258, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[260.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[260.002, "i", "sed -n '150,230p' ../pandas/core/common.py\r"]
[260.004, "o", "sed -n '150,230p' ../pandas/core/common.py\r\n"]
[260.066293, "o", "\u001b[?2004l\r\n"]
[260.126585, "o", "                key = list(key)\r\n"]
[260.186878, "o", "            return lib.is_bool_list(key)\r\n"]
[260.247171, "o", "\r\n"]
[260.307463, "o", "    return False\r\n"]
[260.367756, "o", "\r\n"]
[260.428049, "o", "\r\n"]
[260.488341, "o", "def cast_scalar_indexer(val):\r\n"]
[260.548634, "o", "    \"\"\"\r\n"]
[260.608927, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[260.66922, "o", "\r\n"]
[260.729512, "o", "    Parameters\r\n"]
[260.789805, "o", "    ----------\r\n"]
[260.850098, "o", "    val : scalar\r\n"]
[260.91039, "o", "\r\n"]
[260.970683, "o", "    Returns\r\n"]
[261.030976, "o", "    -------\r\n"]
[261.091268, "o", "    outval : scalar\r\n"]
[261.151561, "o", "    \"\"\"\r\n"]
[261.211854, "o", "    # assumes lib.is_scalar(val)\r\n"]
[261.272146, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[261.332439, "o", "        raise IndexError(\r\n"]
[261.392732, "o", "            # GH#34193\r\n"]
[261.453024, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[261.513317, "o", "            \"to an integer key instead.\"\r\n"]
[261.57361, "o", "        )\r\n"]
[261.633902, "o", "    return val\r\n"]
[261.694195, "o", "\r\n"]
[261.754488, "o", "\r\n"]
[261.81478, "o", "def not_none(*args):\r\n"]
[261.875073, "o", "    \"\"\"\r\n"]
[261.935366, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[261.995659, "o", "    \"\"\"\r\n"]
[262.055951, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[262.116244, "o", "\r\n"]
[262.176537, "o", "\r\n"]
[262.236829, "o", "def any_none(*args) -> bool:\r\n"]
[262.297122, "o", "    \"\"\"\r\n"]
[262.357415, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[262.417707, "o", "    \"\"\"\r\n"]
[262.478, "o", "    return any(arg is None for arg in args)\r\n"]
[262.538293, "o", "\r\n"]
[262.598585, "o", "\r\n"]
[262.658878, "o", "def all_none(*args) -> bool:\r\n"]
[262.719171, "o", "    \"\"\"\r\n"]
[262.779463, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[262.839756, "o", "    \"\"\"\r\n"]
[262.900049, "o", "    return all(arg is None for arg in args)\r\n"]
[262.960341, "o", "\r\n"]
[263.020634, "o", "\r\n"]
[263.080927, "o", "def any_not_none(*args) -> bool:\r\n"]
[263.14122, "o", "    \"\"\"\r\n"]
[263.201512, "o", "    Returns a boolean indicating if any argument is not None.\r\n"]
[263.261805, "o", "    \"\"\"\r\n"]
[263.322098, "o", "    return any(arg is not None for arg in args)\r\n"]
[263.38239, "o", "\r\n"]
[263.442683, "o", "\r\n"]
[263.502976, "o", "def all_not_none(*args) -> bool:\r\n"]
[263.563268, "o", "    \"\"\"\r\n"]
[263.623561, "o", "    Returns a boolean indicating if all arguments are not None.\r\n"]
[263.683854, "o", "    \"\"\"\r\n"]
[263.744146, "o", "    return all(arg is not None for arg in args)\r\n"]
[263.804439, "o", "\r\n"]
[263.864732, "o", "\r\n"]
[263.925024, "o", "def count_not_none(*args) -> int:\r\n"]
[263.985317, "o", "    \"\"\"\r\n"]
[264.04561, "o", "    Returns the count of arguments that are not None.\r\n"]
[264.105902, "o", "    \"\"\"\r\n"]
[264.166195, "o", "    return sum(x is not None for x in args)\r\n"]
[264.226488, "o", "\r\n"]
[264.28678, "o", "\r\n"]
[264.347073, "o", "@overload\r\n"]
[264.407366, "o", "def asarray_tuplesafe(\r\n"]
[264.467659, "o", "    values: ArrayLike | list | tuple | zip, dtype: NpDtype | None = ...\r\n"]
[264.527951, "o", ") -> np.ndarray:\r\n"]
[264.588244, "o", "    # ExtensionArray can only be returned when values is an Index, all other iterables\r\n"]
[264.648537, "o", "    # will return np.ndarray. Unfortunately \"all other\" cannot be encoded in a type\r\n"]
[264.708829, "o", "    # signature, so instead we special-case some common types.\r\n"]
[264.769122, "o", "    ...\r\n"]
[264.829415, "o", "\r\n"]
[264.889707, "o", "\r\n"]
[265.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[265.002, "i", "sed -n '3925,3995p' ../pandas/core/frame.py\r"]
[265.004, "o", "sed -n '3925,3995p' ../pandas/core/frame.py\r\n"]
[265.074667, "o", "\u001b[?2004l\r\n"]
[265.143333, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[265.212, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[265.280667, "o", "                return data._get_item(key)\r\n"]
[265.349333, "o", "\r\n"]
[265.418, "o", "        return data\r\n"]
[265.486667, "o", "\r\n"]
[265.555333, "o", "    def _getitem_bool_array(self, key):\r\n"]
[265.624, "o", "        # also raises Exception if object array with NA values\r\n"]
[265.692667, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[265.761333, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[265.83, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[265.898667, "o", "        # with all other indexing behavior\r\n"]
[265.967333, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[266.036, "o", "            warnings.warn(\r\n"]
[266.104667, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[266.173333, "o", "                UserWarning,\r\n"]
[266.242, "o", "                stacklevel=find_stack_level(),\r\n"]
[266.310667, "o", "            )\r\n"]
[266.379333, "o", "        elif len(key) != len(self.index):\r\n"]
[266.448, "o", "            raise ValueError(\r\n"]
[266.516667, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[266.585333, "o", "            )\r\n"]
[266.654, "o", "\r\n"]
[266.722667, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[266.791333, "o", "        # be reindexed to match DataFrame rows\r\n"]
[266.86, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[266.928667, "o", "\r\n"]
[266.997333, "o", "        if key.all():\r\n"]
[267.066, "o", "            return self.copy(deep=False)\r\n"]
[267.134667, "o", "\r\n"]
[267.203333, "o", "        indexer = key.nonzero()[0]\r\n"]
[267.272, "o", "        return self.take(indexer, axis=0)\r\n"]
[267.340667, "o", "\r\n"]
[267.409333, "o", "    def _getitem_multilevel(self, key):\r\n"]
[267.478, "o", "        # self.columns is a MultiIndex\r\n"]
[267.546667, "o", "        loc = self.columns.get_loc(key)\r\n"]
[267.615333, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[267.684, "o", "            new_columns = self.columns[loc]\r\n"]
[267.752667, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[267.821333, "o", "            result = self.iloc[:, loc]\r\n"]
[267.89, "o", "            result.columns = result_columns\r\n"]
[267.958667, "o", "\r\n"]
[268.027333, "o", "            # If there is only one column being returned, and its name is\r\n"]
[268.096, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[268.164667, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[268.233333, "o", "            # and return the column as if the user had provided that empty\r\n"]
[268.302, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[268.370667, "o", "            # implied empty string from its name.\r\n"]
[268.439333, "o", "            if len(result.columns) == 1:\r\n"]
[268.508, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[268.576667, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[268.645333, "o", "                top = result.columns[0]\r\n"]
[268.714, "o", "                if isinstance(top, tuple):\r\n"]
[268.782667, "o", "                    top = top[0]\r\n"]
[268.851333, "o", "                if top == \"\":\r\n"]
[268.92, "o", "                    result = result[\"\"]\r\n"]
[268.988667, "o", "                    if isinstance(result, Series):\r\n"]
[269.057333, "o", "                        result = self._constructor_sliced(\r\n"]
[269.126, "o", "                            result, index=self.index, name=key\r\n"]
[269.194667, "o", "                        )\r\n"]
[269.263333, "o", "\r\n"]
[269.332, "o", "            return result\r\n"]
[269.400667, "o", "        else:\r\n"]
[269.469333, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[269.538, "o", "            return self._ixs(loc, axis=1)\r\n"]
[269.606667, "o", "\r\n"]
[269.675333, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[269.744, "o", "        \"\"\"\r\n"]
[269.812667, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[269.881333, "o", "\r\n"]
[270.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[270.002, "i", "sed -n '3995,4070p' ../pandas/core/frame.py\r"]
[270.004, "o", "sed -n '3995,4070p' ../pandas/core/frame.py\r\n"]
[270.070208, "o", "\u001b[?2004l\r\n"]
[270.134416, "o", "        Parameters\r\n"]
[270.198623, "o", "        ----------\r\n"]
[270.262831, "o", "        index : row label\r\n"]
[270.327039, "o", "        col : column label\r\n"]
[270.391247, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[270.455455, "o", "\r\n"]
[270.519662, "o", "        Returns\r\n"]
[270.58387, "o", "        -------\r\n"]
[270.648078, "o", "        scalar\r\n"]
[270.712286, "o", "\r\n"]
[270.776494, "o", "        Notes\r\n"]
[270.840701, "o", "        -----\r\n"]
[270.904909, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[270.969117, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[271.033325, "o", "        \"\"\"\r\n"]
[271.097532, "o", "        if takeable:\r\n"]
[271.16174, "o", "            series = self._ixs(col, axis=1)\r\n"]
[271.225948, "o", "            return series._values[index]\r\n"]
[271.290156, "o", "\r\n"]
[271.354364, "o", "        series = self._get_item(col)\r\n"]
[271.418571, "o", "        engine = self.index._engine\r\n"]
[271.482779, "o", "\r\n"]
[271.546987, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[271.611195, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[271.675403, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[271.73961, "o", "            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[271.803818, "o", "            row = self.index.get_loc(index)\r\n"]
[271.868026, "o", "            return series._values[row]\r\n"]
[271.932234, "o", "\r\n"]
[271.996442, "o", "        # For MultiIndex going through engine effectively restricts us to\r\n"]
[272.060649, "o", "        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[272.124857, "o", "        loc = engine.get_loc(index)\r\n"]
[272.189065, "o", "        return series._values[loc]\r\n"]
[272.253273, "o", "\r\n"]
[272.317481, "o", "    def isetitem(self, loc, value) -> None:\r\n"]
[272.381688, "o", "        \"\"\"\r\n"]
[272.445896, "o", "        Set the given value in the column with position `loc`.\r\n"]
[272.510104, "o", "\r\n"]
[272.574312, "o", "        This is a positional analogue to ``__setitem__``.\r\n"]
[272.638519, "o", "\r\n"]
[272.702727, "o", "        Parameters\r\n"]
[272.766935, "o", "        ----------\r\n"]
[272.831143, "o", "        loc : int or sequence of ints\r\n"]
[272.895351, "o", "            Index position for the column.\r\n"]
[272.959558, "o", "        value : scalar or arraylike\r\n"]
[273.023766, "o", "            Value(s) for the column.\r\n"]
[273.087974, "o", "\r\n"]
[273.152182, "o", "        See Also\r\n"]
[273.21639, "o", "        --------\r\n"]
[273.280597, "o", "        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[273.344805, "o", "            position.\r\n"]
[273.409013, "o", "\r\n"]
[273.473221, "o", "        Notes\r\n"]
[273.537429, "o", "        -----\r\n"]
[273.601636, "o", "        ``frame.isetitem(loc, value)`` is an in-place method as it will\r\n"]
[273.665844, "o", "        modify the DataFrame in place (not returning a new object). In contrast to\r\n"]
[273.730052, "o", "        ``frame.iloc[:, i] = value`` which will try to update the existing values in\r\n"]
[273.79426, "o", "        place, ``frame.isetitem(loc, value)`` will not update the values of the column\r\n"]
[273.858468, "o", "        itself in place, it will instead insert a new array.\r\n"]
[273.922675, "o", "\r\n"]
[273.986883, "o", "        In cases where ``frame.columns`` is unique, this is equivalent to\r\n"]
[274.051091, "o", "        ``frame[frame.columns[i]] = value``.\r\n"]
[274.115299, "o", "\r\n"]
[274.179506, "o", "        Examples\r\n"]
[274.243714, "o", "        --------\r\n"]
[274.307922, "o", "        >>> df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\r\n"]
[274.37213, "o", "        >>> df.isetitem(1, [5, 6])\r\n"]
[274.436338, "o", "        >>> df\r\n"]
[274.500545, "o", "              A  B\r\n"]
[274.564753, "o", "        0     1  5\r\n"]
[274.628961, "o", "        1     2  6\r\n"]
[274.693169, "o", "        \"\"\"\r\n"]
[274.757377, "o", "        if isinstance(value, DataFrame):\r\n"]
[274.821584, "o", "            if is_integer(loc):\r\n"]
[274.885792, "o", "                loc = [loc]\r\n"]
[275.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[275.002, "i", "sed -n '90,130p' ../pandas/core/common.py\r"]
[275.004, "o", "sed -n '90,130p' ../pandas/core/common.py\r\n"]
[275.123714, "o", "\u001b[?2004l\r\n"]
[275.241429, "o", "def consensus_name_attr(objs):\r\n"]
[275.359143, "o", "    name = objs[0].name\r\n"]
[275.476857, "o", "    for obj in objs[1:]:\r\n"]
[275.594571, "o", "        try:\r\n"]
[275.712286, "o", "            if obj.name != name:\r\n"]
[275.83, "o", "                name = None\r\n"]
[275.947714, "o", "        except ValueError:\r\n"]
[276.065429, "o", "            name = None\r\n"]
[276.183143, "o", "    return name\r\n"]
[276.300857, "o", "\r\n"]
[276.418571, "o", "\r\n"]
[276.536286, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[276.654, "o", "    \"\"\"\r\n"]
[276.771714, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[276.889429, "o", "\r\n"]
[277.007143, "o", "    Parameters\r\n"]
[277.124857, "o", "    ----------\r\n"]
[277.242571, "o", "    key : Any\r\n"]
[277.360286, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[277.478, "o", "        All other types are not considered a boolean indexer.\r\n"]
[277.595714, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[277.713429, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[277.831143, "o", "\r\n"]
[277.948857, "o", "    Returns\r\n"]
[278.066571, "o", "    -------\r\n"]
[278.184286, "o", "    bool\r\n"]
[278.302, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[278.419714, "o", "\r\n"]
[278.537429, "o", "    Raises\r\n"]
[278.655143, "o", "    ------\r\n"]
[278.772857, "o", "    ValueError\r\n"]
[278.890571, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[279.008286, "o", "        and contains missing values.\r\n"]
[279.126, "o", "\r\n"]
[279.243714, "o", "    See Also\r\n"]
[279.361429, "o", "    --------\r\n"]
[279.479143, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[279.596857, "o", "        and convert to an ndarray.\r\n"]
[279.714571, "o", "    \"\"\"\r\n"]
[279.832286, "o", "    if isinstance(\r\n"]
[280.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[280.002, "i", "sed -n '130,200p' ../pandas/core/common.py\r"]
[280.004, "o", "sed -n '130,200p' ../pandas/core/common.py\r\n"]
[280.074667, "o", "\u001b[?2004l\r\n"]
[280.143333, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[280.212, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[280.280667, "o", "        if key.dtype == np.object_:\r\n"]
[280.349333, "o", "            key_array = np.asarray(key)\r\n"]
[280.418, "o", "\r\n"]
[280.486667, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[280.555333, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[280.624, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[280.692667, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[280.761333, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[280.83, "o", "                    raise ValueError(na_msg)\r\n"]
[280.898667, "o", "                return False\r\n"]
[280.967333, "o", "            return True\r\n"]
[281.036, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[281.104667, "o", "            return True\r\n"]
[281.173333, "o", "    elif isinstance(key, list):\r\n"]
[281.242, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[281.310667, "o", "        if len(key) > 0:\r\n"]
[281.379333, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[281.448, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[281.516667, "o", "                key = list(key)\r\n"]
[281.585333, "o", "            return lib.is_bool_list(key)\r\n"]
[281.654, "o", "\r\n"]
[281.722667, "o", "    return False\r\n"]
[281.791333, "o", "\r\n"]
[281.86, "o", "\r\n"]
[281.928667, "o", "def cast_scalar_indexer(val):\r\n"]
[281.997333, "o", "    \"\"\"\r\n"]
[282.066, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[282.134667, "o", "\r\n"]
[282.203333, "o", "    Parameters\r\n"]
[282.272, "o", "    ----------\r\n"]
[282.340667, "o", "    val : scalar\r\n"]
[282.409333, "o", "\r\n"]
[282.478, "o", "    Returns\r\n"]
[282.546667, "o", "    -------\r\n"]
[282.615333, "o", "    outval : scalar\r\n"]
[282.684, "o", "    \"\"\"\r\n"]
[282.752667, "o", "    # assumes lib.is_scalar(val)\r\n"]
[282.821333, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[282.89, "o", "        raise IndexError(\r\n"]
[282.958667, "o", "            # GH#34193\r\n"]
[283.027333, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[283.096, "o", "            \"to an integer key instead.\"\r\n"]
[283.164667, "o", "        )\r\n"]
[283.233333, "o", "    return val\r\n"]
[283.302, "o", "\r\n"]
[283.370667, "o", "\r\n"]
[283.439333, "o", "def not_none(*args):\r\n"]
[283.508, "o", "    \"\"\"\r\n"]
[283.576667, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[283.645333, "o", "    \"\"\"\r\n"]
[283.714, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[283.782667, "o", "\r\n"]
[283.851333, "o", "\r\n"]
[283.92, "o", "def any_none(*args) -> bool:\r\n"]
[283.988667, "o", "    \"\"\"\r\n"]
[284.057333, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[284.126, "o", "    \"\"\"\r\n"]
[284.194667, "o", "    return any(arg is None for arg in args)\r\n"]
[284.263333, "o", "\r\n"]
[284.332, "o", "\r\n"]
[284.400667, "o", "def all_none(*args) -> bool:\r\n"]
[284.469333, "o", "    \"\"\"\r\n"]
[284.538, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[284.606667, "o", "    \"\"\"\r\n"]
[284.675333, "o", "    return all(arg is None for arg in args)\r\n"]
[284.744, "o", "\r\n"]
[284.812667, "o", "\r\n"]
[284.881333, "o", "def any_not_none(*args) -> bool:\r\n"]
[285.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[285.002, "i", "sed -n '3925,4065p' ../pandas/core/frame.py\r"]
[285.004, "o", "sed -n '3925,4065p' ../pandas/core/frame.py\r\n"]
[285.040817, "o", "\u001b[?2004l\r\n"]
[285.075634, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[285.110451, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[285.145268, "o", "                return data._get_item(key)\r\n"]
[285.180085, "o", "\r\n"]
[285.214901, "o", "        return data\r\n"]
[285.249718, "o", "\r\n"]
[285.284535, "o", "    def _getitem_bool_array(self, key):\r\n"]
[285.319352, "o", "        # also raises Exception if object array with NA values\r\n"]
[285.354169, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[285.388986, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[285.423803, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[285.45862, "o", "        # with all other indexing behavior\r\n"]
[285.493437, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[285.528254, "o", "            warnings.warn(\r\n"]
[285.56307, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[285.597887, "o", "                UserWarning,\r\n"]
[285.632704, "o", "                stacklevel=find_stack_level(),\r\n"]
[285.667521, "o", "            )\r\n"]
[285.702338, "o", "        elif len(key) != len(self.index):\r\n"]
[285.737155, "o", "            raise ValueError(\r\n"]
[285.771972, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[285.806789, "o", "            )\r\n"]
[285.841606, "o", "\r\n"]
[285.876423, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[285.911239, "o", "        # be reindexed to match DataFrame rows\r\n"]
[285.946056, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[285.980873, "o", "\r\n"]
[286.01569, "o", "        if key.all():\r\n"]
[286.050507, "o", "            return self.copy(deep=False)\r\n"]
[286.085324, "o", "\r\n"]
[286.120141, "o", "        indexer = key.nonzero()[0]\r\n"]
[286.154958, "o", "        return self.take(indexer, axis=0)\r\n"]
[286.189775, "o", "\r\n"]
[286.224592, "o", "    def _getitem_multilevel(self, key):\r\n"]
[286.259408, "o", "        # self.columns is a MultiIndex\r\n"]
[286.294225, "o", "        loc = self.columns.get_loc(key)\r\n"]
[286.329042, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[286.363859, "o", "            new_columns = self.columns[loc]\r\n"]
[286.398676, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[286.433493, "o", "            result = self.iloc[:, loc]\r\n"]
[286.46831, "o", "            result.columns = result_columns\r\n"]
[286.503127, "o", "\r\n"]
[286.537944, "o", "            # If there is only one column being returned, and its name is\r\n"]
[286.572761, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[286.607577, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[286.642394, "o", "            # and return the column as if the user had provided that empty\r\n"]
[286.677211, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[286.712028, "o", "            # implied empty string from its name.\r\n"]
[286.746845, "o", "            if len(result.columns) == 1:\r\n"]
[286.781662, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[286.816479, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[286.851296, "o", "                top = result.columns[0]\r\n"]
[286.886113, "o", "                if isinstance(top, tuple):\r\n"]
[286.92093, "o", "                    top = top[0]\r\n"]
[286.955746, "o", "                if top == \"\":\r\n"]
[286.990563, "o", "                    result = result[\"\"]\r\n"]
[287.02538, "o", "                    if isinstance(result, Series):\r\n"]
[287.060197, "o", "                        result = self._constructor_sliced(\r\n"]
[287.095014, "o", "                            result, index=self.index, name=key\r\n"]
[287.129831, "o", "                        )\r\n"]
[287.164648, "o", "\r\n"]
[287.199465, "o", "            return result\r\n"]
[287.234282, "o", "        else:\r\n"]
[287.269099, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[287.303915, "o", "            return self._ixs(loc, axis=1)\r\n"]
[287.338732, "o", "\r\n"]
[287.373549, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[287.408366, "o", "        \"\"\"\r\n"]
[287.443183, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[287.478, "o", "\r\n"]
[287.512817, "o", "        Parameters\r\n"]
[287.547634, "o", "        ----------\r\n"]
[287.582451, "o", "        index : row label\r\n"]
[287.617268, "o", "        col : column label\r\n"]
[287.652085, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[287.686901, "o", "\r\n"]
[287.721718, "o", "        Returns\r\n"]
[287.756535, "o", "        -------\r\n"]
[287.791352, "o", "        scalar\r\n"]
[287.826169, "o", "\r\n"]
[287.860986, "o", "        Notes\r\n"]
[287.895803, "o", "        -----\r\n"]
[287.93062, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[287.965437, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[288.000254, "o", "        \"\"\"\r\n"]
[288.03507, "o", "        if takeable:\r\n"]
[288.069887, "o", "            series = self._ixs(col, axis=1)\r\n"]
[288.104704, "o", "            return series._values[index]\r\n"]
[288.139521, "o", "\r\n"]
[288.174338, "o", "        series = self._get_item(col)\r\n"]
[288.209155, "o", "        engine = self.index._engine\r\n"]
[288.243972, "o", "\r\n"]
[288.278789, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[288.313606, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[288.348423, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[288.383239, "o", "            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[288.418056, "o", "            row = self.index.get_loc(index)\r\n"]
[288.452873, "o", "            return series._values[row]\r\n"]
[288.48769, "o", "\r\n"]
[288.522507, "o", "        # For MultiIndex going through engine effectively restricts us to\r\n"]
[288.557324, "o", "        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[288.592141, "o", "        loc = engine.get_loc(index)\r\n"]
[288.626958, "o", "        return series._values[loc]\r\n"]
[288.661775, "o", "\r\n"]
[288.696592, "o", "    def isetitem(self, loc, value) -> None:\r\n"]
[288.731408, "o", "        \"\"\"\r\n"]
[288.766225, "o", "        Set the given value in the column with position `loc`.\r\n"]
[288.801042, "o", "\r\n"]
[288.835859, "o", "        This is a positional analogue to ``__setitem__``.\r\n"]
[288.870676, "o", "\r\n"]
[288.905493, "o", "        Parameters\r\n"]
[288.94031, "o", "        ----------\r\n"]
[288.975127, "o", "        loc : int or sequence of ints\r\n"]
[289.009944, "o", "            Index position for the column.\r\n"]
[289.044761, "o", "        value : scalar or arraylike\r\n"]
[289.079577, "o", "            Value(s) for the column.\r\n"]
[289.114394, "o", "\r\n"]
[289.149211, "o", "        See Also\r\n"]
[289.184028, "o", "        --------\r\n"]
[289.218845, "o", "        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[289.253662, "o", "            position.\r\n"]
[289.288479, "o", "\r\n"]
[289.323296, "o", "        Notes\r\n"]
[289.358113, "o", "        -----\r\n"]
[289.39293, "o", "        ``frame.isetitem(loc, value)`` is an in-place method as it will\r\n"]
[289.427746, "o", "        modify the DataFrame in place (not returning a new object). In contrast to\r\n"]
[289.462563, "o", "        ``frame.iloc[:, i] = value`` which will try to update the existing values in\r\n"]
[289.49738, "o", "        place, ``frame.isetitem(loc, value)`` will not update the values of the column\r\n"]
[289.532197, "o", "        itself in place, it will instead insert a new array.\r\n"]
[289.567014, "o", "\r\n"]
[289.601831, "o", "        In cases where ``frame.columns`` is unique, this is equivalent to\r\n"]
[289.636648, "o", "        ``frame[frame.columns[i]] = value``.\r\n"]
[289.671465, "o", "\r\n"]
[289.706282, "o", "        Examples\r\n"]
[289.741099, "o", "        --------\r\n"]
[289.775915, "o", "        >>> df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\r\n"]
[289.810732, "o", "        >>> df.isetitem(1, [5, 6])\r\n"]
[289.845549, "o", "        >>> df\r\n"]
[289.880366, "o", "              A  B\r\n"]
[289.915183, "o", "        0     1  5\r\n"]
[290.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[290.002, "i", "sed -n '90,140p' ../pandas/core/common.py\r"]
[290.004, "o", "sed -n '90,140p' ../pandas/core/common.py\r\n"]
[290.101077, "o", "\u001b[?2004l\r\n"]
[290.196154, "o", "def consensus_name_attr(objs):\r\n"]
[290.291231, "o", "    name = objs[0].name\r\n"]
[290.386308, "o", "    for obj in objs[1:]:\r\n"]
[290.481385, "o", "        try:\r\n"]
[290.576462, "o", "            if obj.name != name:\r\n"]
[290.671538, "o", "                name = None\r\n"]
[290.766615, "o", "        except ValueError:\r\n"]
[290.861692, "o", "            name = None\r\n"]
[290.956769, "o", "    return name\r\n"]
[291.051846, "o", "\r\n"]
[291.146923, "o", "\r\n"]
[291.242, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[291.337077, "o", "    \"\"\"\r\n"]
[291.432154, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[291.527231, "o", "\r\n"]
[291.622308, "o", "    Parameters\r\n"]
[291.717385, "o", "    ----------\r\n"]
[291.812462, "o", "    key : Any\r\n"]
[291.907538, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[292.002615, "o", "        All other types are not considered a boolean indexer.\r\n"]
[292.097692, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[292.192769, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[292.287846, "o", "\r\n"]
[292.382923, "o", "    Returns\r\n"]
[292.478, "o", "    -------\r\n"]
[292.573077, "o", "    bool\r\n"]
[292.668154, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[292.763231, "o", "\r\n"]
[292.858308, "o", "    Raises\r\n"]
[292.953385, "o", "    ------\r\n"]
[293.048462, "o", "    ValueError\r\n"]
[293.143538, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[293.238615, "o", "        and contains missing values.\r\n"]
[293.333692, "o", "\r\n"]
[293.428769, "o", "    See Also\r\n"]
[293.523846, "o", "    --------\r\n"]
[293.618923, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[293.714, "o", "        and convert to an ndarray.\r\n"]
[293.809077, "o", "    \"\"\"\r\n"]
[293.904154, "o", "    if isinstance(\r\n"]
[293.999231, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[294.094308, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[294.189385, "o", "        if key.dtype == np.object_:\r\n"]
[294.284462, "o", "            key_array = np.asarray(key)\r\n"]
[294.379538, "o", "\r\n"]
[294.474615, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[294.569692, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[294.664769, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[294.759846, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[294.854923, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[295.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[295.002, "i", "sed -n '140,200p' ../pandas/core/common.py\r"]
[295.004, "o", "sed -n '140,200p' ../pandas/core/common.py\r\n"]
[295.085742, "o", "\u001b[?2004l\r\n"]
[295.165484, "o", "                    raise ValueError(na_msg)\r\n"]
[295.245226, "o", "                return False\r\n"]
[295.324968, "o", "            return True\r\n"]
[295.40471, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[295.484452, "o", "            return True\r\n"]
[295.564194, "o", "    elif isinstance(key, list):\r\n"]
[295.643935, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[295.723677, "o", "        if len(key) > 0:\r\n"]
[295.803419, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[295.883161, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[295.962903, "o", "                key = list(key)\r\n"]
[296.042645, "o", "            return lib.is_bool_list(key)\r\n"]
[296.122387, "o", "\r\n"]
[296.202129, "o", "    return False\r\n"]
[296.281871, "o", "\r\n"]
[296.361613, "o", "\r\n"]
[296.441355, "o", "def cast_scalar_indexer(val):\r\n"]
[296.521097, "o", "    \"\"\"\r\n"]
[296.600839, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[296.680581, "o", "\r\n"]
[296.760323, "o", "    Parameters\r\n"]
[296.840065, "o", "    ----------\r\n"]
[296.919806, "o", "    val : scalar\r\n"]
[296.999548, "o", "\r\n"]
[297.07929, "o", "    Returns\r\n"]
[297.159032, "o", "    -------\r\n"]
[297.238774, "o", "    outval : scalar\r\n"]
[297.318516, "o", "    \"\"\"\r\n"]
[297.398258, "o", "    # assumes lib.is_scalar(val)\r\n"]
[297.478, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[297.557742, "o", "        raise IndexError(\r\n"]
[297.637484, "o", "            # GH#34193\r\n"]
[297.717226, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[297.796968, "o", "            \"to an integer key instead.\"\r\n"]
[297.87671, "o", "        )\r\n"]
[297.956452, "o", "    return val\r\n"]
[298.036194, "o", "\r\n"]
[298.115935, "o", "\r\n"]
[298.195677, "o", "def not_none(*args):\r\n"]
[298.275419, "o", "    \"\"\"\r\n"]
[298.355161, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[298.434903, "o", "    \"\"\"\r\n"]
[298.514645, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[298.594387, "o", "\r\n"]
[298.674129, "o", "\r\n"]
[298.753871, "o", "def any_none(*args) -> bool:\r\n"]
[298.833613, "o", "    \"\"\"\r\n"]
[298.913355, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[298.993097, "o", "    \"\"\"\r\n"]
[299.072839, "o", "    return any(arg is None for arg in args)\r\n"]
[299.152581, "o", "\r\n"]
[299.232323, "o", "\r\n"]
[299.312065, "o", "def all_none(*args) -> bool:\r\n"]
[299.391806, "o", "    \"\"\"\r\n"]
[299.471548, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[299.55129, "o", "    \"\"\"\r\n"]
[299.631032, "o", "    return all(arg is None for arg in args)\r\n"]
[299.710774, "o", "\r\n"]
[299.790516, "o", "\r\n"]
[299.870258, "o", "def any_not_none(*args) -> bool:\r\n"]
[300.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[300.002, "i", "sed -n '2590,2665p' ../pandas/core/indexing.py\r"]
[300.004, "o", "sed -n '2590,2665p' ../pandas/core/indexing.py\r\n"]
[300.070208, "o", "\u001b[?2004l\r\n"]
[300.134416, "o", "    ndim : int\r\n"]
[300.198623, "o", "    loc : object\r\n"]
[300.262831, "o", "\r\n"]
[300.327039, "o", "    Returns\r\n"]
[300.391247, "o", "    -------\r\n"]
[300.455455, "o", "    tuple\r\n"]
[300.519662, "o", "    \"\"\"\r\n"]
[300.58387, "o", "    _tup: list[Hashable | slice]\r\n"]
[300.648078, "o", "    _tup = [slice(None, None) for _ in range(ndim)]\r\n"]
[300.712286, "o", "    _tup[0] = loc\r\n"]
[300.776494, "o", "    return tuple(_tup)\r\n"]
[300.840701, "o", "\r\n"]
[300.904909, "o", "\r\n"]
[300.969117, "o", "def _tupleize_axis_indexer(ndim: int, axis: AxisInt, key) -> tuple:\r\n"]
[301.033325, "o", "    \"\"\"\r\n"]
[301.097532, "o", "    If we have an axis, adapt the given key to be axis-independent.\r\n"]
[301.16174, "o", "    \"\"\"\r\n"]
[301.225948, "o", "    new_key = [slice(None)] * ndim\r\n"]
[301.290156, "o", "    new_key[axis] = key\r\n"]
[301.354364, "o", "    return tuple(new_key)\r\n"]
[301.418571, "o", "\r\n"]
[301.482779, "o", "\r\n"]
[301.546987, "o", "def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[301.611195, "o", "    \"\"\"\r\n"]
[301.675403, "o", "    Check if key is a valid boolean indexer for an object with such index and\r\n"]
[301.73961, "o", "    perform reindexing or conversion if needed.\r\n"]
[301.803818, "o", "\r\n"]
[301.868026, "o", "    This function assumes that is_bool_indexer(key) == True.\r\n"]
[301.932234, "o", "\r\n"]
[301.996442, "o", "    Parameters\r\n"]
[302.060649, "o", "    ----------\r\n"]
[302.124857, "o", "    index : Index\r\n"]
[302.189065, "o", "        Index of the object on which the indexing is done.\r\n"]
[302.253273, "o", "    key : list-like\r\n"]
[302.317481, "o", "        Boolean indexer to check.\r\n"]
[302.381688, "o", "\r\n"]
[302.445896, "o", "    Returns\r\n"]
[302.510104, "o", "    -------\r\n"]
[302.574312, "o", "    np.array\r\n"]
[302.638519, "o", "        Resulting key.\r\n"]
[302.702727, "o", "\r\n"]
[302.766935, "o", "    Raises\r\n"]
[302.831143, "o", "    ------\r\n"]
[302.895351, "o", "    IndexError\r\n"]
[302.959558, "o", "        If the key does not have the same length as index.\r\n"]
[303.023766, "o", "    IndexingError\r\n"]
[303.087974, "o", "        If the index of the key is unalignable to index.\r\n"]
[303.152182, "o", "    \"\"\"\r\n"]
[303.21639, "o", "    result = key\r\n"]
[303.280597, "o", "    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[303.344805, "o", "        indexer = result.index.get_indexer_for(index)\r\n"]
[303.409013, "o", "        if -1 in indexer:\r\n"]
[303.473221, "o", "            raise IndexingError(\r\n"]
[303.537429, "o", "                \"Unalignable boolean Series provided as \"\r\n"]
[303.601636, "o", "                \"indexer (index of the boolean Series and of \"\r\n"]
[303.665844, "o", "                \"the indexed object do not match).\"\r\n"]
[303.730052, "o", "            )\r\n"]
[303.79426, "o", "\r\n"]
[303.858468, "o", "        result = result.take(indexer)\r\n"]
[303.922675, "o", "\r\n"]
[303.986883, "o", "        # fall through for boolean\r\n"]
[304.051091, "o", "        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[304.115299, "o", "            return result.astype(bool)._values\r\n"]
[304.179506, "o", "\r\n"]
[304.243714, "o", "    if is_object_dtype(key):\r\n"]
[304.307922, "o", "        # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[304.37213, "o", "        result = np.asarray(result, dtype=bool)\r\n"]
[304.436338, "o", "    elif not is_array_like(result):\r\n"]
[304.500545, "o", "        # GH 33924\r\n"]
[304.564753, "o", "        # key may contain nan elements, check_array_indexer needs bool array\r\n"]
[304.628961, "o", "        result = pd_array(result, dtype=bool)\r\n"]
[304.693169, "o", "    return check_array_indexer(index, result)\r\n"]
[304.757377, "o", "\r\n"]
[304.821584, "o", "\r\n"]
[304.885792, "o", "def convert_missing_indexer(indexer):\r\n"]
[305.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[305.002, "i", "sed -n '3925,4065p' ../pandas/core/frame.py\r"]
[305.004, "o", "sed -n '3925,4065p' ../pandas/core/frame.py\r\n"]
[305.040817, "o", "\u001b[?2004l\r\n"]
[305.075634, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[305.110451, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[305.145268, "o", "                return data._get_item(key)\r\n"]
[305.180085, "o", "\r\n"]
[305.214901, "o", "        return data\r\n"]
[305.249718, "o", "\r\n"]
[305.284535, "o", "    def _getitem_bool_array(self, key):\r\n"]
[305.319352, "o", "        # also raises Exception if object array with NA values\r\n"]
[305.354169, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[305.388986, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[305.423803, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[305.45862, "o", "        # with all other indexing behavior\r\n"]
[305.493437, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[305.528254, "o", "            warnings.warn(\r\n"]
[305.56307, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[305.597887, "o", "                UserWarning,\r\n"]
[305.632704, "o", "                stacklevel=find_stack_level(),\r\n"]
[305.667521, "o", "            )\r\n"]
[305.702338, "o", "        elif len(key) != len(self.index):\r\n"]
[305.737155, "o", "            raise ValueError(\r\n"]
[305.771972, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[305.806789, "o", "            )\r\n"]
[305.841606, "o", "\r\n"]
[305.876423, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[305.911239, "o", "        # be reindexed to match DataFrame rows\r\n"]
[305.946056, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[305.980873, "o", "\r\n"]
[306.01569, "o", "        if key.all():\r\n"]
[306.050507, "o", "            return self.copy(deep=False)\r\n"]
[306.085324, "o", "\r\n"]
[306.120141, "o", "        indexer = key.nonzero()[0]\r\n"]
[306.154958, "o", "        return self.take(indexer, axis=0)\r\n"]
[306.189775, "o", "\r\n"]
[306.224592, "o", "    def _getitem_multilevel(self, key):\r\n"]
[306.259408, "o", "        # self.columns is a MultiIndex\r\n"]
[306.294225, "o", "        loc = self.columns.get_loc(key)\r\n"]
[306.329042, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[306.363859, "o", "            new_columns = self.columns[loc]\r\n"]
[306.398676, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[306.433493, "o", "            result = self.iloc[:, loc]\r\n"]
[306.46831, "o", "            result.columns = result_columns\r\n"]
[306.503127, "o", "\r\n"]
[306.537944, "o", "            # If there is only one column being returned, and its name is\r\n"]
[306.572761, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[306.607577, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[306.642394, "o", "            # and return the column as if the user had provided that empty\r\n"]
[306.677211, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[306.712028, "o", "            # implied empty string from its name.\r\n"]
[306.746845, "o", "            if len(result.columns) == 1:\r\n"]
[306.781662, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[306.816479, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[306.851296, "o", "                top = result.columns[0]\r\n"]
[306.886113, "o", "                if isinstance(top, tuple):\r\n"]
[306.92093, "o", "                    top = top[0]\r\n"]
[306.955746, "o", "                if top == \"\":\r\n"]
[306.990563, "o", "                    result = result[\"\"]\r\n"]
[307.02538, "o", "                    if isinstance(result, Series):\r\n"]
[307.060197, "o", "                        result = self._constructor_sliced(\r\n"]
[307.095014, "o", "                            result, index=self.index, name=key\r\n"]
[307.129831, "o", "                        )\r\n"]
[307.164648, "o", "\r\n"]
[307.199465, "o", "            return result\r\n"]
[307.234282, "o", "        else:\r\n"]
[307.269099, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[307.303915, "o", "            return self._ixs(loc, axis=1)\r\n"]
[307.338732, "o", "\r\n"]
[307.373549, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[307.408366, "o", "        \"\"\"\r\n"]
[307.443183, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[307.478, "o", "\r\n"]
[307.512817, "o", "        Parameters\r\n"]
[307.547634, "o", "        ----------\r\n"]
[307.582451, "o", "        index : row label\r\n"]
[307.617268, "o", "        col : column label\r\n"]
[307.652085, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[307.686901, "o", "\r\n"]
[307.721718, "o", "        Returns\r\n"]
[307.756535, "o", "        -------\r\n"]
[307.791352, "o", "        scalar\r\n"]
[307.826169, "o", "\r\n"]
[307.860986, "o", "        Notes\r\n"]
[307.895803, "o", "        -----\r\n"]
[307.93062, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[307.965437, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[308.000254, "o", "        \"\"\"\r\n"]
[308.03507, "o", "        if takeable:\r\n"]
[308.069887, "o", "            series = self._ixs(col, axis=1)\r\n"]
[308.104704, "o", "            return series._values[index]\r\n"]
[308.139521, "o", "\r\n"]
[308.174338, "o", "        series = self._get_item(col)\r\n"]
[308.209155, "o", "        engine = self.index._engine\r\n"]
[308.243972, "o", "\r\n"]
[308.278789, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[308.313606, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[308.348423, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[308.383239, "o", "            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[308.418056, "o", "            row = self.index.get_loc(index)\r\n"]
[308.452873, "o", "            return series._values[row]\r\n"]
[308.48769, "o", "\r\n"]
[308.522507, "o", "        # For MultiIndex going through engine effectively restricts us to\r\n"]
[308.557324, "o", "        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[308.592141, "o", "        loc = engine.get_loc(index)\r\n"]
[308.626958, "o", "        return series._values[loc]\r\n"]
[308.661775, "o", "\r\n"]
[308.696592, "o", "    def isetitem(self, loc, value) -> None:\r\n"]
[308.731408, "o", "        \"\"\"\r\n"]
[308.766225, "o", "        Set the given value in the column with position `loc`.\r\n"]
[308.801042, "o", "\r\n"]
[308.835859, "o", "        This is a positional analogue to ``__setitem__``.\r\n"]
[308.870676, "o", "\r\n"]
[308.905493, "o", "        Parameters\r\n"]
[308.94031, "o", "        ----------\r\n"]
[308.975127, "o", "        loc : int or sequence of ints\r\n"]
[309.009944, "o", "            Index position for the column.\r\n"]
[309.044761, "o", "        value : scalar or arraylike\r\n"]
[309.079577, "o", "            Value(s) for the column.\r\n"]
[309.114394, "o", "\r\n"]
[309.149211, "o", "        See Also\r\n"]
[309.184028, "o", "        --------\r\n"]
[309.218845, "o", "        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[309.253662, "o", "            position.\r\n"]
[309.288479, "o", "\r\n"]
[309.323296, "o", "        Notes\r\n"]
[309.358113, "o", "        -----\r\n"]
[309.39293, "o", "        ``frame.isetitem(loc, value)`` is an in-place method as it will\r\n"]
[309.427746, "o", "        modify the DataFrame in place (not returning a new object). In contrast to\r\n"]
[309.462563, "o", "        ``frame.iloc[:, i] = value`` which will try to update the existing values in\r\n"]
[309.49738, "o", "        place, ``frame.isetitem(loc, value)`` will not update the values of the column\r\n"]
[309.532197, "o", "        itself in place, it will instead insert a new array.\r\n"]
[309.567014, "o", "\r\n"]
[309.601831, "o", "        In cases where ``frame.columns`` is unique, this is equivalent to\r\n"]
[309.636648, "o", "        ``frame[frame.columns[i]] = value``.\r\n"]
[309.671465, "o", "\r\n"]
[309.706282, "o", "        Examples\r\n"]
[309.741099, "o", "        --------\r\n"]
[309.775915, "o", "        >>> df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\r\n"]
[309.810732, "o", "        >>> df.isetitem(1, [5, 6])\r\n"]
[309.845549, "o", "        >>> df\r\n"]
[309.880366, "o", "              A  B\r\n"]
[309.915183, "o", "        0     1  5\r\n"]
[310.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[310.002, "i", "sed -n '95,115p' ../pandas/core/common.py\r"]
[310.004, "o", "sed -n '95,115p' ../pandas/core/common.py\r\n"]
[310.230727, "o", "\u001b[?2004l\r\n"]
[310.455455, "o", "                name = None\r\n"]
[310.680182, "o", "        except ValueError:\r\n"]
[310.904909, "o", "            name = None\r\n"]
[311.129636, "o", "    return name\r\n"]
[311.354364, "o", "\r\n"]
[311.579091, "o", "\r\n"]
[311.803818, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[312.028545, "o", "    \"\"\"\r\n"]
[312.253273, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[312.478, "o", "\r\n"]
[312.702727, "o", "    Parameters\r\n"]
[312.927455, "o", "    ----------\r\n"]
[313.152182, "o", "    key : Any\r\n"]
[313.376909, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[313.601636, "o", "        All other types are not considered a boolean indexer.\r\n"]
[313.826364, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[314.051091, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[314.275818, "o", "\r\n"]
[314.500545, "o", "    Returns\r\n"]
[314.725273, "o", "    -------\r\n"]
[315.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[315.002, "i", "sed -n '100,140p' ../pandas/core/common.py\r"]
[315.004, "o", "sed -n '100,140p' ../pandas/core/common.py\r\n"]
[315.123714, "o", "\u001b[?2004l\r\n"]
[315.241429, "o", "\r\n"]
[315.359143, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[315.476857, "o", "    \"\"\"\r\n"]
[315.594571, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[315.712286, "o", "\r\n"]
[315.83, "o", "    Parameters\r\n"]
[315.947714, "o", "    ----------\r\n"]
[316.065429, "o", "    key : Any\r\n"]
[316.183143, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[316.300857, "o", "        All other types are not considered a boolean indexer.\r\n"]
[316.418571, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[316.536286, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[316.654, "o", "\r\n"]
[316.771714, "o", "    Returns\r\n"]
[316.889429, "o", "    -------\r\n"]
[317.007143, "o", "    bool\r\n"]
[317.124857, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[317.242571, "o", "\r\n"]
[317.360286, "o", "    Raises\r\n"]
[317.478, "o", "    ------\r\n"]
[317.595714, "o", "    ValueError\r\n"]
[317.713429, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[317.831143, "o", "        and contains missing values.\r\n"]
[317.948857, "o", "\r\n"]
[318.066571, "o", "    See Also\r\n"]
[318.184286, "o", "    --------\r\n"]
[318.302, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[318.419714, "o", "        and convert to an ndarray.\r\n"]
[318.537429, "o", "    \"\"\"\r\n"]
[318.655143, "o", "    if isinstance(\r\n"]
[318.772857, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[318.890571, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[319.008286, "o", "        if key.dtype == np.object_:\r\n"]
[319.126, "o", "            key_array = np.asarray(key)\r\n"]
[319.243714, "o", "\r\n"]
[319.361429, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[319.479143, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[319.596857, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[319.714571, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[319.832286, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[320.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[320.002, "i", "sed -n '140,220p' ../pandas/core/common.py\r"]
[320.004, "o", "sed -n '140,220p' ../pandas/core/common.py\r\n"]
[320.066293, "o", "\u001b[?2004l\r\n"]
[320.126585, "o", "                    raise ValueError(na_msg)\r\n"]
[320.186878, "o", "                return False\r\n"]
[320.247171, "o", "            return True\r\n"]
[320.307463, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[320.367756, "o", "            return True\r\n"]
[320.428049, "o", "    elif isinstance(key, list):\r\n"]
[320.488341, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[320.548634, "o", "        if len(key) > 0:\r\n"]
[320.608927, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[320.66922, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[320.729512, "o", "                key = list(key)\r\n"]
[320.789805, "o", "            return lib.is_bool_list(key)\r\n"]
[320.850098, "o", "\r\n"]
[320.91039, "o", "    return False\r\n"]
[320.970683, "o", "\r\n"]
[321.030976, "o", "\r\n"]
[321.091268, "o", "def cast_scalar_indexer(val):\r\n"]
[321.151561, "o", "    \"\"\"\r\n"]
[321.211854, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[321.272146, "o", "\r\n"]
[321.332439, "o", "    Parameters\r\n"]
[321.392732, "o", "    ----------\r\n"]
[321.453024, "o", "    val : scalar\r\n"]
[321.513317, "o", "\r\n"]
[321.57361, "o", "    Returns\r\n"]
[321.633902, "o", "    -------\r\n"]
[321.694195, "o", "    outval : scalar\r\n"]
[321.754488, "o", "    \"\"\"\r\n"]
[321.81478, "o", "    # assumes lib.is_scalar(val)\r\n"]
[321.875073, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[321.935366, "o", "        raise IndexError(\r\n"]
[321.995659, "o", "            # GH#34193\r\n"]
[322.055951, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[322.116244, "o", "            \"to an integer key instead.\"\r\n"]
[322.176537, "o", "        )\r\n"]
[322.236829, "o", "    return val\r\n"]
[322.297122, "o", "\r\n"]
[322.357415, "o", "\r\n"]
[322.417707, "o", "def not_none(*args):\r\n"]
[322.478, "o", "    \"\"\"\r\n"]
[322.538293, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[322.598585, "o", "    \"\"\"\r\n"]
[322.658878, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[322.719171, "o", "\r\n"]
[322.779463, "o", "\r\n"]
[322.839756, "o", "def any_none(*args) -> bool:\r\n"]
[322.900049, "o", "    \"\"\"\r\n"]
[322.960341, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[323.020634, "o", "    \"\"\"\r\n"]
[323.080927, "o", "    return any(arg is None for arg in args)\r\n"]
[323.14122, "o", "\r\n"]
[323.201512, "o", "\r\n"]
[323.261805, "o", "def all_none(*args) -> bool:\r\n"]
[323.322098, "o", "    \"\"\"\r\n"]
[323.38239, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[323.442683, "o", "    \"\"\"\r\n"]
[323.502976, "o", "    return all(arg is None for arg in args)\r\n"]
[323.563268, "o", "\r\n"]
[323.623561, "o", "\r\n"]
[323.683854, "o", "def any_not_none(*args) -> bool:\r\n"]
[323.744146, "o", "    \"\"\"\r\n"]
[323.804439, "o", "    Returns a boolean indicating if any argument is not None.\r\n"]
[323.864732, "o", "    \"\"\"\r\n"]
[323.925024, "o", "    return any(arg is not None for arg in args)\r\n"]
[323.985317, "o", "\r\n"]
[324.04561, "o", "\r\n"]
[324.105902, "o", "def all_not_none(*args) -> bool:\r\n"]
[324.166195, "o", "    \"\"\"\r\n"]
[324.226488, "o", "    Returns a boolean indicating if all arguments are not None.\r\n"]
[324.28678, "o", "    \"\"\"\r\n"]
[324.347073, "o", "    return all(arg is not None for arg in args)\r\n"]
[324.407366, "o", "\r\n"]
[324.467659, "o", "\r\n"]
[324.527951, "o", "def count_not_none(*args) -> int:\r\n"]
[324.588244, "o", "    \"\"\"\r\n"]
[324.648537, "o", "    Returns the count of arguments that are not None.\r\n"]
[324.708829, "o", "    \"\"\"\r\n"]
[324.769122, "o", "    return sum(x is not None for x in args)\r\n"]
[324.829415, "o", "\r\n"]
[324.889707, "o", "\r\n"]
[325.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[325.002, "i", "sed -n '2590,2680p' ../pandas/core/indexing.py\r"]
[325.004, "o", "sed -n '2590,2680p' ../pandas/core/indexing.py\r\n"]
[325.059739, "o", "\u001b[?2004l\r\n"]
[325.113478, "o", "    ndim : int\r\n"]
[325.167217, "o", "    loc : object\r\n"]
[325.220957, "o", "\r\n"]
[325.274696, "o", "    Returns\r\n"]
[325.328435, "o", "    -------\r\n"]
[325.382174, "o", "    tuple\r\n"]
[325.435913, "o", "    \"\"\"\r\n"]
[325.489652, "o", "    _tup: list[Hashable | slice]\r\n"]
[325.543391, "o", "    _tup = [slice(None, None) for _ in range(ndim)]\r\n"]
[325.59713, "o", "    _tup[0] = loc\r\n"]
[325.65087, "o", "    return tuple(_tup)\r\n"]
[325.704609, "o", "\r\n"]
[325.758348, "o", "\r\n"]
[325.812087, "o", "def _tupleize_axis_indexer(ndim: int, axis: AxisInt, key) -> tuple:\r\n"]
[325.865826, "o", "    \"\"\"\r\n"]
[325.919565, "o", "    If we have an axis, adapt the given key to be axis-independent.\r\n"]
[325.973304, "o", "    \"\"\"\r\n"]
[326.027043, "o", "    new_key = [slice(None)] * ndim\r\n"]
[326.080783, "o", "    new_key[axis] = key\r\n"]
[326.134522, "o", "    return tuple(new_key)\r\n"]
[326.188261, "o", "\r\n"]
[326.242, "o", "\r\n"]
[326.295739, "o", "def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[326.349478, "o", "    \"\"\"\r\n"]
[326.403217, "o", "    Check if key is a valid boolean indexer for an object with such index and\r\n"]
[326.456957, "o", "    perform reindexing or conversion if needed.\r\n"]
[326.510696, "o", "\r\n"]
[326.564435, "o", "    This function assumes that is_bool_indexer(key) == True.\r\n"]
[326.618174, "o", "\r\n"]
[326.671913, "o", "    Parameters\r\n"]
[326.725652, "o", "    ----------\r\n"]
[326.779391, "o", "    index : Index\r\n"]
[326.83313, "o", "        Index of the object on which the indexing is done.\r\n"]
[326.88687, "o", "    key : list-like\r\n"]
[326.940609, "o", "        Boolean indexer to check.\r\n"]
[326.994348, "o", "\r\n"]
[327.048087, "o", "    Returns\r\n"]
[327.101826, "o", "    -------\r\n"]
[327.155565, "o", "    np.array\r\n"]
[327.209304, "o", "        Resulting key.\r\n"]
[327.263043, "o", "\r\n"]
[327.316783, "o", "    Raises\r\n"]
[327.370522, "o", "    ------\r\n"]
[327.424261, "o", "    IndexError\r\n"]
[327.478, "o", "        If the key does not have the same length as index.\r\n"]
[327.531739, "o", "    IndexingError\r\n"]
[327.585478, "o", "        If the index of the key is unalignable to index.\r\n"]
[327.639217, "o", "    \"\"\"\r\n"]
[327.692957, "o", "    result = key\r\n"]
[327.746696, "o", "    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[327.800435, "o", "        indexer = result.index.get_indexer_for(index)\r\n"]
[327.854174, "o", "        if -1 in indexer:\r\n"]
[327.907913, "o", "            raise IndexingError(\r\n"]
[327.961652, "o", "                \"Unalignable boolean Series provided as \"\r\n"]
[328.015391, "o", "                \"indexer (index of the boolean Series and of \"\r\n"]
[328.06913, "o", "                \"the indexed object do not match).\"\r\n"]
[328.12287, "o", "            )\r\n"]
[328.176609, "o", "\r\n"]
[328.230348, "o", "        result = result.take(indexer)\r\n"]
[328.284087, "o", "\r\n"]
[328.337826, "o", "        # fall through for boolean\r\n"]
[328.391565, "o", "        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[328.445304, "o", "            return result.astype(bool)._values\r\n"]
[328.499043, "o", "\r\n"]
[328.552783, "o", "    if is_object_dtype(key):\r\n"]
[328.606522, "o", "        # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[328.660261, "o", "        result = np.asarray(result, dtype=bool)\r\n"]
[328.714, "o", "    elif not is_array_like(result):\r\n"]
[328.767739, "o", "        # GH 33924\r\n"]
[328.821478, "o", "        # key may contain nan elements, check_array_indexer needs bool array\r\n"]
[328.875217, "o", "        result = pd_array(result, dtype=bool)\r\n"]
[328.928957, "o", "    return check_array_indexer(index, result)\r\n"]
[328.982696, "o", "\r\n"]
[329.036435, "o", "\r\n"]
[329.090174, "o", "def convert_missing_indexer(indexer):\r\n"]
[329.143913, "o", "    \"\"\"\r\n"]
[329.197652, "o", "    Reverse convert a missing indexer, which is a dict\r\n"]
[329.251391, "o", "    return the scalar indexer and a boolean indicating if we converted\r\n"]
[329.30513, "o", "    \"\"\"\r\n"]
[329.35887, "o", "    if isinstance(indexer, dict):\r\n"]
[329.412609, "o", "        # a missing key (but not a tuple indexer)\r\n"]
[329.466348, "o", "        indexer = indexer[\"key\"]\r\n"]
[329.520087, "o", "\r\n"]
[329.573826, "o", "        if isinstance(indexer, bool):\r\n"]
[329.627565, "o", "            raise KeyError(\"cannot use a single bool to index into setitem\")\r\n"]
[329.681304, "o", "        return indexer, True\r\n"]
[329.735043, "o", "\r\n"]
[329.788783, "o", "    return indexer, False\r\n"]
[329.842522, "o", "\r\n"]
[329.896261, "o", "\r\n"]
[330.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[330.002, "i", "sed -n '3920,4060p' ../pandas/core/frame.py\r"]
[330.004, "o", "sed -n '3920,4060p' ../pandas/core/frame.py\r\n"]
[330.040817, "o", "\u001b[?2004l\r\n"]
[330.075634, "o", "        if is_single_key:\r\n"]
[330.110451, "o", "            # What does looking for a single key in a non-unique index return?\r\n"]
[330.145268, "o", "            # The behavior is inconsistent. It returns a Series, except when\r\n"]
[330.180085, "o", "            # - the key itself is repeated (test on data.shape, #9519), or\r\n"]
[330.214901, "o", "            # - we have a MultiIndex on columns (test on self.columns, #21309)\r\n"]
[330.249718, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[330.284535, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[330.319352, "o", "                return data._get_item(key)\r\n"]
[330.354169, "o", "\r\n"]
[330.388986, "o", "        return data\r\n"]
[330.423803, "o", "\r\n"]
[330.45862, "o", "    def _getitem_bool_array(self, key):\r\n"]
[330.493437, "o", "        # also raises Exception if object array with NA values\r\n"]
[330.528254, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[330.56307, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[330.597887, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[330.632704, "o", "        # with all other indexing behavior\r\n"]
[330.667521, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[330.702338, "o", "            warnings.warn(\r\n"]
[330.737155, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[330.771972, "o", "                UserWarning,\r\n"]
[330.806789, "o", "                stacklevel=find_stack_level(),\r\n"]
[330.841606, "o", "            )\r\n"]
[330.876423, "o", "        elif len(key) != len(self.index):\r\n"]
[330.911239, "o", "            raise ValueError(\r\n"]
[330.946056, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[330.980873, "o", "            )\r\n"]
[331.01569, "o", "\r\n"]
[331.050507, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[331.085324, "o", "        # be reindexed to match DataFrame rows\r\n"]
[331.120141, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[331.154958, "o", "\r\n"]
[331.189775, "o", "        if key.all():\r\n"]
[331.224592, "o", "            return self.copy(deep=False)\r\n"]
[331.259408, "o", "\r\n"]
[331.294225, "o", "        indexer = key.nonzero()[0]\r\n"]
[331.329042, "o", "        return self.take(indexer, axis=0)\r\n"]
[331.363859, "o", "\r\n"]
[331.398676, "o", "    def _getitem_multilevel(self, key):\r\n"]
[331.433493, "o", "        # self.columns is a MultiIndex\r\n"]
[331.46831, "o", "        loc = self.columns.get_loc(key)\r\n"]
[331.503127, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[331.537944, "o", "            new_columns = self.columns[loc]\r\n"]
[331.572761, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[331.607577, "o", "            result = self.iloc[:, loc]\r\n"]
[331.642394, "o", "            result.columns = result_columns\r\n"]
[331.677211, "o", "\r\n"]
[331.712028, "o", "            # If there is only one column being returned, and its name is\r\n"]
[331.746845, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[331.781662, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[331.816479, "o", "            # and return the column as if the user had provided that empty\r\n"]
[331.851296, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[331.886113, "o", "            # implied empty string from its name.\r\n"]
[331.92093, "o", "            if len(result.columns) == 1:\r\n"]
[331.955746, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[331.990563, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[332.02538, "o", "                top = result.columns[0]\r\n"]
[332.060197, "o", "                if isinstance(top, tuple):\r\n"]
[332.095014, "o", "                    top = top[0]\r\n"]
[332.129831, "o", "                if top == \"\":\r\n"]
[332.164648, "o", "                    result = result[\"\"]\r\n"]
[332.199465, "o", "                    if isinstance(result, Series):\r\n"]
[332.234282, "o", "                        result = self._constructor_sliced(\r\n"]
[332.269099, "o", "                            result, index=self.index, name=key\r\n"]
[332.303915, "o", "                        )\r\n"]
[332.338732, "o", "\r\n"]
[332.373549, "o", "            return result\r\n"]
[332.408366, "o", "        else:\r\n"]
[332.443183, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[332.478, "o", "            return self._ixs(loc, axis=1)\r\n"]
[332.512817, "o", "\r\n"]
[332.547634, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[332.582451, "o", "        \"\"\"\r\n"]
[332.617268, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[332.652085, "o", "\r\n"]
[332.686901, "o", "        Parameters\r\n"]
[332.721718, "o", "        ----------\r\n"]
[332.756535, "o", "        index : row label\r\n"]
[332.791352, "o", "        col : column label\r\n"]
[332.826169, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[332.860986, "o", "\r\n"]
[332.895803, "o", "        Returns\r\n"]
[332.93062, "o", "        -------\r\n"]
[332.965437, "o", "        scalar\r\n"]
[333.000254, "o", "\r\n"]
[333.03507, "o", "        Notes\r\n"]
[333.069887, "o", "        -----\r\n"]
[333.104704, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[333.139521, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[333.174338, "o", "        \"\"\"\r\n"]
[333.209155, "o", "        if takeable:\r\n"]
[333.243972, "o", "            series = self._ixs(col, axis=1)\r\n"]
[333.278789, "o", "            return series._values[index]\r\n"]
[333.313606, "o", "\r\n"]
[333.348423, "o", "        series = self._get_item(col)\r\n"]
[333.383239, "o", "        engine = self.index._engine\r\n"]
[333.418056, "o", "\r\n"]
[333.452873, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[333.48769, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[333.522507, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[333.557324, "o", "            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[333.592141, "o", "            row = self.index.get_loc(index)\r\n"]
[333.626958, "o", "            return series._values[row]\r\n"]
[333.661775, "o", "\r\n"]
[333.696592, "o", "        # For MultiIndex going through engine effectively restricts us to\r\n"]
[333.731408, "o", "        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[333.766225, "o", "        loc = engine.get_loc(index)\r\n"]
[333.801042, "o", "        return series._values[loc]\r\n"]
[333.835859, "o", "\r\n"]
[333.870676, "o", "    def isetitem(self, loc, value) -> None:\r\n"]
[333.905493, "o", "        \"\"\"\r\n"]
[333.94031, "o", "        Set the given value in the column with position `loc`.\r\n"]
[333.975127, "o", "\r\n"]
[334.009944, "o", "        This is a positional analogue to ``__setitem__``.\r\n"]
[334.044761, "o", "\r\n"]
[334.079577, "o", "        Parameters\r\n"]
[334.114394, "o", "        ----------\r\n"]
[334.149211, "o", "        loc : int or sequence of ints\r\n"]
[334.184028, "o", "            Index position for the column.\r\n"]
[334.218845, "o", "        value : scalar or arraylike\r\n"]
[334.253662, "o", "            Value(s) for the column.\r\n"]
[334.288479, "o", "\r\n"]
[334.323296, "o", "        See Also\r\n"]
[334.358113, "o", "        --------\r\n"]
[334.39293, "o", "        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[334.427746, "o", "            position.\r\n"]
[334.462563, "o", "\r\n"]
[334.49738, "o", "        Notes\r\n"]
[334.532197, "o", "        -----\r\n"]
[334.567014, "o", "        ``frame.isetitem(loc, value)`` is an in-place method as it will\r\n"]
[334.601831, "o", "        modify the DataFrame in place (not returning a new object). In contrast to\r\n"]
[334.636648, "o", "        ``frame.iloc[:, i] = value`` which will try to update the existing values in\r\n"]
[334.671465, "o", "        place, ``frame.isetitem(loc, value)`` will not update the values of the column\r\n"]
[334.706282, "o", "        itself in place, it will instead insert a new array.\r\n"]
[334.741099, "o", "\r\n"]
[334.775915, "o", "        In cases where ``frame.columns`` is unique, this is equivalent to\r\n"]
[334.810732, "o", "        ``frame[frame.columns[i]] = value``.\r\n"]
[334.845549, "o", "\r\n"]
[334.880366, "o", "        Examples\r\n"]
[334.915183, "o", "        --------\r\n"]
[335.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[335.002, "i", "sed -n '80,140p' ../pandas/core/common.py\r"]
[335.004, "o", "sed -n '80,140p' ../pandas/core/common.py\r\n"]
[335.085742, "o", "\u001b[?2004l\r\n"]
[335.165484, "o", "    -------\r\n"]
[335.245226, "o", "    flattened : generator\r\n"]
[335.324968, "o", "    \"\"\"\r\n"]
[335.40471, "o", "    for element in line:\r\n"]
[335.484452, "o", "        if iterable_not_string(element):\r\n"]
[335.564194, "o", "            yield from flatten(element)\r\n"]
[335.643935, "o", "        else:\r\n"]
[335.723677, "o", "            yield element\r\n"]
[335.803419, "o", "\r\n"]
[335.883161, "o", "\r\n"]
[335.962903, "o", "def consensus_name_attr(objs):\r\n"]
[336.042645, "o", "    name = objs[0].name\r\n"]
[336.122387, "o", "    for obj in objs[1:]:\r\n"]
[336.202129, "o", "        try:\r\n"]
[336.281871, "o", "            if obj.name != name:\r\n"]
[336.361613, "o", "                name = None\r\n"]
[336.441355, "o", "        except ValueError:\r\n"]
[336.521097, "o", "            name = None\r\n"]
[336.600839, "o", "    return name\r\n"]
[336.680581, "o", "\r\n"]
[336.760323, "o", "\r\n"]
[336.840065, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[336.919806, "o", "    \"\"\"\r\n"]
[336.999548, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[337.07929, "o", "\r\n"]
[337.159032, "o", "    Parameters\r\n"]
[337.238774, "o", "    ----------\r\n"]
[337.318516, "o", "    key : Any\r\n"]
[337.398258, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[337.478, "o", "        All other types are not considered a boolean indexer.\r\n"]
[337.557742, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[337.637484, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[337.717226, "o", "\r\n"]
[337.796968, "o", "    Returns\r\n"]
[337.87671, "o", "    -------\r\n"]
[337.956452, "o", "    bool\r\n"]
[338.036194, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[338.115935, "o", "\r\n"]
[338.195677, "o", "    Raises\r\n"]
[338.275419, "o", "    ------\r\n"]
[338.355161, "o", "    ValueError\r\n"]
[338.434903, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[338.514645, "o", "        and contains missing values.\r\n"]
[338.594387, "o", "\r\n"]
[338.674129, "o", "    See Also\r\n"]
[338.753871, "o", "    --------\r\n"]
[338.833613, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[338.913355, "o", "        and convert to an ndarray.\r\n"]
[338.993097, "o", "    \"\"\"\r\n"]
[339.072839, "o", "    if isinstance(\r\n"]
[339.152581, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[339.232323, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[339.312065, "o", "        if key.dtype == np.object_:\r\n"]
[339.391806, "o", "            key_array = np.asarray(key)\r\n"]
[339.471548, "o", "\r\n"]
[339.55129, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[339.631032, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[339.710774, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[339.790516, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[339.870258, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[340.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[340.002, "i", "sed -n '140,220p' ../pandas/core/common.py\r"]
[340.004, "o", "sed -n '140,220p' ../pandas/core/common.py\r\n"]
[340.066293, "o", "\u001b[?2004l\r\n"]
[340.126585, "o", "                    raise ValueError(na_msg)\r\n"]
[340.186878, "o", "                return False\r\n"]
[340.247171, "o", "            return True\r\n"]
[340.307463, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[340.367756, "o", "            return True\r\n"]
[340.428049, "o", "    elif isinstance(key, list):\r\n"]
[340.488341, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[340.548634, "o", "        if len(key) > 0:\r\n"]
[340.608927, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[340.66922, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[340.729512, "o", "                key = list(key)\r\n"]
[340.789805, "o", "            return lib.is_bool_list(key)\r\n"]
[340.850098, "o", "\r\n"]
[340.91039, "o", "    return False\r\n"]
[340.970683, "o", "\r\n"]
[341.030976, "o", "\r\n"]
[341.091268, "o", "def cast_scalar_indexer(val):\r\n"]
[341.151561, "o", "    \"\"\"\r\n"]
[341.211854, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[341.272146, "o", "\r\n"]
[341.332439, "o", "    Parameters\r\n"]
[341.392732, "o", "    ----------\r\n"]
[341.453024, "o", "    val : scalar\r\n"]
[341.513317, "o", "\r\n"]
[341.57361, "o", "    Returns\r\n"]
[341.633902, "o", "    -------\r\n"]
[341.694195, "o", "    outval : scalar\r\n"]
[341.754488, "o", "    \"\"\"\r\n"]
[341.81478, "o", "    # assumes lib.is_scalar(val)\r\n"]
[341.875073, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[341.935366, "o", "        raise IndexError(\r\n"]
[341.995659, "o", "            # GH#34193\r\n"]
[342.055951, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[342.116244, "o", "            \"to an integer key instead.\"\r\n"]
[342.176537, "o", "        )\r\n"]
[342.236829, "o", "    return val\r\n"]
[342.297122, "o", "\r\n"]
[342.357415, "o", "\r\n"]
[342.417707, "o", "def not_none(*args):\r\n"]
[342.478, "o", "    \"\"\"\r\n"]
[342.538293, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[342.598585, "o", "    \"\"\"\r\n"]
[342.658878, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[342.719171, "o", "\r\n"]
[342.779463, "o", "\r\n"]
[342.839756, "o", "def any_none(*args) -> bool:\r\n"]
[342.900049, "o", "    \"\"\"\r\n"]
[342.960341, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[343.020634, "o", "    \"\"\"\r\n"]
[343.080927, "o", "    return any(arg is None for arg in args)\r\n"]
[343.14122, "o", "\r\n"]
[343.201512, "o", "\r\n"]
[343.261805, "o", "def all_none(*args) -> bool:\r\n"]
[343.322098, "o", "    \"\"\"\r\n"]
[343.38239, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[343.442683, "o", "    \"\"\"\r\n"]
[343.502976, "o", "    return all(arg is None for arg in args)\r\n"]
[343.563268, "o", "\r\n"]
[343.623561, "o", "\r\n"]
[343.683854, "o", "def any_not_none(*args) -> bool:\r\n"]
[343.744146, "o", "    \"\"\"\r\n"]
[343.804439, "o", "    Returns a boolean indicating if any argument is not None.\r\n"]
[343.864732, "o", "    \"\"\"\r\n"]
[343.925024, "o", "    return any(arg is not None for arg in args)\r\n"]
[343.985317, "o", "\r\n"]
[344.04561, "o", "\r\n"]
[344.105902, "o", "def all_not_none(*args) -> bool:\r\n"]
[344.166195, "o", "    \"\"\"\r\n"]
[344.226488, "o", "    Returns a boolean indicating if all arguments are not None.\r\n"]
[344.28678, "o", "    \"\"\"\r\n"]
[344.347073, "o", "    return all(arg is not None for arg in args)\r\n"]
[344.407366, "o", "\r\n"]
[344.467659, "o", "\r\n"]
[344.527951, "o", "def count_not_none(*args) -> int:\r\n"]
[344.588244, "o", "    \"\"\"\r\n"]
[344.648537, "o", "    Returns the count of arguments that are not None.\r\n"]
[344.708829, "o", "    \"\"\"\r\n"]
[344.769122, "o", "    return sum(x is not None for x in args)\r\n"]
[344.829415, "o", "\r\n"]
[344.889707, "o", "\r\n"]
[345.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[345.002, "i", "sed -n '2590,2680p' ../pandas/core/indexing.py\r"]
[345.004, "o", "sed -n '2590,2680p' ../pandas/core/indexing.py\r\n"]
[345.059739, "o", "\u001b[?2004l\r\n"]
[345.113478, "o", "    ndim : int\r\n"]
[345.167217, "o", "    loc : object\r\n"]
[345.220957, "o", "\r\n"]
[345.274696, "o", "    Returns\r\n"]
[345.328435, "o", "    -------\r\n"]
[345.382174, "o", "    tuple\r\n"]
[345.435913, "o", "    \"\"\"\r\n"]
[345.489652, "o", "    _tup: list[Hashable | slice]\r\n"]
[345.543391, "o", "    _tup = [slice(None, None) for _ in range(ndim)]\r\n"]
[345.59713, "o", "    _tup[0] = loc\r\n"]
[345.65087, "o", "    return tuple(_tup)\r\n"]
[345.704609, "o", "\r\n"]
[345.758348, "o", "\r\n"]
[345.812087, "o", "def _tupleize_axis_indexer(ndim: int, axis: AxisInt, key) -> tuple:\r\n"]
[345.865826, "o", "    \"\"\"\r\n"]
[345.919565, "o", "    If we have an axis, adapt the given key to be axis-independent.\r\n"]
[345.973304, "o", "    \"\"\"\r\n"]
[346.027043, "o", "    new_key = [slice(None)] * ndim\r\n"]
[346.080783, "o", "    new_key[axis] = key\r\n"]
[346.134522, "o", "    return tuple(new_key)\r\n"]
[346.188261, "o", "\r\n"]
[346.242, "o", "\r\n"]
[346.295739, "o", "def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[346.349478, "o", "    \"\"\"\r\n"]
[346.403217, "o", "    Check if key is a valid boolean indexer for an object with such index and\r\n"]
[346.456957, "o", "    perform reindexing or conversion if needed.\r\n"]
[346.510696, "o", "\r\n"]
[346.564435, "o", "    This function assumes that is_bool_indexer(key) == True.\r\n"]
[346.618174, "o", "\r\n"]
[346.671913, "o", "    Parameters\r\n"]
[346.725652, "o", "    ----------\r\n"]
[346.779391, "o", "    index : Index\r\n"]
[346.83313, "o", "        Index of the object on which the indexing is done.\r\n"]
[346.88687, "o", "    key : list-like\r\n"]
[346.940609, "o", "        Boolean indexer to check.\r\n"]
[346.994348, "o", "\r\n"]
[347.048087, "o", "    Returns\r\n"]
[347.101826, "o", "    -------\r\n"]
[347.155565, "o", "    np.array\r\n"]
[347.209304, "o", "        Resulting key.\r\n"]
[347.263043, "o", "\r\n"]
[347.316783, "o", "    Raises\r\n"]
[347.370522, "o", "    ------\r\n"]
[347.424261, "o", "    IndexError\r\n"]
[347.478, "o", "        If the key does not have the same length as index.\r\n"]
[347.531739, "o", "    IndexingError\r\n"]
[347.585478, "o", "        If the index of the key is unalignable to index.\r\n"]
[347.639217, "o", "    \"\"\"\r\n"]
[347.692957, "o", "    result = key\r\n"]
[347.746696, "o", "    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[347.800435, "o", "        indexer = result.index.get_indexer_for(index)\r\n"]
[347.854174, "o", "        if -1 in indexer:\r\n"]
[347.907913, "o", "            raise IndexingError(\r\n"]
[347.961652, "o", "                \"Unalignable boolean Series provided as \"\r\n"]
[348.015391, "o", "                \"indexer (index of the boolean Series and of \"\r\n"]
[348.06913, "o", "                \"the indexed object do not match).\"\r\n"]
[348.12287, "o", "            )\r\n"]
[348.176609, "o", "\r\n"]
[348.230348, "o", "        result = result.take(indexer)\r\n"]
[348.284087, "o", "\r\n"]
[348.337826, "o", "        # fall through for boolean\r\n"]
[348.391565, "o", "        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[348.445304, "o", "            return result.astype(bool)._values\r\n"]
[348.499043, "o", "\r\n"]
[348.552783, "o", "    if is_object_dtype(key):\r\n"]
[348.606522, "o", "        # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[348.660261, "o", "        result = np.asarray(result, dtype=bool)\r\n"]
[348.714, "o", "    elif not is_array_like(result):\r\n"]
[348.767739, "o", "        # GH 33924\r\n"]
[348.821478, "o", "        # key may contain nan elements, check_array_indexer needs bool array\r\n"]
[348.875217, "o", "        result = pd_array(result, dtype=bool)\r\n"]
[348.928957, "o", "    return check_array_indexer(index, result)\r\n"]
[348.982696, "o", "\r\n"]
[349.036435, "o", "\r\n"]
[349.090174, "o", "def convert_missing_indexer(indexer):\r\n"]
[349.143913, "o", "    \"\"\"\r\n"]
[349.197652, "o", "    Reverse convert a missing indexer, which is a dict\r\n"]
[349.251391, "o", "    return the scalar indexer and a boolean indicating if we converted\r\n"]
[349.30513, "o", "    \"\"\"\r\n"]
[349.35887, "o", "    if isinstance(indexer, dict):\r\n"]
[349.412609, "o", "        # a missing key (but not a tuple indexer)\r\n"]
[349.466348, "o", "        indexer = indexer[\"key\"]\r\n"]
[349.520087, "o", "\r\n"]
[349.573826, "o", "        if isinstance(indexer, bool):\r\n"]
[349.627565, "o", "            raise KeyError(\"cannot use a single bool to index into setitem\")\r\n"]
[349.681304, "o", "        return indexer, True\r\n"]
[349.735043, "o", "\r\n"]
[349.788783, "o", "    return indexer, False\r\n"]
[349.842522, "o", "\r\n"]
[349.896261, "o", "\r\n"]
[350.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[350.002, "i", "python - << 'PY'\r"]
[350.004, "o", "python - << 'PY'\r\n"]
[350.136105, "o", "\u001b[?2004l\r\n"]
[350.266211, "o", "\u001b[?2004h> import io, sys, re\r\n"]
[350.396316, "o", "\u001b[?2004l\r\n"]
[350.526421, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[350.656526, "o", "\u001b[?2004l\r\n"]
[350.786632, "o", "\u001b[?2004h> p = Path('../pandas/core/indexing.py')\r\n"]
[350.916737, "o", "\u001b[?2004l\r\n"]
[351.046842, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[351.176947, "o", "\u001b[?2004l\r\n"]
[351.307053, "o", "\u001b[?2004h> old = '    result = key\\n    if isinstance(key, ABCSeries) and not key.index.equals(index):'\r\n"]
[351.437158, "o", "\u001b[?2004l\r\n"]
[351.567263, "o", "\u001b[?2004h> new = (\r\n"]
[351.697368, "o", "\u001b[?2004l\r\n"]
[351.827474, "o", "\u001b[?2004h>     '    result = key\\n'\r\n"]
[351.957579, "o", "\u001b[?2004l\r\n"]
[352.087684, "o", "\u001b[?2004h>     '    if isinstance(key, ABCSeries):\\n'\r\n"]
[352.217789, "o", "\u001b[?2004l\r\n"]
[352.347895, "o", "\u001b[?2004h>     '        # Fastpath: avoid expensive equals() when index objects are identical\\n'\r\n"]
[352.478, "o", "\u001b[?2004l\r\n"]
[352.608105, "o", "\u001b[?2004h>     '        if result.index is not index and not result.index.equals(index):'\r\n"]
[352.738211, "o", "\u001b[?2004l\r\n"]
[352.868316, "o", "\u001b[?2004h> )\r\n"]
[352.998421, "o", "\u001b[?2004l\r\n"]
[353.128526, "o", "\u001b[?2004h> if old in s:\r\n"]
[353.258632, "o", "\u001b[?2004l\r\n"]
[353.388737, "o", "\u001b[?2004h>     s2 = s.replace(old, new)\r\n"]
[353.518842, "o", "\u001b[?2004l\r\n"]
[353.648947, "o", "\u001b[?2004h>     p.write_text(s2)\r\n"]
[353.779053, "o", "\u001b[?2004l\r\n"]
[353.909158, "o", "\u001b[?2004h>     print('Patched check_bool_indexer fastpath added')\r\n"]
[354.039263, "o", "\u001b[?2004l\r\n"]
[354.169368, "o", "\u001b[?2004h> else:\r\n"]
[354.299474, "o", "\u001b[?2004l\r\n"]
[354.429579, "o", "\u001b[?2004h>     print('Expected pattern not found; aborting', file=sys.stderr)\r\n"]
[354.559684, "o", "\u001b[?2004l\r\n"]
[354.689789, "o", "\u001b[?2004h> PY\r\n"]
[354.819895, "o", "\u001b[?2004l\r\n"]
[355.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[355.002, "i", "git diff -- ../pandas/core/indexing.py | sed -n '1,200p'\r"]
[355.004, "o", "git diff -- ../pandas/core/indexing.py | sed -n '1,200p'\r\n"]
[355.315, "o", "\u001b[?2004l\r\n"]
[355.624, "o", "diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py\r\n"]
[355.933, "o", "index b3ae53272c..291c56230c 100644\r\n"]
[356.242, "o", "--- a/pandas/core/indexing.py\r\n"]
[356.551, "o", "+++ b/pandas/core/indexing.py\r\n"]
[356.86, "o", "@@ -2636,7 +2636,9 @@ def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[357.169, "o", "         If the index of the key is unalignable to index.\r\n"]
[357.478, "o", "     \"\"\"\r\n"]
[357.787, "o", "     result = key\r\n"]
[358.096, "o", "-    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[358.405, "o", "+    if isinstance(key, ABCSeries):\r\n"]
[358.714, "o", "+        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[359.023, "o", "+        if result.index is not index and not result.index.equals(index):\r\n"]
[359.332, "o", "         indexer = result.index.get_indexer_for(index)\r\n"]
[359.641, "o", "         if -1 in indexer:\r\n"]
[360.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[360.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[360.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[360.102941, "o", "\u001b[?2004l\r\n"]
[360.199882, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[360.296824, "o", "\u00b7\u00b7 \u001b[0;31mError running /opt/conda/envs/asv_3.10/bin/python3.10 /opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv/benchmark.py discover /workspace/repo/asv_bench/benchmarks /tmp/tmpl4x5tnwy/result.json (exit status 1)\u001b[0m\r\n"]
[360.393765, "o", "   STDOUT -------->\r\n"]
[360.490706, "o", "   [1/1] Generating write_version_file with a custom command\r\n"]
[360.587647, "o", "   + /opt/conda/envs/asv_3.10/bin/ninja\r\n"]
[360.684588, "o", "   STDERR -------->\r\n"]
[360.781529, "o", "   Traceback (most recent call last):\r\n"]
[360.878471, "o", "     File \"/opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv/benchmark.py\", line 99, in <module>\r\n"]
[360.975412, "o", "       main()\r\n"]
[361.072353, "o", "     File \"/opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv/benchmark.py\", line 91, in main\r\n"]
[361.169294, "o", "       commands[mode](args)\r\n"]
[361.266235, "o", "     File \"/opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv_runner/discovery.py\", line 310, in _discover\r\n"]
[361.363176, "o", "       list_benchmarks(benchmark_dir, fp)\r\n"]
[361.460118, "o", "     File \"/opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv_runner/discovery.py\", line 278, in list_benchmarks\r\n"]
[361.557059, "o", "       for benchmark in disc_benchmarks(root):\r\n"]
[361.654, "o", "     File \"/opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv_runner/discovery.py\", line 144, in disc_benchmarks\r\n"]
[361.750941, "o", "       for module in disc_modules(root_name, ignore_import_errors=ignore_import_errors):\r\n"]
[361.847882, "o", "     File \"/opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv_runner/discovery.py\", line 109, in disc_modules\r\n"]
[361.944824, "o", "       yield from disc_modules(name, ignore_import_errors)\r\n"]
[362.041765, "o", "     File \"/opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv_runner/discovery.py\", line 98, in disc_modules\r\n"]
[362.138706, "o", "       module = importlib.import_module(module_name)\r\n"]
[362.235647, "o", "     File \"/opt/conda/envs/asv_3.10/lib/python3.10/importlib/__init__.py\", line 126, in import_module\r\n"]
[362.332588, "o", "       return _bootstrap._gcd_import(name[level:], package, level)\r\n"]
[362.429529, "o", "     File \"<frozen importlib._bootstrap>\", line 1050, in _gcd_import\r\n"]
[362.526471, "o", "     File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\r\n"]
[362.623412, "o", "     File \"<frozen importlib._bootstrap>\", line 1006, in _find_and_load_unlocked\r\n"]
[362.720353, "o", "     File \"<frozen importlib._bootstrap>\", line 688, in _load_unlocked\r\n"]
[362.817294, "o", "     File \"<frozen importlib._bootstrap_external>\", line 883, in exec_module\r\n"]
[362.914235, "o", "     File \"<frozen importlib._bootstrap>\", line 241, in _call_with_frames_removed\r\n"]
[363.011176, "o", "     File \"/workspace/repo/asv_bench/benchmarks/algorithms.py\", line 5, in <module>\r\n"]
[363.108118, "o", "       import pandas as pd\r\n"]
[363.205059, "o", "     File \"/workspace/repo/pandas/__init__.py\", line 47, in <module>\r\n"]
[363.302, "o", "       from pandas.core.api import (\r\n"]
[363.398941, "o", "     File \"/workspace/repo/pandas/core/api.py\", line 46, in <module>\r\n"]
[363.495882, "o", "       from pandas.core.groupby import (\r\n"]
[363.592824, "o", "     File \"/workspace/repo/pandas/core/groupby/__init__.py\", line 1, in <module>\r\n"]
[363.689765, "o", "       from pandas.core.groupby.generic import (\r\n"]
[363.786706, "o", "     File \"/workspace/repo/pandas/core/groupby/generic.py\", line 63, in <module>\r\n"]
[363.883647, "o", "       from pandas.core.frame import DataFrame\r\n"]
[363.980588, "o", "     File \"/workspace/repo/pandas/core/frame.py\", line 145, in <module>\r\n"]
[364.077529, "o", "       from pandas.core.generic import (\r\n"]
[364.174471, "o", "     File \"/workspace/repo/pandas/core/generic.py\", line 139, in <module>\r\n"]
[364.271412, "o", "       from pandas.core import (\r\n"]
[364.368353, "o", "     File \"/workspace/repo/pandas/core/indexing.py\", line 2642\r\n"]
[364.465294, "o", "       indexer = result.index.get_indexer_for(index)\r\n"]
[364.562235, "o", "       ^\r\n"]
[364.659176, "o", "   IndentationError: expected an indented block after 'if' statement on line 2641\r\n"]
[364.756118, "o", "\r\n"]
[364.853059, "o", "\u00b7\u00b7 \u001b[0;31mLast error: Command '/opt/conda/envs/asv_3.10/bin/python3.10 /opt/conda/envs/asv_3.10/lib/python3.10/site-packages/asv/benchmark.py discover /workspace/repo/asv_bench/benchmarks /tmp/tmpl4x5tnwy/result.json' returned non-zero exit status 1\u001b[0m\r\n"]
[365.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[365.002, "i", "sed -n '2628,2660p' ../pandas/core/indexing.py\r"]
[365.004, "o", "sed -n '2628,2660p' ../pandas/core/indexing.py\r\n"]
[365.151412, "o", "\u001b[?2004l\r\n"]
[365.296824, "o", "    np.array\r\n"]
[365.442235, "o", "        Resulting key.\r\n"]
[365.587647, "o", "\r\n"]
[365.733059, "o", "    Raises\r\n"]
[365.878471, "o", "    ------\r\n"]
[366.023882, "o", "    IndexError\r\n"]
[366.169294, "o", "        If the key does not have the same length as index.\r\n"]
[366.314706, "o", "    IndexingError\r\n"]
[366.460118, "o", "        If the index of the key is unalignable to index.\r\n"]
[366.605529, "o", "    \"\"\"\r\n"]
[366.750941, "o", "    result = key\r\n"]
[366.896353, "o", "    if isinstance(key, ABCSeries):\r\n"]
[367.041765, "o", "        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[367.187176, "o", "        if result.index is not index and not result.index.equals(index):\r\n"]
[367.332588, "o", "        indexer = result.index.get_indexer_for(index)\r\n"]
[367.478, "o", "        if -1 in indexer:\r\n"]
[367.623412, "o", "            raise IndexingError(\r\n"]
[367.768824, "o", "                \"Unalignable boolean Series provided as \"\r\n"]
[367.914235, "o", "                \"indexer (index of the boolean Series and of \"\r\n"]
[368.059647, "o", "                \"the indexed object do not match).\"\r\n"]
[368.205059, "o", "            )\r\n"]
[368.350471, "o", "\r\n"]
[368.495882, "o", "        result = result.take(indexer)\r\n"]
[368.641294, "o", "\r\n"]
[368.786706, "o", "        # fall through for boolean\r\n"]
[368.932118, "o", "        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[369.077529, "o", "            return result.astype(bool)._values\r\n"]
[369.222941, "o", "\r\n"]
[369.368353, "o", "    if is_object_dtype(key):\r\n"]
[369.513765, "o", "        # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[369.659176, "o", "        result = np.asarray(result, dtype=bool)\r\n"]
[369.804588, "o", "    elif not is_array_like(result):\r\n"]
[370.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[370.002, "i", "python - << 'PY'\r"]
[370.004, "o", "python - << 'PY'\r\n"]
[370.120977, "o", "\u001b[?2004l\r\n"]
[370.235953, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[370.35093, "o", "\u001b[?2004l\r\n"]
[370.465907, "o", "\u001b[?2004h> p = Path('../pandas/core/indexing.py')\r\n"]
[370.580884, "o", "\u001b[?2004l\r\n"]
[370.69586, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[370.810837, "o", "\u001b[?2004l\r\n"]
[370.925814, "o", "\u001b[?2004h> start = s.find('def check_bool_indexer')\r\n"]
[371.040791, "o", "\u001b[?2004l\r\n"]
[371.155767, "o", "\u001b[?2004h> chunk = s[start:s.find('\\n\\n', start)]\r\n"]
[371.270744, "o", "\u001b[?2004l\r\n"]
[371.385721, "o", "\u001b[?2004h> # Fix indentation by ensuring the reindexing block is indented under the inner if\r\n"]
[371.500698, "o", "\u001b[?2004l\r\n"]
[371.615674, "o", "\u001b[?2004h> s = s.replace(\r\n"]
[371.730651, "o", "\u001b[?2004l\r\n"]
[371.845628, "o", "\u001b[?2004h>     '    if isinstance(key, ABCSeries):\\n        # Fastpath: avoid expensive equals() when index objects are identical\\n        if result.index is not index an\r\n"]
[371.960605, "o", "nd not result.index.equals(index):\\n        indexer = result.index.get_indexer_for(index)\\n        if -1 in indexer:\\n            raise IndexingError(\\n',\r\n"]
[372.075581, "o", "\u001b[?2004l\r\n"]
[372.190558, "o", "\u001b[?2004h>     '    if isinstance(key, ABCSeries):\\n        # Fastpath: avoid expensive equals() when index objects are identical\\n        if result.index is not index an\r\n"]
[372.305535, "o", "nd not result.index.equals(index):\\n            indexer = result.index.get_indexer_for(index)\\n            if -1 in indexer:\\n                raise IndexingError\r\n"]
[372.420512, "o", "r(\\n'\r\n"]
[372.535488, "o", "\u001b[?2004l\r\n"]
[372.650465, "o", "\u001b[?2004h> )\r\n"]
[372.765442, "o", "\u001b[?2004l\r\n"]
[372.880419, "o", "\u001b[?2004h> # Also indent the subsequent lines in that block if needed\r\n"]
[372.995395, "o", "\u001b[?2004l\r\n"]
[373.110372, "o", "\u001b[?2004h> s = s.replace(\r\n"]
[373.225349, "o", "\u001b[?2004l\r\n"]
[373.340326, "o", "\u001b[?2004h>     '        result = result.take(indexer)\\n\\n        # fall through for boolean\\n        if not isinstance(result.dtype, ExtensionDtype):\\n            return \r\n"]
[373.455302, "o", " result.astype(bool)._values\\n',\r\n"]
[373.570279, "o", "\u001b[?2004l\r\n"]
[373.685256, "o", "\u001b[?2004h>     '            result = result.take(indexer)\\n\\n            # fall through for boolean\\n            if not isinstance(result.dtype, ExtensionDtype):\\n       \r\n"]
[373.800233, "o", "          return result.astype(bool)._values\\n'\r\n"]
[373.915209, "o", "\u001b[?2004l\r\n"]
[374.030186, "o", "\u001b[?2004h> )\r\n"]
[374.145163, "o", "\u001b[?2004l\r\n"]
[374.26014, "o", "\u001b[?2004h> p.write_text(s)\r\n"]
[374.375116, "o", "\u001b[?2004l\r\n"]
[374.490093, "o", "\u001b[?2004h> print('Indentation fixed')\r\n"]
[374.60507, "o", "\u001b[?2004l\r\n"]
[374.720047, "o", "\u001b[?2004h> PY\r\n"]
[374.835023, "o", "\u001b[?2004l\r\n"]
[375.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[375.002, "i", "git diff -- ../pandas/core/indexing.py | sed -n '1,200p'\r"]
[375.004, "o", "git diff -- ../pandas/core/indexing.py | sed -n '1,200p'\r\n"]
[375.143333, "o", "\u001b[?2004l\r\n"]
[375.280667, "o", "diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py\r\n"]
[375.418, "o", "index b3ae53272c..8556b56555 100644\r\n"]
[375.555333, "o", "--- a/pandas/core/indexing.py\r\n"]
[375.692667, "o", "+++ b/pandas/core/indexing.py\r\n"]
[375.83, "o", "@@ -2636,20 +2636,22 @@ def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[375.967333, "o", "         If the index of the key is unalignable to index.\r\n"]
[376.104667, "o", "     \"\"\"\r\n"]
[376.242, "o", "     result = key\r\n"]
[376.379333, "o", "-    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[376.516667, "o", "-        indexer = result.index.get_indexer_for(index)\r\n"]
[376.654, "o", "-        if -1 in indexer:\r\n"]
[376.791333, "o", "-            raise IndexingError(\r\n"]
[376.928667, "o", "+    if isinstance(key, ABCSeries):\r\n"]
[377.066, "o", "+        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[377.203333, "o", "+        if result.index is not index and not result.index.equals(index):\r\n"]
[377.340667, "o", "+            indexer = result.index.get_indexer_for(index)\r\n"]
[377.478, "o", "+            if -1 in indexer:\r\n"]
[377.615333, "o", "+                raise IndexingError(\r\n"]
[377.752667, "o", "                 \"Unalignable boolean Series provided as \"\r\n"]
[377.89, "o", "                 \"indexer (index of the boolean Series and of \"\r\n"]
[378.027333, "o", "                 \"the indexed object do not match).\"\r\n"]
[378.164667, "o", "             )\r\n"]
[378.302, "o", " \r\n"]
[378.439333, "o", "-        result = result.take(indexer)\r\n"]
[378.576667, "o", "+            result = result.take(indexer)\r\n"]
[378.714, "o", " \r\n"]
[378.851333, "o", "-        # fall through for boolean\r\n"]
[378.988667, "o", "-        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[379.126, "o", "-            return result.astype(bool)._values\r\n"]
[379.263333, "o", "+            # fall through for boolean\r\n"]
[379.400667, "o", "+            if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[379.538, "o", "+                return result.astype(bool)._values\r\n"]
[379.675333, "o", " \r\n"]
[379.812667, "o", "     if is_object_dtype(key):\r\n"]
[380.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[380.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[380.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[380.418, "o", "\u001b[?2004l\r\n"]
[380.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[381.242, "o", "\u00b7 \u001b[0;32mRunning 7 total benchmarks (1 commits * 1 environments * 7 benchmarks)\u001b[0m\r\n"]
[381.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[382.066, "o", "[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_at--)\u001b[0m.......\r\n"]
[382.478, "o", "[57.14%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at\u001b[0m                                                                                                12.9\u00b10.2\u03bcs\r\n"]
[382.89, "o", "[64.29%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at_setitem\u001b[0m                                                                                        12.4\u00b10.2\u03bcs\r\n"]
[383.302, "o", "[71.43%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows\u001b[0m                                                                                         118\u00b11\u03bcs\r\n"]
[383.714, "o", "[78.57%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_boolean\u001b[0m                                                                                 115\u00b11\u03bcs\r\n"]
[384.126, "o", "[85.71%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                  166\u00b11\u03bcs\r\n"]
[384.538, "o", "[92.86%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_getitem_scalar\u001b[0m                                                                                    13.0\u00b10.2\u03bcs\r\n"]
[385.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[385.002, "i", "sed -n '80,160p' ../pandas/core/common.py\r"]
[385.004, "o", "sed -n '80,160p' ../pandas/core/common.py\r\n"]
[385.066293, "o", "\u001b[?2004l\r\n"]
[385.126585, "o", "    -------\r\n"]
[385.186878, "o", "    flattened : generator\r\n"]
[385.247171, "o", "    \"\"\"\r\n"]
[385.307463, "o", "    for element in line:\r\n"]
[385.367756, "o", "        if iterable_not_string(element):\r\n"]
[385.428049, "o", "            yield from flatten(element)\r\n"]
[385.488341, "o", "        else:\r\n"]
[385.548634, "o", "            yield element\r\n"]
[385.608927, "o", "\r\n"]
[385.66922, "o", "\r\n"]
[385.729512, "o", "def consensus_name_attr(objs):\r\n"]
[385.789805, "o", "    name = objs[0].name\r\n"]
[385.850098, "o", "    for obj in objs[1:]:\r\n"]
[385.91039, "o", "        try:\r\n"]
[385.970683, "o", "            if obj.name != name:\r\n"]
[386.030976, "o", "                name = None\r\n"]
[386.091268, "o", "        except ValueError:\r\n"]
[386.151561, "o", "            name = None\r\n"]
[386.211854, "o", "    return name\r\n"]
[386.272146, "o", "\r\n"]
[386.332439, "o", "\r\n"]
[386.392732, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[386.453024, "o", "    \"\"\"\r\n"]
[386.513317, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[386.57361, "o", "\r\n"]
[386.633902, "o", "    Parameters\r\n"]
[386.694195, "o", "    ----------\r\n"]
[386.754488, "o", "    key : Any\r\n"]
[386.81478, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[386.875073, "o", "        All other types are not considered a boolean indexer.\r\n"]
[386.935366, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[386.995659, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[387.055951, "o", "\r\n"]
[387.116244, "o", "    Returns\r\n"]
[387.176537, "o", "    -------\r\n"]
[387.236829, "o", "    bool\r\n"]
[387.297122, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[387.357415, "o", "\r\n"]
[387.417707, "o", "    Raises\r\n"]
[387.478, "o", "    ------\r\n"]
[387.538293, "o", "    ValueError\r\n"]
[387.598585, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[387.658878, "o", "        and contains missing values.\r\n"]
[387.719171, "o", "\r\n"]
[387.779463, "o", "    See Also\r\n"]
[387.839756, "o", "    --------\r\n"]
[387.900049, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[387.960341, "o", "        and convert to an ndarray.\r\n"]
[388.020634, "o", "    \"\"\"\r\n"]
[388.080927, "o", "    if isinstance(\r\n"]
[388.14122, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[388.201512, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[388.261805, "o", "        if key.dtype == np.object_:\r\n"]
[388.322098, "o", "            key_array = np.asarray(key)\r\n"]
[388.38239, "o", "\r\n"]
[388.442683, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[388.502976, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[388.563268, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[388.623561, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[388.683854, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[388.744146, "o", "                    raise ValueError(na_msg)\r\n"]
[388.804439, "o", "                return False\r\n"]
[388.864732, "o", "            return True\r\n"]
[388.925024, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[388.985317, "o", "            return True\r\n"]
[389.04561, "o", "    elif isinstance(key, list):\r\n"]
[389.105902, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[389.166195, "o", "        if len(key) > 0:\r\n"]
[389.226488, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[389.28678, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[389.347073, "o", "                key = list(key)\r\n"]
[389.407366, "o", "            return lib.is_bool_list(key)\r\n"]
[389.467659, "o", "\r\n"]
[389.527951, "o", "    return False\r\n"]
[389.588244, "o", "\r\n"]
[389.648537, "o", "\r\n"]
[389.708829, "o", "def cast_scalar_indexer(val):\r\n"]
[389.769122, "o", "    \"\"\"\r\n"]
[389.829415, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[389.889707, "o", "\r\n"]
[390.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[390.002, "i", "sed -n '160,260p' ../pandas/core/common.py\r"]
[390.004, "o", "sed -n '160,260p' ../pandas/core/common.py\r\n"]
[390.054471, "o", "\u001b[?2004l\r\n"]
[390.102941, "o", "    Parameters\r\n"]
[390.151412, "o", "    ----------\r\n"]
[390.199882, "o", "    val : scalar\r\n"]
[390.248353, "o", "\r\n"]
[390.296824, "o", "    Returns\r\n"]
[390.345294, "o", "    -------\r\n"]
[390.393765, "o", "    outval : scalar\r\n"]
[390.442235, "o", "    \"\"\"\r\n"]
[390.490706, "o", "    # assumes lib.is_scalar(val)\r\n"]
[390.539176, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[390.587647, "o", "        raise IndexError(\r\n"]
[390.636118, "o", "            # GH#34193\r\n"]
[390.684588, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[390.733059, "o", "            \"to an integer key instead.\"\r\n"]
[390.781529, "o", "        )\r\n"]
[390.83, "o", "    return val\r\n"]
[390.878471, "o", "\r\n"]
[390.926941, "o", "\r\n"]
[390.975412, "o", "def not_none(*args):\r\n"]
[391.023882, "o", "    \"\"\"\r\n"]
[391.072353, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[391.120824, "o", "    \"\"\"\r\n"]
[391.169294, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[391.217765, "o", "\r\n"]
[391.266235, "o", "\r\n"]
[391.314706, "o", "def any_none(*args) -> bool:\r\n"]
[391.363176, "o", "    \"\"\"\r\n"]
[391.411647, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[391.460118, "o", "    \"\"\"\r\n"]
[391.508588, "o", "    return any(arg is None for arg in args)\r\n"]
[391.557059, "o", "\r\n"]
[391.605529, "o", "\r\n"]
[391.654, "o", "def all_none(*args) -> bool:\r\n"]
[391.702471, "o", "    \"\"\"\r\n"]
[391.750941, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[391.799412, "o", "    \"\"\"\r\n"]
[391.847882, "o", "    return all(arg is None for arg in args)\r\n"]
[391.896353, "o", "\r\n"]
[391.944824, "o", "\r\n"]
[391.993294, "o", "def any_not_none(*args) -> bool:\r\n"]
[392.041765, "o", "    \"\"\"\r\n"]
[392.090235, "o", "    Returns a boolean indicating if any argument is not None.\r\n"]
[392.138706, "o", "    \"\"\"\r\n"]
[392.187176, "o", "    return any(arg is not None for arg in args)\r\n"]
[392.235647, "o", "\r\n"]
[392.284118, "o", "\r\n"]
[392.332588, "o", "def all_not_none(*args) -> bool:\r\n"]
[392.381059, "o", "    \"\"\"\r\n"]
[392.429529, "o", "    Returns a boolean indicating if all arguments are not None.\r\n"]
[392.478, "o", "    \"\"\"\r\n"]
[392.526471, "o", "    return all(arg is not None for arg in args)\r\n"]
[392.574941, "o", "\r\n"]
[392.623412, "o", "\r\n"]
[392.671882, "o", "def count_not_none(*args) -> int:\r\n"]
[392.720353, "o", "    \"\"\"\r\n"]
[392.768824, "o", "    Returns the count of arguments that are not None.\r\n"]
[392.817294, "o", "    \"\"\"\r\n"]
[392.865765, "o", "    return sum(x is not None for x in args)\r\n"]
[392.914235, "o", "\r\n"]
[392.962706, "o", "\r\n"]
[393.011176, "o", "@overload\r\n"]
[393.059647, "o", "def asarray_tuplesafe(\r\n"]
[393.108118, "o", "    values: ArrayLike | list | tuple | zip, dtype: NpDtype | None = ...\r\n"]
[393.156588, "o", ") -> np.ndarray:\r\n"]
[393.205059, "o", "    # ExtensionArray can only be returned when values is an Index, all other iterables\r\n"]
[393.253529, "o", "    # will return np.ndarray. Unfortunately \"all other\" cannot be encoded in a type\r\n"]
[393.302, "o", "    # signature, so instead we special-case some common types.\r\n"]
[393.350471, "o", "    ...\r\n"]
[393.398941, "o", "\r\n"]
[393.447412, "o", "\r\n"]
[393.495882, "o", "@overload\r\n"]
[393.544353, "o", "def asarray_tuplesafe(values: Iterable, dtype: NpDtype | None = ...) -> ArrayLike: ...\r\n"]
[393.592824, "o", "\r\n"]
[393.641294, "o", "\r\n"]
[393.689765, "o", "def asarray_tuplesafe(values: Iterable, dtype: NpDtype | None = None) -> ArrayLike:\r\n"]
[393.738235, "o", "    if not (isinstance(values, (list, tuple)) or hasattr(values, \"__array__\")):\r\n"]
[393.786706, "o", "        values = list(values)\r\n"]
[393.835176, "o", "    elif isinstance(values, ABCIndex):\r\n"]
[393.883647, "o", "        return values._values\r\n"]
[393.932118, "o", "    elif isinstance(values, ABCSeries):\r\n"]
[393.980588, "o", "        return values._values\r\n"]
[394.029059, "o", "\r\n"]
[394.077529, "o", "    if isinstance(values, list) and dtype in [np.object_, object]:\r\n"]
[394.126, "o", "        return construct_1d_object_array_from_listlike(values)\r\n"]
[394.174471, "o", "\r\n"]
[394.222941, "o", "    try:\r\n"]
[394.271412, "o", "        with warnings.catch_warnings():\r\n"]
[394.319882, "o", "            # Can remove warning filter once NumPy 1.24 is min version\r\n"]
[394.368353, "o", "            if not np_version_gte1p24:\r\n"]
[394.416824, "o", "                warnings.simplefilter(\"ignore\", np.VisibleDeprecationWarning)\r\n"]
[394.465294, "o", "            result = np.asarray(values, dtype=dtype)\r\n"]
[394.513765, "o", "    except ValueError:\r\n"]
[394.562235, "o", "        # Using try/except since it's more performant than checking is_list_like\r\n"]
[394.610706, "o", "        # over each element\r\n"]
[394.659176, "o", "        # error: Argument 1 to \"construct_1d_object_array_from_listlike\"\r\n"]
[394.707647, "o", "        # has incompatible type \"Iterable[Any]\"; expected \"Sized\"\r\n"]
[394.756118, "o", "        return construct_1d_object_array_from_listlike(values)  # type: ignore[arg-type]\r\n"]
[394.804588, "o", "\r\n"]
[394.853059, "o", "    if issubclass(result.dtype.type, str):\r\n"]
[394.901529, "o", "        result = np.asarray(values, dtype=object)\r\n"]
[395.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[395.002, "i", "sed -n '1,260p' ../pandas/core/common.py\r"]
[395.004, "o", "sed -n '1,260p' ../pandas/core/common.py\r\n"]
[395.024943, "o", "\u001b[?2004l\r\n"]
[395.043885, "o", "\"\"\"\r\n"]
[395.062828, "o", "Misc tools for implementing data structures\r\n"]
[395.08177, "o", "\r\n"]
[395.100713, "o", "Note: pandas.core.common is *not* part of the public API.\r\n"]
[395.119655, "o", "\"\"\"\r\n"]
[395.138598, "o", "\r\n"]
[395.15754, "o", "from __future__ import annotations\r\n"]
[395.176483, "o", "\r\n"]
[395.195425, "o", "import builtins\r\n"]
[395.214368, "o", "from collections import (\r\n"]
[395.23331, "o", "    abc,\r\n"]
[395.252253, "o", "    defaultdict,\r\n"]
[395.271195, "o", ")\r\n"]
[395.290138, "o", "from collections.abc import (\r\n"]
[395.30908, "o", "    Collection,\r\n"]
[395.328023, "o", "    Generator,\r\n"]
[395.346966, "o", "    Hashable,\r\n"]
[395.365908, "o", "    Iterable,\r\n"]
[395.384851, "o", "    Sequence,\r\n"]
[395.403793, "o", ")\r\n"]
[395.422736, "o", "import contextlib\r\n"]
[395.441678, "o", "from functools import partial\r\n"]
[395.460621, "o", "import inspect\r\n"]
[395.479563, "o", "from typing import (\r\n"]
[395.498506, "o", "    TYPE_CHECKING,\r\n"]
[395.517448, "o", "    Any,\r\n"]
[395.536391, "o", "    Callable,\r\n"]
[395.555333, "o", "    TypeVar,\r\n"]
[395.574276, "o", "    cast,\r\n"]
[395.593218, "o", "    overload,\r\n"]
[395.612161, "o", ")\r\n"]
[395.631103, "o", "import warnings\r\n"]
[395.650046, "o", "\r\n"]
[395.668989, "o", "import numpy as np\r\n"]
[395.687931, "o", "\r\n"]
[395.706874, "o", "from pandas._libs import lib\r\n"]
[395.725816, "o", "from pandas.compat.numpy import np_version_gte1p24\r\n"]
[395.744759, "o", "\r\n"]
[395.763701, "o", "from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\r\n"]
[395.782644, "o", "from pandas.core.dtypes.common import (\r\n"]
[395.801586, "o", "    is_bool_dtype,\r\n"]
[395.820529, "o", "    is_integer,\r\n"]
[395.839471, "o", ")\r\n"]
[395.858414, "o", "from pandas.core.dtypes.generic import (\r\n"]
[395.877356, "o", "    ABCExtensionArray,\r\n"]
[395.896299, "o", "    ABCIndex,\r\n"]
[395.915241, "o", "    ABCMultiIndex,\r\n"]
[395.934184, "o", "    ABCSeries,\r\n"]
[395.953126, "o", ")\r\n"]
[395.972069, "o", "from pandas.core.dtypes.inference import iterable_not_string\r\n"]
[395.991011, "o", "\r\n"]
[396.009954, "o", "if TYPE_CHECKING:\r\n"]
[396.028897, "o", "    from pandas._typing import (\r\n"]
[396.047839, "o", "        AnyArrayLike,\r\n"]
[396.066782, "o", "        ArrayLike,\r\n"]
[396.085724, "o", "        Concatenate,\r\n"]
[396.104667, "o", "        NpDtype,\r\n"]
[396.123609, "o", "        P,\r\n"]
[396.142552, "o", "        RandomState,\r\n"]
[396.161494, "o", "        T,\r\n"]
[396.180437, "o", "    )\r\n"]
[396.199379, "o", "\r\n"]
[396.218322, "o", "    from pandas import Index\r\n"]
[396.237264, "o", "\r\n"]
[396.256207, "o", "\r\n"]
[396.275149, "o", "def flatten(line):\r\n"]
[396.294092, "o", "    \"\"\"\r\n"]
[396.313034, "o", "    Flatten an arbitrarily nested sequence.\r\n"]
[396.331977, "o", "\r\n"]
[396.35092, "o", "    Parameters\r\n"]
[396.369862, "o", "    ----------\r\n"]
[396.388805, "o", "    line : sequence\r\n"]
[396.407747, "o", "        The non string sequence to flatten\r\n"]
[396.42669, "o", "\r\n"]
[396.445632, "o", "    Notes\r\n"]
[396.464575, "o", "    -----\r\n"]
[396.483517, "o", "    This doesn't consider strings sequences.\r\n"]
[396.50246, "o", "\r\n"]
[396.521402, "o", "    Returns\r\n"]
[396.540345, "o", "    -------\r\n"]
[396.559287, "o", "    flattened : generator\r\n"]
[396.57823, "o", "    \"\"\"\r\n"]
[396.597172, "o", "    for element in line:\r\n"]
[396.616115, "o", "        if iterable_not_string(element):\r\n"]
[396.635057, "o", "            yield from flatten(element)\r\n"]
[396.654, "o", "        else:\r\n"]
[396.672943, "o", "            yield element\r\n"]
[396.691885, "o", "\r\n"]
[396.710828, "o", "\r\n"]
[396.72977, "o", "def consensus_name_attr(objs):\r\n"]
[396.748713, "o", "    name = objs[0].name\r\n"]
[396.767655, "o", "    for obj in objs[1:]:\r\n"]
[396.786598, "o", "        try:\r\n"]
[396.80554, "o", "            if obj.name != name:\r\n"]
[396.824483, "o", "                name = None\r\n"]
[396.843425, "o", "        except ValueError:\r\n"]
[396.862368, "o", "            name = None\r\n"]
[396.88131, "o", "    return name\r\n"]
[396.900253, "o", "\r\n"]
[396.919195, "o", "\r\n"]
[396.938138, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[396.95708, "o", "    \"\"\"\r\n"]
[396.976023, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[396.994966, "o", "\r\n"]
[397.013908, "o", "    Parameters\r\n"]
[397.032851, "o", "    ----------\r\n"]
[397.051793, "o", "    key : Any\r\n"]
[397.070736, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[397.089678, "o", "        All other types are not considered a boolean indexer.\r\n"]
[397.108621, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[397.127563, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[397.146506, "o", "\r\n"]
[397.165448, "o", "    Returns\r\n"]
[397.184391, "o", "    -------\r\n"]
[397.203333, "o", "    bool\r\n"]
[397.222276, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[397.241218, "o", "\r\n"]
[397.260161, "o", "    Raises\r\n"]
[397.279103, "o", "    ------\r\n"]
[397.298046, "o", "    ValueError\r\n"]
[397.316989, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[397.335931, "o", "        and contains missing values.\r\n"]
[397.354874, "o", "\r\n"]
[397.373816, "o", "    See Also\r\n"]
[397.392759, "o", "    --------\r\n"]
[397.411701, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[397.430644, "o", "        and convert to an ndarray.\r\n"]
[397.449586, "o", "    \"\"\"\r\n"]
[397.468529, "o", "    if isinstance(\r\n"]
[397.487471, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[397.506414, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[397.525356, "o", "        if key.dtype == np.object_:\r\n"]
[397.544299, "o", "            key_array = np.asarray(key)\r\n"]
[397.563241, "o", "\r\n"]
[397.582184, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[397.601126, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[397.620069, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[397.639011, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[397.657954, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[397.676897, "o", "                    raise ValueError(na_msg)\r\n"]
[397.695839, "o", "                return False\r\n"]
[397.714782, "o", "            return True\r\n"]
[397.733724, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[397.752667, "o", "            return True\r\n"]
[397.771609, "o", "    elif isinstance(key, list):\r\n"]
[397.790552, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[397.809494, "o", "        if len(key) > 0:\r\n"]
[397.828437, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[397.847379, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[397.866322, "o", "                key = list(key)\r\n"]
[397.885264, "o", "            return lib.is_bool_list(key)\r\n"]
[397.904207, "o", "\r\n"]
[397.923149, "o", "    return False\r\n"]
[397.942092, "o", "\r\n"]
[397.961034, "o", "\r\n"]
[397.979977, "o", "def cast_scalar_indexer(val):\r\n"]
[397.99892, "o", "    \"\"\"\r\n"]
[398.017862, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[398.036805, "o", "\r\n"]
[398.055747, "o", "    Parameters\r\n"]
[398.07469, "o", "    ----------\r\n"]
[398.093632, "o", "    val : scalar\r\n"]
[398.112575, "o", "\r\n"]
[398.131517, "o", "    Returns\r\n"]
[398.15046, "o", "    -------\r\n"]
[398.169402, "o", "    outval : scalar\r\n"]
[398.188345, "o", "    \"\"\"\r\n"]
[398.207287, "o", "    # assumes lib.is_scalar(val)\r\n"]
[398.22623, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[398.245172, "o", "        raise IndexError(\r\n"]
[398.264115, "o", "            # GH#34193\r\n"]
[398.283057, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[398.302, "o", "            \"to an integer key instead.\"\r\n"]
[398.320943, "o", "        )\r\n"]
[398.339885, "o", "    return val\r\n"]
[398.358828, "o", "\r\n"]
[398.37777, "o", "\r\n"]
[398.396713, "o", "def not_none(*args):\r\n"]
[398.415655, "o", "    \"\"\"\r\n"]
[398.434598, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[398.45354, "o", "    \"\"\"\r\n"]
[398.472483, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[398.491425, "o", "\r\n"]
[398.510368, "o", "\r\n"]
[398.52931, "o", "def any_none(*args) -> bool:\r\n"]
[398.548253, "o", "    \"\"\"\r\n"]
[398.567195, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[398.586138, "o", "    \"\"\"\r\n"]
[398.60508, "o", "    return any(arg is None for arg in args)\r\n"]
[398.624023, "o", "\r\n"]
[398.642966, "o", "\r\n"]
[398.661908, "o", "def all_none(*args) -> bool:\r\n"]
[398.680851, "o", "    \"\"\"\r\n"]
[398.699793, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[398.718736, "o", "    \"\"\"\r\n"]
[398.737678, "o", "    return all(arg is None for arg in args)\r\n"]
[398.756621, "o", "\r\n"]
[398.775563, "o", "\r\n"]
[398.794506, "o", "def any_not_none(*args) -> bool:\r\n"]
[398.813448, "o", "    \"\"\"\r\n"]
[398.832391, "o", "    Returns a boolean indicating if any argument is not None.\r\n"]
[398.851333, "o", "    \"\"\"\r\n"]
[398.870276, "o", "    return any(arg is not None for arg in args)\r\n"]
[398.889218, "o", "\r\n"]
[398.908161, "o", "\r\n"]
[398.927103, "o", "def all_not_none(*args) -> bool:\r\n"]
[398.946046, "o", "    \"\"\"\r\n"]
[398.964989, "o", "    Returns a boolean indicating if all arguments are not None.\r\n"]
[398.983931, "o", "    \"\"\"\r\n"]
[399.002874, "o", "    return all(arg is not None for arg in args)\r\n"]
[399.021816, "o", "\r\n"]
[399.040759, "o", "\r\n"]
[399.059701, "o", "def count_not_none(*args) -> int:\r\n"]
[399.078644, "o", "    \"\"\"\r\n"]
[399.097586, "o", "    Returns the count of arguments that are not None.\r\n"]
[399.116529, "o", "    \"\"\"\r\n"]
[399.135471, "o", "    return sum(x is not None for x in args)\r\n"]
[399.154414, "o", "\r\n"]
[399.173356, "o", "\r\n"]
[399.192299, "o", "@overload\r\n"]
[399.211241, "o", "def asarray_tuplesafe(\r\n"]
[399.230184, "o", "    values: ArrayLike | list | tuple | zip, dtype: NpDtype | None = ...\r\n"]
[399.249126, "o", ") -> np.ndarray:\r\n"]
[399.268069, "o", "    # ExtensionArray can only be returned when values is an Index, all other iterables\r\n"]
[399.287011, "o", "    # will return np.ndarray. Unfortunately \"all other\" cannot be encoded in a type\r\n"]
[399.305954, "o", "    # signature, so instead we special-case some common types.\r\n"]
[399.324897, "o", "    ...\r\n"]
[399.343839, "o", "\r\n"]
[399.362782, "o", "\r\n"]
[399.381724, "o", "@overload\r\n"]
[399.400667, "o", "def asarray_tuplesafe(values: Iterable, dtype: NpDtype | None = ...) -> ArrayLike: ...\r\n"]
[399.419609, "o", "\r\n"]
[399.438552, "o", "\r\n"]
[399.457494, "o", "def asarray_tuplesafe(values: Iterable, dtype: NpDtype | None = None) -> ArrayLike:\r\n"]
[399.476437, "o", "    if not (isinstance(values, (list, tuple)) or hasattr(values, \"__array__\")):\r\n"]
[399.495379, "o", "        values = list(values)\r\n"]
[399.514322, "o", "    elif isinstance(values, ABCIndex):\r\n"]
[399.533264, "o", "        return values._values\r\n"]
[399.552207, "o", "    elif isinstance(values, ABCSeries):\r\n"]
[399.571149, "o", "        return values._values\r\n"]
[399.590092, "o", "\r\n"]
[399.609034, "o", "    if isinstance(values, list) and dtype in [np.object_, object]:\r\n"]
[399.627977, "o", "        return construct_1d_object_array_from_listlike(values)\r\n"]
[399.64692, "o", "\r\n"]
[399.665862, "o", "    try:\r\n"]
[399.684805, "o", "        with warnings.catch_warnings():\r\n"]
[399.703747, "o", "            # Can remove warning filter once NumPy 1.24 is min version\r\n"]
[399.72269, "o", "            if not np_version_gte1p24:\r\n"]
[399.741632, "o", "                warnings.simplefilter(\"ignore\", np.VisibleDeprecationWarning)\r\n"]
[399.760575, "o", "            result = np.asarray(values, dtype=dtype)\r\n"]
[399.779517, "o", "    except ValueError:\r\n"]
[399.79846, "o", "        # Using try/except since it's more performant than checking is_list_like\r\n"]
[399.817402, "o", "        # over each element\r\n"]
[399.836345, "o", "        # error: Argument 1 to \"construct_1d_object_array_from_listlike\"\r\n"]
[399.855287, "o", "        # has incompatible type \"Iterable[Any]\"; expected \"Sized\"\r\n"]
[399.87423, "o", "        return construct_1d_object_array_from_listlike(values)  # type: ignore[arg-type]\r\n"]
[399.893172, "o", "\r\n"]
[399.912115, "o", "    if issubclass(result.dtype.type, str):\r\n"]
[399.931057, "o", "        result = np.asarray(values, dtype=object)\r\n"]
[400.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[400.002, "i", "grep -n \"def is_bool_indexer\\(\" ../pandas/core/common.py\r"]
[400.004, "o", "grep -n \"def is_bool_indexer\\(\" ../pandas/core/common.py\r\n"]
[402.478, "o", "\u001b[?2004l\r\n"]
[405.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[405.002, "i", "sed -n '90,180p' ../pandas/core/common.py\r"]
[405.004, "o", "sed -n '90,180p' ../pandas/core/common.py\r\n"]
[405.059739, "o", "\u001b[?2004l\r\n"]
[405.113478, "o", "def consensus_name_attr(objs):\r\n"]
[405.167217, "o", "    name = objs[0].name\r\n"]
[405.220957, "o", "    for obj in objs[1:]:\r\n"]
[405.274696, "o", "        try:\r\n"]
[405.328435, "o", "            if obj.name != name:\r\n"]
[405.382174, "o", "                name = None\r\n"]
[405.435913, "o", "        except ValueError:\r\n"]
[405.489652, "o", "            name = None\r\n"]
[405.543391, "o", "    return name\r\n"]
[405.59713, "o", "\r\n"]
[405.65087, "o", "\r\n"]
[405.704609, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[405.758348, "o", "    \"\"\"\r\n"]
[405.812087, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[405.865826, "o", "\r\n"]
[405.919565, "o", "    Parameters\r\n"]
[405.973304, "o", "    ----------\r\n"]
[406.027043, "o", "    key : Any\r\n"]
[406.080783, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[406.134522, "o", "        All other types are not considered a boolean indexer.\r\n"]
[406.188261, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[406.242, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[406.295739, "o", "\r\n"]
[406.349478, "o", "    Returns\r\n"]
[406.403217, "o", "    -------\r\n"]
[406.456957, "o", "    bool\r\n"]
[406.510696, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[406.564435, "o", "\r\n"]
[406.618174, "o", "    Raises\r\n"]
[406.671913, "o", "    ------\r\n"]
[406.725652, "o", "    ValueError\r\n"]
[406.779391, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[406.83313, "o", "        and contains missing values.\r\n"]
[406.88687, "o", "\r\n"]
[406.940609, "o", "    See Also\r\n"]
[406.994348, "o", "    --------\r\n"]
[407.048087, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[407.101826, "o", "        and convert to an ndarray.\r\n"]
[407.155565, "o", "    \"\"\"\r\n"]
[407.209304, "o", "    if isinstance(\r\n"]
[407.263043, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[407.316783, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[407.370522, "o", "        if key.dtype == np.object_:\r\n"]
[407.424261, "o", "            key_array = np.asarray(key)\r\n"]
[407.478, "o", "\r\n"]
[407.531739, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[407.585478, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[407.639217, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[407.692957, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[407.746696, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[407.800435, "o", "                    raise ValueError(na_msg)\r\n"]
[407.854174, "o", "                return False\r\n"]
[407.907913, "o", "            return True\r\n"]
[407.961652, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[408.015391, "o", "            return True\r\n"]
[408.06913, "o", "    elif isinstance(key, list):\r\n"]
[408.12287, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[408.176609, "o", "        if len(key) > 0:\r\n"]
[408.230348, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[408.284087, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[408.337826, "o", "                key = list(key)\r\n"]
[408.391565, "o", "            return lib.is_bool_list(key)\r\n"]
[408.445304, "o", "\r\n"]
[408.499043, "o", "    return False\r\n"]
[408.552783, "o", "\r\n"]
[408.606522, "o", "\r\n"]
[408.660261, "o", "def cast_scalar_indexer(val):\r\n"]
[408.714, "o", "    \"\"\"\r\n"]
[408.767739, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[408.821478, "o", "\r\n"]
[408.875217, "o", "    Parameters\r\n"]
[408.928957, "o", "    ----------\r\n"]
[408.982696, "o", "    val : scalar\r\n"]
[409.036435, "o", "\r\n"]
[409.090174, "o", "    Returns\r\n"]
[409.143913, "o", "    -------\r\n"]
[409.197652, "o", "    outval : scalar\r\n"]
[409.251391, "o", "    \"\"\"\r\n"]
[409.30513, "o", "    # assumes lib.is_scalar(val)\r\n"]
[409.35887, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[409.412609, "o", "        raise IndexError(\r\n"]
[409.466348, "o", "            # GH#34193\r\n"]
[409.520087, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[409.573826, "o", "            \"to an integer key instead.\"\r\n"]
[409.627565, "o", "        )\r\n"]
[409.681304, "o", "    return val\r\n"]
[409.735043, "o", "\r\n"]
[409.788783, "o", "\r\n"]
[409.842522, "o", "def not_none(*args):\r\n"]
[409.896261, "o", "    \"\"\"\r\n"]
[410.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[410.002, "i", "sed -n '80,140p' ../pandas/core/common.py\r"]
[410.004, "o", "sed -n '80,140p' ../pandas/core/common.py\r\n"]
[410.085742, "o", "\u001b[?2004l\r\n"]
[410.165484, "o", "    -------\r\n"]
[410.245226, "o", "    flattened : generator\r\n"]
[410.324968, "o", "    \"\"\"\r\n"]
[410.40471, "o", "    for element in line:\r\n"]
[410.484452, "o", "        if iterable_not_string(element):\r\n"]
[410.564194, "o", "            yield from flatten(element)\r\n"]
[410.643935, "o", "        else:\r\n"]
[410.723677, "o", "            yield element\r\n"]
[410.803419, "o", "\r\n"]
[410.883161, "o", "\r\n"]
[410.962903, "o", "def consensus_name_attr(objs):\r\n"]
[411.042645, "o", "    name = objs[0].name\r\n"]
[411.122387, "o", "    for obj in objs[1:]:\r\n"]
[411.202129, "o", "        try:\r\n"]
[411.281871, "o", "            if obj.name != name:\r\n"]
[411.361613, "o", "                name = None\r\n"]
[411.441355, "o", "        except ValueError:\r\n"]
[411.521097, "o", "            name = None\r\n"]
[411.600839, "o", "    return name\r\n"]
[411.680581, "o", "\r\n"]
[411.760323, "o", "\r\n"]
[411.840065, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[411.919806, "o", "    \"\"\"\r\n"]
[411.999548, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[412.07929, "o", "\r\n"]
[412.159032, "o", "    Parameters\r\n"]
[412.238774, "o", "    ----------\r\n"]
[412.318516, "o", "    key : Any\r\n"]
[412.398258, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[412.478, "o", "        All other types are not considered a boolean indexer.\r\n"]
[412.557742, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[412.637484, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[412.717226, "o", "\r\n"]
[412.796968, "o", "    Returns\r\n"]
[412.87671, "o", "    -------\r\n"]
[412.956452, "o", "    bool\r\n"]
[413.036194, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[413.115935, "o", "\r\n"]
[413.195677, "o", "    Raises\r\n"]
[413.275419, "o", "    ------\r\n"]
[413.355161, "o", "    ValueError\r\n"]
[413.434903, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[413.514645, "o", "        and contains missing values.\r\n"]
[413.594387, "o", "\r\n"]
[413.674129, "o", "    See Also\r\n"]
[413.753871, "o", "    --------\r\n"]
[413.833613, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[413.913355, "o", "        and convert to an ndarray.\r\n"]
[413.993097, "o", "    \"\"\"\r\n"]
[414.072839, "o", "    if isinstance(\r\n"]
[414.152581, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[414.232323, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[414.312065, "o", "        if key.dtype == np.object_:\r\n"]
[414.391806, "o", "            key_array = np.asarray(key)\r\n"]
[414.471548, "o", "\r\n"]
[414.55129, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[414.631032, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[414.710774, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[414.790516, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[414.870258, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[415.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[415.002, "i", "sed -n '100,170p' ../pandas/core/common.py\r"]
[415.004, "o", "sed -n '100,170p' ../pandas/core/common.py\r\n"]
[415.074667, "o", "\u001b[?2004l\r\n"]
[415.143333, "o", "\r\n"]
[415.212, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[415.280667, "o", "    \"\"\"\r\n"]
[415.349333, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[415.418, "o", "\r\n"]
[415.486667, "o", "    Parameters\r\n"]
[415.555333, "o", "    ----------\r\n"]
[415.624, "o", "    key : Any\r\n"]
[415.692667, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[415.761333, "o", "        All other types are not considered a boolean indexer.\r\n"]
[415.83, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[415.898667, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[415.967333, "o", "\r\n"]
[416.036, "o", "    Returns\r\n"]
[416.104667, "o", "    -------\r\n"]
[416.173333, "o", "    bool\r\n"]
[416.242, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[416.310667, "o", "\r\n"]
[416.379333, "o", "    Raises\r\n"]
[416.448, "o", "    ------\r\n"]
[416.516667, "o", "    ValueError\r\n"]
[416.585333, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[416.654, "o", "        and contains missing values.\r\n"]
[416.722667, "o", "\r\n"]
[416.791333, "o", "    See Also\r\n"]
[416.86, "o", "    --------\r\n"]
[416.928667, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[416.997333, "o", "        and convert to an ndarray.\r\n"]
[417.066, "o", "    \"\"\"\r\n"]
[417.134667, "o", "    if isinstance(\r\n"]
[417.203333, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[417.272, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[417.340667, "o", "        if key.dtype == np.object_:\r\n"]
[417.409333, "o", "            key_array = np.asarray(key)\r\n"]
[417.478, "o", "\r\n"]
[417.546667, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[417.615333, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[417.684, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[417.752667, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[417.821333, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[417.89, "o", "                    raise ValueError(na_msg)\r\n"]
[417.958667, "o", "                return False\r\n"]
[418.027333, "o", "            return True\r\n"]
[418.096, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[418.164667, "o", "            return True\r\n"]
[418.233333, "o", "    elif isinstance(key, list):\r\n"]
[418.302, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[418.370667, "o", "        if len(key) > 0:\r\n"]
[418.439333, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[418.508, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[418.576667, "o", "                key = list(key)\r\n"]
[418.645333, "o", "            return lib.is_bool_list(key)\r\n"]
[418.714, "o", "\r\n"]
[418.782667, "o", "    return False\r\n"]
[418.851333, "o", "\r\n"]
[418.92, "o", "\r\n"]
[418.988667, "o", "def cast_scalar_indexer(val):\r\n"]
[419.057333, "o", "    \"\"\"\r\n"]
[419.126, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[419.194667, "o", "\r\n"]
[419.263333, "o", "    Parameters\r\n"]
[419.332, "o", "    ----------\r\n"]
[419.400667, "o", "    val : scalar\r\n"]
[419.469333, "o", "\r\n"]
[419.538, "o", "    Returns\r\n"]
[419.606667, "o", "    -------\r\n"]
[419.675333, "o", "    outval : scalar\r\n"]
[419.744, "o", "    \"\"\"\r\n"]
[419.812667, "o", "    # assumes lib.is_scalar(val)\r\n"]
[419.881333, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[420.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[420.002, "i", "sed -n '1,120p' ../pandas/core/common.py | sed -n '90,130p'\r"]
[420.004, "o", "sed -n '1,120p' ../pandas/core/common.py | sed -n '90,130p'\r\n"]
[420.1605, "o", "\u001b[?2004l\r\n"]
[420.315, "o", "def consensus_name_attr(objs):\r\n"]
[420.4695, "o", "    name = objs[0].name\r\n"]
[420.624, "o", "    for obj in objs[1:]:\r\n"]
[420.7785, "o", "        try:\r\n"]
[420.933, "o", "            if obj.name != name:\r\n"]
[421.0875, "o", "                name = None\r\n"]
[421.242, "o", "        except ValueError:\r\n"]
[421.3965, "o", "            name = None\r\n"]
[421.551, "o", "    return name\r\n"]
[421.7055, "o", "\r\n"]
[421.86, "o", "\r\n"]
[422.0145, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[422.169, "o", "    \"\"\"\r\n"]
[422.3235, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[422.478, "o", "\r\n"]
[422.6325, "o", "    Parameters\r\n"]
[422.787, "o", "    ----------\r\n"]
[422.9415, "o", "    key : Any\r\n"]
[423.096, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[423.2505, "o", "        All other types are not considered a boolean indexer.\r\n"]
[423.405, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[423.5595, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[423.714, "o", "\r\n"]
[423.8685, "o", "    Returns\r\n"]
[424.023, "o", "    -------\r\n"]
[424.1775, "o", "    bool\r\n"]
[424.332, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[424.4865, "o", "\r\n"]
[424.641, "o", "    Raises\r\n"]
[424.7955, "o", "    ------\r\n"]
[425.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[425.002, "i", "sed -n '90,200p' ../pandas/core/common.py\r"]
[425.004, "o", "sed -n '90,200p' ../pandas/core/common.py\r\n"]
[425.050143, "o", "\u001b[?2004l\r\n"]
[425.094286, "o", "def consensus_name_attr(objs):\r\n"]
[425.138429, "o", "    name = objs[0].name\r\n"]
[425.182571, "o", "    for obj in objs[1:]:\r\n"]
[425.226714, "o", "        try:\r\n"]
[425.270857, "o", "            if obj.name != name:\r\n"]
[425.315, "o", "                name = None\r\n"]
[425.359143, "o", "        except ValueError:\r\n"]
[425.403286, "o", "            name = None\r\n"]
[425.447429, "o", "    return name\r\n"]
[425.491571, "o", "\r\n"]
[425.535714, "o", "\r\n"]
[425.579857, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[425.624, "o", "    \"\"\"\r\n"]
[425.668143, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[425.712286, "o", "\r\n"]
[425.756429, "o", "    Parameters\r\n"]
[425.800571, "o", "    ----------\r\n"]
[425.844714, "o", "    key : Any\r\n"]
[425.888857, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[425.933, "o", "        All other types are not considered a boolean indexer.\r\n"]
[425.977143, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[426.021286, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[426.065429, "o", "\r\n"]
[426.109571, "o", "    Returns\r\n"]
[426.153714, "o", "    -------\r\n"]
[426.197857, "o", "    bool\r\n"]
[426.242, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[426.286143, "o", "\r\n"]
[426.330286, "o", "    Raises\r\n"]
[426.374429, "o", "    ------\r\n"]
[426.418571, "o", "    ValueError\r\n"]
[426.462714, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[426.506857, "o", "        and contains missing values.\r\n"]
[426.551, "o", "\r\n"]
[426.595143, "o", "    See Also\r\n"]
[426.639286, "o", "    --------\r\n"]
[426.683429, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[426.727571, "o", "        and convert to an ndarray.\r\n"]
[426.771714, "o", "    \"\"\"\r\n"]
[426.815857, "o", "    if isinstance(\r\n"]
[426.86, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[426.904143, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[426.948286, "o", "        if key.dtype == np.object_:\r\n"]
[426.992429, "o", "            key_array = np.asarray(key)\r\n"]
[427.036571, "o", "\r\n"]
[427.080714, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[427.124857, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[427.169, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[427.213143, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[427.257286, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[427.301429, "o", "                    raise ValueError(na_msg)\r\n"]
[427.345571, "o", "                return False\r\n"]
[427.389714, "o", "            return True\r\n"]
[427.433857, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[427.478, "o", "            return True\r\n"]
[427.522143, "o", "    elif isinstance(key, list):\r\n"]
[427.566286, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[427.610429, "o", "        if len(key) > 0:\r\n"]
[427.654571, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[427.698714, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[427.742857, "o", "                key = list(key)\r\n"]
[427.787, "o", "            return lib.is_bool_list(key)\r\n"]
[427.831143, "o", "\r\n"]
[427.875286, "o", "    return False\r\n"]
[427.919429, "o", "\r\n"]
[427.963571, "o", "\r\n"]
[428.007714, "o", "def cast_scalar_indexer(val):\r\n"]
[428.051857, "o", "    \"\"\"\r\n"]
[428.096, "o", "    Disallow indexing with a float key, even if that key is a round number.\r\n"]
[428.140143, "o", "\r\n"]
[428.184286, "o", "    Parameters\r\n"]
[428.228429, "o", "    ----------\r\n"]
[428.272571, "o", "    val : scalar\r\n"]
[428.316714, "o", "\r\n"]
[428.360857, "o", "    Returns\r\n"]
[428.405, "o", "    -------\r\n"]
[428.449143, "o", "    outval : scalar\r\n"]
[428.493286, "o", "    \"\"\"\r\n"]
[428.537429, "o", "    # assumes lib.is_scalar(val)\r\n"]
[428.581571, "o", "    if lib.is_float(val) and val.is_integer():\r\n"]
[428.625714, "o", "        raise IndexError(\r\n"]
[428.669857, "o", "            # GH#34193\r\n"]
[428.714, "o", "            \"Indexing with a float is no longer supported. Manually convert \"\r\n"]
[428.758143, "o", "            \"to an integer key instead.\"\r\n"]
[428.802286, "o", "        )\r\n"]
[428.846429, "o", "    return val\r\n"]
[428.890571, "o", "\r\n"]
[428.934714, "o", "\r\n"]
[428.978857, "o", "def not_none(*args):\r\n"]
[429.023, "o", "    \"\"\"\r\n"]
[429.067143, "o", "    Returns a generator consisting of the arguments that are not None.\r\n"]
[429.111286, "o", "    \"\"\"\r\n"]
[429.155429, "o", "    return (arg for arg in args if arg is not None)\r\n"]
[429.199571, "o", "\r\n"]
[429.243714, "o", "\r\n"]
[429.287857, "o", "def any_none(*args) -> bool:\r\n"]
[429.332, "o", "    \"\"\"\r\n"]
[429.376143, "o", "    Returns a boolean indicating if any argument is None.\r\n"]
[429.420286, "o", "    \"\"\"\r\n"]
[429.464429, "o", "    return any(arg is None for arg in args)\r\n"]
[429.508571, "o", "\r\n"]
[429.552714, "o", "\r\n"]
[429.596857, "o", "def all_none(*args) -> bool:\r\n"]
[429.641, "o", "    \"\"\"\r\n"]
[429.685143, "o", "    Returns a boolean indicating if all arguments are None.\r\n"]
[429.729286, "o", "    \"\"\"\r\n"]
[429.773429, "o", "    return all(arg is None for arg in args)\r\n"]
[429.817571, "o", "\r\n"]
[429.861714, "o", "\r\n"]
[429.905857, "o", "def any_not_none(*args) -> bool:\r\n"]
[430.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[430.002, "i", "sed -n '3925,4005p' ../pandas/core/frame.py\r"]
[430.004, "o", "sed -n '3925,4005p' ../pandas/core/frame.py\r\n"]
[430.066293, "o", "\u001b[?2004l\r\n"]
[430.126585, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[430.186878, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[430.247171, "o", "                return data._get_item(key)\r\n"]
[430.307463, "o", "\r\n"]
[430.367756, "o", "        return data\r\n"]
[430.428049, "o", "\r\n"]
[430.488341, "o", "    def _getitem_bool_array(self, key):\r\n"]
[430.548634, "o", "        # also raises Exception if object array with NA values\r\n"]
[430.608927, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[430.66922, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[430.729512, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[430.789805, "o", "        # with all other indexing behavior\r\n"]
[430.850098, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[430.91039, "o", "            warnings.warn(\r\n"]
[430.970683, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[431.030976, "o", "                UserWarning,\r\n"]
[431.091268, "o", "                stacklevel=find_stack_level(),\r\n"]
[431.151561, "o", "            )\r\n"]
[431.211854, "o", "        elif len(key) != len(self.index):\r\n"]
[431.272146, "o", "            raise ValueError(\r\n"]
[431.332439, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[431.392732, "o", "            )\r\n"]
[431.453024, "o", "\r\n"]
[431.513317, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[431.57361, "o", "        # be reindexed to match DataFrame rows\r\n"]
[431.633902, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[431.694195, "o", "\r\n"]
[431.754488, "o", "        if key.all():\r\n"]
[431.81478, "o", "            return self.copy(deep=False)\r\n"]
[431.875073, "o", "\r\n"]
[431.935366, "o", "        indexer = key.nonzero()[0]\r\n"]
[431.995659, "o", "        return self.take(indexer, axis=0)\r\n"]
[432.055951, "o", "\r\n"]
[432.116244, "o", "    def _getitem_multilevel(self, key):\r\n"]
[432.176537, "o", "        # self.columns is a MultiIndex\r\n"]
[432.236829, "o", "        loc = self.columns.get_loc(key)\r\n"]
[432.297122, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[432.357415, "o", "            new_columns = self.columns[loc]\r\n"]
[432.417707, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[432.478, "o", "            result = self.iloc[:, loc]\r\n"]
[432.538293, "o", "            result.columns = result_columns\r\n"]
[432.598585, "o", "\r\n"]
[432.658878, "o", "            # If there is only one column being returned, and its name is\r\n"]
[432.719171, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[432.779463, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[432.839756, "o", "            # and return the column as if the user had provided that empty\r\n"]
[432.900049, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[432.960341, "o", "            # implied empty string from its name.\r\n"]
[433.020634, "o", "            if len(result.columns) == 1:\r\n"]
[433.080927, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[433.14122, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[433.201512, "o", "                top = result.columns[0]\r\n"]
[433.261805, "o", "                if isinstance(top, tuple):\r\n"]
[433.322098, "o", "                    top = top[0]\r\n"]
[433.38239, "o", "                if top == \"\":\r\n"]
[433.442683, "o", "                    result = result[\"\"]\r\n"]
[433.502976, "o", "                    if isinstance(result, Series):\r\n"]
[433.563268, "o", "                        result = self._constructor_sliced(\r\n"]
[433.623561, "o", "                            result, index=self.index, name=key\r\n"]
[433.683854, "o", "                        )\r\n"]
[433.744146, "o", "\r\n"]
[433.804439, "o", "            return result\r\n"]
[433.864732, "o", "        else:\r\n"]
[433.925024, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[433.985317, "o", "            return self._ixs(loc, axis=1)\r\n"]
[434.04561, "o", "\r\n"]
[434.105902, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[434.166195, "o", "        \"\"\"\r\n"]
[434.226488, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[434.28678, "o", "\r\n"]
[434.347073, "o", "        Parameters\r\n"]
[434.407366, "o", "        ----------\r\n"]
[434.467659, "o", "        index : row label\r\n"]
[434.527951, "o", "        col : column label\r\n"]
[434.588244, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[434.648537, "o", "\r\n"]
[434.708829, "o", "        Returns\r\n"]
[434.769122, "o", "        -------\r\n"]
[434.829415, "o", "        scalar\r\n"]
[434.889707, "o", "\r\n"]
[435.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[435.002, "i", "sed -n '4005,4085p' ../pandas/core/frame.py\r"]
[435.004, "o", "sed -n '4005,4085p' ../pandas/core/frame.py\r\n"]
[435.066293, "o", "\u001b[?2004l\r\n"]
[435.126585, "o", "        Notes\r\n"]
[435.186878, "o", "        -----\r\n"]
[435.247171, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[435.307463, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[435.367756, "o", "        \"\"\"\r\n"]
[435.428049, "o", "        if takeable:\r\n"]
[435.488341, "o", "            series = self._ixs(col, axis=1)\r\n"]
[435.548634, "o", "            return series._values[index]\r\n"]
[435.608927, "o", "\r\n"]
[435.66922, "o", "        series = self._get_item(col)\r\n"]
[435.729512, "o", "        engine = self.index._engine\r\n"]
[435.789805, "o", "\r\n"]
[435.850098, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[435.91039, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[435.970683, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[436.030976, "o", "            # IntervalIndex: IntervalTree has no get_loc\r\n"]
[436.091268, "o", "            row = self.index.get_loc(index)\r\n"]
[436.151561, "o", "            return series._values[row]\r\n"]
[436.211854, "o", "\r\n"]
[436.272146, "o", "        # For MultiIndex going through engine effectively restricts us to\r\n"]
[436.332439, "o", "        #  same-length tuples; see test_get_set_value_no_partial_indexing\r\n"]
[436.392732, "o", "        loc = engine.get_loc(index)\r\n"]
[436.453024, "o", "        return series._values[loc]\r\n"]
[436.513317, "o", "\r\n"]
[436.57361, "o", "    def isetitem(self, loc, value) -> None:\r\n"]
[436.633902, "o", "        \"\"\"\r\n"]
[436.694195, "o", "        Set the given value in the column with position `loc`.\r\n"]
[436.754488, "o", "\r\n"]
[436.81478, "o", "        This is a positional analogue to ``__setitem__``.\r\n"]
[436.875073, "o", "\r\n"]
[436.935366, "o", "        Parameters\r\n"]
[436.995659, "o", "        ----------\r\n"]
[437.055951, "o", "        loc : int or sequence of ints\r\n"]
[437.116244, "o", "            Index position for the column.\r\n"]
[437.176537, "o", "        value : scalar or arraylike\r\n"]
[437.236829, "o", "            Value(s) for the column.\r\n"]
[437.297122, "o", "\r\n"]
[437.357415, "o", "        See Also\r\n"]
[437.417707, "o", "        --------\r\n"]
[437.478, "o", "        DataFrame.iloc : Purely integer-location based indexing for selection by\r\n"]
[437.538293, "o", "            position.\r\n"]
[437.598585, "o", "\r\n"]
[437.658878, "o", "        Notes\r\n"]
[437.719171, "o", "        -----\r\n"]
[437.779463, "o", "        ``frame.isetitem(loc, value)`` is an in-place method as it will\r\n"]
[437.839756, "o", "        modify the DataFrame in place (not returning a new object). In contrast to\r\n"]
[437.900049, "o", "        ``frame.iloc[:, i] = value`` which will try to update the existing values in\r\n"]
[437.960341, "o", "        place, ``frame.isetitem(loc, value)`` will not update the values of the column\r\n"]
[438.020634, "o", "        itself in place, it will instead insert a new array.\r\n"]
[438.080927, "o", "\r\n"]
[438.14122, "o", "        In cases where ``frame.columns`` is unique, this is equivalent to\r\n"]
[438.201512, "o", "        ``frame[frame.columns[i]] = value``.\r\n"]
[438.261805, "o", "\r\n"]
[438.322098, "o", "        Examples\r\n"]
[438.38239, "o", "        --------\r\n"]
[438.442683, "o", "        >>> df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\r\n"]
[438.502976, "o", "        >>> df.isetitem(1, [5, 6])\r\n"]
[438.563268, "o", "        >>> df\r\n"]
[438.623561, "o", "              A  B\r\n"]
[438.683854, "o", "        0     1  5\r\n"]
[438.744146, "o", "        1     2  6\r\n"]
[438.804439, "o", "        \"\"\"\r\n"]
[438.864732, "o", "        if isinstance(value, DataFrame):\r\n"]
[438.925024, "o", "            if is_integer(loc):\r\n"]
[438.985317, "o", "                loc = [loc]\r\n"]
[439.04561, "o", "\r\n"]
[439.105902, "o", "            if len(loc) != len(value.columns):\r\n"]
[439.166195, "o", "                raise ValueError(\r\n"]
[439.226488, "o", "                    f\"Got {len(loc)} positions but value has {len(value.columns)} \"\r\n"]
[439.28678, "o", "                    f\"columns.\"\r\n"]
[439.347073, "o", "                )\r\n"]
[439.407366, "o", "\r\n"]
[439.467659, "o", "            for i, idx in enumerate(loc):\r\n"]
[439.527951, "o", "                arraylike, refs = self._sanitize_column(value.iloc[:, i])\r\n"]
[439.588244, "o", "                self._iset_item_mgr(idx, arraylike, inplace=False, refs=refs)\r\n"]
[439.648537, "o", "            return\r\n"]
[439.708829, "o", "\r\n"]
[439.769122, "o", "        arraylike, refs = self._sanitize_column(value)\r\n"]
[439.829415, "o", "        self._iset_item_mgr(loc, arraylike, inplace=False, refs=refs)\r\n"]
[439.889707, "o", "\r\n"]
[440.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[440.002, "i", "grep -n \"is_bool_dtype\" ../pandas/core/indexing.py || true\r"]
[440.004, "o", "grep -n \"is_bool_dtype\" ../pandas/core/indexing.py || true\r\n"]
[441.242, "o", "\u001b[?2004l\r\n"]
[442.478, "o", "\u001b[32m\u001b[K36\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[Kis_bool_dtype\u001b[m\u001b[K,\r\n"]
[443.714, "o", "\u001b[32m\u001b[K1236\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            \u001b[01;31m\u001b[Kis_bool_dtype\u001b[m\u001b[K(ax.dtype)\r\n"]
[445.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[445.002, "i", "python - << 'PY'\r"]
[445.004, "o", "python - << 'PY'\r\n"]
[445.069385, "o", "\u001b[?2004l\r\n"]
[445.132769, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[445.196154, "o", "\u001b[?2004l\r\n"]
[445.259538, "o", "\u001b[?2004h> p = Path('../pandas/core/indexing.py')\r\n"]
[445.322923, "o", "\u001b[?2004l\r\n"]
[445.386308, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[445.449692, "o", "\u001b[?2004l\r\n"]
[445.513077, "o", "\u001b[?2004h> # Ensure is_bool_dtype is imported if not already\r\n"]
[445.576462, "o", "\u001b[?2004l\r\n"]
[445.639846, "o", "\u001b[?2004h> if 'is_bool_dtype' not in s.split('\\n',1)[0] and 'is_bool_dtype' not in s:\r\n"]
[445.703231, "o", "\u001b[?2004l\r\n"]
[445.766615, "o", "\u001b[?2004h>     # Try to add import from dtypes.common near other imports\r\n"]
[445.83, "o", "\u001b[?2004l\r\n"]
[445.893385, "o", "\u001b[?2004h>     if 'from pandas.core.dtypes.common import (' in s:\r\n"]
[445.956769, "o", "\u001b[?2004l\r\n"]
[446.020154, "o", "\u001b[?2004h>         s = s.replace(\r\n"]
[446.083538, "o", "\u001b[?2004l\r\n"]
[446.146923, "o", "\u001b[?2004h>             'from pandas.core.dtypes.common import (',\r\n"]
[446.210308, "o", "\u001b[?2004l\r\n"]
[446.273692, "o", "\u001b[?2004h>             'from pandas.core.dtypes.common import ('\r\n"]
[446.337077, "o", "\u001b[?2004l\r\n"]
[446.400462, "o", "\u001b[?2004h>         )\r\n"]
[446.463846, "o", "\u001b[?2004l\r\n"]
[446.527231, "o", "\u001b[?2004h>     # append is_bool_dtype to the import list if a block exists\r\n"]
[446.590615, "o", "\u001b[?2004l\r\n"]
[446.654, "o", "\u001b[?2004h>     s = s.replace(\r\n"]
[446.717385, "o", "\u001b[?2004l\r\n"]
[446.780769, "o", "\u001b[?2004h>         'from pandas.core.dtypes.common import (',\r\n"]
[446.844154, "o", "\u001b[?2004l\r\n"]
[446.907538, "o", "\u001b[?2004h>         'from pandas.core.dtypes.common import (\r\n"]
[446.970923, "o", "\u001b[?2004l\r\n"]
[447.034308, "o", "\u001b[?2004h>     is_bool_dtype,')\r\n"]
[447.097692, "o", "\u001b[?2004l\r\n"]
[447.161077, "o", "\u001b[?2004h> # Inject early-return for identical-index boolean Series\r\n"]
[447.224462, "o", "\u001b[?2004l\r\n"]
[447.287846, "o", "\u001b[?2004h> needle = (\r\n"]
[447.351231, "o", "\u001b[?2004l\r\n"]
[447.414615, "o", "\u001b[?2004h>     '    if isinstance(key, ABCSeries):\\n'\r\n"]
[447.478, "o", "\u001b[?2004l\r\n"]
[447.541385, "o", "\u001b[?2004h>     '        # Fastpath: avoid expensive equals() when index objects are identical\\n'\r\n"]
[447.604769, "o", "\u001b[?2004l\r\n"]
[447.668154, "o", "\u001b[?2004h>     '        if result.index is not index and not result.index.equals(index):\\n'\r\n"]
[447.731538, "o", "\u001b[?2004l\r\n"]
[447.794923, "o", "\u001b[?2004h> )\r\n"]
[447.858308, "o", "\u001b[?2004l\r\n"]
[447.921692, "o", "\u001b[?2004h> if needle in s:\r\n"]
[447.985077, "o", "\u001b[?2004l\r\n"]
[448.048462, "o", "\u001b[?2004h>     insert_after = needle + '            '\r\n"]
[448.111846, "o", "\u001b[?2004l\r\n"]
[448.175231, "o", "\u001b[?2004h>     # Find position just after the inner-if block ends; we add an else branch before the next top-level if\r\n"]
[448.238615, "o", "\u001b[?2004l\r\n"]
[448.302, "o", "\u001b[?2004h>     # Simpler: replace the subsequent block start to include an else branch\r\n"]
[448.365385, "o", "\u001b[?2004l\r\n"]
[448.428769, "o", "\u001b[?2004h>     s = s.replace(\r\n"]
[448.492154, "o", "\u001b[?2004l\r\n"]
[448.555538, "o", "\u001b[?2004h>         needle + '',\r\n"]
[448.618923, "o", "\u001b[?2004l\r\n"]
[448.682308, "o", "\u001b[?2004h>         needle + '        else:\\n            if not isinstance(result.dtype, ExtensionDtype):\\n                # If dtype is boolean numpy, we can return under\r\n"]
[448.745692, "o", "rlying array directly\\n                try:\\n                    from pandas.core.dtypes.common import is_bool_dtype\\n                except Exception:\\n        \r\n"]
[448.809077, "o", "             pass\\n                if hasattr(result, \"dtype\") and getattr(result, \"dtype\", None) is not None and getattr(result.dtype, \"kind\", None) == \"b\":\\n  \r\n"]
[448.872462, "o", "                   return result._values\\n'\r\n"]
[448.935846, "o", "\u001b[?2004l\r\n"]
[448.999231, "o", "\u001b[?2004h>     )\r\n"]
[449.062615, "o", "\u001b[?2004l\r\n"]
[449.126, "o", "\u001b[?2004h>     Path('../pandas/core/indexing.py').write_text(s)\r\n"]
[449.189385, "o", "\u001b[?2004l\r\n"]
[449.252769, "o", "\u001b[?2004h>     print('Patched early-return for boolean Series with identical index')\r\n"]
[449.316154, "o", "\u001b[?2004l\r\n"]
[449.379538, "o", "\u001b[?2004h> else:\r\n"]
[449.442923, "o", "\u001b[?2004l\r\n"]
[449.506308, "o", "\u001b[?2004h>     print('Patch anchor not found; skipping',)\r\n"]
[449.569692, "o", "\u001b[?2004l\r\n"]
[449.633077, "o", "\u001b[?2004h> PY\r\n"]
[449.696462, "o", "\u001b[?2004l\r\n"]
[449.759846, "o", "  File \"<stdin>\", line 15\r\n"]
[449.823231, "o", "    'from pandas.core.dtypes.common import (\r\n"]
[449.886615, "o", "    ^\r\n"]
[450.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[450.002, "i", "git diff -- ../pandas/core/indexing.py | sed -n '1,240p'\r"]
[450.004, "o", "git diff -- ../pandas/core/indexing.py | sed -n '1,240p'\r\n"]
[450.143333, "o", "\u001b[?2004l\r\n"]
[450.280667, "o", "diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py\r\n"]
[450.418, "o", "index b3ae53272c..8556b56555 100644\r\n"]
[450.555333, "o", "--- a/pandas/core/indexing.py\r\n"]
[450.692667, "o", "+++ b/pandas/core/indexing.py\r\n"]
[450.83, "o", "@@ -2636,20 +2636,22 @@ def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[450.967333, "o", "         If the index of the key is unalignable to index.\r\n"]
[451.104667, "o", "     \"\"\"\r\n"]
[451.242, "o", "     result = key\r\n"]
[451.379333, "o", "-    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[451.516667, "o", "-        indexer = result.index.get_indexer_for(index)\r\n"]
[451.654, "o", "-        if -1 in indexer:\r\n"]
[451.791333, "o", "-            raise IndexingError(\r\n"]
[451.928667, "o", "+    if isinstance(key, ABCSeries):\r\n"]
[452.066, "o", "+        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[452.203333, "o", "+        if result.index is not index and not result.index.equals(index):\r\n"]
[452.340667, "o", "+            indexer = result.index.get_indexer_for(index)\r\n"]
[452.478, "o", "+            if -1 in indexer:\r\n"]
[452.615333, "o", "+                raise IndexingError(\r\n"]
[452.752667, "o", "                 \"Unalignable boolean Series provided as \"\r\n"]
[452.89, "o", "                 \"indexer (index of the boolean Series and of \"\r\n"]
[453.027333, "o", "                 \"the indexed object do not match).\"\r\n"]
[453.164667, "o", "             )\r\n"]
[453.302, "o", " \r\n"]
[453.439333, "o", "-        result = result.take(indexer)\r\n"]
[453.576667, "o", "+            result = result.take(indexer)\r\n"]
[453.714, "o", " \r\n"]
[453.851333, "o", "-        # fall through for boolean\r\n"]
[453.988667, "o", "-        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[454.126, "o", "-            return result.astype(bool)._values\r\n"]
[454.263333, "o", "+            # fall through for boolean\r\n"]
[454.400667, "o", "+            if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[454.538, "o", "+                return result.astype(bool)._values\r\n"]
[454.675333, "o", " \r\n"]
[454.812667, "o", "     if is_object_dtype(key):\r\n"]
[455.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[455.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[455.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[455.418, "o", "\u001b[?2004l\r\n"]
[455.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[456.242, "o", "\u00b7 \u001b[0;32mRunning 7 total benchmarks (1 commits * 1 environments * 7 benchmarks)\u001b[0m\r\n"]
[456.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[457.066, "o", "[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_at--)\u001b[0m.......\r\n"]
[457.478, "o", "[57.14%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at\u001b[0m                                                                                                13.2\u00b10.4\u03bcs\r\n"]
[457.89, "o", "[64.29%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at_setitem\u001b[0m                                                                                        12.5\u00b10.3\u03bcs\r\n"]
[458.302, "o", "[71.43%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows\u001b[0m                                                                                       117\u00b10.8\u03bcs\r\n"]
[458.714, "o", "[78.57%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_boolean\u001b[0m                                                                               115\u00b10.8\u03bcs\r\n"]
[459.126, "o", "[85.71%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                165\u00b10.6\u03bcs\r\n"]
[459.538, "o", "[92.86%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_getitem_scalar\u001b[0m                                                                                    13.5\u00b10.2\u03bcs\r\n"]
[460.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[460.002, "i", "sed -n '2628,2660p' ../pandas/core/indexing.py\r"]
[460.004, "o", "sed -n '2628,2660p' ../pandas/core/indexing.py\r\n"]
[460.151412, "o", "\u001b[?2004l\r\n"]
[460.296824, "o", "    np.array\r\n"]
[460.442235, "o", "        Resulting key.\r\n"]
[460.587647, "o", "\r\n"]
[460.733059, "o", "    Raises\r\n"]
[460.878471, "o", "    ------\r\n"]
[461.023882, "o", "    IndexError\r\n"]
[461.169294, "o", "        If the key does not have the same length as index.\r\n"]
[461.314706, "o", "    IndexingError\r\n"]
[461.460118, "o", "        If the index of the key is unalignable to index.\r\n"]
[461.605529, "o", "    \"\"\"\r\n"]
[461.750941, "o", "    result = key\r\n"]
[461.896353, "o", "    if isinstance(key, ABCSeries):\r\n"]
[462.041765, "o", "        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[462.187176, "o", "        if result.index is not index and not result.index.equals(index):\r\n"]
[462.332588, "o", "            indexer = result.index.get_indexer_for(index)\r\n"]
[462.478, "o", "            if -1 in indexer:\r\n"]
[462.623412, "o", "                raise IndexingError(\r\n"]
[462.768824, "o", "                \"Unalignable boolean Series provided as \"\r\n"]
[462.914235, "o", "                \"indexer (index of the boolean Series and of \"\r\n"]
[463.059647, "o", "                \"the indexed object do not match).\"\r\n"]
[463.205059, "o", "            )\r\n"]
[463.350471, "o", "\r\n"]
[463.495882, "o", "            result = result.take(indexer)\r\n"]
[463.641294, "o", "\r\n"]
[463.786706, "o", "            # fall through for boolean\r\n"]
[463.932118, "o", "            if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[464.077529, "o", "                return result.astype(bool)._values\r\n"]
[464.222941, "o", "\r\n"]
[464.368353, "o", "    if is_object_dtype(key):\r\n"]
[464.513765, "o", "        # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[464.659176, "o", "        result = np.asarray(result, dtype=bool)\r\n"]
[464.804588, "o", "    elif not is_array_like(result):\r\n"]
[465.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[465.002, "i", "python - << 'PY'\r"]
[465.004, "o", "python - << 'PY'\r\n"]
[465.092737, "o", "\u001b[?2004l\r\n"]
[465.179474, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[465.266211, "o", "\u001b[?2004l\r\n"]
[465.352947, "o", "\u001b[?2004h> p = Path('../pandas/core/indexing.py')\r\n"]
[465.439684, "o", "\u001b[?2004l\r\n"]
[465.526421, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[465.613158, "o", "\u001b[?2004l\r\n"]
[465.699895, "o", "\u001b[?2004h> anchor = (\r\n"]
[465.786632, "o", "\u001b[?2004l\r\n"]
[465.873368, "o", "\u001b[?2004h>     '        if result.index is not index and not result.index.equals(index):\\n'\r\n"]
[465.960105, "o", "\u001b[?2004l\r\n"]
[466.046842, "o", "\u001b[?2004h>     '            indexer = result.index.get_indexer_for(index)\\n'\r\n"]
[466.133579, "o", "\u001b[?2004l\r\n"]
[466.220316, "o", "\u001b[?2004h>     '            if -1 in indexer:\\n'\r\n"]
[466.307053, "o", "\u001b[?2004l\r\n"]
[466.393789, "o", "\u001b[?2004h>     '                raise IndexingError('\\n)\r\n"]
[466.480526, "o", "\u001b[?2004l\r\n"]
[466.567263, "o", "\u001b[?2004h> # We will insert an else-block after the existing fastpath block that returns early\r\n"]
[466.654, "o", "\u001b[?2004l\r\n"]
[466.740737, "o", "\u001b[?2004h> insertion_point = s.find('\\n    if is_object_dtype(key):')\r\n"]
[466.827474, "o", "\u001b[?2004l\r\n"]
[466.914211, "o", "\u001b[?2004h> block_start = s.rfind('if isinstance(key, ABCSeries):', 0, insertion_point)\r\n"]
[467.000947, "o", "\u001b[?2004l\r\n"]
[467.087684, "o", "\u001b[?2004h> inner_if = s.find('if result.index is not index and not result.index.equals(index):', block_start, insertion_point)\r\n"]
[467.174421, "o", "\u001b[?2004l\r\n"]
[467.261158, "o", "\u001b[?2004h> block_end = s.find('\\n\\n    if is_object_dtype(key):', block_start)\r\n"]
[467.347895, "o", "\u001b[?2004l\r\n"]
[467.434632, "o", "\u001b[?2004h> if inner_if != -1 and block_end != -1:\r\n"]
[467.521368, "o", "\u001b[?2004l\r\n"]
[467.608105, "o", "\u001b[?2004h>     # Craft the else branch to return early when index objects are identical\r\n"]
[467.694842, "o", "\u001b[?2004l\r\n"]
[467.781579, "o", "\u001b[?2004h>     insertion = (\r\n"]
[467.868316, "o", "\u001b[?2004l\r\n"]
[467.955053, "o", "\u001b[?2004h>         '\\n        else:\\n'\r\n"]
[468.041789, "o", "\u001b[?2004l\r\n"]
[468.128526, "o", "\u001b[?2004h>         '            if not isinstance(result.dtype, ExtensionDtype):\\n'\r\n"]
[468.215263, "o", "\u001b[?2004l\r\n"]
[468.302, "o", "\u001b[?2004h>         '                return result.astype(bool)._values\\n'\r\n"]
[468.388737, "o", "\u001b[?2004l\r\n"]
[468.475474, "o", "\u001b[?2004h>     )\r\n"]
[468.562211, "o", "\u001b[?2004l\r\n"]
[468.648947, "o", "\u001b[?2004h>     s = s.replace('\\n\\n    if is_object_dtype(key):', insertion + '\\n    if is_object_dtype(key):', 1)\r\n"]
[468.735684, "o", "\u001b[?2004l\r\n"]
[468.822421, "o", "\u001b[?2004h>     p.write_text(s)\r\n"]
[468.909158, "o", "\u001b[?2004l\r\n"]
[468.995895, "o", "\u001b[?2004h>     print('Added else early-return for identical-index boolean Series')\r\n"]
[469.082632, "o", "\u001b[?2004l\r\n"]
[469.169368, "o", "\u001b[?2004h> else:\r\n"]
[469.256105, "o", "\u001b[?2004l\r\n"]
[469.342842, "o", "\u001b[?2004h>     print('Could not locate patch positions; no changes made')\r\n"]
[469.429579, "o", "\u001b[?2004l\r\n"]
[469.516316, "o", "\u001b[?2004h> PY\r\n"]
[469.603053, "o", "\u001b[?2004l\r\n"]
[469.689789, "o", "  File \"<stdin>\", line 8\r\n"]
[469.776526, "o", "    '                raise IndexingError('\\n)\r\n"]
[469.863263, "o", "                                           ^\r\n"]
[470.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[470.002, "i", "git diff -- ../pandas/core/indexing.py | sed -n '1,240p'\r"]
[470.004, "o", "git diff -- ../pandas/core/indexing.py | sed -n '1,240p'\r\n"]
[470.143333, "o", "\u001b[?2004l\r\n"]
[470.280667, "o", "diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py\r\n"]
[470.418, "o", "index b3ae53272c..8556b56555 100644\r\n"]
[470.555333, "o", "--- a/pandas/core/indexing.py\r\n"]
[470.692667, "o", "+++ b/pandas/core/indexing.py\r\n"]
[470.83, "o", "@@ -2636,20 +2636,22 @@ def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[470.967333, "o", "         If the index of the key is unalignable to index.\r\n"]
[471.104667, "o", "     \"\"\"\r\n"]
[471.242, "o", "     result = key\r\n"]
[471.379333, "o", "-    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[471.516667, "o", "-        indexer = result.index.get_indexer_for(index)\r\n"]
[471.654, "o", "-        if -1 in indexer:\r\n"]
[471.791333, "o", "-            raise IndexingError(\r\n"]
[471.928667, "o", "+    if isinstance(key, ABCSeries):\r\n"]
[472.066, "o", "+        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[472.203333, "o", "+        if result.index is not index and not result.index.equals(index):\r\n"]
[472.340667, "o", "+            indexer = result.index.get_indexer_for(index)\r\n"]
[472.478, "o", "+            if -1 in indexer:\r\n"]
[472.615333, "o", "+                raise IndexingError(\r\n"]
[472.752667, "o", "                 \"Unalignable boolean Series provided as \"\r\n"]
[472.89, "o", "                 \"indexer (index of the boolean Series and of \"\r\n"]
[473.027333, "o", "                 \"the indexed object do not match).\"\r\n"]
[473.164667, "o", "             )\r\n"]
[473.302, "o", " \r\n"]
[473.439333, "o", "-        result = result.take(indexer)\r\n"]
[473.576667, "o", "+            result = result.take(indexer)\r\n"]
[473.714, "o", " \r\n"]
[473.851333, "o", "-        # fall through for boolean\r\n"]
[473.988667, "o", "-        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[474.126, "o", "-            return result.astype(bool)._values\r\n"]
[474.263333, "o", "+            # fall through for boolean\r\n"]
[474.400667, "o", "+            if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[474.538, "o", "+                return result.astype(bool)._values\r\n"]
[474.675333, "o", " \r\n"]
[474.812667, "o", "     if is_object_dtype(key):\r\n"]
[475.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[475.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[475.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[475.418, "o", "\u001b[?2004l\r\n"]
[475.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[476.242, "o", "\u00b7 \u001b[0;32mRunning 7 total benchmarks (1 commits * 1 environments * 7 benchmarks)\u001b[0m\r\n"]
[476.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[477.066, "o", "[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_at--)\u001b[0m.......\r\n"]
[477.478, "o", "[57.14%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at\u001b[0m                                                                                                12.2\u00b10.5\u03bcs\r\n"]
[477.89, "o", "[64.29%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at_setitem\u001b[0m                                                                                        12.9\u00b10.2\u03bcs\r\n"]
[478.302, "o", "[71.43%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows\u001b[0m                                                                                       118\u00b10.8\u03bcs\r\n"]
[478.714, "o", "[78.57%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_boolean\u001b[0m                                                                                 115\u00b11\u03bcs\r\n"]
[479.126, "o", "[85.71%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                  165\u00b14\u03bcs\r\n"]
[479.538, "o", "[92.86%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_getitem_scalar\u001b[0m                                                                                    12.7\u00b10.2\u03bcs\r\n"]
[480.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[480.002, "i", "sed -n '2628,2675p' ../pandas/core/indexing.py\r"]
[480.004, "o", "sed -n '2628,2675p' ../pandas/core/indexing.py\r\n"]
[480.106898, "o", "\u001b[?2004l\r\n"]
[480.207796, "o", "    np.array\r\n"]
[480.308694, "o", "        Resulting key.\r\n"]
[480.409592, "o", "\r\n"]
[480.51049, "o", "    Raises\r\n"]
[480.611388, "o", "    ------\r\n"]
[480.712286, "o", "    IndexError\r\n"]
[480.813184, "o", "        If the key does not have the same length as index.\r\n"]
[480.914082, "o", "    IndexingError\r\n"]
[481.01498, "o", "        If the index of the key is unalignable to index.\r\n"]
[481.115878, "o", "    \"\"\"\r\n"]
[481.216776, "o", "    result = key\r\n"]
[481.317673, "o", "    if isinstance(key, ABCSeries):\r\n"]
[481.418571, "o", "        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[481.519469, "o", "        if result.index is not index and not result.index.equals(index):\r\n"]
[481.620367, "o", "            indexer = result.index.get_indexer_for(index)\r\n"]
[481.721265, "o", "            if -1 in indexer:\r\n"]
[481.822163, "o", "                raise IndexingError(\r\n"]
[481.923061, "o", "                \"Unalignable boolean Series provided as \"\r\n"]
[482.023959, "o", "                \"indexer (index of the boolean Series and of \"\r\n"]
[482.124857, "o", "                \"the indexed object do not match).\"\r\n"]
[482.225755, "o", "            )\r\n"]
[482.326653, "o", "\r\n"]
[482.427551, "o", "            result = result.take(indexer)\r\n"]
[482.528449, "o", "\r\n"]
[482.629347, "o", "            # fall through for boolean\r\n"]
[482.730245, "o", "            if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[482.831143, "o", "                return result.astype(bool)._values\r\n"]
[482.932041, "o", "\r\n"]
[483.032939, "o", "    if is_object_dtype(key):\r\n"]
[483.133837, "o", "        # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[483.234735, "o", "        result = np.asarray(result, dtype=bool)\r\n"]
[483.335633, "o", "    elif not is_array_like(result):\r\n"]
[483.436531, "o", "        # GH 33924\r\n"]
[483.537429, "o", "        # key may contain nan elements, check_array_indexer needs bool array\r\n"]
[483.638327, "o", "        result = pd_array(result, dtype=bool)\r\n"]
[483.739224, "o", "    return check_array_indexer(index, result)\r\n"]
[483.840122, "o", "\r\n"]
[483.94102, "o", "\r\n"]
[484.041918, "o", "def convert_missing_indexer(indexer):\r\n"]
[484.142816, "o", "    \"\"\"\r\n"]
[484.243714, "o", "    Reverse convert a missing indexer, which is a dict\r\n"]
[484.344612, "o", "    return the scalar indexer and a boolean indicating if we converted\r\n"]
[484.44551, "o", "    \"\"\"\r\n"]
[484.546408, "o", "    if isinstance(indexer, dict):\r\n"]
[484.647306, "o", "        # a missing key (but not a tuple indexer)\r\n"]
[484.748204, "o", "        indexer = indexer[\"key\"]\r\n"]
[484.849102, "o", "\r\n"]
[485.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[485.002, "i", "python - << 'PY'\r"]
[485.004, "o", "python - << 'PY'\r\n"]
[485.1296, "o", "\u001b[?2004l\r\n"]
[485.2532, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[485.3768, "o", "\u001b[?2004l\r\n"]
[485.5004, "o", "\u001b[?2004h> p = Path('../pandas/core/indexing.py')\r\n"]
[485.624, "o", "\u001b[?2004l\r\n"]
[485.7476, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[485.8712, "o", "\u001b[?2004l\r\n"]
[485.9948, "o", "\u001b[?2004h> needle = '\\n    if is_object_dtype(key):'\r\n"]
[486.1184, "o", "\u001b[?2004l\r\n"]
[486.242, "o", "\u001b[?2004h> abc_start = s.rfind('if isinstance(key, ABCSeries):', 0, s.find(needle))\r\n"]
[486.3656, "o", "\u001b[?2004l\r\n"]
[486.4892, "o", "\u001b[?2004h> inner_if = s.find('if result.index is not index and not result.index.equals(index):', abc_start)\r\n"]
[486.6128, "o", "\u001b[?2004l\r\n"]
[486.7364, "o", "\u001b[?2004h> # Only insert if the else block is not already present\r\n"]
[486.86, "o", "\u001b[?2004l\r\n"]
[486.9836, "o", "\u001b[?2004h> if abc_start != -1 and inner_if != -1 and 'else:\\n            if not isinstance(result.dtype, ExtensionDtype):' not in s[abc_start:s.find(needle)]:\r\n"]
[487.1072, "o", "\u001b[?2004l\r\n"]
[487.2308, "o", "\u001b[?2004h>     insertion = (\r\n"]
[487.3544, "o", "\u001b[?2004l\r\n"]
[487.478, "o", "\u001b[?2004h>         '        else:\\n'\r\n"]
[487.6016, "o", "\u001b[?2004l\r\n"]
[487.7252, "o", "\u001b[?2004h>         '            if not isinstance(result.dtype, ExtensionDtype):\\n'\r\n"]
[487.8488, "o", "\u001b[?2004l\r\n"]
[487.9724, "o", "\u001b[?2004h>         '                return result.astype(bool)._values\\n\\n'\r\n"]
[488.096, "o", "\u001b[?2004l\r\n"]
[488.2196, "o", "\u001b[?2004h>     )\r\n"]
[488.3432, "o", "\u001b[?2004l\r\n"]
[488.4668, "o", "\u001b[?2004h>     s = s.replace(needle, insertion + '    if is_object_dtype(key):', 1)\r\n"]
[488.5904, "o", "\u001b[?2004l\r\n"]
[488.714, "o", "\u001b[?2004h>     p.write_text(s)\r\n"]
[488.8376, "o", "\u001b[?2004l\r\n"]
[488.9612, "o", "\u001b[?2004h>     print('Inserted early-return else block for identical-index boolean Series')\r\n"]
[489.0848, "o", "\u001b[?2004l\r\n"]
[489.2084, "o", "\u001b[?2004h> else:\r\n"]
[489.332, "o", "\u001b[?2004l\r\n"]
[489.4556, "o", "\u001b[?2004h>     print('Skip insertion (not found or already present)')\r\n"]
[489.5792, "o", "\u001b[?2004l\r\n"]
[489.7028, "o", "\u001b[?2004h> PY\r\n"]
[489.8264, "o", "\u001b[?2004l\r\n"]
[490.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[490.002, "i", "git diff -- ../pandas/core/indexing.py | sed -n '1,240p'\r"]
[490.004, "o", "git diff -- ../pandas/core/indexing.py | sed -n '1,240p'\r\n"]
[490.132769, "o", "\u001b[?2004l\r\n"]
[490.259538, "o", "diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py\r\n"]
[490.386308, "o", "index b3ae53272c..8fde1a2f4a 100644\r\n"]
[490.513077, "o", "--- a/pandas/core/indexing.py\r\n"]
[490.639846, "o", "+++ b/pandas/core/indexing.py\r\n"]
[490.766615, "o", "@@ -2636,20 +2636,25 @@ def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[490.893385, "o", "         If the index of the key is unalignable to index.\r\n"]
[491.020154, "o", "     \"\"\"\r\n"]
[491.146923, "o", "     result = key\r\n"]
[491.273692, "o", "-    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[491.400462, "o", "-        indexer = result.index.get_indexer_for(index)\r\n"]
[491.527231, "o", "-        if -1 in indexer:\r\n"]
[491.654, "o", "-            raise IndexingError(\r\n"]
[491.780769, "o", "+    if isinstance(key, ABCSeries):\r\n"]
[491.907538, "o", "+        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[492.034308, "o", "+        if result.index is not index and not result.index.equals(index):\r\n"]
[492.161077, "o", "+            indexer = result.index.get_indexer_for(index)\r\n"]
[492.287846, "o", "+            if -1 in indexer:\r\n"]
[492.414615, "o", "+                raise IndexingError(\r\n"]
[492.541385, "o", "                 \"Unalignable boolean Series provided as \"\r\n"]
[492.668154, "o", "                 \"indexer (index of the boolean Series and of \"\r\n"]
[492.794923, "o", "                 \"the indexed object do not match).\"\r\n"]
[492.921692, "o", "             )\r\n"]
[493.048462, "o", " \r\n"]
[493.175231, "o", "-        result = result.take(indexer)\r\n"]
[493.302, "o", "+            result = result.take(indexer)\r\n"]
[493.428769, "o", " \r\n"]
[493.555538, "o", "-        # fall through for boolean\r\n"]
[493.682308, "o", "-        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[493.809077, "o", "-            return result.astype(bool)._values\r\n"]
[493.935846, "o", "+            # fall through for boolean\r\n"]
[494.062615, "o", "+            if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[494.189385, "o", "+                return result.astype(bool)._values\r\n"]
[494.316154, "o", "+        else:\r\n"]
[494.442923, "o", "+            if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[494.569692, "o", "+                return result.astype(bool)._values\r\n"]
[494.696462, "o", " \r\n"]
[494.823231, "o", "     if is_object_dtype(key):\r\n"]
[495.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[495.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[495.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[495.418, "o", "\u001b[?2004l\r\n"]
[495.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[496.242, "o", "\u00b7 \u001b[0;32mRunning 7 total benchmarks (1 commits * 1 environments * 7 benchmarks)\u001b[0m\r\n"]
[496.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[497.066, "o", "[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_at--)\u001b[0m.......\r\n"]
[497.478, "o", "[57.14%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at\u001b[0m                                                                                                12.7\u00b10.3\u03bcs\r\n"]
[497.89, "o", "[64.29%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at_setitem\u001b[0m                                                                                        12.9\u00b10.2\u03bcs\r\n"]
[498.302, "o", "[71.43%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows\u001b[0m                                                                                         128\u00b12\u03bcs\r\n"]
[498.714, "o", "[78.57%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_boolean\u001b[0m                                                                                 115\u00b11\u03bcs\r\n"]
[499.126, "o", "[85.71%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                  193\u00b11\u03bcs\r\n"]
[499.538, "o", "[92.86%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_getitem_scalar\u001b[0m                                                                                    13.4\u00b10.1\u03bcs\r\n"]
[500.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[500.002, "i", "python - << 'PY'\r"]
[500.004, "o", "python - << 'PY'\r\n"]
[500.1605, "o", "\u001b[?2004l\r\n"]
[500.315, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[500.4695, "o", "\u001b[?2004l\r\n"]
[500.624, "o", "\u001b[?2004h> p = Path('../pandas/core/indexing.py')\r\n"]
[500.7785, "o", "\u001b[?2004l\r\n"]
[500.933, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[501.0875, "o", "\u001b[?2004l\r\n"]
[501.242, "o", "\u001b[?2004h> added = (\r\n"]
[501.3965, "o", "\u001b[?2004l\r\n"]
[501.551, "o", "\u001b[?2004h>     '        else:\\n'\r\n"]
[501.7055, "o", "\u001b[?2004l\r\n"]
[501.86, "o", "\u001b[?2004h>     '            if not isinstance(result.dtype, ExtensionDtype):\\n'\r\n"]
[502.0145, "o", "\u001b[?2004l\r\n"]
[502.169, "o", "\u001b[?2004h>     '                return result.astype(bool)._values\\n\\n'\r\n"]
[502.3235, "o", "\u001b[?2004l\r\n"]
[502.478, "o", "\u001b[?2004h> )\r\n"]
[502.6325, "o", "\u001b[?2004l\r\n"]
[502.787, "o", "\u001b[?2004h> if added in s:\r\n"]
[502.9415, "o", "\u001b[?2004l\r\n"]
[503.096, "o", "\u001b[?2004h>     s = s.replace(added, '')\r\n"]
[503.2505, "o", "\u001b[?2004l\r\n"]
[503.405, "o", "\u001b[?2004h>     p.write_text(s)\r\n"]
[503.5595, "o", "\u001b[?2004l\r\n"]
[503.714, "o", "\u001b[?2004h>     print('Reverted early-return else block')\r\n"]
[503.8685, "o", "\u001b[?2004l\r\n"]
[504.023, "o", "\u001b[?2004h> else:\r\n"]
[504.1775, "o", "\u001b[?2004l\r\n"]
[504.332, "o", "\u001b[?2004h>     print('Early-return else block not found; nothing to revert')\r\n"]
[504.4865, "o", "\u001b[?2004l\r\n"]
[504.641, "o", "\u001b[?2004h> PY\r\n"]
[504.7955, "o", "\u001b[?2004l\r\n"]
[505.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[505.002, "i", "git diff -- ../pandas/core/indexing.py | sed -n '1,200p'\r"]
[505.004, "o", "git diff -- ../pandas/core/indexing.py | sed -n '1,200p'\r\n"]
[505.139622, "o", "\u001b[?2004l\r\n"]
[505.273243, "o", "diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py\r\n"]
[505.406865, "o", "index b3ae53272c..4d114175c9 100644\r\n"]
[505.540486, "o", "--- a/pandas/core/indexing.py\r\n"]
[505.674108, "o", "+++ b/pandas/core/indexing.py\r\n"]
[505.80773, "o", "@@ -2636,21 +2636,22 @@ def check_bool_indexer(index: Index, key) -> np.ndarray:\r\n"]
[505.941351, "o", "         If the index of the key is unalignable to index.\r\n"]
[506.074973, "o", "     \"\"\"\r\n"]
[506.208595, "o", "     result = key\r\n"]
[506.342216, "o", "-    if isinstance(key, ABCSeries) and not key.index.equals(index):\r\n"]
[506.475838, "o", "-        indexer = result.index.get_indexer_for(index)\r\n"]
[506.609459, "o", "-        if -1 in indexer:\r\n"]
[506.743081, "o", "-            raise IndexingError(\r\n"]
[506.876703, "o", "+    if isinstance(key, ABCSeries):\r\n"]
[507.010324, "o", "+        # Fastpath: avoid expensive equals() when index objects are identical\r\n"]
[507.143946, "o", "+        if result.index is not index and not result.index.equals(index):\r\n"]
[507.277568, "o", "+            indexer = result.index.get_indexer_for(index)\r\n"]
[507.411189, "o", "+            if -1 in indexer:\r\n"]
[507.544811, "o", "+                raise IndexingError(\r\n"]
[507.678432, "o", "                 \"Unalignable boolean Series provided as \"\r\n"]
[507.812054, "o", "                 \"indexer (index of the boolean Series and of \"\r\n"]
[507.945676, "o", "                 \"the indexed object do not match).\"\r\n"]
[508.079297, "o", "             )\r\n"]
[508.212919, "o", " \r\n"]
[508.346541, "o", "-        result = result.take(indexer)\r\n"]
[508.480162, "o", "-\r\n"]
[508.613784, "o", "-        # fall through for boolean\r\n"]
[508.747405, "o", "-        if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[508.881027, "o", "-            return result.astype(bool)._values\r\n"]
[509.014649, "o", "+            result = result.take(indexer)\r\n"]
[509.14827, "o", " \r\n"]
[509.281892, "o", "+            # fall through for boolean\r\n"]
[509.415514, "o", "+            if not isinstance(result.dtype, ExtensionDtype):\r\n"]
[509.549135, "o", "+                return result.astype(bool)._values\r\n"]
[509.682757, "o", "     if is_object_dtype(key):\r\n"]
[509.816378, "o", "         # key might be object-dtype bool, check_array_indexer needs bool array\r\n"]
[510.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[510.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[510.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[510.418, "o", "\u001b[?2004l\r\n"]
[510.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[511.242, "o", "\u00b7 \u001b[0;32mRunning 7 total benchmarks (1 commits * 1 environments * 7 benchmarks)\u001b[0m\r\n"]
[511.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[512.066, "o", "[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_at--)\u001b[0m.......\r\n"]
[512.478, "o", "[57.14%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at\u001b[0m                                                                                                12.8\u00b10.6\u03bcs\r\n"]
[512.89, "o", "[64.29%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at_setitem\u001b[0m                                                                                        13.5\u00b10.8\u03bcs\r\n"]
[513.302, "o", "[71.43%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows\u001b[0m                                                                                       116\u00b10.9\u03bcs\r\n"]
[513.714, "o", "[78.57%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_boolean\u001b[0m                                                                               114\u00b10.7\u03bcs\r\n"]
[514.126, "o", "[85.71%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                  169\u00b12\u03bcs\r\n"]
[514.538, "o", "[92.86%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_getitem_scalar\u001b[0m                                                                                    13.4\u00b10.2\u03bcs\r\n"]
[515.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[515.002, "i", "sed -n '/def is_bool_indexer(/,/^def /p' ../pandas/core/common.py\r"]
[515.004, "o", "sed -n '/def is_bool_indexer(/,/^def /p' ../pandas/core/common.py\r\n"]
[515.092737, "o", "\u001b[?2004l\r\n"]
[515.179474, "o", "def is_bool_indexer(key: Any) -> bool:\r\n"]
[515.266211, "o", "    \"\"\"\r\n"]
[515.352947, "o", "    Check whether `key` is a valid boolean indexer.\r\n"]
[515.439684, "o", "\r\n"]
[515.526421, "o", "    Parameters\r\n"]
[515.613158, "o", "    ----------\r\n"]
[515.699895, "o", "    key : Any\r\n"]
[515.786632, "o", "        Only list-likes may be considered boolean indexers.\r\n"]
[515.873368, "o", "        All other types are not considered a boolean indexer.\r\n"]
[515.960105, "o", "        For array-like input, boolean ndarrays or ExtensionArrays\r\n"]
[516.046842, "o", "        with ``_is_boolean`` set are considered boolean indexers.\r\n"]
[516.133579, "o", "\r\n"]
[516.220316, "o", "    Returns\r\n"]
[516.307053, "o", "    -------\r\n"]
[516.393789, "o", "    bool\r\n"]
[516.480526, "o", "        Whether `key` is a valid boolean indexer.\r\n"]
[516.567263, "o", "\r\n"]
[516.654, "o", "    Raises\r\n"]
[516.740737, "o", "    ------\r\n"]
[516.827474, "o", "    ValueError\r\n"]
[516.914211, "o", "        When the array is an object-dtype ndarray or ExtensionArray\r\n"]
[517.000947, "o", "        and contains missing values.\r\n"]
[517.087684, "o", "\r\n"]
[517.174421, "o", "    See Also\r\n"]
[517.261158, "o", "    --------\r\n"]
[517.347895, "o", "    check_array_indexer : Check that `key` is a valid array to index,\r\n"]
[517.434632, "o", "        and convert to an ndarray.\r\n"]
[517.521368, "o", "    \"\"\"\r\n"]
[517.608105, "o", "    if isinstance(\r\n"]
[517.694842, "o", "        key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\r\n"]
[517.781579, "o", "    ) and not isinstance(key, ABCMultiIndex):\r\n"]
[517.868316, "o", "        if key.dtype == np.object_:\r\n"]
[517.955053, "o", "            key_array = np.asarray(key)\r\n"]
[518.041789, "o", "\r\n"]
[518.128526, "o", "            if not lib.is_bool_array(key_array):\r\n"]
[518.215263, "o", "                na_msg = \"Cannot mask with non-boolean array containing NA / NaN values\"\r\n"]
[518.302, "o", "                if lib.is_bool_array(key_array, skipna=True):\r\n"]
[518.388737, "o", "                    # Don't raise on e.g. [\"A\", \"B\", np.nan], see\r\n"]
[518.475474, "o", "                    #  test_loc_getitem_list_of_labels_categoricalindex_with_na\r\n"]
[518.562211, "o", "                    raise ValueError(na_msg)\r\n"]
[518.648947, "o", "                return False\r\n"]
[518.735684, "o", "            return True\r\n"]
[518.822421, "o", "        elif is_bool_dtype(key.dtype):\r\n"]
[518.909158, "o", "            return True\r\n"]
[518.995895, "o", "    elif isinstance(key, list):\r\n"]
[519.082632, "o", "        # check if np.array(key).dtype would be bool\r\n"]
[519.169368, "o", "        if len(key) > 0:\r\n"]
[519.256105, "o", "            if type(key) is not list:  # noqa: E721\r\n"]
[519.342842, "o", "                # GH#42461 cython will raise TypeError if we pass a subclass\r\n"]
[519.429579, "o", "                key = list(key)\r\n"]
[519.516316, "o", "            return lib.is_bool_list(key)\r\n"]
[519.603053, "o", "\r\n"]
[519.689789, "o", "    return False\r\n"]
[519.776526, "o", "\r\n"]
[519.863263, "o", "\r\n"]
[520.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[520.002, "i", "sed -n '3920,4020p' ../pandas/core/frame.py\r"]
[520.004, "o", "sed -n '3920,4020p' ../pandas/core/frame.py\r\n"]
[520.054471, "o", "\u001b[?2004l\r\n"]
[520.102941, "o", "        if is_single_key:\r\n"]
[520.151412, "o", "            # What does looking for a single key in a non-unique index return?\r\n"]
[520.199882, "o", "            # The behavior is inconsistent. It returns a Series, except when\r\n"]
[520.248353, "o", "            # - the key itself is repeated (test on data.shape, #9519), or\r\n"]
[520.296824, "o", "            # - we have a MultiIndex on columns (test on self.columns, #21309)\r\n"]
[520.345294, "o", "            if data.shape[1] == 1 and not isinstance(self.columns, MultiIndex):\r\n"]
[520.393765, "o", "                # GH#26490 using data[key] can cause RecursionError\r\n"]
[520.442235, "o", "                return data._get_item(key)\r\n"]
[520.490706, "o", "\r\n"]
[520.539176, "o", "        return data\r\n"]
[520.587647, "o", "\r\n"]
[520.636118, "o", "    def _getitem_bool_array(self, key):\r\n"]
[520.684588, "o", "        # also raises Exception if object array with NA values\r\n"]
[520.733059, "o", "        # warning here just in case -- previously __setitem__ was\r\n"]
[520.781529, "o", "        # reindexing but __getitem__ was not; it seems more reasonable to\r\n"]
[520.83, "o", "        # go with the __setitem__ behavior since that is more consistent\r\n"]
[520.878471, "o", "        # with all other indexing behavior\r\n"]
[520.926941, "o", "        if isinstance(key, Series) and not key.index.equals(self.index):\r\n"]
[520.975412, "o", "            warnings.warn(\r\n"]
[521.023882, "o", "                \"Boolean Series key will be reindexed to match DataFrame index.\",\r\n"]
[521.072353, "o", "                UserWarning,\r\n"]
[521.120824, "o", "                stacklevel=find_stack_level(),\r\n"]
[521.169294, "o", "            )\r\n"]
[521.217765, "o", "        elif len(key) != len(self.index):\r\n"]
[521.266235, "o", "            raise ValueError(\r\n"]
[521.314706, "o", "                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\r\n"]
[521.363176, "o", "            )\r\n"]
[521.411647, "o", "\r\n"]
[521.460118, "o", "        # check_bool_indexer will throw exception if Series key cannot\r\n"]
[521.508588, "o", "        # be reindexed to match DataFrame rows\r\n"]
[521.557059, "o", "        key = check_bool_indexer(self.index, key)\r\n"]
[521.605529, "o", "\r\n"]
[521.654, "o", "        if key.all():\r\n"]
[521.702471, "o", "            return self.copy(deep=False)\r\n"]
[521.750941, "o", "\r\n"]
[521.799412, "o", "        indexer = key.nonzero()[0]\r\n"]
[521.847882, "o", "        return self.take(indexer, axis=0)\r\n"]
[521.896353, "o", "\r\n"]
[521.944824, "o", "    def _getitem_multilevel(self, key):\r\n"]
[521.993294, "o", "        # self.columns is a MultiIndex\r\n"]
[522.041765, "o", "        loc = self.columns.get_loc(key)\r\n"]
[522.090235, "o", "        if isinstance(loc, (slice, np.ndarray)):\r\n"]
[522.138706, "o", "            new_columns = self.columns[loc]\r\n"]
[522.187176, "o", "            result_columns = maybe_droplevels(new_columns, key)\r\n"]
[522.235647, "o", "            result = self.iloc[:, loc]\r\n"]
[522.284118, "o", "            result.columns = result_columns\r\n"]
[522.332588, "o", "\r\n"]
[522.381059, "o", "            # If there is only one column being returned, and its name is\r\n"]
[522.429529, "o", "            # either an empty string, or a tuple with an empty string as its\r\n"]
[522.478, "o", "            # first element, then treat the empty string as a placeholder\r\n"]
[522.526471, "o", "            # and return the column as if the user had provided that empty\r\n"]
[522.574941, "o", "            # string in the key. If the result is a Series, exclude the\r\n"]
[522.623412, "o", "            # implied empty string from its name.\r\n"]
[522.671882, "o", "            if len(result.columns) == 1:\r\n"]
[522.720353, "o", "                # e.g. test_frame_getitem_multicolumn_empty_level,\r\n"]
[522.768824, "o", "                #  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice\r\n"]
[522.817294, "o", "                top = result.columns[0]\r\n"]
[522.865765, "o", "                if isinstance(top, tuple):\r\n"]
[522.914235, "o", "                    top = top[0]\r\n"]
[522.962706, "o", "                if top == \"\":\r\n"]
[523.011176, "o", "                    result = result[\"\"]\r\n"]
[523.059647, "o", "                    if isinstance(result, Series):\r\n"]
[523.108118, "o", "                        result = self._constructor_sliced(\r\n"]
[523.156588, "o", "                            result, index=self.index, name=key\r\n"]
[523.205059, "o", "                        )\r\n"]
[523.253529, "o", "\r\n"]
[523.302, "o", "            return result\r\n"]
[523.350471, "o", "        else:\r\n"]
[523.398941, "o", "            # loc is neither a slice nor ndarray, so must be an int\r\n"]
[523.447412, "o", "            return self._ixs(loc, axis=1)\r\n"]
[523.495882, "o", "\r\n"]
[523.544353, "o", "    def _get_value(self, index, col, takeable: bool = False) -> Scalar:\r\n"]
[523.592824, "o", "        \"\"\"\r\n"]
[523.641294, "o", "        Quickly retrieve single value at passed column and index.\r\n"]
[523.689765, "o", "\r\n"]
[523.738235, "o", "        Parameters\r\n"]
[523.786706, "o", "        ----------\r\n"]
[523.835176, "o", "        index : row label\r\n"]
[523.883647, "o", "        col : column label\r\n"]
[523.932118, "o", "        takeable : interpret the index/col as indexers, default False\r\n"]
[523.980588, "o", "\r\n"]
[524.029059, "o", "        Returns\r\n"]
[524.077529, "o", "        -------\r\n"]
[524.126, "o", "        scalar\r\n"]
[524.174471, "o", "\r\n"]
[524.222941, "o", "        Notes\r\n"]
[524.271412, "o", "        -----\r\n"]
[524.319882, "o", "        Assumes that both `self.index._index_as_unique` and\r\n"]
[524.368353, "o", "        `self.columns._index_as_unique`; Caller is responsible for checking.\r\n"]
[524.416824, "o", "        \"\"\"\r\n"]
[524.465294, "o", "        if takeable:\r\n"]
[524.513765, "o", "            series = self._ixs(col, axis=1)\r\n"]
[524.562235, "o", "            return series._values[index]\r\n"]
[524.610706, "o", "\r\n"]
[524.659176, "o", "        series = self._get_item(col)\r\n"]
[524.707647, "o", "        engine = self.index._engine\r\n"]
[524.756118, "o", "\r\n"]
[524.804588, "o", "        if not isinstance(self.index, MultiIndex):\r\n"]
[524.853059, "o", "            # CategoricalIndex: Trying to use the engine fastpath may give incorrect\r\n"]
[524.901529, "o", "            #  results if our categories are integers that dont match our codes\r\n"]
[525.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[525.002, "i", "git add ../pandas/core/indexing.py && git commit -m \"perf(indexing): fast-path in check_bool_indexer to s\r"]
[525.004, "o", "git add ../pandas/core/indexing.py && git commit -m \"perf(indexing): fast-path in check_bool_indexer to s\r\n"]
[525.3356, "o", "skip Index.equals when index objects are identical for boolean Series masks\"\r\n"]
[525.6652, "o", "\u001b[?2004l\r\n"]
[525.9948, "o", "Author identity unknown\r\n"]
[526.3244, "o", "\r\n"]
[526.654, "o", "*** Please tell me who you are.\r\n"]
[526.9836, "o", "\r\n"]
[527.3132, "o", "Run\r\n"]
[527.6428, "o", "\r\n"]
[527.9724, "o", "  git config --global user.email \"you@example.com\"\r\n"]
[528.302, "o", "  git config --global user.name \"Your Name\"\r\n"]
[528.6316, "o", "\r\n"]
[528.9612, "o", "to set your account's default identity.\r\n"]
[529.2908, "o", "Omit --global to set the identity only in this repository.\r\n"]
[529.6204, "o", "\r\n"]
[530.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[530.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[530.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[530.418, "o", "\u001b[?2004l\r\n"]
[530.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[531.242, "o", "\u00b7 \u001b[0;32mRunning 7 total benchmarks (1 commits * 1 environments * 7 benchmarks)\u001b[0m\r\n"]
[531.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[532.066, "o", "[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_at--)\u001b[0m.......\r\n"]
[532.478, "o", "[57.14%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at\u001b[0m                                                                                                12.9\u00b10.1\u03bcs\r\n"]
[532.89, "o", "[64.29%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at_setitem\u001b[0m                                                                                        12.9\u00b10.5\u03bcs\r\n"]
[533.302, "o", "[71.43%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows\u001b[0m                                                                                         117\u00b12\u03bcs\r\n"]
[533.714, "o", "[78.57%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_boolean\u001b[0m                                                                               116\u00b10.8\u03bcs\r\n"]
[534.126, "o", "[85.71%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                  172\u00b11\u03bcs\r\n"]
[534.538, "o", "[92.86%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_getitem_scalar\u001b[0m                                                                                    13.9\u00b10.1\u03bcs\r\n"]
[535.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[535.002, "i", "python - << 'PY'\r"]
[535.004, "o", "python - << 'PY'\r\n"]
[535.196154, "o", "\u001b[?2004l\r\n"]
[535.386308, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[535.576462, "o", "\u001b[?2004l\r\n"]
[535.766615, "o", "\u001b[?2004h> p = Path('../pandas/core/frame.py')\r\n"]
[535.956769, "o", "\u001b[?2004l\r\n"]
[536.146923, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[536.337077, "o", "\u001b[?2004l\r\n"]
[536.527231, "o", "\u001b[?2004h> old = '        if isinstance(key, Series) and not key.index.equals(self.index):'\r\n"]
[536.717385, "o", "\u001b[?2004l\r\n"]
[536.907538, "o", "\u001b[?2004h> new = '        if isinstance(key, Series) and (key.index is not self.index) and not key.index.equals(self.index):'\r\n"]
[537.097692, "o", "\u001b[?2004l\r\n"]
[537.287846, "o", "\u001b[?2004h> if old in s:\r\n"]
[537.478, "o", "\u001b[?2004l\r\n"]
[537.668154, "o", "\u001b[?2004h>     s = s.replace(old, new)\r\n"]
[537.858308, "o", "\u001b[?2004l\r\n"]
[538.048462, "o", "\u001b[?2004h>     p.write_text(s)\r\n"]
[538.238615, "o", "\u001b[?2004l\r\n"]
[538.428769, "o", "\u001b[?2004h>     print('Patched DataFrame._getitem_bool_array to avoid unnecessary equals on identical index objects')\r\n"]
[538.618923, "o", "\u001b[?2004l\r\n"]
[538.809077, "o", "\u001b[?2004h> else:\r\n"]
[538.999231, "o", "\u001b[?2004l\r\n"]
[539.189385, "o", "\u001b[?2004h>     print('Pattern not found; no changes made')\r\n"]
[539.379538, "o", "\u001b[?2004l\r\n"]
[539.569692, "o", "\u001b[?2004h> PY\r\n"]
[539.759846, "o", "\u001b[?2004l\r\n"]
[540.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[540.002, "i", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r"]
[540.004, "o", "asv run --python=same --bench=\"indexing.DataFrameStringIndexing.*\"\r\n"]
[540.418, "o", "\u001b[?2004l\r\n"]
[540.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[541.242, "o", "\u00b7 \u001b[0;32mRunning 7 total benchmarks (1 commits * 1 environments * 7 benchmarks)\u001b[0m\r\n"]
[541.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.10_bin_python3.10\u001b[0m\r\n"]
[542.066, "o", "[ 7.14%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (indexing.DataFrameStringIndexing.time_at--)\u001b[0m.......\r\n"]
[542.478, "o", "[57.14%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at\u001b[0m                                                                                                12.9\u00b10.4\u03bcs\r\n"]
[542.89, "o", "[64.29%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_at_setitem\u001b[0m                                                                                        12.3\u00b10.6\u03bcs\r\n"]
[543.302, "o", "[71.43%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows\u001b[0m                                                                                         120\u00b11\u03bcs\r\n"]
[543.714, "o", "[78.57%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_boolean\u001b[0m                                                                                 119\u00b11\u03bcs\r\n"]
[544.126, "o", "[85.71%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_boolean_rows_object\u001b[0m                                                                                  173\u00b14\u03bcs\r\n"]
[544.538, "o", "[92.86%] \u00b7\u00b7\u00b7 \u001b[0;39mindexing.DataFrameStringIndexing.time_getitem_scalar\u001b[0m                                                                                    13.3\u00b10.3\u03bcs\r\n"]
[545.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[545.002, "i", "git status -sb\r"]
[545.004, "o", "git status -sb\r\n"]
[546.242, "o", "\u001b[?2004l\r\n"]
[547.478, "o", "## \u001b[32mmain\u001b[m\r\n"]
[548.714, "o", " \u001b[31mM\u001b[m ../pandas/core/frame.py\r\n"]
[550.0, "o", "(asv_3.10) root@a3191d0fdab3:/workspace/repo/asv_bench# "]
[550.002, "i", "\u001b[?2004l\r"]
[550.004, "o", "\u001b[?2004l\r\n"]
[552.478, "o", "\r\n"]
