{"version": 2, "width": 160, "height": 40, "timestamp": 1762942247, "env": {"SHELL": "/bin/bash", "TERM": "screen"}}
[0.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[0.002, "i", "asciinema rec --stdin /logs/agent.cast\r"]
[0.004, "o", "asciinema rec --stdin /logs/agent.cast\r\n"]
[0.006, "o", "\u001b[?2004l\r\n\u001b[0;31masciinema: /logs/agent.cast already exists, aborting\u001b[0m\r\n\u001b[0;31masciinema: use --overwrite option if you want to overwrite existing recording\u001b[0m\r\n\u001b[0;31masciinema: use --append option if you want to append to existing recording\u001b[0m\r\n"]
[5.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[5.002, "i", "clear\r"]
[5.004, "o", "clear\r\n"]
[5.006, "o", "\u001b[?2004l\r\n\u001b[H\u001b[J\r\n"]
[10.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[10.002, "i", "ls -la\r"]
[10.004, "o", "ls -la\r\n"]
[10.006, "o", "\u001b[?2004l\r\ntotal 208\r\ndrwxr-xr-x 1 root root  4096 Oct  1 18:15 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 15 17:10 \u001b[01;34m..\u001b[0m\r\ndrwxr-xr-x 2 root root  4096 Sep 12 21:44 \u001b[01;34m.circleci\u001b[0m\r\n-rw-r--r-- 1 root root  1021 Sep 12 21:44 .devcontainer.json\r\ndrwxr-xr-x 1 root root  4096 Oct  1 18:15 \u001b[01;34m.git\u001b[0m\r\n-rw-r--r-- 1 root root   229 Sep 12 21:44 .gitattributes\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34m.github\u001b[0m\r\n-rw-r--r-- 1 root root  1740 Sep 12 21:44 .gitignore\r\n-rw-r--r-- 1 root root  2322 Sep 12 21:44 .gitpod.yml\r\n-rw-r--r-- 1 root root   761 Sep 12 21:44 .libcst.codemod.yaml\r\n-rw-r--r-- 1 root root   109 Sep 12 21:44 .pep8speaks.yml\r\n-rw-r--r-- 1 root root 16108 Sep 12 21:44 .pre-commit-config.yaml\r\n-rw-r--r-- 1 root root  2284 Sep 12 21:44 AUTHORS.md\r\n-rw-r--r-- 1 root root   372 Sep 12 21:44 CITATION.cff\r\n-rw-r--r-- 1 root root   369 Sep 12 21:44 Dockerfile\r\n-rw-r--r-- 1 root root  1634 Sep 12 21:44 LICENSE\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mLICENSES\u001b[0m\r\n-rw-r--r-- 1 root root  1228 Sep 12 21:44 MANIFEST.in\r\n-rw-r--r-- 1 root root 10387 Sep 12 21:44 README.md\r\n-rw-r--r-- 1 root root   246 Sep 12 21:44 RELEASE.md\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34masv_bench\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mci\u001b[0m\r\n-rw-r--r-- 1 root root   256 Sep 12 21:41 codecov.yml\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mdoc\u001b[0m\r\n-rw-r--r-- 1 root root  2116 Sep 12 21:44 environment.yml\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mgitpod\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 13 21:55 \u001b[01;34mpandas\u001b[0m\r\n-rw-r--r-- 1 root root 15980 Sep 12 21:44 pyproject.toml\r\n-rw-r--r-- 1 root root  4429 Sep 12 21:44 pyright_reportGeneralTypeIssues.json\r\n-rw-r--r-- 1 root root  1103 Sep 12 21:44 requirements-dev.txt\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mscripts\u001b[0m\r\n-rw-r--r-- 1 root root  2095 Sep 12 21:44 setup.cfg\r\n-rwxr-xr-x 1 root root 21965 Sep 12 21:44 \u001b[01;32msetup.py\u001b[0m\r\ndrwxr-xr-x 2 root root  4096 Sep 12 21:41 \u001b[01;34mtypings\u001b[0m\r\ndrwxr-xr-x 1 root root  4096 Sep 12 21:44 \u001b[01;34mweb\u001b[0m\r\n"]
[15.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[15.002, "i", "ls -la asv.conf.json .asv\r"]
[15.004, "o", "ls -la asv.conf.json .asv\r\n"]
[15.006, "o", "\u001b[?2004l\r\nls: cannot access 'asv.conf.json': No such file or directory\r\nls: cannot access '.asv': No such file or directory\r\n"]
[20.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[20.002, "i", "grep -RIl \"class .*Groupby\" -n . || true\r"]
[20.004, "o", "grep -RIl \"class .*Groupby\" -n . || true\r\n"]
[20.006, "o", "\u001b[?2004l\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_period.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_numpy.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_arrow.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/base/groupby.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_interval.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_string.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_datetime.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/decimal/test_decimal.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/json/test_json.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_boolean.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_integer.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/extension/test_floating.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/tests/plotting/frame/test_frame_groupby.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/core/window/rolling.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/core/window/expanding.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/core/window/ewm.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/core/indexers/objects.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./pandas/core/resample.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./asv_bench/benchmarks/rolling.py\u001b[m\u001b[K\r\n\u001b[35m\u001b[K./asv_bench/benchmarks/gil.py\u001b[m\u001b[K\r\n"]
[25.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[25.002, "i", "grep -RIn \"rolling.Groupby\" -n . || true\r"]
[25.004, "o", "grep -RIn \"rolling.Groupby\" -n . || true\r\n"]
[25.006, "o", "\u001b[?2004l\r\n"]
[30.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[30.002, "i", "rg -n \"Groupby|rolling\" asv* **/bench* 2>/dev/null || true\r"]
[30.004, "o", "rg -n \"Groupby|rolling\" asv* **/bench* 2>/dev/null || true\r\n"]
[30.006, "o", "\u001b[?2004l\r\n"]
[35.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[35.002, "i", "cat asv.conf.json\r"]
[35.004, "o", "cat asv.conf.json\r\n"]
[35.006, "o", "\u001b[?2004l\r\ncat: asv.conf.json: No such file or directory\r\n"]
[40.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[40.002, "i", "ls -la benchmarks asv_bench asv_benchmarks.txt 2>/dev/null || true\r"]
[40.004, "o", "ls -la benchmarks asv_bench asv_benchmarks.txt 2>/dev/null || true\r\n"]
[40.006, "o", "\u001b[?2004l\r\nasv_bench:\r\ntotal 24\r\ndrwxr-xr-x 1 root root 4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root 4096 Oct  1 18:15 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root 5217 Sep 12 21:44 asv.conf.json\r\ndrwxr-xr-x 1 root root 4096 Sep 12 21:44 \u001b[01;34mbenchmarks\u001b[0m\r\n"]
[45.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[45.002, "i", "cat asv_benchmarks.txt 2>/dev/null || true\r"]
[45.004, "o", "cat asv_benchmarks.txt 2>/dev/null || true\r\n"]
[45.006, "o", "\u001b[?2004l\r\n"]
[50.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[50.002, "i", "asv run --python=same --bench=\"rolling.Groupby.*\"\r"]
[50.004, "o", "asv run --python=same --bench=\"rolling.Groupby.*\"\r\n"]
[50.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;31mNo `asv.conf` file found for valid extensions: ['.json', '.jsonc'].\u001b[0m\r\n"]
[55.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[55.002, "i", "sed -n '1,200p' asv_bench/asv.conf.json\r"]
[55.004, "o", "sed -n '1,200p' asv_bench/asv.conf.json\r\n"]
[55.006, "o", "\u001b[?2004l\r\n{\r\n    // The version of the config file format.  Do not change, unless\r\n    // you know what you are doing.\r\n    \"version\": 1,\r\n\r\n    // The name of the project being benchmarked\r\n    \"project\": \"pandas\",\r\n\r\n    // The project's homepage\r\n    \"project_url\": \"https://pandas.pydata.org/\",\r\n\r\n    // The URL of the source code repository for the project being\r\n    // benchmarked\r\n    \"repo\": \"..\",\r\n\r\n    // List of branches to benchmark. If not provided, defaults to \"master\"\r\n    // (for git) or \"default\" (for mercurial).\r\n    \"branches\": [\"main\"],\r\n\r\n    // The tool to use to create environments.  May be \"conda\",\r\n    // \"virtualenv\" or other value depending on the plugins in use.\r\n    // If missing or the empty string, the tool will be automatically\r\n    // determined by looking for tools on the PATH environment\r\n    // variable.\r\n    \"environment_type\": \"conda\",\r\n\r\n    // the base URL to show a commit for the project.\r\n    \"show_commit_url\": \"https://github.com/pandas-dev/pandas/commit/\",\r\n\r\n    // The Pythons you'd like to test against.  If not provided, defaults\r\n    // to the current version of Python used to run `asv`.\r\n    \"pythons\": [\"3.8\"],\r\n\r\n    // The matrix of dependencies to test.  Each key is the name of a\r\n    // package (in PyPI) and the values are version numbers.  An empty\r\n    // list or empty string indicates to just test against the default\r\n    // (latest) version. null indicates that the package is to not be\r\n    // installed. If the package to be tested is only available from\r\n    // PyPi, and the 'environment_type' is conda, then you can preface\r\n    // the package name by 'pip+', and the package will be installed via\r\n    // pip (with all the conda available packages installed first,\r\n    // followed by the pip installed packages).\r\n    \"matrix\": {\r\n        \"numpy\": [],\r\n        \"Cython\": [\"0.29.32\"],\r\n        \"matplotlib\": [],\r\n        \"sqlalchemy\": [],\r\n        \"scipy\": [],\r\n        \"numba\": [],\r\n        \"numexpr\": [],\r\n        \"pytables\": [null, \"\"],  // platform dependent, see excludes below\r\n        \"pyarrow\": [],\r\n        \"tables\": [null, \"\"],\r\n        \"openpyxl\": [],\r\n        \"xlsxwriter\": [],\r\n        \"xlrd\": [],\r\n        \"odfpy\": [],\r\n        \"jinja2\": [],\r\n    },\r\n    \"conda_channels\": [\"conda-forge\"],\r\n    // Combinations of libraries/python versions can be excluded/included\r\n    // from the set to test. Each entry is a dictionary containing additional\r\n    // key-value pairs to include/exclude.\r\n    //\r\n    // An exclude entry excludes entries where all values match. The\r\n    // values are regexps that should match the whole string.\r\n    //\r\n    // An include entry adds an environment. Only the packages listed\r\n    // are installed. The 'python' key is required. The exclude rules\r\n    // do not apply to includes.\r\n    //\r\n    // In addition to package names, the following keys are available:\r\n    //\r\n    // - python\r\n    //     Python version, as in the *pythons* variable above.\r\n    // - environment_type\r\n    //     Environment type, as above.\r\n    // - sys_platform\r\n    //     Platform, as in sys.platform. Possible values for the common\r\n    //     cases: 'linux2', 'win32', 'cygwin', 'darwin'.\r\n    \"exclude\": [\r\n        // On conda install pytables, otherwise tables\r\n        {\"environment_type\": \"conda\", \"tables\": \"\"},\r\n        {\"environment_type\": \"conda\", \"pytables\": null},\r\n        {\"environment_type\": \"(?!conda).*\", \"tables\": null},\r\n        {\"environment_type\": \"(?!conda).*\", \"pytables\": \"\"},\r\n    ],\r\n    \"include\": [],\r\n\r\n    // The directory (relative to the current directory) that benchmarks are\r\n    // stored in.  If not provided, defaults to \"benchmarks\"\r\n    // \"benchmark_dir\": \"benchmarks\",\r\n\r\n    // The directory (relative to the current directory) to cache the Python\r\n    // environments in.  If not provided, defaults to \"env\"\r\n    // \"env_dir\": \"env\",\r\n\r\n    // The directory (relative to the current directory) that raw benchmark\r\n    // results are stored in.  If not provided, defaults to \"results\".\r\n    // \"results_dir\": \"results\",\r\n\r\n    // The directory (relative to the current directory) that the html tree\r\n    // should be written to.  If not provided, defaults to \"html\".\r\n    // \"html_dir\": \"html\",\r\n\r\n    // The number of characters to retain in the commit hashes.\r\n    // \"hash_length\": 8,\r\n\r\n    // `asv` will cache wheels of the recent builds in each\r\n    // environment, making them faster to install next time.  This is\r\n    // number of builds to keep, per environment.\r\n    \"build_cache_size\": 8,\r\n\r\n    // The commits after which the regression search in `asv publish`\r\n    // should start looking for regressions. Dictionary whose keys are\r\n    // regexps matching to benchmark names, and values corresponding to\r\n    // the commit (exclusive) after which to start looking for\r\n    // regressions.  The default is to start from the first commit\r\n    // with results. If the commit is `null`, regression detection is\r\n    // skipped for the matching benchmark.\r\n    //\r\n    \"regressions_first_commits\": {\r\n        \".*\": \"0409521665\"\r\n    },\r\n    \"regression_thresholds\": {\r\n    },\r\n    \"build_command\":\r\n    [\"python -m pip install versioneer[toml]\",\r\n     \"python setup.py build -j4\",\r\n     \"PIP_NO_BUILD_ISOLATION=false python -mpip wheel --no-deps --no-index -w {build_cache_dir} {build_dir}\"],\r\n}\r\n"]
[60.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[60.002, "i", "sed -n '1,200p' asv_bench/benchmarks/rolling.py\r"]
[60.004, "o", "sed -n '1,200p' asv_bench/benchmarks/rolling.py\r\n"]
[60.006, "o", "\u001b[?2004l\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nimport pandas as pd\r\n\r\n\r\nclass Methods:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [(\"rolling\", {\"window\": 10}), (\"rolling\", {\"window\": 1000}), (\"expanding\", {})],\r\n        [\"int\", \"float\"],\r\n        [\"median\", \"mean\", \"max\", \"min\", \"std\", \"count\", \"skew\", \"kurt\", \"sum\", \"sem\"],\r\n    )\r\n    param_names = [\"constructor\", \"window_kwargs\", \"dtype\", \"method\"]\r\n\r\n    def setup(self, constructor, window_kwargs, dtype, method):\r\n        N = 10**5\r\n        window, kwargs = window_kwargs\r\n        arr = (100 * np.random.random(N)).astype(dtype)\r\n        obj = getattr(pd, constructor)(arr)\r\n        self.window = getattr(obj, window)(**kwargs)\r\n\r\n    def time_method(self, constructor, window_kwargs, dtype, method):\r\n        getattr(self.window, method)()\r\n\r\n    def peakmem_method(self, constructor, window_kwargs, dtype, method):\r\n        getattr(self.window, method)()\r\n\r\n\r\nclass Apply:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [3, 300],\r\n        [\"int\", \"float\"],\r\n        [sum, np.sum, lambda x: np.sum(x) + 5],\r\n        [True, False],\r\n    )\r\n    param_names = [\"constructor\", \"window\", \"dtype\", \"function\", \"raw\"]\r\n\r\n    def setup(self, constructor, window, dtype, function, raw):\r\n        N = 10**3\r\n        arr = (100 * np.random.random(N)).astype(dtype)\r\n        self.roll = getattr(pd, constructor)(arr).rolling(window)\r\n\r\n    def time_rolling(self, constructor, window, dtype, function, raw):\r\n        self.roll.apply(function, raw=raw)\r\n\r\n\r\nclass NumbaEngineMethods:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [\"int\", \"float\"],\r\n        [(\"rolling\", {\"window\": 10}), (\"expanding\", {})],\r\n        [\"sum\", \"max\", \"min\", \"median\", \"mean\", \"var\", \"std\"],\r\n        [True, False],\r\n        [None, 100],\r\n    )\r\n    param_names = [\r\n        \"constructor\",\r\n        \"dtype\",\r\n        \"window_kwargs\",\r\n        \"method\",\r\n        \"parallel\",\r\n        \"cols\",\r\n    ]\r\n\r\n    def setup(self, constructor, dtype, window_kwargs, method, parallel, cols):\r\n        N = 10**3\r\n        window, kwargs = window_kwargs\r\n        shape = (N, cols) if cols is not None and constructor != \"Series\" else N\r\n        arr = (100 * np.random.random(shape)).astype(dtype)\r\n        data = getattr(pd, constructor)(arr)\r\n\r\n        # Warm the cache\r\n        with warnings.catch_warnings(record=True):\r\n            # Catch parallel=True not being applicable e.g. 1D data\r\n            self.window = getattr(data, window)(**kwargs)\r\n            getattr(self.window, method)(\r\n                engine=\"numba\", engine_kwargs={\"parallel\": parallel}\r\n            )\r\n\r\n    def test_method(self, constructor, dtype, window_kwargs, method, parallel, cols):\r\n        with warnings.catch_warnings(record=True):\r\n            getattr(self.window, method)(\r\n                engine=\"numba\", engine_kwargs={\"parallel\": parallel}\r\n            )\r\n\r\n\r\nclass NumbaEngineApply:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [\"int\", \"float\"],\r\n        [(\"rolling\", {\"window\": 10}), (\"expanding\", {})],\r\n        [np.sum, lambda x: np.sum(x) + 5],\r\n        [True, False],\r\n        [None, 100],\r\n    )\r\n    param_names = [\r\n        \"constructor\",\r\n        \"dtype\",\r\n        \"window_kwargs\",\r\n        \"function\",\r\n        \"parallel\",\r\n        \"cols\",\r\n    ]\r\n\r\n    def setup(self, constructor, dtype, window_kwargs, function, parallel, cols):\r\n        N = 10**3\r\n        window, kwargs = window_kwargs\r\n        shape = (N, cols) if cols is not None and constructor != \"Series\" else N\r\n        arr = (100 * np.random.random(shape)).astype(dtype)\r\n        data = getattr(pd, constructor)(arr)\r\n\r\n        # Warm the cache\r\n        with warnings.catch_warnings(record=True):\r\n            # Catch parallel=True not being applicable e.g. 1D data\r\n            self.window = getattr(data, window)(**kwargs)\r\n            self.window.apply(\r\n                function, raw=True, engine=\"numba\", engine_kwargs={\"parallel\": parallel}\r\n            )\r\n\r\n    def test_method(self, constructor, dtype, window_kwargs, function, parallel, cols):\r\n        with warnings.catch_warnings(record=True):\r\n            self.window.apply(\r\n                function, raw=True, engine=\"numba\", engine_kwargs={\"parallel\": parallel}\r\n            )\r\n\r\n\r\nclass EWMMethods:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [\r\n            ({\"halflife\": 10}, \"mean\"),\r\n            ({\"halflife\": 10}, \"std\"),\r\n            ({\"halflife\": 1000}, \"mean\"),\r\n            ({\"halflife\": 1000}, \"std\"),\r\n            (\r\n                {\r\n                    \"halflife\": \"1 Day\",\r\n                    \"times\": pd.date_range(\"1900\", periods=10**5, freq=\"23s\"),\r\n                },\r\n                \"mean\",\r\n            ),\r\n        ],\r\n        [\"int\", \"float\"],\r\n    )\r\n    param_names = [\"constructor\", \"kwargs_method\", \"dtype\"]\r\n\r\n    def setup(self, constructor, kwargs_method, dtype):\r\n        N = 10**5\r\n        kwargs, method = kwargs_method\r\n        arr = (100 * np.random.random(N)).astype(dtype)\r\n        self.method = method\r\n        self.ewm = getattr(pd, constructor)(arr).ewm(**kwargs)\r\n\r\n    def time_ewm(self, constructor, kwargs_method, dtype):\r\n        getattr(self.ewm, self.method)()\r\n\r\n\r\nclass VariableWindowMethods(Methods):\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [\"50s\", \"1h\", \"1d\"],\r\n        [\"int\", \"float\"],\r\n        [\"median\", \"mean\", \"max\", \"min\", \"std\", \"count\", \"skew\", \"kurt\", \"sum\", \"sem\"],\r\n    )\r\n    param_names = [\"constructor\", \"window\", \"dtype\", \"method\"]\r\n\r\n    def setup(self, constructor, window, dtype, method):\r\n        N = 10**5\r\n        arr = (100 * np.random.random(N)).astype(dtype)\r\n        index = pd.date_range(\"2017-01-01\", periods=N, freq=\"5s\")\r\n        self.window = getattr(pd, constructor)(arr, index=index).rolling(window)\r\n\r\n\r\nclass Pairwise:\r\n    params = (\r\n        [({\"window\": 10}, \"rolling\"), ({\"window\": 1000}, \"rolling\"), ({}, \"expanding\")],\r\n        [\"corr\", \"cov\"],\r\n        [True, False],\r\n    )\r\n    param_names = [\"window_kwargs\", \"method\", \"pairwise\"]\r\n\r\n    def setup(self, kwargs_window, method, pairwise):\r\n        N = 10**4\r\n        n_groups = 20\r\n        kwargs, window = kwargs_window\r\n        groups = [i for _ in range(N // n_groups) for i in range(n_groups)]\r\n        arr = np.random.random(N)\r\n        self.df = pd.DataFrame(arr)\r\n        self.window = getattr(self.df, window)(**kwargs)\r\n        self.window_group = getattr(\r\n            pd.DataFrame({\"A\": groups, \"B\": arr}).groupby(\"A\"), window\r\n        )(**kwargs)\r\n\r\n    def time_pairwise(self, kwargs_window, method, pairwise):\r\n        getattr(self.window, method)(self.df, pairwise=pairwise)\r\n\r\n    def time_groupby(self, kwargs_window, method, pairwise):\r\n"]
[65.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[65.002, "i", "asv run --config=asv_bench/asv.conf.json --python=same --bench=\"rolling.*Groupby.*\"\r"]
[65.004, "o", "asv run --config=asv_bench/asv.conf.json --python=same --bench=\"rolling.*Groupby.*\"\r\n"]
[65.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;31mConfig file asv_bench/asv.conf.json not found.\u001b[0m\r\n"]
[70.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[70.002, "i", "pwd\r"]
[70.004, "o", "pwd\r\n"]
[70.006, "o", "\u001b[?2004l\r\n/workspace/repo\r\n"]
[75.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[75.002, "i", "ls -la asv_bench/asv.conf.json\r"]
[75.004, "o", "ls -la asv_bench/asv.conf.json\r\n"]
[75.006, "o", "\u001b[?2004l\r\n-rw-r--r-- 1 root root 5217 Sep 12 21:44 asv_bench/asv.conf.json\r\n"]
[80.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo# "]
[80.002, "i", "cd asv_bench\r"]
[80.004, "o", "cd asv_bench\r\n"]
[80.006, "o", "\u001b[?2004l\r\n"]
[85.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[85.002, "i", "ls -la\r"]
[85.004, "o", "ls -la\r\n"]
[85.006, "o", "\u001b[?2004l\r\ntotal 24\r\ndrwxr-xr-x 1 root root 4096 Sep 12 21:44 \u001b[0m\u001b[01;34m.\u001b[0m\r\ndrwxr-xr-x 1 root root 4096 Oct  1 18:15 \u001b[01;34m..\u001b[0m\r\n-rw-r--r-- 1 root root 5217 Sep 12 21:44 asv.conf.json\r\ndrwxr-xr-x 1 root root 4096 Sep 12 21:44 \u001b[01;34mbenchmarks\u001b[0m\r\n"]
[90.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[90.002, "i", "rg -n \"Groupby\" benchmarks/rolling.py || true\r"]
[90.004, "o", "rg -n \"Groupby\" benchmarks/rolling.py || true\r\n"]
[90.006, "o", "\u001b[?2004l\r\n-bash: rg: command not found\r\n"]
[95.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[95.002, "i", "sed -n '1,240p' benchmarks/rolling.py\r"]
[95.004, "o", "sed -n '1,240p' benchmarks/rolling.py\r\n"]
[95.006, "o", "\u001b[?2004l\r\nimport warnings\r\n\r\nimport numpy as np\r\n\r\nimport pandas as pd\r\n\r\n\r\nclass Methods:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [(\"rolling\", {\"window\": 10}), (\"rolling\", {\"window\": 1000}), (\"expanding\", {})],\r\n        [\"int\", \"float\"],\r\n        [\"median\", \"mean\", \"max\", \"min\", \"std\", \"count\", \"skew\", \"kurt\", \"sum\", \"sem\"],\r\n    )\r\n    param_names = [\"constructor\", \"window_kwargs\", \"dtype\", \"method\"]\r\n\r\n    def setup(self, constructor, window_kwargs, dtype, method):\r\n        N = 10**5\r\n        window, kwargs = window_kwargs\r\n        arr = (100 * np.random.random(N)).astype(dtype)\r\n        obj = getattr(pd, constructor)(arr)\r\n        self.window = getattr(obj, window)(**kwargs)\r\n\r\n    def time_method(self, constructor, window_kwargs, dtype, method):\r\n        getattr(self.window, method)()\r\n\r\n    def peakmem_method(self, constructor, window_kwargs, dtype, method):\r\n        getattr(self.window, method)()\r\n\r\n\r\nclass Apply:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [3, 300],\r\n        [\"int\", \"float\"],\r\n        [sum, np.sum, lambda x: np.sum(x) + 5],\r\n        [True, False],\r\n    )\r\n    param_names = [\"constructor\", \"window\", \"dtype\", \"function\", \"raw\"]\r\n\r\n    def setup(self, constructor, window, dtype, function, raw):\r\n        N = 10**3\r\n        arr = (100 * np.random.random(N)).astype(dtype)\r\n        self.roll = getattr(pd, constructor)(arr).rolling(window)\r\n\r\n    def time_rolling(self, constructor, window, dtype, function, raw):\r\n        self.roll.apply(function, raw=raw)\r\n\r\n\r\nclass NumbaEngineMethods:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [\"int\", \"float\"],\r\n        [(\"rolling\", {\"window\": 10}), (\"expanding\", {})],\r\n        [\"sum\", \"max\", \"min\", \"median\", \"mean\", \"var\", \"std\"],\r\n        [True, False],\r\n        [None, 100],\r\n    )\r\n    param_names = [\r\n        \"constructor\",\r\n        \"dtype\",\r\n        \"window_kwargs\",\r\n        \"method\",\r\n        \"parallel\",\r\n        \"cols\",\r\n    ]\r\n\r\n    def setup(self, constructor, dtype, window_kwargs, method, parallel, cols):\r\n        N = 10**3\r\n        window, kwargs = window_kwargs\r\n        shape = (N, cols) if cols is not None and constructor != \"Series\" else N\r\n        arr = (100 * np.random.random(shape)).astype(dtype)\r\n        data = getattr(pd, constructor)(arr)\r\n\r\n        # Warm the cache\r\n        with warnings.catch_warnings(record=True):\r\n            # Catch parallel=True not being applicable e.g. 1D data\r\n            self.window = getattr(data, window)(**kwargs)\r\n            getattr(self.window, method)(\r\n                engine=\"numba\", engine_kwargs={\"parallel\": parallel}\r\n            )\r\n\r\n    def test_method(self, constructor, dtype, window_kwargs, method, parallel, cols):\r\n        with warnings.catch_warnings(record=True):\r\n            getattr(self.window, method)(\r\n                engine=\"numba\", engine_kwargs={\"parallel\": parallel}\r\n            )\r\n\r\n\r\nclass NumbaEngineApply:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [\"int\", \"float\"],\r\n        [(\"rolling\", {\"window\": 10}), (\"expanding\", {})],\r\n        [np.sum, lambda x: np.sum(x) + 5],\r\n        [True, False],\r\n        [None, 100],\r\n    )\r\n    param_names = [\r\n        \"constructor\",\r\n        \"dtype\",\r\n        \"window_kwargs\",\r\n        \"function\",\r\n        \"parallel\",\r\n        \"cols\",\r\n    ]\r\n\r\n    def setup(self, constructor, dtype, window_kwargs, function, parallel, cols):\r\n        N = 10**3\r\n        window, kwargs = window_kwargs\r\n        shape = (N, cols) if cols is not None and constructor != \"Series\" else N\r\n        arr = (100 * np.random.random(shape)).astype(dtype)\r\n        data = getattr(pd, constructor)(arr)\r\n\r\n        # Warm the cache\r\n        with warnings.catch_warnings(record=True):\r\n            # Catch parallel=True not being applicable e.g. 1D data\r\n            self.window = getattr(data, window)(**kwargs)\r\n            self.window.apply(\r\n                function, raw=True, engine=\"numba\", engine_kwargs={\"parallel\": parallel}\r\n            )\r\n\r\n    def test_method(self, constructor, dtype, window_kwargs, function, parallel, cols):\r\n        with warnings.catch_warnings(record=True):\r\n            self.window.apply(\r\n                function, raw=True, engine=\"numba\", engine_kwargs={\"parallel\": parallel}\r\n            )\r\n\r\n\r\nclass EWMMethods:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [\r\n            ({\"halflife\": 10}, \"mean\"),\r\n            ({\"halflife\": 10}, \"std\"),\r\n            ({\"halflife\": 1000}, \"mean\"),\r\n            ({\"halflife\": 1000}, \"std\"),\r\n            (\r\n                {\r\n                    \"halflife\": \"1 Day\",\r\n                    \"times\": pd.date_range(\"1900\", periods=10**5, freq=\"23s\"),\r\n                },\r\n                \"mean\",\r\n            ),\r\n        ],\r\n        [\"int\", \"float\"],\r\n    )\r\n    param_names = [\"constructor\", \"kwargs_method\", \"dtype\"]\r\n\r\n    def setup(self, constructor, kwargs_method, dtype):\r\n        N = 10**5\r\n        kwargs, method = kwargs_method\r\n        arr = (100 * np.random.random(N)).astype(dtype)\r\n        self.method = method\r\n        self.ewm = getattr(pd, constructor)(arr).ewm(**kwargs)\r\n\r\n    def time_ewm(self, constructor, kwargs_method, dtype):\r\n        getattr(self.ewm, self.method)()\r\n\r\n\r\nclass VariableWindowMethods(Methods):\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [\"50s\", \"1h\", \"1d\"],\r\n        [\"int\", \"float\"],\r\n        [\"median\", \"mean\", \"max\", \"min\", \"std\", \"count\", \"skew\", \"kurt\", \"sum\", \"sem\"],\r\n    )\r\n    param_names = [\"constructor\", \"window\", \"dtype\", \"method\"]\r\n\r\n    def setup(self, constructor, window, dtype, method):\r\n        N = 10**5\r\n        arr = (100 * np.random.random(N)).astype(dtype)\r\n        index = pd.date_range(\"2017-01-01\", periods=N, freq=\"5s\")\r\n        self.window = getattr(pd, constructor)(arr, index=index).rolling(window)\r\n\r\n\r\nclass Pairwise:\r\n    params = (\r\n        [({\"window\": 10}, \"rolling\"), ({\"window\": 1000}, \"rolling\"), ({}, \"expanding\")],\r\n        [\"corr\", \"cov\"],\r\n        [True, False],\r\n    )\r\n    param_names = [\"window_kwargs\", \"method\", \"pairwise\"]\r\n\r\n    def setup(self, kwargs_window, method, pairwise):\r\n        N = 10**4\r\n        n_groups = 20\r\n        kwargs, window = kwargs_window\r\n        groups = [i for _ in range(N // n_groups) for i in range(n_groups)]\r\n        arr = np.random.random(N)\r\n        self.df = pd.DataFrame(arr)\r\n        self.window = getattr(self.df, window)(**kwargs)\r\n        self.window_group = getattr(\r\n            pd.DataFrame({\"A\": groups, \"B\": arr}).groupby(\"A\"), window\r\n        )(**kwargs)\r\n\r\n    def time_pairwise(self, kwargs_window, method, pairwise):\r\n        getattr(self.window, method)(self.df, pairwise=pairwise)\r\n\r\n    def time_groupby(self, kwargs_window, method, pairwise):\r\n        getattr(self.window_group, method)(self.df, pairwise=pairwise)\r\n\r\n\r\nclass Quantile:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [10, 1000],\r\n        [\"int\", \"float\"],\r\n        [0, 0.5, 1],\r\n        [\"linear\", \"nearest\", \"lower\", \"higher\", \"midpoint\"],\r\n    )\r\n    param_names = [\"constructor\", \"window\", \"dtype\", \"percentile\"]\r\n\r\n    def setup(self, constructor, window, dtype, percentile, interpolation):\r\n        N = 10**5\r\n        arr = np.random.random(N).astype(dtype)\r\n        self.roll = getattr(pd, constructor)(arr).rolling(window)\r\n\r\n    def time_quantile(self, constructor, window, dtype, percentile, interpolation):\r\n        self.roll.quantile(percentile, interpolation=interpolation)\r\n\r\n\r\nclass Rank:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [10, 1000],\r\n        [\"int\", \"float\"],\r\n        [True, False],\r\n        [True, False],\r\n        [\"min\", \"max\", \"average\"],\r\n    )\r\n    param_names = [\r\n        \"constructor\",\r\n        \"window\",\r\n        \"dtype\",\r\n        \"percentile\",\r\n        \"ascending\",\r\n        \"method\",\r\n    ]\r\n\r\n"]
[100.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[100.002, "i", "sed -n '240,520p' benchmarks/rolling.py\r"]
[100.004, "o", "sed -n '240,520p' benchmarks/rolling.py\r\n"]
[100.006, "o", "\u001b[?2004l\r\n\r\n    def setup(self, constructor, window, dtype, percentile, ascending, method):\r\n        N = 10**5\r\n        arr = np.random.random(N).astype(dtype)\r\n        self.roll = getattr(pd, constructor)(arr).rolling(window)\r\n\r\n    def time_rank(self, constructor, window, dtype, percentile, ascending, method):\r\n        self.roll.rank(pct=percentile, ascending=ascending, method=method)\r\n\r\n\r\nclass PeakMemFixedWindowMinMax:\r\n    params = [\"min\", \"max\"]\r\n\r\n    def setup(self, operation):\r\n        N = 10**6\r\n        arr = np.random.random(N)\r\n        self.roll = pd.Series(arr).rolling(2)\r\n\r\n    def peakmem_fixed(self, operation):\r\n        for x in range(5):\r\n            getattr(self.roll, operation)()\r\n\r\n\r\nclass ForwardWindowMethods:\r\n    params = (\r\n        [\"DataFrame\", \"Series\"],\r\n        [10, 1000],\r\n        [\"int\", \"float\"],\r\n        [\"median\", \"mean\", \"max\", \"min\", \"kurt\", \"sum\"],\r\n    )\r\n    param_names = [\"constructor\", \"window_size\", \"dtype\", \"method\"]\r\n\r\n    def setup(self, constructor, window_size, dtype, method):\r\n        N = 10**5\r\n        arr = np.random.random(N).astype(dtype)\r\n        indexer = pd.api.indexers.FixedForwardWindowIndexer(window_size=window_size)\r\n        self.roll = getattr(pd, constructor)(arr).rolling(window=indexer)\r\n\r\n    def time_rolling(self, constructor, window_size, dtype, method):\r\n        getattr(self.roll, method)()\r\n\r\n    def peakmem_rolling(self, constructor, window_size, dtype, method):\r\n        getattr(self.roll, method)()\r\n\r\n\r\nclass Groupby:\r\n    params = (\r\n        [\"sum\", \"median\", \"mean\", \"max\", \"min\", \"kurt\", \"sum\"],\r\n        [\r\n            (\"rolling\", {\"window\": 2}),\r\n            (\"rolling\", {\"window\": \"30s\"}),\r\n            (\"expanding\", {}),\r\n        ],\r\n    )\r\n\r\n    def setup(self, method, window_kwargs):\r\n        N = 1000\r\n        window, kwargs = window_kwargs\r\n        df = pd.DataFrame(\r\n            {\r\n                \"A\": [str(i) for i in range(N)] * 10,\r\n                \"B\": list(range(N)) * 10,\r\n            }\r\n        )\r\n        if isinstance(kwargs.get(\"window\", None), str):\r\n            df.index = pd.date_range(start=\"1900-01-01\", freq=\"1min\", periods=N * 10)\r\n        self.groupby_window = getattr(df.groupby(\"A\"), window)(**kwargs)\r\n\r\n    def time_method(self, method, window_kwargs):\r\n        getattr(self.groupby_window, method)()\r\n\r\n\r\nclass GroupbyLargeGroups:\r\n    # https://github.com/pandas-dev/pandas/issues/38038\r\n    # specific example where the rolling operation on a larger dataframe\r\n    # is relatively cheap (few but large groups), but creation of\r\n    # MultiIndex of result can be expensive\r\n\r\n    def setup(self):\r\n        N = 100000\r\n        self.df = pd.DataFrame({\"A\": [1, 2] * (N // 2), \"B\": np.random.randn(N)})\r\n\r\n    def time_rolling_multiindex_creation(self):\r\n        self.df.groupby(\"A\").rolling(3).mean()\r\n\r\n\r\nclass GroupbyEWM:\r\n    params = [\"var\", \"std\", \"cov\", \"corr\"]\r\n    param_names = [\"method\"]\r\n\r\n    def setup(self, method):\r\n        df = pd.DataFrame({\"A\": range(50), \"B\": range(50)})\r\n        self.gb_ewm = df.groupby(\"A\").ewm(com=1.0)\r\n\r\n    def time_groupby_method(self, method):\r\n        getattr(self.gb_ewm, method)()\r\n\r\n\r\nclass GroupbyEWMEngine:\r\n    params = [\"cython\", \"numba\"]\r\n    param_names = [\"engine\"]\r\n\r\n    def setup(self, engine):\r\n        df = pd.DataFrame({\"A\": range(50), \"B\": range(50)})\r\n        self.gb_ewm = df.groupby(\"A\").ewm(com=1.0)\r\n\r\n    def time_groupby_mean(self, engine):\r\n        self.gb_ewm.mean(engine=engine)\r\n\r\n\r\ndef table_method_func(x):\r\n    return np.sum(x, axis=0) + 1\r\n\r\n\r\nclass TableMethod:\r\n    params = [\"single\", \"table\"]\r\n    param_names = [\"method\"]\r\n\r\n    def setup(self, method):\r\n        self.df = pd.DataFrame(np.random.randn(10, 1000))\r\n\r\n    def time_apply(self, method):\r\n        self.df.rolling(2, method=method).apply(\r\n            table_method_func, raw=True, engine=\"numba\"\r\n        )\r\n\r\n    def time_ewm_mean(self, method):\r\n        self.df.ewm(1, method=method).mean(engine=\"numba\")\r\n\r\n\r\nfrom .pandas_vb_common import setup  # noqa: F401 isort:skip\r\n"]
[105.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[105.002, "i", "sed -n '520,900p' benchmarks/rolling.py\r"]
[105.004, "o", "sed -n '520,900p' benchmarks/rolling.py\r\n"]
[105.006, "o", "\u001b[?2004l\r\n"]
[110.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[110.002, "i", "asv dev -b \".*Groupby.*\" -c asv.conf.json\r"]
[110.004, "o", "asv dev -b \".*Groupby.*\" -c asv.conf.json\r\n"]
[110.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: invalid choice: 'dev' (choose from 'help', 'quickstart', 'machine', 'setup', 'run', 'continuous', 'find', 'rm', 'publish', 'preview', 'profile', 'update', 'show', 'compare', 'check', 'gh-pages')\r\n"]
[115.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[115.002, "i", "asv run -c asv.conf.json --python=same --bench=\"rolling.Groupby.*\" --quick\r"]
[115.004, "o", "asv run -c asv.conf.json --python=same --bench=\"rolling.Groupby.*\" --quick\r\n"]
[115.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[120.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[120.002, "i", "asv profile --python=same -c asv.conf.json rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\r"]
[120.004, "o", "asv profile --python=same -c asv.conf.json rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\r\n"]
[120.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[125.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[125.002, "i", "asv profile --python=same -c asv.conf.json rolling.Groupby.time_method\r"]
[125.004, "o", "asv profile --python=same -c asv.conf.json rolling.Groupby.time_method\r\n"]
[125.006, "o", "\u001b[?2004l\r\nusage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\nasv: error: unrecognized arguments: -c\r\n"]
[130.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[130.002, "i", "sed -n '1,240p' ../pandas/core/window/rolling.py\r"]
[130.004, "o", "sed -n '1,240p' ../pandas/core/window/rolling.py\r\n"]
[130.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nProvide a generic structure to support window functions,\r\nsimilar to how we have a Groupby object.\r\n\"\"\"\r\nfrom __future__ import annotations\r\n\r\nimport copy\r\nfrom datetime import timedelta\r\nfrom functools import partial\r\nimport inspect\r\nfrom textwrap import dedent\r\nfrom typing import (\r\n    TYPE_CHECKING,\r\n    Any,\r\n    Callable,\r\n    Hashable,\r\n    Iterator,\r\n    Sized,\r\n    cast,\r\n)\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._libs.tslibs import (\r\n    BaseOffset,\r\n    to_offset,\r\n)\r\nimport pandas._libs.window.aggregations as window_aggregations\r\nfrom pandas._typing import (\r\n    ArrayLike,\r\n    Axis,\r\n    NDFrameT,\r\n    QuantileInterpolation,\r\n    WindowingRankType,\r\n)\r\nfrom pandas.compat._optional import import_optional_dependency\r\nfrom pandas.errors import DataError\r\nfrom pandas.util._decorators import doc\r\n\r\nfrom pandas.core.dtypes.common import (\r\n    ensure_float64,\r\n    is_bool,\r\n    is_integer,\r\n    is_list_like,\r\n    is_numeric_dtype,\r\n    is_scalar,\r\n    needs_i8_conversion,\r\n)\r\nfrom pandas.core.dtypes.generic import (\r\n    ABCDataFrame,\r\n    ABCSeries,\r\n)\r\nfrom pandas.core.dtypes.missing import notna\r\n\r\nfrom pandas.core._numba import executor\r\nfrom pandas.core.algorithms import factorize\r\nfrom pandas.core.apply import ResamplerWindowApply\r\nfrom pandas.core.arrays import ExtensionArray\r\nfrom pandas.core.base import SelectionMixin\r\nimport pandas.core.common as com\r\nfrom pandas.core.indexers.objects import (\r\n    BaseIndexer,\r\n    FixedWindowIndexer,\r\n    GroupbyIndexer,\r\n    VariableWindowIndexer,\r\n)\r\nfrom pandas.core.indexes.api import (\r\n    DatetimeIndex,\r\n    Index,\r\n    MultiIndex,\r\n    PeriodIndex,\r\n    TimedeltaIndex,\r\n)\r\nfrom pandas.core.reshape.concat import concat\r\nfrom pandas.core.util.numba_ import (\r\n    get_jit_arguments,\r\n    maybe_use_numba,\r\n)\r\nfrom pandas.core.window.common import (\r\n    flex_binary_moment,\r\n    zsqrt,\r\n)\r\nfrom pandas.core.window.doc import (\r\n    _shared_docs,\r\n    create_section_header,\r\n    kwargs_numeric_only,\r\n    kwargs_scipy,\r\n    numba_notes,\r\n    template_header,\r\n    template_returns,\r\n    template_see_also,\r\n    window_agg_numba_parameters,\r\n    window_apply_parameters,\r\n)\r\nfrom pandas.core.window.numba_ import (\r\n    generate_manual_numpy_nan_agg_with_axis,\r\n    generate_numba_apply_func,\r\n    generate_numba_table_func,\r\n)\r\n\r\nif TYPE_CHECKING:\r\n    from pandas import (\r\n        DataFrame,\r\n        Series,\r\n    )\r\n    from pandas.core.generic import NDFrame\r\n    from pandas.core.groupby.ops import BaseGrouper\r\n\r\n\r\nclass BaseWindow(SelectionMixin):\r\n    \"\"\"Provides utilities for performing windowing operations.\"\"\"\r\n\r\n    _attributes: list[str] = []\r\n    exclusions: frozenset[Hashable] = frozenset()\r\n    _on: Index\r\n\r\n    def __init__(\r\n        self,\r\n        obj: NDFrame,\r\n        window=None,\r\n        min_periods: int | None = None,\r\n        center: bool | None = False,\r\n        win_type: str | None = None,\r\n        axis: Axis = 0,\r\n        on: str | Index | None = None,\r\n        closed: str | None = None,\r\n        step: int | None = None,\r\n        method: str = \"single\",\r\n        *,\r\n        selection=None,\r\n    ) -> None:\r\n        self.obj = obj\r\n        self.on = on\r\n        self.closed = closed\r\n        self.step = step\r\n        self.window = window\r\n        self.min_periods = min_periods\r\n        self.center = center\r\n        self.win_type = win_type\r\n        self.axis = obj._get_axis_number(axis) if axis is not None else None\r\n        self.method = method\r\n        self._win_freq_i8: int | None = None\r\n        if self.on is None:\r\n            if self.axis == 0:\r\n                self._on = self.obj.index\r\n            else:\r\n                # i.e. self.axis == 1\r\n                self._on = self.obj.columns\r\n        elif isinstance(self.on, Index):\r\n            self._on = self.on\r\n        elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\r\n            self._on = Index(self.obj[self.on])\r\n        else:\r\n            raise ValueError(\r\n                f\"invalid on specified as {self.on}, \"\r\n                \"must be a column (of DataFrame), an Index or None\"\r\n            )\r\n\r\n        self._selection = selection\r\n        self._validate()\r\n\r\n    def _validate(self) -> None:\r\n        if self.center is not None and not is_bool(self.center):\r\n            raise ValueError(\"center must be a boolean\")\r\n        if self.min_periods is not None:\r\n            if not is_integer(self.min_periods):\r\n                raise ValueError(\"min_periods must be an integer\")\r\n            if self.min_periods < 0:\r\n                raise ValueError(\"min_periods must be >= 0\")\r\n            if is_integer(self.window) and self.min_periods > self.window:\r\n                raise ValueError(\r\n                    f\"min_periods {self.min_periods} must be <= window {self.window}\"\r\n                )\r\n        if self.closed is not None and self.closed not in [\r\n            \"right\",\r\n            \"both\",\r\n            \"left\",\r\n            \"neither\",\r\n        ]:\r\n            raise ValueError(\"closed must be 'right', 'left', 'both' or 'neither'\")\r\n        if not isinstance(self.obj, (ABCSeries, ABCDataFrame)):\r\n            raise TypeError(f\"invalid type: {type(self)}\")\r\n        if isinstance(self.window, BaseIndexer):\r\n            # Validate that the passed BaseIndexer subclass has\r\n            # a get_window_bounds with the correct signature.\r\n            get_window_bounds_signature = inspect.signature(\r\n                self.window.get_window_bounds\r\n            ).parameters.keys()\r\n            expected_signature = inspect.signature(\r\n                BaseIndexer().get_window_bounds\r\n            ).parameters.keys()\r\n            if get_window_bounds_signature != expected_signature:\r\n                raise ValueError(\r\n                    f\"{type(self.window).__name__} does not implement \"\r\n                    f\"the correct signature for get_window_bounds\"\r\n                )\r\n        if self.method not in [\"table\", \"single\"]:\r\n            raise ValueError(\"method must be 'table' or 'single\")\r\n        if self.step is not None:\r\n            if not is_integer(self.step):\r\n                raise ValueError(\"step must be an integer\")\r\n            if self.step < 0:\r\n                raise ValueError(\"step must be >= 0\")\r\n\r\n    def _check_window_bounds(\r\n        self, start: np.ndarray, end: np.ndarray, num_vals: int\r\n    ) -> None:\r\n        if len(start) != len(end):\r\n            raise ValueError(\r\n                f\"start ({len(start)}) and end ({len(end)}) bounds must be the \"\r\n                f\"same length\"\r\n            )\r\n        if len(start) != (num_vals + (self.step or 1) - 1) // (self.step or 1):\r\n            raise ValueError(\r\n                f\"start and end bounds ({len(start)}) must be the same length \"\r\n                f\"as the object ({num_vals}) divided by the step ({self.step}) \"\r\n                f\"if given and rounded up\"\r\n            )\r\n\r\n    def _slice_axis_for_step(self, index: Index, result: Sized | None = None) -> Index:\r\n        \"\"\"\r\n        Slices the index for a given result and the preset step.\r\n        \"\"\"\r\n        return (\r\n            index\r\n            if result is None or len(result) == len(index)\r\n            else index[:: self.step]\r\n        )\r\n\r\n    def _validate_numeric_only(self, name: str, numeric_only: bool) -> None:\r\n        \"\"\"\r\n        Validate numeric_only argument, raising if invalid for the input.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the operator (kernel).\r\n        numeric_only : bool\r\n            Value passed by user.\r\n        \"\"\"\r\n"]
[135.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[135.002, "i", "sed -n '240,520p' ../pandas/core/window/rolling.py\r"]
[135.004, "o", "sed -n '240,520p' ../pandas/core/window/rolling.py\r\n"]
[135.006, "o", "\u001b[?2004l\r\n        \"\"\"\r\n        if (\r\n            self._selected_obj.ndim == 1\r\n            and numeric_only\r\n            and not is_numeric_dtype(self._selected_obj.dtype)\r\n        ):\r\n            raise NotImplementedError(\r\n                f\"{type(self).__name__}.{name} does not implement numeric_only\"\r\n            )\r\n\r\n    def _make_numeric_only(self, obj: NDFrameT) -> NDFrameT:\r\n        \"\"\"Subset DataFrame to numeric columns.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : DataFrame\r\n\r\n        Returns\r\n        -------\r\n        obj subset to numeric-only columns.\r\n        \"\"\"\r\n        result = obj.select_dtypes(include=[\"number\"], exclude=[\"timedelta\"])\r\n        return result\r\n\r\n    def _create_data(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n        \"\"\"\r\n        Split data into blocks & return conformed data.\r\n        \"\"\"\r\n        # filter out the on from the object\r\n        if self.on is not None and not isinstance(self.on, Index) and obj.ndim == 2:\r\n            obj = obj.reindex(columns=obj.columns.difference([self.on]), copy=False)\r\n        if obj.ndim > 1 and (numeric_only or self.axis == 1):\r\n            # GH: 20649 in case of mixed dtype and axis=1 we have to convert everything\r\n            # to float to calculate the complete row at once. We exclude all non-numeric\r\n            # dtypes.\r\n            obj = self._make_numeric_only(obj)\r\n        if self.axis == 1:\r\n            obj = obj.astype(\"float64\", copy=False)\r\n            obj._mgr = obj._mgr.consolidate()\r\n        return obj\r\n\r\n    def _gotitem(self, key, ndim, subset=None):\r\n        \"\"\"\r\n        Sub-classes to define. Return a sliced object.\r\n\r\n        Parameters\r\n        ----------\r\n        key : str / list of selections\r\n        ndim : {1, 2}\r\n            requested ndim of result\r\n        subset : object, default None\r\n            subset to act on\r\n        \"\"\"\r\n        # create a new object to prevent aliasing\r\n        if subset is None:\r\n            subset = self.obj\r\n\r\n        # we need to make a shallow copy of ourselves\r\n        # with the same groupby\r\n        kwargs = {attr: getattr(self, attr) for attr in self._attributes}\r\n\r\n        selection = None\r\n        if subset.ndim == 2 and (\r\n            (is_scalar(key) and key in subset) or is_list_like(key)\r\n        ):\r\n            selection = key\r\n        elif subset.ndim == 1 and is_scalar(key) and key == subset.name:\r\n            selection = key\r\n\r\n        new_win = type(self)(subset, selection=selection, **kwargs)\r\n        return new_win\r\n\r\n    def __getattr__(self, attr: str):\r\n        if attr in self._internal_names_set:\r\n            return object.__getattribute__(self, attr)\r\n        if attr in self.obj:\r\n            return self[attr]\r\n\r\n        raise AttributeError(\r\n            f\"'{type(self).__name__}' object has no attribute '{attr}'\"\r\n        )\r\n\r\n    def _dir_additions(self):\r\n        return self.obj._dir_additions()\r\n\r\n    def __repr__(self) -> str:\r\n        \"\"\"\r\n        Provide a nice str repr of our rolling object.\r\n        \"\"\"\r\n        attrs_list = (\r\n            f\"{attr_name}={getattr(self, attr_name)}\"\r\n            for attr_name in self._attributes\r\n            if getattr(self, attr_name, None) is not None and attr_name[0] != \"_\"\r\n        )\r\n        attrs = \",\".join(attrs_list)\r\n        return f\"{type(self).__name__} [{attrs}]\"\r\n\r\n    def __iter__(self) -> Iterator:\r\n        obj = self._selected_obj.set_axis(self._on)\r\n        obj = self._create_data(obj)\r\n        indexer = self._get_window_indexer()\r\n\r\n        start, end = indexer.get_window_bounds(\r\n            num_values=len(obj),\r\n            min_periods=self.min_periods,\r\n            center=self.center,\r\n            closed=self.closed,\r\n            step=self.step,\r\n        )\r\n        self._check_window_bounds(start, end, len(obj))\r\n\r\n        for s, e in zip(start, end):\r\n            result = obj.iloc[slice(s, e)]\r\n            yield result\r\n\r\n    def _prep_values(self, values: ArrayLike) -> np.ndarray:\r\n        \"\"\"Convert input to numpy arrays for Cython routines\"\"\"\r\n        if needs_i8_conversion(values.dtype):\r\n            raise NotImplementedError(\r\n                f\"ops for {type(self).__name__} for this \"\r\n                f\"dtype {values.dtype} are not implemented\"\r\n            )\r\n        # GH #12373 : rolling functions error on float32 data\r\n        # make sure the data is coerced to float64\r\n        try:\r\n            if isinstance(values, ExtensionArray):\r\n                values = values.to_numpy(np.float64, na_value=np.nan)\r\n            else:\r\n                values = ensure_float64(values)\r\n        except (ValueError, TypeError) as err:\r\n            raise TypeError(f\"cannot handle this type -> {values.dtype}\") from err\r\n\r\n        # Convert inf to nan for C funcs\r\n        inf = np.isinf(values)\r\n        if inf.any():\r\n            values = np.where(inf, np.nan, values)\r\n\r\n        return values\r\n\r\n    def _insert_on_column(self, result: DataFrame, obj: DataFrame) -> None:\r\n        # if we have an 'on' column we want to put it back into\r\n        # the results in the same location\r\n        from pandas import Series\r\n\r\n        if self.on is not None and not self._on.equals(obj.index):\r\n            name = self._on.name\r\n            extra_col = Series(self._on, index=self.obj.index, name=name)\r\n            if name in result.columns:\r\n                # TODO: sure we want to overwrite results?\r\n                result[name] = extra_col\r\n            elif name in result.index.names:\r\n                pass\r\n            elif name in self._selected_obj.columns:\r\n                # insert in the same location as we had in _selected_obj\r\n                old_cols = self._selected_obj.columns\r\n                new_cols = result.columns\r\n                old_loc = old_cols.get_loc(name)\r\n                overlap = new_cols.intersection(old_cols[:old_loc])\r\n                new_loc = len(overlap)\r\n                result.insert(new_loc, name, extra_col)\r\n            else:\r\n                # insert at the end\r\n                result[name] = extra_col\r\n\r\n    @property\r\n    def _index_array(self):\r\n        # TODO: why do we get here with e.g. MultiIndex?\r\n        if needs_i8_conversion(self._on.dtype):\r\n            idx = cast(\"PeriodIndex | DatetimeIndex | TimedeltaIndex\", self._on)\r\n            return idx.asi8\r\n        return None\r\n\r\n    def _resolve_output(self, out: DataFrame, obj: DataFrame) -> DataFrame:\r\n        \"\"\"Validate and finalize result.\"\"\"\r\n        if out.shape[1] == 0 and obj.shape[1] > 0:\r\n            raise DataError(\"No numeric types to aggregate\")\r\n        if out.shape[1] == 0:\r\n            return obj.astype(\"float64\")\r\n\r\n        self._insert_on_column(out, obj)\r\n        return out\r\n\r\n    def _get_window_indexer(self) -> BaseIndexer:\r\n        \"\"\"\r\n        Return an indexer class that will compute the window start and end bounds\r\n        \"\"\"\r\n        if isinstance(self.window, BaseIndexer):\r\n            return self.window\r\n        if self._win_freq_i8 is not None:\r\n            return VariableWindowIndexer(\r\n                index_array=self._index_array,\r\n                window_size=self._win_freq_i8,\r\n                center=self.center,\r\n            )\r\n        return FixedWindowIndexer(window_size=self.window)\r\n\r\n    def _apply_series(\r\n        self, homogeneous_func: Callable[..., ArrayLike], name: str | None = None\r\n    ) -> Series:\r\n        \"\"\"\r\n        Series version of _apply_blockwise\r\n        \"\"\"\r\n        obj = self._create_data(self._selected_obj)\r\n\r\n        if name == \"count\":\r\n            # GH 12541: Special case for count where we support date-like types\r\n            obj = notna(obj).astype(int)\r\n        try:\r\n            values = self._prep_values(obj._values)\r\n        except (TypeError, NotImplementedError) as err:\r\n            raise DataError(\"No numeric types to aggregate\") from err\r\n\r\n        result = homogeneous_func(values)\r\n        index = self._slice_axis_for_step(obj.index, result)\r\n        return obj._constructor(result, index=index, name=obj.name)\r\n\r\n    def _apply_blockwise(\r\n        self,\r\n        homogeneous_func: Callable[..., ArrayLike],\r\n        name: str,\r\n        numeric_only: bool = False,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given function to the DataFrame broken down into homogeneous\r\n        sub-frames.\r\n        \"\"\"\r\n        self._validate_numeric_only(name, numeric_only)\r\n        if self._selected_obj.ndim == 1:\r\n            return self._apply_series(homogeneous_func, name)\r\n\r\n        obj = self._create_data(self._selected_obj, numeric_only)\r\n        if name == \"count\":\r\n            # GH 12541: Special case for count where we support date-like types\r\n            obj = notna(obj).astype(int)\r\n            obj._mgr = obj._mgr.consolidate()\r\n\r\n        if self.axis == 1:\r\n            obj = obj.T\r\n\r\n        taker = []\r\n        res_values = []\r\n        for i, arr in enumerate(obj._iter_column_arrays()):\r\n            # GH#42736 operate column-wise instead of block-wise\r\n            # As of 2.0, hfunc will raise for nuisance columns\r\n            try:\r\n                arr = self._prep_values(arr)\r\n            except (TypeError, NotImplementedError) as err:\r\n                raise DataError(\r\n                    f\"Cannot aggregate non-numeric type: {arr.dtype}\"\r\n                ) from err\r\n            res = homogeneous_func(arr)\r\n            res_values.append(res)\r\n            taker.append(i)\r\n\r\n        index = self._slice_axis_for_step(\r\n            obj.index, res_values[0] if len(res_values) > 0 else None\r\n        )\r\n        df = type(obj)._from_arrays(\r\n            res_values,\r\n            index=index,\r\n            columns=obj.columns.take(taker),\r\n            verify_integrity=False,\r\n        )\r\n\r\n        if self.axis == 1:\r\n            df = df.T\r\n\r\n        return self._resolve_output(df, obj)\r\n\r\n    def _apply_tablewise(\r\n        self,\r\n        homogeneous_func: Callable[..., ArrayLike],\r\n        name: str | None = None,\r\n        numeric_only: bool = False,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given function to the DataFrame across the entire object\r\n        \"\"\"\r\n        if self._selected_obj.ndim == 1:\r\n            raise ValueError(\"method='table' not applicable for Series objects.\")\r\n        obj = self._create_data(self._selected_obj, numeric_only)\r\n"]
[140.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[140.002, "i", "sed -n '520,900p' ../pandas/core/window/rolling.py\r"]
[140.004, "o", "sed -n '520,900p' ../pandas/core/window/rolling.py\r\n"]
[140.006, "o", "\u001b[?2004l\r\n        obj = self._create_data(self._selected_obj, numeric_only)\r\n        values = self._prep_values(obj.to_numpy())\r\n        values = values.T if self.axis == 1 else values\r\n        result = homogeneous_func(values)\r\n        result = result.T if self.axis == 1 else result\r\n        index = self._slice_axis_for_step(obj.index, result)\r\n        columns = (\r\n            obj.columns\r\n            if result.shape[1] == len(obj.columns)\r\n            else obj.columns[:: self.step]\r\n        )\r\n        out = obj._constructor(result, index=index, columns=columns)\r\n\r\n        return self._resolve_output(out, obj)\r\n\r\n    def _apply_pairwise(\r\n        self,\r\n        target: DataFrame | Series,\r\n        other: DataFrame | Series | None,\r\n        pairwise: bool | None,\r\n        func: Callable[[DataFrame | Series, DataFrame | Series], DataFrame | Series],\r\n        numeric_only: bool,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given pairwise function given 2 pandas objects (DataFrame/Series)\r\n        \"\"\"\r\n        target = self._create_data(target, numeric_only)\r\n        if other is None:\r\n            other = target\r\n            # only default unset\r\n            pairwise = True if pairwise is None else pairwise\r\n        elif not isinstance(other, (ABCDataFrame, ABCSeries)):\r\n            raise ValueError(\"other must be a DataFrame or Series\")\r\n        elif other.ndim == 2 and numeric_only:\r\n            other = self._make_numeric_only(other)\r\n\r\n        return flex_binary_moment(target, other, func, pairwise=bool(pairwise))\r\n\r\n    def _apply(\r\n        self,\r\n        func: Callable[..., Any],\r\n        name: str,\r\n        numeric_only: bool = False,\r\n        numba_args: tuple[Any, ...] = (),\r\n        **kwargs,\r\n    ):\r\n        \"\"\"\r\n        Rolling statistical measure using supplied function.\r\n\r\n        Designed to be used with passed-in Cython array-based functions.\r\n\r\n        Parameters\r\n        ----------\r\n        func : callable function to apply\r\n        name : str,\r\n        numba_args : tuple\r\n            args to be passed when func is a numba func\r\n        **kwargs\r\n            additional arguments for rolling function and window function\r\n\r\n        Returns\r\n        -------\r\n        y : type of input\r\n        \"\"\"\r\n        window_indexer = self._get_window_indexer()\r\n        min_periods = (\r\n            self.min_periods\r\n            if self.min_periods is not None\r\n            else window_indexer.window_size\r\n        )\r\n\r\n        def homogeneous_func(values: np.ndarray):\r\n            # calculation function\r\n\r\n            if values.size == 0:\r\n                return values.copy()\r\n\r\n            def calc(x):\r\n                start, end = window_indexer.get_window_bounds(\r\n                    num_values=len(x),\r\n                    min_periods=min_periods,\r\n                    center=self.center,\r\n                    closed=self.closed,\r\n                    step=self.step,\r\n                )\r\n                self._check_window_bounds(start, end, len(x))\r\n\r\n                return func(x, start, end, min_periods, *numba_args)\r\n\r\n            with np.errstate(all=\"ignore\"):\r\n                result = calc(values)\r\n\r\n            return result\r\n\r\n        if self.method == \"single\":\r\n            return self._apply_blockwise(homogeneous_func, name, numeric_only)\r\n        else:\r\n            return self._apply_tablewise(homogeneous_func, name, numeric_only)\r\n\r\n    def _numba_apply(\r\n        self,\r\n        func: Callable[..., Any],\r\n        engine_kwargs: dict[str, bool] | None = None,\r\n        *func_args,\r\n    ):\r\n        window_indexer = self._get_window_indexer()\r\n        min_periods = (\r\n            self.min_periods\r\n            if self.min_periods is not None\r\n            else window_indexer.window_size\r\n        )\r\n        obj = self._create_data(self._selected_obj)\r\n        if self.axis == 1:\r\n            obj = obj.T\r\n        values = self._prep_values(obj.to_numpy())\r\n        if values.ndim == 1:\r\n            values = values.reshape(-1, 1)\r\n        start, end = window_indexer.get_window_bounds(\r\n            num_values=len(values),\r\n            min_periods=min_periods,\r\n            center=self.center,\r\n            closed=self.closed,\r\n            step=self.step,\r\n        )\r\n        self._check_window_bounds(start, end, len(values))\r\n        aggregator = executor.generate_shared_aggregator(\r\n            func, **get_jit_arguments(engine_kwargs)\r\n        )\r\n        result = aggregator(values, start, end, min_periods, *func_args)\r\n        result = result.T if self.axis == 1 else result\r\n        index = self._slice_axis_for_step(obj.index, result)\r\n        if obj.ndim == 1:\r\n            result = result.squeeze()\r\n            out = obj._constructor(result, index=index, name=obj.name)\r\n            return out\r\n        else:\r\n            columns = self._slice_axis_for_step(obj.columns, result.T)\r\n            out = obj._constructor(result, index=index, columns=columns)\r\n            return self._resolve_output(out, obj)\r\n\r\n    def aggregate(self, func, *args, **kwargs):\r\n        result = ResamplerWindowApply(self, func, args=args, kwargs=kwargs).agg()\r\n        if result is None:\r\n            return self.apply(func, raw=False, args=args, kwargs=kwargs)\r\n        return result\r\n\r\n    agg = aggregate\r\n\r\n\r\nclass BaseWindowGroupby(BaseWindow):\r\n    \"\"\"\r\n    Provide the groupby windowing facilities.\r\n    \"\"\"\r\n\r\n    _grouper: BaseGrouper\r\n    _as_index: bool\r\n    _attributes: list[str] = [\"_grouper\"]\r\n\r\n    def __init__(\r\n        self,\r\n        obj: DataFrame | Series,\r\n        *args,\r\n        _grouper: BaseGrouper,\r\n        _as_index: bool = True,\r\n        **kwargs,\r\n    ) -> None:\r\n        from pandas.core.groupby.ops import BaseGrouper\r\n\r\n        if not isinstance(_grouper, BaseGrouper):\r\n            raise ValueError(\"Must pass a BaseGrouper object.\")\r\n        self._grouper = _grouper\r\n        self._as_index = _as_index\r\n        # GH 32262: It's convention to keep the grouping column in\r\n        # groupby.<agg_func>, but unexpected to users in\r\n        # groupby.rolling.<agg_func>\r\n        obj = obj.drop(columns=self._grouper.names, errors=\"ignore\")\r\n        # GH 15354\r\n        if kwargs.get(\"step\") is not None:\r\n            raise NotImplementedError(\"step not implemented for groupby\")\r\n        super().__init__(obj, *args, **kwargs)\r\n\r\n    def _apply(\r\n        self,\r\n        func: Callable[..., Any],\r\n        name: str,\r\n        numeric_only: bool = False,\r\n        numba_args: tuple[Any, ...] = (),\r\n        **kwargs,\r\n    ) -> DataFrame | Series:\r\n        result = super()._apply(\r\n            func,\r\n            name,\r\n            numeric_only,\r\n            numba_args,\r\n            **kwargs,\r\n        )\r\n        # Reconstruct the resulting MultiIndex\r\n        # 1st set of levels = group by labels\r\n        # 2nd set of levels = original DataFrame/Series index\r\n        grouped_object_index = self.obj.index\r\n        grouped_index_name = [*grouped_object_index.names]\r\n        groupby_keys = copy.copy(self._grouper.names)\r\n        result_index_names = groupby_keys + grouped_index_name\r\n\r\n        drop_columns = [\r\n            key\r\n            for key in self._grouper.names\r\n            if key not in self.obj.index.names or key is None\r\n        ]\r\n\r\n        if len(drop_columns) != len(groupby_keys):\r\n            # Our result will have still kept the column in the result\r\n            result = result.drop(columns=drop_columns, errors=\"ignore\")\r\n\r\n        codes = self._grouper.codes\r\n        levels = copy.copy(self._grouper.levels)\r\n\r\n        group_indices = self._grouper.indices.values()\r\n        if group_indices:\r\n            indexer = np.concatenate(list(group_indices))\r\n        else:\r\n            indexer = np.array([], dtype=np.intp)\r\n        codes = [c.take(indexer) for c in codes]\r\n\r\n        # if the index of the original dataframe needs to be preserved, append\r\n        # this index (but reordered) to the codes/levels from the groupby\r\n        if grouped_object_index is not None:\r\n            idx = grouped_object_index.take(indexer)\r\n            if not isinstance(idx, MultiIndex):\r\n                idx = MultiIndex.from_arrays([idx])\r\n            codes.extend(list(idx.codes))\r\n            levels.extend(list(idx.levels))\r\n\r\n        result_index = MultiIndex(\r\n            levels, codes, names=result_index_names, verify_integrity=False\r\n        )\r\n\r\n        result.index = result_index\r\n        if not self._as_index:\r\n            result = result.reset_index(level=list(range(len(groupby_keys))))\r\n        return result\r\n\r\n    def _apply_pairwise(\r\n        self,\r\n        target: DataFrame | Series,\r\n        other: DataFrame | Series | None,\r\n        pairwise: bool | None,\r\n        func: Callable[[DataFrame | Series, DataFrame | Series], DataFrame | Series],\r\n        numeric_only: bool,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given pairwise function given 2 pandas objects (DataFrame/Series)\r\n        \"\"\"\r\n        # Manually drop the grouping column first\r\n        target = target.drop(columns=self._grouper.names, errors=\"ignore\")\r\n        result = super()._apply_pairwise(target, other, pairwise, func, numeric_only)\r\n        # 1) Determine the levels + codes of the groupby levels\r\n        if other is not None and not all(\r\n            len(group) == len(other) for group in self._grouper.indices.values()\r\n        ):\r\n            # GH 42915\r\n            # len(other) != len(any group), so must reindex (expand) the result\r\n            # from flex_binary_moment to a \"transform\"-like result\r\n            # per groupby combination\r\n            old_result_len = len(result)\r\n            result = concat(\r\n                [\r\n                    result.take(gb_indices).reindex(result.index)\r\n                    for gb_indices in self._grouper.indices.values()\r\n                ]\r\n            )\r\n\r\n            gb_pairs = (\r\n                com.maybe_make_list(pair) for pair in self._grouper.indices.keys()\r\n            )\r\n            groupby_codes = []\r\n            groupby_levels = []\r\n            # e.g. [[1, 2], [4, 5]] as [[1, 4], [2, 5]]\r\n            for gb_level_pair in map(list, zip(*gb_pairs)):\r\n                labels = np.repeat(np.array(gb_level_pair), old_result_len)\r\n                codes, levels = factorize(labels)\r\n                groupby_codes.append(codes)\r\n                groupby_levels.append(levels)\r\n        else:\r\n            # pairwise=True or len(other) == len(each group), so repeat\r\n            # the groupby labels by the number of columns in the original object\r\n            groupby_codes = self._grouper.codes\r\n            # error: Incompatible types in assignment (expression has type\r\n            # \"List[Index]\", variable has type \"List[Union[ndarray, Index]]\")\r\n            groupby_levels = self._grouper.levels  # type: ignore[assignment]\r\n\r\n            group_indices = self._grouper.indices.values()\r\n            if group_indices:\r\n                indexer = np.concatenate(list(group_indices))\r\n            else:\r\n                indexer = np.array([], dtype=np.intp)\r\n\r\n            if target.ndim == 1:\r\n                repeat_by = 1\r\n            else:\r\n                repeat_by = len(target.columns)\r\n            groupby_codes = [\r\n                np.repeat(c.take(indexer), repeat_by) for c in groupby_codes\r\n            ]\r\n        # 2) Determine the levels + codes of the result from super()._apply_pairwise\r\n        if isinstance(result.index, MultiIndex):\r\n            result_codes = list(result.index.codes)\r\n            result_levels = list(result.index.levels)\r\n            result_names = list(result.index.names)\r\n        else:\r\n            idx_codes, idx_levels = factorize(result.index)\r\n            result_codes = [idx_codes]\r\n            result_levels = [idx_levels]\r\n            result_names = [result.index.name]\r\n\r\n        # 3) Create the resulting index by combining 1) + 2)\r\n        result_codes = groupby_codes + result_codes\r\n        result_levels = groupby_levels + result_levels\r\n        result_names = self._grouper.names + result_names\r\n\r\n        result_index = MultiIndex(\r\n            result_levels, result_codes, names=result_names, verify_integrity=False\r\n        )\r\n        result.index = result_index\r\n        return result\r\n\r\n    def _create_data(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n        \"\"\"\r\n        Split data into blocks & return conformed data.\r\n        \"\"\"\r\n        # Ensure the object we're rolling over is monotonically sorted relative\r\n        # to the groups\r\n        # GH 36197\r\n        if not obj.empty:\r\n            groupby_order = np.concatenate(list(self._grouper.indices.values())).astype(\r\n                np.int64\r\n            )\r\n            obj = obj.take(groupby_order)\r\n        return super()._create_data(obj, numeric_only)\r\n\r\n    def _gotitem(self, key, ndim, subset=None):\r\n        # we are setting the index on the actual object\r\n        # here so our index is carried through to the selected obj\r\n        # when we do the splitting for the groupby\r\n        if self.on is not None:\r\n            # GH 43355\r\n            subset = self.obj.set_index(self._on)\r\n        return super()._gotitem(key, ndim, subset=subset)\r\n\r\n\r\nclass Window(BaseWindow):\r\n    \"\"\"\r\n    Provide rolling window calculations.\r\n\r\n    Parameters\r\n    ----------\r\n    window : int, timedelta, str, offset, or BaseIndexer subclass\r\n        Size of the moving window.\r\n\r\n        If an integer, the fixed number of observations used for\r\n        each window.\r\n\r\n        If a timedelta, str, or offset, the time period of each window. Each\r\n        window will be a variable sized based on the observations included in\r\n        the time-period. This is only valid for datetimelike indexes.\r\n        To learn more about the offsets & frequency strings, please see `this link\r\n        <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n\r\n        If a BaseIndexer subclass, the window boundaries\r\n        based on the defined ``get_window_bounds`` method. Additional rolling\r\n        keyword arguments, namely ``min_periods``, ``center``, ``closed`` and\r\n        ``step`` will be passed to ``get_window_bounds``.\r\n\r\n    min_periods : int, default None\r\n        Minimum number of observations in window required to have a value;\r\n        otherwise, result is ``np.nan``.\r\n\r\n        For a window that is specified by an offset, ``min_periods`` will default to 1.\r\n\r\n        For a window that is specified by an integer, ``min_periods`` will default\r\n        to the size of the window.\r\n"]
[145.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[145.002, "i", "asv run --config=asv.conf.json --python=same --bench=\"rolling.Groupby.*\"\r"]
[145.004, "o", "asv run --config=asv.conf.json --python=same --bench=\"rolling.Groupby.*\"\r\n"]
[145.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 4 total benchmarks (1 commits * 1 environments * 4 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n[12.50%] \u00b7\u00b7\u00b7 \u001b[0;39mRunning (rolling.Groupby.time_method--)\u001b[0m....\r\n[62.50%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.Groupby.time_method\u001b[0m                                                                                                                     ok\r\n[62.50%] \u00b7\u00b7\u00b7 \u001b[0;39m=========== ============================ ================================ ===================\u001b[0m\r\n             --                                                param2                                     \r\n             ----------- ---------------------------------------------------------------------------------\r\n                param1    ('rolling', {'window': 2})   ('rolling', {'window': '30s'})   ('expanding', {}) \r\n             =========== ============================ ================================ ===================\r\n              'sum' (0)           40.3\u00b10.3ms                     16.3\u00b10.2ms                 14.9\u00b10.2ms    \r\n                median            41.2\u00b10.5ms                     19.6\u00b10.4ms                 16.9\u00b10.4ms    \r\n                 mean             39.5\u00b10.8ms                     16.1\u00b10.2ms                 14.6\u00b10.1ms    \r\n                 max              39.8\u00b10.5ms                     16.3\u00b10.4ms                 14.7\u00b10.2ms    \r\n                 min              40.2\u00b10.3ms                     16.3\u00b10.2ms                 14.8\u00b10.1ms    \r\n                 kurt             40.1\u00b10.4ms                     16.2\u00b10.3ms                 14.9\u00b10.1ms    \r\n              'sum' (1)           40.1\u00b10.3ms                     16.3\u00b10.2ms                 14.9\u00b10.1ms    \r\n             =========== ============================ ================================ ===================\r\n\r\n[75.00%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyEWM.time_groupby_method\u001b[0m                                                                                                          ok\r\n[75.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== =============\u001b[0m\r\n              method               \r\n             -------- -------------\r\n               var       1.05\u00b10ms  \r\n               std     1.20\u00b10.01ms \r\n               cov     3.67\u00b10.07ms \r\n               corr    3.80\u00b10.02ms \r\n             ======== =============\r\n\r\n[87.50%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyEWMEngine.time_groupby_mean\u001b[0m                                                                                                      ok\r\n[87.50%] \u00b7\u00b7\u00b7 \u001b[0;39m======== =============\u001b[0m\r\n              engine               \r\n             -------- -------------\r\n              cython   1.06\u00b10.01ms \r\n              numba    1.26\u00b10.05ms \r\n             ======== =============\r\n\r\n[100.00%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                             19.1\u00b10.1ms\r\n"]
[150.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[150.002, "i", "asv profile --python=same --config=asv.conf.json rolling.GroupbyLargeGroups.time_rolling_multiindex_creati\r"]
[150.004, "o", "asv profile --python=same --config=asv.conf.json rolling.GroupbyLargeGroups.time_rolling_multiindex_creati\r\n"]
[150.006, "o", "ion\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (rolling.GroupbyLargeGroups.time_rolling_multiindex_creation--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                            18.3\u00b10.08ms\r\n\r\nWed Oct  1 18:26:21 2025    /tmp/tmpy1_x7uby\r\n\r\n         2358 function calls (2304 primitive calls) in 0.019 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.019    0.019 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.019    0.019 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.019    0.019 rolling.py:322(time_rolling_multiindex_creation)\r\n        1    0.000    0.000    0.018    0.018 rolling.py:2070(mean)\r\n        1    0.000    0.000    0.018    0.018 rolling.py:1489(mean)\r\n        1    0.000    0.000    0.018    0.018 rolling.py:701(_apply)\r\n        1    0.000    0.000    0.012    0.012 multi.py:445(from_arrays)\r\n        1    0.000    0.000    0.012    0.012 categorical.py:2586(factorize_from_iterables)\r\n        2    0.000    0.000    0.012    0.006 categorical.py:2607(<genexpr>)\r\n        1    0.000    0.000    0.012    0.012 categorical.py:2545(factorize_from_iterable)\r\n        1    0.000    0.000    0.012    0.012 categorical.py:359(__init__)\r\n      3/2    0.000    0.000    0.012    0.006 algorithms.py:610(factorize)\r\n        1    0.000    0.000    0.011    0.011 base.py:1143(factorize)\r\n        2    0.000    0.000    0.010    0.005 algorithms.py:1702(safe_sort)\r\n        4    0.010    0.002    0.010    0.002 {method 'argsort' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.005    0.005 rolling.py:558(_apply)\r\n        1    0.000    0.000    0.003    0.003 rolling.py:456(_apply_blockwise)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:591(homogeneous_func)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:597(calc)\r\n        2    0.000    0.000    0.002    0.001 algorithms.py:548(factorize_array)\r\n        2    0.002    0.001    0.002    0.001 {method 'factorize' of 'pandas._libs.hashtable.Int64HashTable' objects}\r\n        1    0.000    0.000    0.002    0.002 rolling.py:2695(_get_window_indexer)\r\n        1    0.000    0.000    0.002    0.002 ops.py:784(indices)\r\n        1    0.001    0.001    0.001    0.001 {pandas._libs.window.aggregations.roll_mean}\r\n        1    0.000    0.000    0.001    0.001 objects.py:324(get_window_bounds)\r\n        1    0.000    0.000    0.001    0.001 sorting.py:599(get_indexer_dict)\r\n        1    0.000    0.000    0.001    0.001 groupby.py:2649(rolling)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:678(__init__)\r\n        1    0.000    0.000    0.001    0.001 frame.py:5087(drop)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4505(drop)\r\n       12    0.001    0.000    0.001    0.000 {method 'take' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.001    0.001 generic.py:4544(_drop_axis)\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:186(__init__)\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:339(_finalize)\r\n        2    0.000    0.000    0.001    0.000 dtypes.py:511(validate_categories)\r\n        1    0.000    0.000    0.001    0.001 ops.py:910(result_index)\r\n        2    0.001    0.000    0.001    0.000 base.py:2168(is_unique)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:846(_create_data)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:688(result_index)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:700(group_index)\r\n        6    0.000    0.000    0.001    0.000 take.py:58(take_nd)\r\n        6    0.000    0.000    0.001    0.000 take.py:120(_take_nd_ndarray)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:722(_codes_and_uniques)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3819(take)\r\n        2    0.000    0.000    0.001    0.000 managers.py:641(reindex_indexer)\r\n    27/15    0.000    0.000    0.001    0.000 {built-in method numpy.core._multiarray_umath.implement_array_function}\r\n        1    0.000    0.000    0.001    0.001 generic.py:3898(_take)\r\n        1    0.000    0.000    0.001    0.001 managers.py:886(take)\r\n        2    0.000    0.000    0.001    0.000 blocks.py:858(take_nd)\r\n        2    0.000    0.000    0.000    0.000 objects.py:76(get_window_bounds)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:632(get_group_index_sorter)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.groupsort_indexer}\r\n        2    0.000    0.000    0.000    0.000 base.py:3676(get_indexer)\r\n        1    0.000    0.000    0.000    0.000 base.py:6610(drop)\r\n        1    0.000    0.000    0.000    0.000 managers.py:705(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 base.py:1033(take)\r\n        4    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(clip)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:2111(clip)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:51(_wrapfunc)\r\n        1    0.000    0.000    0.000    0.000 managers.py:726(_slice_take_blocks_ax0)\r\n        4    0.000    0.000    0.000    0.000 {method 'clip' of 'numpy.ndarray' objects}\r\n        4    0.000    0.000    0.000    0.000 _methods.py:127(_clip)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_2d_axis0_float64_float64}\r\n        1    0.000    0.000    0.000    0.000 frame.py:8104(groupby)\r\n        6    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(concatenate)\r\n        1    0.000    0.000    0.000    0.000 base.py:5777(get_indexer_for)\r\n        1    0.000    0.000    0.000    0.000 groupby.py:896(__init__)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:790(get_grouper)\r\n        3    0.000    0.000    0.000    0.000 algorithms.py:1396(take)\r\n        4    0.000    0.000    0.000    0.000 _methods.py:108(_clip_dep_invoke_with_casting)\r\n  392/382    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        4    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_1d_int64_int64}\r\n        3    0.000    0.000    0.000    0.000 base.py:449(__new__)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_2d_axis1_float64_float64}\r\n        1    0.000    0.000    0.000    0.000 frame.py:2459(_from_arrays)\r\n        2    0.000    0.000    0.000    0.000 multi.py:313(__new__)\r\n        5    0.000    0.000    0.000    0.000 {built-in method numpy.arange}\r\n        1    0.000    0.000    0.000    0.000 sorting.py:109(get_group_index)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.indices_fast}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:742(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 construction.py:96(arrays_to_mgr)\r\n        1    0.000    0.000    0.000    0.000 frame.py:3689(__getitem__)\r\n        4    0.000    0.000    0.000    0.000 cast.py:971(coerce_indexer_dtype)\r\n        9    0.000    0.000    0.000    0.000 base.py:7014(ensure_index)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:622(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 utils.py:241(maybe_convert_indices)\r\n       12    0.000    0.000    0.000    0.000 {method 'astype' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 base.py:6305(_maybe_cast_listlike_indexer)\r\n        2    0.000    0.000    0.000    0.000 base.py:6029(_should_compare)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4220(_get_item_cache)\r\n      117    0.000    0.000    0.000    0.000 generic.py:42(_instancecheck)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:265(_get_hashtable_algo)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2069(create_block_manager_from_column_arrays)\r\n        9    0.000    0.000    0.000    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n        3    0.000    0.000    0.000    0.000 construction.py:500(sanitize_array)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2141(_form_blocks)\r\n        1    0.000    0.000    0.000    0.000 frame.py:3615(_ixs)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(append)\r\n        2    0.000    0.000    0.000    0.000 multi.py:982(_set_codes)\r\n        2    0.000    0.000    0.000    0.000 function_base.py:5444(append)\r\n        5    0.000    0.000    0.000    0.000 {method 'any' of 'numpy.ndarray' objects}\r\n        6    0.000    0.000    0.000    0.000 common.py:1241(is_bool_dtype)\r\n        5    0.000    0.000    0.000    0.000 multi.py:998(<genexpr>)\r\n       17    0.000    0.000    0.000    0.000 base.py:286(is_dtype)\r\n        5    0.000    0.000    0.000    0.000 _methods.py:55(_any)\r\n        3    0.000    0.000    0.000    0.000 multi.py:3871(_coerce_indexer_frozen)\r\n       13    0.000    0.000    0.000    0.000 common.py:458(is_categorical_dtype)\r\n   130/99    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        2    0.000    0.000    0.000    0.000 base.py:3809(_check_indexing_method)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int8}\r\n      117    0.000    0.000    0.000    0.000 generic.py:37(_check)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:355(_prep_values)\r\n        8    0.000    0.000    0.000    0.000 _methods.py:93(_clip_dep_is_scalar_nan)\r\n        2    0.000    0.000    0.000    0.000 base.py:791(_engine)\r\n       27    0.000    0.000    0.000    0.000 base.py:4892(_values)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:113(_ensure_data)\r\n        2    0.000    0.000    0.000    0.000 common.py:229(asarray_tuplesafe)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1916(__contains__)\r\n        2    0.000    0.000    0.000    0.000 base.py:5052(__contains__)\r\n        1    0.000    0.000    0.000    0.000 range.py:201(_data)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2199(_stack_arrays)\r\n        3    0.000    0.000    0.000    0.000 base.py:2599(inferred_type)\r\n        2    0.000    0.000    0.000    0.000 base.py:3764(_get_indexer)\r\n        5    0.000    0.000    0.000    0.000 {pandas._libs.lib.infer_dtype}\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:283(_check_object_for_strings)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int32}\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:344(_name_get)\r\n        3    0.000    0.000    0.000    0.000 generic.py:5975(__setattr__)\r\n        1    0.000    0.000    0.000    0.000 cast.py:1129(maybe_infer_to_datetimelike)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1039(iget)\r\n        2    0.000    0.000    0.000    0.000 common.py:420(is_interval_dtype)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:117(__init__)\r\n        1    0.000    0.000    0.000    0.000 base.py:636(_with_infer)\r\n        1    0.000    0.000    0.000    0.000 common.py:261(index_labels_to_array)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(prod)\r\n        4    0.000    0.000    0.000    0.000 algorithms.py:193(_reconstruct_data)\r\n        2    0.000    0.000    0.000    0.000 dtypes.py:1241(is_dtype)\r\n        3    0.000    0.000    0.000    0.000 fromnumeric.py:69(_wrapreduction)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.maybe_convert_objects}\r\n       12    0.000    0.000    0.000    0.000 base.py:616(_simple_new)\r\n        2    0.000    0.000    0.000    0.000 multi.py:807(_set_levels)\r\n        1    0.000    0.000    0.000    0.000 base.py:6518(delete)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:1752(_validate)\r\n        4    0.000    0.000    0.000    0.000 managers.py:163(blknos)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:2955(prod)\r\n        2    0.000    0.000    0.000    0.000 base.py:5255(equals)\r\n        1    0.000    0.000    0.000    0.000 generic.py:720(_set_axis)\r\n       16    0.000    0.000    0.000    0.000 common.py:1491(_is_dtype_type)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4203(_box_col_values)\r\n        2    0.000    0.000    0.000    0.000 typing.py:868(__new__)\r\n        1    0.000    0.000    0.000    0.000 base.py:1786(rename)\r\n        6    0.000    0.000    0.000    0.000 construction.py:402(extract_array)\r\n        4    0.000    0.000    0.000    0.000 base.py:4918(_get_engine_target)\r\n        7    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        8    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(ndim)\r\n        3    0.000    0.000    0.000    0.000 generic.py:5915(__finalize__)\r\n      152    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        2    0.000    0.000    0.000    0.000 {method '_rebuild_blknos_and_blklocs' of 'pandas._libs.internals.BlockManager' objects}\r\n        3    0.000    0.000    0.000    0.000 frame.py:640(__init__)\r\n        1    0.000    0.000    0.000    0.000 base.py:1679(set_names)\r\n        2    0.000    0.000    0.000    0.000 generic.py:1921(empty)\r\n        4    0.000    0.000    0.000    0.000 base.py:54(shape)\r\n        2    0.000    0.000    0.000    0.000 _ufunc_config.py:33(seterr)\r\n        4    0.000    0.000    0.000    0.000 common.py:1124(is_numeric_dtype)\r\n       20    0.000    0.000    0.000    0.000 common.py:1456(get_dtype)\r\n        8    0.000    0.000    0.000    0.000 common.py:157(is_object_dtype)\r\n        1    0.000    0.000    0.000    0.000 managers.py:219(set_axis)\r\n        4    0.000    0.000    0.000    0.000 generic.py:262(__init__)\r\n        1    0.000    0.000    0.000    0.000 dtypes.py:547(update_dtype)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(delete)\r\n        2    0.000    0.000    0.000    0.000 {method 'get_indexer' of 'pandas._libs.index.IndexEngine' objects}\r\n        2    0.000    0.000    0.000    0.000 blocks.py:190(fill_value)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:228(make_block_same_class)\r\n        6    0.000    0.000    0.000    0.000 take.py:564(_take_preprocess_indexer_and_fill_value)\r\n        1    0.000    0.000    0.000    0.000 numeric.py:290(full)\r\n        1    0.000    0.000    0.000    0.000 base.py:58(_validate_set_axis)\r\n        5    0.000    0.000    0.000    0.000 base.py:731(_view)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:508(__init__)\r\n        1    0.000    0.000    0.000    0.000 function_base.py:5054(delete)\r\n        1    0.000    0.000    0.000    0.000 config.py:260(__call__)\r\n        5    0.000    0.000    0.000    0.000 multi.py:828(<genexpr>)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:330(_name_includes_bit_suffix)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:430(__enter__)\r\n        1    0.000    0.000    0.000    0.000 config.py:134(_get_option)\r\n        6    0.000    0.000    0.000    0.000 common.py:549(is_dtype_equal)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:412(_resolve_output)\r\n        1    0.000    0.000    0.000    0.000 dtypes.py:209(_from_values_or_dtype)\r\n        4    0.000    0.000    0.000    0.000 base.py:5102(__getitem__)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:36(__init__)\r\n        2    0.000    0.000    0.000    0.000 multi.py:1398(_set_names)\r\n        2    0.000    0.000    0.000    0.000 missing.py:625(na_value_for_dtype)\r\n        3    0.000    0.000    0.000    0.000 base.py:559(_dtype_to_subclass)\r\n        2    0.000    0.000    0.000    0.000 base.py:6047(_is_comparable_dtype)\r\n        6    0.000    0.000    0.000    0.000 generic.py:1979(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:165(simplefilter)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(all)\r\n        8    0.000    0.000    0.000    0.000 fromnumeric.py:3152(ndim)\r\n       33    0.000    0.000    0.000    0.000 {built-in method numpy.asarray}\r\n        7    0.000    0.000    0.000    0.000 abc.py:96(__instancecheck__)\r\n       25    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_list_like}\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(ravel)\r\n       12    0.000    0.000    0.000    0.000 base.py:56(<genexpr>)\r\n        4    0.000    0.000    0.000    0.000 ops.py:830(names)\r\n        2    0.000    0.000    0.000    0.000 base.py:5949(_maybe_promote)\r\n       24    0.000    0.000    0.000    0.000 base.py:842(__len__)\r\n        1    0.000    0.000    0.000    0.000 multi.py:782(__len__)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1685(_check_label_or_level_ambiguity)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(copyto)\r\n        9    0.000    0.000    0.000    0.000 {built-in method numpy.empty}\r\n        2    0.000    0.000    0.000    0.000 numerictypes.py:356(issubdtype)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:181(_add_filter)\r\n        3    0.000    0.000    0.000    0.000 base.py:7109(maybe_extract_name)\r\n        1    0.000    0.000    0.000    0.000 _asarray.py:31(require)\r\n        1    0.000    0.000    0.000    0.000 fromnumeric.py:2432(all)\r\n        2    0.000    0.000    0.000    0.000 base.py:7144(unpack_nested_dtype)\r\n       41    0.000    0.000    0.000    0.000 {built-in method builtins.issubclass}\r\n        1    0.000    0.000    0.000    0.000 construction.py:128(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:435(__exit__)\r\n        2    0.000    0.000    0.000    0.000 frame.py:3659(_iter_column_arrays)\r\n        1    0.000    0.000    0.000    0.000 config.py:116(_get_single_key)\r\n        1    0.000    0.000    0.000    0.000 series.py:367(__init__)\r\n        1    0.000    0.000    0.000    0.000 {method 'max' of 'numpy.ndarray' objects}\r\n        5    0.000    0.000    0.000    0.000 cast.py:559(maybe_promote)\r\n        7    0.000    0.000    0.000    0.000 {built-in method _abc._abc_instancecheck}\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:1781(ravel)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:1021(_convert_grouper)\r\n        1    0.000    0.000    0.000    0.000 frozen.py:73(__getitem__)\r\n        6    0.000    0.000    0.000    0.000 base.py:120(_reset_cache)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:733(codes)\r\n        6    0.000    0.000    0.000    0.000 generic.py:520(_get_axis)\r\n       24    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_platform_int}\r\n        1    0.000    0.000    0.000    0.000 objects.py:288(__init__)\r\n       28    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:230(_validate_numeric_only)\r\n        2    0.000    0.000    0.000    0.000 common.py:651(is_integer_dtype)\r\n        2    0.000    0.000    0.000    0.000 common.py:1206(is_float_dtype)\r\n        1    0.000    0.000    0.000    0.000 multi.py:796(levels)\r\n        1    0.000    0.000    0.000    0.000 _methods.py:39(_amax)\r\n        2    0.000    0.000    0.000    0.000 base.py:432(_engine_type)\r\n        7    0.000    0.000    0.000    0.000 inference.py:189(is_array_like)\r\n        2    0.000    0.000    0.000    0.000 inference.py:267(is_dict_like)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:38(_remove)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:619(_passed_categorical)\r\n        2    0.000    0.000    0.000    0.000 _ufunc_config.py:132(geterr)\r\n        6    0.000    0.000    0.000    0.000 common.py:151(<lambda>)\r\n       14    0.000    0.000    0.000    0.000 base.py:780(_reset_identity)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:116(update)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:458(__enter__)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:162(_validate)\r\n        6    0.000    0.000    0.000    0.000 common.py:1074(needs_i8_conversion)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:379(_insert_on_column)\r\n        2    0.000    0.000    0.000    0.000 base.py:2641(_na_value)\r\n        4    0.000    0.000    0.000    0.000 ops.py:832(<listcomp>)\r\n        6    0.000    0.000    0.000    0.000 common.py:1386(is_ea_or_datetimelike_dtype)\r\n        4    0.000    0.000    0.000    0.000 numerictypes.py:282(issubclass_)\r\n        1    0.000    0.000    0.000    0.000 base.py:1634(_set_names)\r\n        3    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap>:1017(_handle_fromlist)\r\n        4    0.000    0.000    0.000    0.000 _weakrefset.py:81(add)\r\n        8    0.000    0.000    0.000    0.000 _methods.py:103(_clip_dep_is_byte_swapped)\r\n        1    0.000    0.000    0.000    0.000 series.py:1262(_set_as_cached)\r\n        2    0.000    0.000    0.000    0.000 managers.py:974(from_blocks)\r\n        1    0.000    0.000    0.000    0.000 multi.py:801(<listcomp>)\r\n        6    0.000    0.000    0.000    0.000 take.py:325(_get_take_nd_function)\r\n        7    0.000    0.000    0.000    0.000 inference.py:328(is_hashable)\r\n        4    0.000    0.000    0.000    0.000 common.py:1332(is_extension_array_dtype)\r\n       16    0.000    0.000    0.000    0.000 {built-in method __new__ of type object at 0x55edbfb9c680}\r\n        1    0.000    0.000    0.000    0.000 frame.py:3649(_get_column_array)\r\n       10    0.000    0.000    0.000    0.000 common.py:143(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:404(_index_array)\r\n        3    0.000    0.000    0.000    0.000 {built-in method builtins.all}\r\n        3    0.000    0.000    0.000    0.000 base.py:1631(_get_names)\r\n       12    0.000    0.000    0.000    0.000 generic.py:506(_get_axis_number)\r\n        2    0.000    0.000    0.000    0.000 frame.py:903(shape)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1775(_consolidate_inplace)\r\n        2    0.000    0.000    0.000    0.000 {method 'format' of 'str' objects}\r\n        3    0.000    0.000    0.000    0.000 base.py:2623(_is_multi)\r\n        3    0.000    0.000    0.000    0.000 construction.py:650(_sanitize_ndim)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1053(iget_values)\r\n        1    0.000    0.000    0.000    0.000 base.py:3585(get_loc)\r\n        1    0.000    0.000    0.000    0.000 base.py:740(_rename)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:231(_ensure_arraylike)\r\n        1    0.000    0.000    0.000    0.000 base.py:2664(hasnans)\r\n        1    0.000    0.000    0.000    0.000 series.py:691(_values)\r\n        3    0.000    0.000    0.000    0.000 objects.py:46(__init__)\r\n        4    0.000    0.000    0.000    0.000 flags.py:49(__init__)\r\n        5    0.000    0.000    0.000    0.000 {built-in method numpy.asanyarray}\r\n        2    0.000    0.000    0.000    0.000 copy.py:66(copy)\r\n        3    0.000    0.000    0.000    0.000 base.py:541(_ensure_array)\r\n        4    0.000    0.000    0.000    0.000 common.py:150(cast_scalar_indexer)\r\n        6    0.000    0.000    0.000    0.000 range.py:889(__len__)\r\n        2    0.000    0.000    0.000    0.000 {method 'remove' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 config.py:595(_get_root)\r\n        4    0.000    0.000    0.000    0.000 common.py:1649(pandas_dtype)\r\n        6    0.000    0.000    0.000    0.000 __init__.py:33(using_copy_on_write)\r\n        2    0.000    0.000    0.000    0.000 missing.py:455(array_equivalent)\r\n        3    0.000    0.000    0.000    0.000 flags.py:85(allows_duplicate_labels)\r\n        2    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        4    0.000    0.000    0.000    0.000 common.py:274(is_datetime64_dtype)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1757(is_consolidated)\r\n        2    0.000    0.000    0.000    0.000 common.py:1432(_is_dtype)\r\n        2    0.000    0.000    0.000    0.000 missing.py:949(clean_reindex_fill_method)\r\n        2    0.000    0.000    0.000    0.000 range.py:307(dtype)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2125(_grouping_func)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:697(categories)\r\n        1    0.000    0.000    0.000    0.000 blocks.py:2211(get_block_type)\r\n        4    0.000    0.000    0.000    0.000 dtypes.py:492(validate_ordered)\r\n        1    0.000    0.000    0.000    0.000 _asarray.py:112(<setcomp>)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:220(_slice_axis_for_step)\r\n        1    0.000    0.000    0.000    0.000 config.py:648(_warn_if_deprecated)\r\n        1    0.000    0.000    0.000    0.000 ops.py:821(codes)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:24(_kind_name)\r\n        3    0.000    0.000    0.000    0.000 construction.py:689(_sanitize_str_dtypes)\r\n       10    0.000    0.000    0.000    0.000 common.py:141(classes)\r\n        8    0.000    0.000    0.000    0.000 base.py:1545(name)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:437(__init__)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:477(__exit__)\r\n        6    0.000    0.000    0.000    0.000 inference.py:294(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 common.py:1624(validate_all_hashable)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2273(_preprocess_slice_or_indexer)\r\n        6    0.000    0.000    0.000    0.000 common.py:146(classes_and_not_datetimelike)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:724(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:891(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 ops.py:685(__init__)\r\n       11    0.000    0.000    0.000    0.000 ops.py:699(groupings)\r\n        4    0.000    0.000    0.000    0.000 common.py:350(is_timedelta64_dtype)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:623(name)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:312(__getattr__)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:824(iget)\r\n        1    0.000    0.000    0.000    0.000 base.py:2070(_can_hold_na)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1961(internal_values)\r\n        2    0.000    0.000    0.000    0.000 {built-in method numpy.seterrobj}\r\n        9    0.000    0.000    0.000    0.000 {built-in method builtins.hash}\r\n        6    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        7    0.000    0.000    0.000    0.000 generic.py:620(ndim)\r\n        3    0.000    0.000    0.000    0.000 construction.py:464(ensure_wrapped_if_datetimelike)\r\n        2    0.000    0.000    0.000    0.000 {method 'copy' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 multi.py:506(<listcomp>)\r\n       11    0.000    0.000    0.000    0.000 base.py:324(ndim)\r\n        1    0.000    0.000    0.000    0.000 indexing.py:2606(check_dict_or_set_indexers)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:264(_create_data)\r\n        1    0.000    0.000    0.000    0.000 generic.py:526(_get_block_manager_axis)\r\n        3    0.000    0.000    0.000    0.000 fromnumeric.py:70(<dictcomp>)\r\n        1    0.000    0.000    0.000    0.000 generic.py:596(_info_axis)\r\n        2    0.000    0.000    0.000    0.000 base.py:749(is_)\r\n        2    0.000    0.000    0.000    0.000 config.py:609(_get_deprecated_option)\r\n        2    0.000    0.000    0.000    0.000 {method 'ravel' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:205(_check_window_bounds)\r\n        3    0.000    0.000    0.000    0.000 base.py:654(_constructor)\r\n        2    0.000    0.000    0.000    0.000 sorting.py:608(<genexpr>)\r\n        4    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        4    0.000    0.000    0.000    0.000 {built-in method numpy.geterrobj}\r\n        1    0.000    0.000    0.000    0.000 grouper.py:943(is_in_obj)\r\n        6    0.000    0.000    0.000    0.000 base.py:898(dtype)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:426(__init__)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:157(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 ops.py:824(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:144(_int64_cut_off)\r\n        9    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        2    0.000    0.000    0.000    0.000 grouper.py:893(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 _validators.py:222(validate_bool_kwarg)\r\n        4    0.000    0.000    0.000    0.000 multi.py:943(nlevels)\r\n        2    0.000    0.000    0.000    0.000 multi.py:1395(_get_names)\r\n        8    0.000    0.000    0.000    0.000 fromnumeric.py:3148(_ndim_dispatcher)\r\n        6    0.000    0.000    0.000    0.000 multiarray.py:152(concatenate)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1765(_consolidate_check)\r\n        1    0.000    0.000    0.000    0.000 ops.py:790(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 ops.py:826(levels)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:927(is_in_axis)\r\n        8    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 groupby.py:720(_selected_obj)\r\n        6    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_bool}\r\n        4    0.000    0.000    0.000    0.000 managers.py:179(blklocs)\r\n        1    0.000    0.000    0.000    0.000 groupby.py:945(__getattr__)\r\n        1    0.000    0.000    0.000    0.000 numba_.py:18(maybe_use_numba)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4217(_clear_item_cache)\r\n        7    0.000    0.000    0.000    0.000 {method 'clear' of 'dict' objects}\r\n        3    0.000    0.000    0.000    0.000 {method 'discard' of 'set' objects}\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_scalar}\r\n        5    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\r\n        2    0.000    0.000    0.000    0.000 missing.py:121(clean_fill_method)\r\n        2    0.000    0.000    0.000    0.000 frame.py:631(_constructor)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:459(dtype)\r\n        7    0.000    0.000    0.000    0.000 typing.py:1149(cast)\r\n        1    0.000    0.000    0.000    0.000 config.py:577(_select_options)\r\n        3    0.000    0.000    0.000    0.000 generic.py:335(attrs)\r\n        3    0.000    0.000    0.000    0.000 base.py:1064(_maybe_disallow_fill)\r\n        2    0.000    0.000    0.000    0.000 common.py:1643(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.max}\r\n        1    0.000    0.000    0.000    0.000 range.py:482(equals)\r\n        5    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_integer}\r\n        2    0.000    0.000    0.000    0.000 grouper.py:669(codes)\r\n        6    0.000    0.000    0.000    0.000 {built-in method _warnings._filters_mutated}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.internals.get_blkno_placements}\r\n        5    0.000    0.000    0.000    0.000 dtypes.py:580(categories)\r\n        3    0.000    0.000    0.000    0.000 base.py:5937(_index_as_unique)\r\n        1    0.000    0.000    0.000    0.000 config.py:636(_translate_key)\r\n        6    0.000    0.000    0.000    0.000 generic.py:356(flags)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:2107(_clip_dispatcher)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:892(<genexpr>)\r\n        3    0.000    0.000    0.000    0.000 flags.py:53(allows_duplicate_labels)\r\n        1    0.000    0.000    0.000    0.000 managers.py:224(is_single_block)\r\n        3    0.000    0.000    0.000    0.000 managers.py:939(__init__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1799(__init__)\r\n        2    0.000    0.000    0.000    0.000 {method 'insert' of 'list' objects}\r\n        2    0.000    0.000    0.000    0.000 common.py:1165(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:227(is_int64_overflow_possible)\r\n        3    0.000    0.000    0.000    0.000 dtypes.py:587(ordered)\r\n        4    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_float}\r\n        1    0.000    0.000    0.000    0.000 base.py:200(_selected_obj)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:1768(_codes)\r\n        1    0.000    0.000    0.000    0.000 range.py:248(start)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:1017(_is_label_like)\r\n        1    0.000    0.000    0.000    0.000 common.py:367(apply_if_callable)\r\n        1    0.000    0.000    0.000    0.000 common.py:1319(is_1d_only_ea_dtype)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_iterator}\r\n        1    0.000    0.000    0.000    0.000 blocks.py:476(dtype)\r\n        1    0.000    0.000    0.000    0.000 {method 'item' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 {method 'values' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 frame.py:886(axes)\r\n        1    0.000    0.000    0.000    0.000 ops.py:828(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 {method 'get_loc' of 'pandas._libs.index.IndexEngine' objects}\r\n        3    0.000    0.000    0.000    0.000 construction.py:709(_maybe_repeat)\r\n        1    0.000    0.000    0.000    0.000 ops.py:791(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 function.py:60(__call__)\r\n        2    0.000    0.000    0.000    0.000 {method 'extend' of 'list' objects}\r\n        2    0.000    0.000    0.000    0.000 function_base.py:5440(_append_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 {method 'upper' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 grouper.py:641(_ilevel)\r\n        1    0.000    0.000    0.000    0.000 managers.py:229(items)\r\n        2    0.000    0.000    0.000    0.000 multi.py:978(codes)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:1777(_ravel_dispatcher)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:2950(_prod_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 range.py:195(_constructor)\r\n        1    0.000    0.000    0.000    0.000 {method 'split' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.item_from_zerodim}\r\n        1    0.000    0.000    0.000    0.000 managers.py:1894(_block)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_float64}\r\n        2    0.000    0.000    0.000    0.000 {built-in method builtins.callable}\r\n        1    0.000    0.000    0.000    0.000 range.py:263(step)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int64}\r\n        1    0.000    0.000    0.000    0.000 series.py:594(name)\r\n        1    0.000    0.000    0.000    0.000 fromnumeric.py:2427(_all_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 multiarray.py:1079(copyto)\r\n        2    0.000    0.000    0.000    0.000 {method 'copy' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 function_base.py:5050(_delete_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 base.py:6298(_maybe_cast_indexer)\r\n        1    0.000    0.000    0.000    0.000 {method 'pop' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 generic.py:1706(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 range.py:256(stop)\r\n        1    0.000    0.000    0.000    0.000 {function FrozenList.__getitem__ at 0x7fcbe8b6d280}\r\n\r\n\r\n"]
[155.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[155.002, "i", "asv profile --python=same --config=asv.conf.json rolling.Groupby.time_method\r"]
[155.004, "o", "asv profile --python=same --config=asv.conf.json rolling.Groupby.time_method\r\n"]
[155.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;31m'rolling.Groupby.time_method' benchmark not found\u001b[0m\r\n"]
[160.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[160.002, "i", "asv profile --python=same --config=asv.conf.json rolling.GroupbyLargeGroups.time_rolling_multiindex_creati\r"]
[160.004, "o", "asv profile --python=same --config=asv.conf.json rolling.GroupbyLargeGroups.time_rolling_multiindex_creati\r\n"]
[160.006, "o", "ion\r\n\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (rolling.GroupbyLargeGroups.time_rolling_multiindex_creation--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                             18.7\u00b10.2ms\r\n\r\nWed Oct  1 18:28:18 2025    /tmp/tmp72ogkcsg\r\n\r\n         2358 function calls (2304 primitive calls) in 0.019 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.019    0.019 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.019    0.019 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.019    0.019 rolling.py:322(time_rolling_multiindex_creation)\r\n        1    0.000    0.000    0.018    0.018 rolling.py:2070(mean)\r\n        1    0.000    0.000    0.018    0.018 rolling.py:1489(mean)\r\n        1    0.000    0.000    0.018    0.018 rolling.py:701(_apply)\r\n        1    0.000    0.000    0.013    0.013 multi.py:445(from_arrays)\r\n        1    0.000    0.000    0.013    0.013 categorical.py:2586(factorize_from_iterables)\r\n        2    0.000    0.000    0.013    0.006 categorical.py:2607(<genexpr>)\r\n        1    0.000    0.000    0.013    0.013 categorical.py:2545(factorize_from_iterable)\r\n        1    0.000    0.000    0.013    0.013 categorical.py:359(__init__)\r\n      3/2    0.000    0.000    0.012    0.006 algorithms.py:610(factorize)\r\n        1    0.000    0.000    0.012    0.012 base.py:1143(factorize)\r\n        2    0.000    0.000    0.010    0.005 algorithms.py:1702(safe_sort)\r\n        4    0.010    0.002    0.010    0.002 {method 'argsort' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.005    0.005 rolling.py:558(_apply)\r\n        1    0.000    0.000    0.003    0.003 rolling.py:456(_apply_blockwise)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:591(homogeneous_func)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:597(calc)\r\n        2    0.000    0.000    0.002    0.001 algorithms.py:548(factorize_array)\r\n        2    0.002    0.001    0.002    0.001 {method 'factorize' of 'pandas._libs.hashtable.Int64HashTable' objects}\r\n        1    0.000    0.000    0.002    0.002 rolling.py:2695(_get_window_indexer)\r\n        1    0.000    0.000    0.002    0.002 ops.py:784(indices)\r\n        1    0.001    0.001    0.001    0.001 {pandas._libs.window.aggregations.roll_mean}\r\n        1    0.000    0.000    0.001    0.001 sorting.py:599(get_indexer_dict)\r\n        1    0.000    0.000    0.001    0.001 objects.py:324(get_window_bounds)\r\n        1    0.000    0.000    0.001    0.001 groupby.py:2649(rolling)\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:186(__init__)\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:339(_finalize)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:678(__init__)\r\n        2    0.000    0.000    0.001    0.000 dtypes.py:511(validate_categories)\r\n        2    0.001    0.000    0.001    0.000 base.py:2168(is_unique)\r\n       12    0.001    0.000    0.001    0.000 {method 'take' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.001    0.001 frame.py:5087(drop)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4505(drop)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4544(_drop_axis)\r\n        1    0.000    0.000    0.001    0.001 ops.py:910(result_index)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:688(result_index)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:700(group_index)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:846(_create_data)\r\n        6    0.000    0.000    0.001    0.000 take.py:58(take_nd)\r\n        6    0.000    0.000    0.001    0.000 take.py:120(_take_nd_ndarray)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:722(_codes_and_uniques)\r\n        2    0.000    0.000    0.001    0.000 managers.py:641(reindex_indexer)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3819(take)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3898(_take)\r\n    27/15    0.000    0.000    0.001    0.000 {built-in method numpy.core._multiarray_umath.implement_array_function}\r\n        1    0.000    0.000    0.001    0.001 managers.py:886(take)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:858(take_nd)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:632(get_group_index_sorter)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.groupsort_indexer}\r\n        2    0.000    0.000    0.000    0.000 objects.py:76(get_window_bounds)\r\n        1    0.000    0.000    0.000    0.000 base.py:6610(drop)\r\n        2    0.000    0.000    0.000    0.000 base.py:3676(get_indexer)\r\n        1    0.000    0.000    0.000    0.000 managers.py:705(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 base.py:1033(take)\r\n        1    0.000    0.000    0.000    0.000 managers.py:726(_slice_take_blocks_ax0)\r\n        1    0.000    0.000    0.000    0.000 frame.py:8104(groupby)\r\n        4    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(clip)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:2111(clip)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:51(_wrapfunc)\r\n        4    0.000    0.000    0.000    0.000 {method 'clip' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_2d_axis0_float64_float64}\r\n        4    0.000    0.000    0.000    0.000 _methods.py:127(_clip)\r\n        6    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(concatenate)\r\n        1    0.000    0.000    0.000    0.000 groupby.py:896(__init__)\r\n        1    0.000    0.000    0.000    0.000 base.py:5777(get_indexer_for)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:790(get_grouper)\r\n  392/382    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        3    0.000    0.000    0.000    0.000 algorithms.py:1396(take)\r\n        4    0.000    0.000    0.000    0.000 _methods.py:108(_clip_dep_invoke_with_casting)\r\n        4    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_1d_int64_int64}\r\n        3    0.000    0.000    0.000    0.000 base.py:449(__new__)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_2d_axis1_float64_float64}\r\n        1    0.000    0.000    0.000    0.000 frame.py:2459(_from_arrays)\r\n        2    0.000    0.000    0.000    0.000 multi.py:313(__new__)\r\n        5    0.000    0.000    0.000    0.000 {built-in method numpy.arange}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.indices_fast}\r\n        1    0.000    0.000    0.000    0.000 frame.py:3689(__getitem__)\r\n        1    0.000    0.000    0.000    0.000 construction.py:96(arrays_to_mgr)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:109(get_group_index)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:265(_get_hashtable_algo)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:742(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 utils.py:241(maybe_convert_indices)\r\n        9    0.000    0.000    0.000    0.000 base.py:7014(ensure_index)\r\n        4    0.000    0.000    0.000    0.000 cast.py:971(coerce_indexer_dtype)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4220(_get_item_cache)\r\n        2    0.000    0.000    0.000    0.000 base.py:6305(_maybe_cast_listlike_indexer)\r\n      117    0.000    0.000    0.000    0.000 generic.py:42(_instancecheck)\r\n       12    0.000    0.000    0.000    0.000 {method 'astype' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 managers.py:2069(create_block_manager_from_column_arrays)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:622(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 base.py:6029(_should_compare)\r\n        3    0.000    0.000    0.000    0.000 construction.py:500(sanitize_array)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2141(_form_blocks)\r\n        9    0.000    0.000    0.000    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(append)\r\n        1    0.000    0.000    0.000    0.000 frame.py:3615(_ixs)\r\n        2    0.000    0.000    0.000    0.000 function_base.py:5444(append)\r\n        2    0.000    0.000    0.000    0.000 multi.py:982(_set_codes)\r\n        6    0.000    0.000    0.000    0.000 common.py:1241(is_bool_dtype)\r\n        5    0.000    0.000    0.000    0.000 {method 'any' of 'numpy.ndarray' objects}\r\n       17    0.000    0.000    0.000    0.000 base.py:286(is_dtype)\r\n        5    0.000    0.000    0.000    0.000 multi.py:998(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:113(_ensure_data)\r\n        5    0.000    0.000    0.000    0.000 _methods.py:55(_any)\r\n       13    0.000    0.000    0.000    0.000 common.py:458(is_categorical_dtype)\r\n        3    0.000    0.000    0.000    0.000 multi.py:3871(_coerce_indexer_frozen)\r\n   130/99    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n      117    0.000    0.000    0.000    0.000 generic.py:37(_check)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int8}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:355(_prep_values)\r\n       27    0.000    0.000    0.000    0.000 base.py:4892(_values)\r\n        8    0.000    0.000    0.000    0.000 _methods.py:93(_clip_dep_is_scalar_nan)\r\n        2    0.000    0.000    0.000    0.000 base.py:791(_engine)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2199(_stack_arrays)\r\n        2    0.000    0.000    0.000    0.000 common.py:229(asarray_tuplesafe)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1916(__contains__)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:283(_check_object_for_strings)\r\n        2    0.000    0.000    0.000    0.000 base.py:5052(__contains__)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:344(_name_get)\r\n        1    0.000    0.000    0.000    0.000 range.py:201(_data)\r\n        1    0.000    0.000    0.000    0.000 cast.py:1129(maybe_infer_to_datetimelike)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int32}\r\n        3    0.000    0.000    0.000    0.000 base.py:2599(inferred_type)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1039(iget)\r\n        2    0.000    0.000    0.000    0.000 base.py:3764(_get_indexer)\r\n        5    0.000    0.000    0.000    0.000 {pandas._libs.lib.infer_dtype}\r\n        3    0.000    0.000    0.000    0.000 generic.py:5975(__setattr__)\r\n        1    0.000    0.000    0.000    0.000 common.py:261(index_labels_to_array)\r\n        1    0.000    0.000    0.000    0.000 base.py:636(_with_infer)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:117(__init__)\r\n        6    0.000    0.000    0.000    0.000 take.py:564(_take_preprocess_indexer_and_fill_value)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.maybe_convert_objects}\r\n        2    0.000    0.000    0.000    0.000 base.py:3809(_check_indexing_method)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(prod)\r\n        4    0.000    0.000    0.000    0.000 algorithms.py:193(_reconstruct_data)\r\n       16    0.000    0.000    0.000    0.000 common.py:1491(_is_dtype_type)\r\n       12    0.000    0.000    0.000    0.000 base.py:616(_simple_new)\r\n        2    0.000    0.000    0.000    0.000 multi.py:807(_set_levels)\r\n        3    0.000    0.000    0.000    0.000 fromnumeric.py:69(_wrapreduction)\r\n        4    0.000    0.000    0.000    0.000 managers.py:163(blknos)\r\n        1    0.000    0.000    0.000    0.000 base.py:6518(delete)\r\n        6    0.000    0.000    0.000    0.000 construction.py:402(extract_array)\r\n        2    0.000    0.000    0.000    0.000 base.py:5255(equals)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:1752(_validate)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:2955(prod)\r\n        1    0.000    0.000    0.000    0.000 generic.py:720(_set_axis)\r\n        5    0.000    0.000    0.000    0.000 cast.py:559(maybe_promote)\r\n        2    0.000    0.000    0.000    0.000 {method '_rebuild_blknos_and_blklocs' of 'pandas._libs.internals.BlockManager' objects}\r\n        1    0.000    0.000    0.000    0.000 frame.py:4203(_box_col_values)\r\n      152    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        2    0.000    0.000    0.000    0.000 typing.py:868(__new__)\r\n        1    0.000    0.000    0.000    0.000 base.py:1786(rename)\r\n        4    0.000    0.000    0.000    0.000 base.py:4918(_get_engine_target)\r\n        8    0.000    0.000    0.000    0.000 common.py:157(is_object_dtype)\r\n        8    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(ndim)\r\n        7    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        4    0.000    0.000    0.000    0.000 common.py:1124(is_numeric_dtype)\r\n        1    0.000    0.000    0.000    0.000 base.py:1679(set_names)\r\n        3    0.000    0.000    0.000    0.000 generic.py:5915(__finalize__)\r\n        2    0.000    0.000    0.000    0.000 _ufunc_config.py:33(seterr)\r\n        2    0.000    0.000    0.000    0.000 generic.py:1921(empty)\r\n       20    0.000    0.000    0.000    0.000 common.py:1456(get_dtype)\r\n        1    0.000    0.000    0.000    0.000 dtypes.py:547(update_dtype)\r\n        4    0.000    0.000    0.000    0.000 base.py:54(shape)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(delete)\r\n        1    0.000    0.000    0.000    0.000 managers.py:219(set_axis)\r\n        3    0.000    0.000    0.000    0.000 frame.py:640(__init__)\r\n        1    0.000    0.000    0.000    0.000 numeric.py:290(full)\r\n        1    0.000    0.000    0.000    0.000 base.py:58(_validate_set_axis)\r\n        4    0.000    0.000    0.000    0.000 generic.py:262(__init__)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:508(__init__)\r\n        1    0.000    0.000    0.000    0.000 function_base.py:5054(delete)\r\n        2    0.000    0.000    0.000    0.000 {method 'get_indexer' of 'pandas._libs.index.IndexEngine' objects}\r\n        1    0.000    0.000    0.000    0.000 config.py:260(__call__)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:330(_name_includes_bit_suffix)\r\n        2    0.000    0.000    0.000    0.000 common.py:420(is_interval_dtype)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:430(__enter__)\r\n        5    0.000    0.000    0.000    0.000 base.py:731(_view)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:190(fill_value)\r\n        3    0.000    0.000    0.000    0.000 base.py:559(_dtype_to_subclass)\r\n        1    0.000    0.000    0.000    0.000 config.py:134(_get_option)\r\n        5    0.000    0.000    0.000    0.000 multi.py:828(<genexpr>)\r\n        4    0.000    0.000    0.000    0.000 base.py:5102(__getitem__)\r\n        2    0.000    0.000    0.000    0.000 multi.py:1398(_set_names)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:228(make_block_same_class)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:412(_resolve_output)\r\n       25    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_list_like}\r\n        1    0.000    0.000    0.000    0.000 dtypes.py:209(_from_values_or_dtype)\r\n        6    0.000    0.000    0.000    0.000 common.py:549(is_dtype_equal)\r\n        2    0.000    0.000    0.000    0.000 base.py:6047(_is_comparable_dtype)\r\n       33    0.000    0.000    0.000    0.000 {built-in method numpy.asarray}\r\n        6    0.000    0.000    0.000    0.000 generic.py:1979(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:165(simplefilter)\r\n       24    0.000    0.000    0.000    0.000 base.py:842(__len__)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(ravel)\r\n        8    0.000    0.000    0.000    0.000 fromnumeric.py:3152(ndim)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(all)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1685(_check_label_or_level_ambiguity)\r\n        2    0.000    0.000    0.000    0.000 dtypes.py:1241(is_dtype)\r\n        2    0.000    0.000    0.000    0.000 missing.py:625(na_value_for_dtype)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:36(__init__)\r\n        2    0.000    0.000    0.000    0.000 base.py:5949(_maybe_promote)\r\n       12    0.000    0.000    0.000    0.000 base.py:56(<genexpr>)\r\n        4    0.000    0.000    0.000    0.000 ops.py:830(names)\r\n        7    0.000    0.000    0.000    0.000 abc.py:96(__instancecheck__)\r\n        2    0.000    0.000    0.000    0.000 numerictypes.py:356(issubdtype)\r\n        1    0.000    0.000    0.000    0.000 multi.py:782(__len__)\r\n        1    0.000    0.000    0.000    0.000 base.py:3585(get_loc)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(copyto)\r\n        9    0.000    0.000    0.000    0.000 {built-in method numpy.empty}\r\n        1    0.000    0.000    0.000    0.000 construction.py:128(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 _asarray.py:31(require)\r\n        2    0.000    0.000    0.000    0.000 common.py:651(is_integer_dtype)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:435(__exit__)\r\n        3    0.000    0.000    0.000    0.000 base.py:7109(maybe_extract_name)\r\n        1    0.000    0.000    0.000    0.000 config.py:116(_get_single_key)\r\n       41    0.000    0.000    0.000    0.000 {built-in method builtins.issubclass}\r\n        2    0.000    0.000    0.000    0.000 warnings.py:181(_add_filter)\r\n        1    0.000    0.000    0.000    0.000 fromnumeric.py:2432(all)\r\n        2    0.000    0.000    0.000    0.000 base.py:7144(unpack_nested_dtype)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:733(codes)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:1781(ravel)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:1021(_convert_grouper)\r\n        1    0.000    0.000    0.000    0.000 frozen.py:73(__getitem__)\r\n       24    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_platform_int}\r\n        1    0.000    0.000    0.000    0.000 {method 'max' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 frame.py:3659(_iter_column_arrays)\r\n        7    0.000    0.000    0.000    0.000 inference.py:189(is_array_like)\r\n       28    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        6    0.000    0.000    0.000    0.000 base.py:120(_reset_cache)\r\n        6    0.000    0.000    0.000    0.000 generic.py:520(_get_axis)\r\n        6    0.000    0.000    0.000    0.000 common.py:151(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 multi.py:796(levels)\r\n        2    0.000    0.000    0.000    0.000 _ufunc_config.py:132(geterr)\r\n        7    0.000    0.000    0.000    0.000 {built-in method _abc._abc_instancecheck}\r\n        1    0.000    0.000    0.000    0.000 series.py:367(__init__)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:38(_remove)\r\n        1    0.000    0.000    0.000    0.000 objects.py:288(__init__)\r\n        1    0.000    0.000    0.000    0.000 _methods.py:39(_amax)\r\n        2    0.000    0.000    0.000    0.000 inference.py:267(is_dict_like)\r\n        2    0.000    0.000    0.000    0.000 common.py:1206(is_float_dtype)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:619(_passed_categorical)\r\n        6    0.000    0.000    0.000    0.000 common.py:1074(needs_i8_conversion)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:230(_validate_numeric_only)\r\n       14    0.000    0.000    0.000    0.000 base.py:780(_reset_identity)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:379(_insert_on_column)\r\n        2    0.000    0.000    0.000    0.000 base.py:432(_engine_type)\r\n        3    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap>:1017(_handle_fromlist)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:162(_validate)\r\n        6    0.000    0.000    0.000    0.000 common.py:1386(is_ea_or_datetimelike_dtype)\r\n        4    0.000    0.000    0.000    0.000 numerictypes.py:282(issubclass_)\r\n        8    0.000    0.000    0.000    0.000 _methods.py:103(_clip_dep_is_byte_swapped)\r\n        1    0.000    0.000    0.000    0.000 base.py:1634(_set_names)\r\n        1    0.000    0.000    0.000    0.000 series.py:1262(_set_as_cached)\r\n        4    0.000    0.000    0.000    0.000 _weakrefset.py:81(add)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:458(__enter__)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:116(update)\r\n        3    0.000    0.000    0.000    0.000 base.py:2623(_is_multi)\r\n        6    0.000    0.000    0.000    0.000 take.py:325(_get_take_nd_function)\r\n       10    0.000    0.000    0.000    0.000 common.py:143(<lambda>)\r\n        2    0.000    0.000    0.000    0.000 base.py:2641(_na_value)\r\n        4    0.000    0.000    0.000    0.000 ops.py:832(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 base.py:1631(_get_names)\r\n        1    0.000    0.000    0.000    0.000 multi.py:801(<listcomp>)\r\n       16    0.000    0.000    0.000    0.000 {built-in method __new__ of type object at 0x55cac2099680}\r\n        7    0.000    0.000    0.000    0.000 inference.py:328(is_hashable)\r\n        4    0.000    0.000    0.000    0.000 common.py:1332(is_extension_array_dtype)\r\n        3    0.000    0.000    0.000    0.000 {built-in method builtins.all}\r\n        1    0.000    0.000    0.000    0.000 frame.py:3649(_get_column_array)\r\n        2    0.000    0.000    0.000    0.000 frame.py:903(shape)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:231(_ensure_arraylike)\r\n        3    0.000    0.000    0.000    0.000 construction.py:650(_sanitize_ndim)\r\n       12    0.000    0.000    0.000    0.000 generic.py:506(_get_axis_number)\r\n        2    0.000    0.000    0.000    0.000 {method 'format' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:404(_index_array)\r\n        2    0.000    0.000    0.000    0.000 managers.py:974(from_blocks)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1775(_consolidate_inplace)\r\n        1    0.000    0.000    0.000    0.000 series.py:691(_values)\r\n        1    0.000    0.000    0.000    0.000 base.py:2664(hasnans)\r\n        5    0.000    0.000    0.000    0.000 {built-in method numpy.asanyarray}\r\n        4    0.000    0.000    0.000    0.000 common.py:150(cast_scalar_indexer)\r\n        2    0.000    0.000    0.000    0.000 copy.py:66(copy)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1053(iget_values)\r\n        4    0.000    0.000    0.000    0.000 flags.py:49(__init__)\r\n        1    0.000    0.000    0.000    0.000 config.py:595(_get_root)\r\n        6    0.000    0.000    0.000    0.000 __init__.py:33(using_copy_on_write)\r\n        4    0.000    0.000    0.000    0.000 dtypes.py:492(validate_ordered)\r\n        1    0.000    0.000    0.000    0.000 base.py:740(_rename)\r\n        4    0.000    0.000    0.000    0.000 common.py:274(is_datetime64_dtype)\r\n        3    0.000    0.000    0.000    0.000 objects.py:46(__init__)\r\n        4    0.000    0.000    0.000    0.000 common.py:1649(pandas_dtype)\r\n        6    0.000    0.000    0.000    0.000 range.py:889(__len__)\r\n        3    0.000    0.000    0.000    0.000 flags.py:85(allows_duplicate_labels)\r\n        3    0.000    0.000    0.000    0.000 base.py:541(_ensure_array)\r\n        2    0.000    0.000    0.000    0.000 common.py:1432(_is_dtype)\r\n        1    0.000    0.000    0.000    0.000 blocks.py:2211(get_block_type)\r\n        2    0.000    0.000    0.000    0.000 missing.py:455(array_equivalent)\r\n        2    0.000    0.000    0.000    0.000 {method 'remove' of 'list' objects}\r\n        3    0.000    0.000    0.000    0.000 construction.py:689(_sanitize_str_dtypes)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:697(categories)\r\n        1    0.000    0.000    0.000    0.000 ops.py:821(codes)\r\n        6    0.000    0.000    0.000    0.000 common.py:146(classes_and_not_datetimelike)\r\n        2    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        1    0.000    0.000    0.000    0.000 managers.py:2125(_grouping_func)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:437(__init__)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:24(_kind_name)\r\n       11    0.000    0.000    0.000    0.000 ops.py:699(groupings)\r\n        1    0.000    0.000    0.000    0.000 _asarray.py:112(<setcomp>)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:220(_slice_axis_for_step)\r\n       10    0.000    0.000    0.000    0.000 common.py:141(classes)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1757(is_consolidated)\r\n        1    0.000    0.000    0.000    0.000 common.py:1624(validate_all_hashable)\r\n        1    0.000    0.000    0.000    0.000 config.py:648(_warn_if_deprecated)\r\n        2    0.000    0.000    0.000    0.000 range.py:307(dtype)\r\n        2    0.000    0.000    0.000    0.000 missing.py:949(clean_reindex_fill_method)\r\n       11    0.000    0.000    0.000    0.000 base.py:324(ndim)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1961(internal_values)\r\n        6    0.000    0.000    0.000    0.000 inference.py:294(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 base.py:2070(_can_hold_na)\r\n        8    0.000    0.000    0.000    0.000 base.py:1545(name)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2273(_preprocess_slice_or_indexer)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:891(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:477(__exit__)\r\n        1    0.000    0.000    0.000    0.000 indexing.py:2606(check_dict_or_set_indexers)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:724(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 construction.py:464(ensure_wrapped_if_datetimelike)\r\n        2    0.000    0.000    0.000    0.000 {built-in method numpy.seterrobj}\r\n        4    0.000    0.000    0.000    0.000 common.py:350(is_timedelta64_dtype)\r\n        1    0.000    0.000    0.000    0.000 multi.py:506(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:623(name)\r\n        1    0.000    0.000    0.000    0.000 ops.py:685(__init__)\r\n        7    0.000    0.000    0.000    0.000 generic.py:620(ndim)\r\n        6    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 generic.py:596(_info_axis)\r\n        2    0.000    0.000    0.000    0.000 {method 'copy' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 ops.py:824(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 config.py:609(_get_deprecated_option)\r\n        6    0.000    0.000    0.000    0.000 base.py:898(dtype)\r\n        1    0.000    0.000    0.000    0.000 ops.py:790(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:824(iget)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:264(_create_data)\r\n        9    0.000    0.000    0.000    0.000 {built-in method builtins.hash}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:312(__getattr__)\r\n        2    0.000    0.000    0.000    0.000 base.py:749(is_)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:144(_int64_cut_off)\r\n        4    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        4    0.000    0.000    0.000    0.000 {built-in method numpy.geterrobj}\r\n        1    0.000    0.000    0.000    0.000 ops.py:826(levels)\r\n        4    0.000    0.000    0.000    0.000 multi.py:943(nlevels)\r\n        1    0.000    0.000    0.000    0.000 generic.py:526(_get_block_manager_axis)\r\n        3    0.000    0.000    0.000    0.000 fromnumeric.py:70(<dictcomp>)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:943(is_in_obj)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:205(_check_window_bounds)\r\n        1    0.000    0.000    0.000    0.000 _validators.py:222(validate_bool_kwarg)\r\n        2    0.000    0.000    0.000    0.000 sorting.py:608(<genexpr>)\r\n        9    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        2    0.000    0.000    0.000    0.000 grouper.py:893(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 groupby.py:945(__getattr__)\r\n        6    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_bool}\r\n        2    0.000    0.000    0.000    0.000 {method 'ravel' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 config.py:636(_translate_key)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.internals.get_blkno_placements}\r\n        1    0.000    0.000    0.000    0.000 sorting.py:157(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 {method 'discard' of 'set' objects}\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_scalar}\r\n        8    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        2    0.000    0.000    0.000    0.000 grouper.py:669(codes)\r\n        2    0.000    0.000    0.000    0.000 multi.py:1395(_get_names)\r\n        1    0.000    0.000    0.000    0.000 groupby.py:720(_selected_obj)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4217(_clear_item_cache)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1765(_consolidate_check)\r\n        7    0.000    0.000    0.000    0.000 typing.py:1149(cast)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:927(is_in_axis)\r\n        3    0.000    0.000    0.000    0.000 base.py:1064(_maybe_disallow_fill)\r\n        8    0.000    0.000    0.000    0.000 fromnumeric.py:3148(_ndim_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:426(__init__)\r\n        7    0.000    0.000    0.000    0.000 {method 'clear' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 categorical.py:459(dtype)\r\n        3    0.000    0.000    0.000    0.000 generic.py:335(attrs)\r\n        2    0.000    0.000    0.000    0.000 common.py:1643(<genexpr>)\r\n        6    0.000    0.000    0.000    0.000 multiarray.py:152(concatenate)\r\n        1    0.000    0.000    0.000    0.000 numba_.py:18(maybe_use_numba)\r\n        4    0.000    0.000    0.000    0.000 managers.py:179(blklocs)\r\n        5    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\r\n        5    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_integer}\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.max}\r\n        1    0.000    0.000    0.000    0.000 categorical.py:1768(_codes)\r\n        3    0.000    0.000    0.000    0.000 base.py:654(_constructor)\r\n        2    0.000    0.000    0.000    0.000 frame.py:631(_constructor)\r\n        4    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_float}\r\n        5    0.000    0.000    0.000    0.000 dtypes.py:580(categories)\r\n        2    0.000    0.000    0.000    0.000 {method 'insert' of 'list' objects}\r\n        3    0.000    0.000    0.000    0.000 base.py:5937(_index_as_unique)\r\n        1    0.000    0.000    0.000    0.000 config.py:577(_select_options)\r\n        6    0.000    0.000    0.000    0.000 generic.py:356(flags)\r\n        6    0.000    0.000    0.000    0.000 {built-in method _warnings._filters_mutated}\r\n        2    0.000    0.000    0.000    0.000 grouper.py:892(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 range.py:482(equals)\r\n        3    0.000    0.000    0.000    0.000 dtypes.py:587(ordered)\r\n        1    0.000    0.000    0.000    0.000 frame.py:886(axes)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:2107(_clip_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 common.py:367(apply_if_callable)\r\n        2    0.000    0.000    0.000    0.000 missing.py:121(clean_fill_method)\r\n        2    0.000    0.000    0.000    0.000 common.py:1165(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1799(__init__)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:227(is_int64_overflow_possible)\r\n        1    0.000    0.000    0.000    0.000 {method 'get_loc' of 'pandas._libs.index.IndexEngine' objects}\r\n        1    0.000    0.000    0.000    0.000 common.py:1319(is_1d_only_ea_dtype)\r\n        3    0.000    0.000    0.000    0.000 flags.py:53(allows_duplicate_labels)\r\n        3    0.000    0.000    0.000    0.000 managers.py:939(__init__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:224(is_single_block)\r\n        1    0.000    0.000    0.000    0.000 base.py:200(_selected_obj)\r\n        1    0.000    0.000    0.000    0.000 range.py:248(start)\r\n        1    0.000    0.000    0.000    0.000 ops.py:828(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 construction.py:709(_maybe_repeat)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:1017(_is_label_like)\r\n        1    0.000    0.000    0.000    0.000 {method 'item' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 function_base.py:5440(_append_dispatcher)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_iterator}\r\n        2    0.000    0.000    0.000    0.000 {method 'values' of 'dict' objects}\r\n        2    0.000    0.000    0.000    0.000 {method 'extend' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 function.py:60(__call__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1894(_block)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.item_from_zerodim}\r\n        1    0.000    0.000    0.000    0.000 ops.py:791(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:641(_ilevel)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:1777(_ravel_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:2950(_prod_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 range.py:195(_constructor)\r\n        1    0.000    0.000    0.000    0.000 blocks.py:476(dtype)\r\n        2    0.000    0.000    0.000    0.000 multi.py:978(codes)\r\n        1    0.000    0.000    0.000    0.000 {method 'upper' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 {method 'split' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 managers.py:229(items)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_float64}\r\n        2    0.000    0.000    0.000    0.000 {built-in method builtins.callable}\r\n        1    0.000    0.000    0.000    0.000 range.py:263(step)\r\n        1    0.000    0.000    0.000    0.000 series.py:594(name)\r\n        1    0.000    0.000    0.000    0.000 function_base.py:5050(_delete_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1706(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 fromnumeric.py:2427(_all_dispatcher)\r\n        2    0.000    0.000    0.000    0.000 {method 'copy' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 range.py:256(stop)\r\n        1    0.000    0.000    0.000    0.000 base.py:6298(_maybe_cast_indexer)\r\n        1    0.000    0.000    0.000    0.000 {method 'pop' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int64}\r\n        1    0.000    0.000    0.000    0.000 multiarray.py:1079(copyto)\r\n        1    0.000    0.000    0.000    0.000 {function FrozenList.__getitem__ at 0x7f24aba84280}\r\n\r\n\r\n"]
[165.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[165.002, "i", "grep -n \"_create_data\\|_grouper\\|MultiIndex\\|indices.values\\|np.concatenate\" ../pandas/core/window/rolling\r"]
[165.004, "o", "grep -n \"_create_data\\|_grouper\\|MultiIndex\\|indices.values\\|np.concatenate\" ../pandas/core/window/rolling\r\n"]
[165.006, "o", "g.py\r\n\u001b[?2004l\r\n\u001b[32m\u001b[K70\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K,\r\n\u001b[32m\u001b[K264\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n\u001b[32m\u001b[K339\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(obj)\r\n\u001b[32m\u001b[K406\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # TODO: why do we get here with e.g. \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K?\r\n\u001b[32m\u001b[K442\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self._selected_obj)\r\n\u001b[32m\u001b[K470\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self._selected_obj, numeric_only)\r\n\u001b[32m\u001b[K520\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self._selected_obj, numeric_only)\r\n\u001b[32m\u001b[K546\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        target = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(target, numeric_only)\r\n\u001b[32m\u001b[K631\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self._selected_obj)\r\n\u001b[32m\u001b[K674\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    \u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K: BaseGrouper\r\n\u001b[32m\u001b[K676\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    _attributes: list[str] = [\"\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K\"]\r\n\u001b[32m\u001b[K682\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K: BaseGrouper,\r\n\u001b[32m\u001b[K688\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if not isinstance(\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K, BaseGrouper):\r\n\u001b[32m\u001b[K690\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K = \u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K\r\n\u001b[32m\u001b[K695\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = obj.drop(columns=self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.names, errors=\"ignore\")\r\n\u001b[32m\u001b[K716\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Reconstruct the resulting \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K\r\n\u001b[32m\u001b[K721\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        groupby_keys = copy.copy(self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.names)\r\n\u001b[32m\u001b[K726\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            for key in self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.names\r\n\u001b[32m\u001b[K734\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        codes = self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.codes\r\n\u001b[32m\u001b[K735\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        levels = copy.copy(self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.levels)\r\n\u001b[32m\u001b[K737\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        group_indices = self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K739\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            indexer = \u001b[01;31m\u001b[Knp.concatenate\u001b[m\u001b[K(list(group_indices))\r\n\u001b[32m\u001b[K748\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            if not isinstance(idx, \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K):\r\n\u001b[32m\u001b[K749\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                idx = \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K.from_arrays([idx])\r\n\u001b[32m\u001b[K753\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        result_index = \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K(\r\n\u001b[32m\u001b[K774\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        target = target.drop(columns=self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.names, errors=\"ignore\")\r\n\u001b[32m\u001b[K778\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            len(group) == len(other) for group in self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K788\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                    for gb_indices in self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K793\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                com.maybe_make_list(pair) for pair in self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.indices.keys()\r\n\u001b[32m\u001b[K806\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            groupby_codes = self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.codes\r\n\u001b[32m\u001b[K809\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            groupby_levels = self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.levels  # type: ignore[assignment]\r\n\u001b[32m\u001b[K811\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            group_indices = self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K813\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                indexer = \u001b[01;31m\u001b[Knp.concatenate\u001b[m\u001b[K(list(group_indices))\r\n\u001b[32m\u001b[K825\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        if isinstance(result.index, \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K):\r\n\u001b[32m\u001b[K838\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        result_names = self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.names + result_names\r\n\u001b[32m\u001b[K840\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        result_index = \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K(\r\n\u001b[32m\u001b[K846\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n\u001b[32m\u001b[K854\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            groupby_order = \u001b[01;31m\u001b[Knp.concatenate\u001b[m\u001b[K(list(self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K())).astype(\r\n\u001b[32m\u001b[K858\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        return super().\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(obj, numeric_only)\r\n\u001b[32m\u001b[K1206\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                x = \u001b[01;31m\u001b[Knp.concatenate\u001b[m\u001b[K((x, additional_nans))\r\n\u001b[32m\u001b[K2523\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            output will be a \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[Ked DataFrame in the case of DataFrame\r\n\u001b[32m\u001b[K2566\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            output will be a \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[Ked DataFrame in the case of DataFrame\r\n\u001b[32m\u001b[K2601\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        When `pairwise` is set to `True`, the output will be a \u001b[01;31m\u001b[KMultiIndex\u001b[m\u001b[K DataFrame\r\n\u001b[32m\u001b[K2724\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            groupby_indices=self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.indices,\r\n\u001b[32m\u001b[K2737\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        for group_indices in self.\u001b[01;31m\u001b[K_grouper\u001b[m\u001b[K.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K():\r\n"]
[170.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[170.002, "i", "sed -n '1,260p' ../pandas/core/window/rolling.py\r"]
[170.004, "o", "sed -n '1,260p' ../pandas/core/window/rolling.py\r\n"]
[170.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nProvide a generic structure to support window functions,\r\nsimilar to how we have a Groupby object.\r\n\"\"\"\r\nfrom __future__ import annotations\r\n\r\nimport copy\r\nfrom datetime import timedelta\r\nfrom functools import partial\r\nimport inspect\r\nfrom textwrap import dedent\r\nfrom typing import (\r\n    TYPE_CHECKING,\r\n    Any,\r\n    Callable,\r\n    Hashable,\r\n    Iterator,\r\n    Sized,\r\n    cast,\r\n)\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._libs.tslibs import (\r\n    BaseOffset,\r\n    to_offset,\r\n)\r\nimport pandas._libs.window.aggregations as window_aggregations\r\nfrom pandas._typing import (\r\n    ArrayLike,\r\n    Axis,\r\n    NDFrameT,\r\n    QuantileInterpolation,\r\n    WindowingRankType,\r\n)\r\nfrom pandas.compat._optional import import_optional_dependency\r\nfrom pandas.errors import DataError\r\nfrom pandas.util._decorators import doc\r\n\r\nfrom pandas.core.dtypes.common import (\r\n    ensure_float64,\r\n    is_bool,\r\n    is_integer,\r\n    is_list_like,\r\n    is_numeric_dtype,\r\n    is_scalar,\r\n    needs_i8_conversion,\r\n)\r\nfrom pandas.core.dtypes.generic import (\r\n    ABCDataFrame,\r\n    ABCSeries,\r\n)\r\nfrom pandas.core.dtypes.missing import notna\r\n\r\nfrom pandas.core._numba import executor\r\nfrom pandas.core.algorithms import factorize\r\nfrom pandas.core.apply import ResamplerWindowApply\r\nfrom pandas.core.arrays import ExtensionArray\r\nfrom pandas.core.base import SelectionMixin\r\nimport pandas.core.common as com\r\nfrom pandas.core.indexers.objects import (\r\n    BaseIndexer,\r\n    FixedWindowIndexer,\r\n    GroupbyIndexer,\r\n    VariableWindowIndexer,\r\n)\r\nfrom pandas.core.indexes.api import (\r\n    DatetimeIndex,\r\n    Index,\r\n    MultiIndex,\r\n    PeriodIndex,\r\n    TimedeltaIndex,\r\n)\r\nfrom pandas.core.reshape.concat import concat\r\nfrom pandas.core.util.numba_ import (\r\n    get_jit_arguments,\r\n    maybe_use_numba,\r\n)\r\nfrom pandas.core.window.common import (\r\n    flex_binary_moment,\r\n    zsqrt,\r\n)\r\nfrom pandas.core.window.doc import (\r\n    _shared_docs,\r\n    create_section_header,\r\n    kwargs_numeric_only,\r\n    kwargs_scipy,\r\n    numba_notes,\r\n    template_header,\r\n    template_returns,\r\n    template_see_also,\r\n    window_agg_numba_parameters,\r\n    window_apply_parameters,\r\n)\r\nfrom pandas.core.window.numba_ import (\r\n    generate_manual_numpy_nan_agg_with_axis,\r\n    generate_numba_apply_func,\r\n    generate_numba_table_func,\r\n)\r\n\r\nif TYPE_CHECKING:\r\n    from pandas import (\r\n        DataFrame,\r\n        Series,\r\n    )\r\n    from pandas.core.generic import NDFrame\r\n    from pandas.core.groupby.ops import BaseGrouper\r\n\r\n\r\nclass BaseWindow(SelectionMixin):\r\n    \"\"\"Provides utilities for performing windowing operations.\"\"\"\r\n\r\n    _attributes: list[str] = []\r\n    exclusions: frozenset[Hashable] = frozenset()\r\n    _on: Index\r\n\r\n    def __init__(\r\n        self,\r\n        obj: NDFrame,\r\n        window=None,\r\n        min_periods: int | None = None,\r\n        center: bool | None = False,\r\n        win_type: str | None = None,\r\n        axis: Axis = 0,\r\n        on: str | Index | None = None,\r\n        closed: str | None = None,\r\n        step: int | None = None,\r\n        method: str = \"single\",\r\n        *,\r\n        selection=None,\r\n    ) -> None:\r\n        self.obj = obj\r\n        self.on = on\r\n        self.closed = closed\r\n        self.step = step\r\n        self.window = window\r\n        self.min_periods = min_periods\r\n        self.center = center\r\n        self.win_type = win_type\r\n        self.axis = obj._get_axis_number(axis) if axis is not None else None\r\n        self.method = method\r\n        self._win_freq_i8: int | None = None\r\n        if self.on is None:\r\n            if self.axis == 0:\r\n                self._on = self.obj.index\r\n            else:\r\n                # i.e. self.axis == 1\r\n                self._on = self.obj.columns\r\n        elif isinstance(self.on, Index):\r\n            self._on = self.on\r\n        elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\r\n            self._on = Index(self.obj[self.on])\r\n        else:\r\n            raise ValueError(\r\n                f\"invalid on specified as {self.on}, \"\r\n                \"must be a column (of DataFrame), an Index or None\"\r\n            )\r\n\r\n        self._selection = selection\r\n        self._validate()\r\n\r\n    def _validate(self) -> None:\r\n        if self.center is not None and not is_bool(self.center):\r\n            raise ValueError(\"center must be a boolean\")\r\n        if self.min_periods is not None:\r\n            if not is_integer(self.min_periods):\r\n                raise ValueError(\"min_periods must be an integer\")\r\n            if self.min_periods < 0:\r\n                raise ValueError(\"min_periods must be >= 0\")\r\n            if is_integer(self.window) and self.min_periods > self.window:\r\n                raise ValueError(\r\n                    f\"min_periods {self.min_periods} must be <= window {self.window}\"\r\n                )\r\n        if self.closed is not None and self.closed not in [\r\n            \"right\",\r\n            \"both\",\r\n            \"left\",\r\n            \"neither\",\r\n        ]:\r\n            raise ValueError(\"closed must be 'right', 'left', 'both' or 'neither'\")\r\n        if not isinstance(self.obj, (ABCSeries, ABCDataFrame)):\r\n            raise TypeError(f\"invalid type: {type(self)}\")\r\n        if isinstance(self.window, BaseIndexer):\r\n            # Validate that the passed BaseIndexer subclass has\r\n            # a get_window_bounds with the correct signature.\r\n            get_window_bounds_signature = inspect.signature(\r\n                self.window.get_window_bounds\r\n            ).parameters.keys()\r\n            expected_signature = inspect.signature(\r\n                BaseIndexer().get_window_bounds\r\n            ).parameters.keys()\r\n            if get_window_bounds_signature != expected_signature:\r\n                raise ValueError(\r\n                    f\"{type(self.window).__name__} does not implement \"\r\n                    f\"the correct signature for get_window_bounds\"\r\n                )\r\n        if self.method not in [\"table\", \"single\"]:\r\n            raise ValueError(\"method must be 'table' or 'single\")\r\n        if self.step is not None:\r\n            if not is_integer(self.step):\r\n                raise ValueError(\"step must be an integer\")\r\n            if self.step < 0:\r\n                raise ValueError(\"step must be >= 0\")\r\n\r\n    def _check_window_bounds(\r\n        self, start: np.ndarray, end: np.ndarray, num_vals: int\r\n    ) -> None:\r\n        if len(start) != len(end):\r\n            raise ValueError(\r\n                f\"start ({len(start)}) and end ({len(end)}) bounds must be the \"\r\n                f\"same length\"\r\n            )\r\n        if len(start) != (num_vals + (self.step or 1) - 1) // (self.step or 1):\r\n            raise ValueError(\r\n                f\"start and end bounds ({len(start)}) must be the same length \"\r\n                f\"as the object ({num_vals}) divided by the step ({self.step}) \"\r\n                f\"if given and rounded up\"\r\n            )\r\n\r\n    def _slice_axis_for_step(self, index: Index, result: Sized | None = None) -> Index:\r\n        \"\"\"\r\n        Slices the index for a given result and the preset step.\r\n        \"\"\"\r\n        return (\r\n            index\r\n            if result is None or len(result) == len(index)\r\n            else index[:: self.step]\r\n        )\r\n\r\n    def _validate_numeric_only(self, name: str, numeric_only: bool) -> None:\r\n        \"\"\"\r\n        Validate numeric_only argument, raising if invalid for the input.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the operator (kernel).\r\n        numeric_only : bool\r\n            Value passed by user.\r\n        \"\"\"\r\n        if (\r\n            self._selected_obj.ndim == 1\r\n            and numeric_only\r\n            and not is_numeric_dtype(self._selected_obj.dtype)\r\n        ):\r\n            raise NotImplementedError(\r\n                f\"{type(self).__name__}.{name} does not implement numeric_only\"\r\n            )\r\n\r\n    def _make_numeric_only(self, obj: NDFrameT) -> NDFrameT:\r\n        \"\"\"Subset DataFrame to numeric columns.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : DataFrame\r\n\r\n        Returns\r\n        -------\r\n        obj subset to numeric-only columns.\r\n        \"\"\"\r\n"]
[175.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[175.002, "i", "sed -n '260,640p' ../pandas/core/window/rolling.py\r"]
[175.004, "o", "sed -n '260,640p' ../pandas/core/window/rolling.py\r\n"]
[175.006, "o", "\u001b[?2004l\r\n        \"\"\"\r\n        result = obj.select_dtypes(include=[\"number\"], exclude=[\"timedelta\"])\r\n        return result\r\n\r\n    def _create_data(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n        \"\"\"\r\n        Split data into blocks & return conformed data.\r\n        \"\"\"\r\n        # filter out the on from the object\r\n        if self.on is not None and not isinstance(self.on, Index) and obj.ndim == 2:\r\n            obj = obj.reindex(columns=obj.columns.difference([self.on]), copy=False)\r\n        if obj.ndim > 1 and (numeric_only or self.axis == 1):\r\n            # GH: 20649 in case of mixed dtype and axis=1 we have to convert everything\r\n            # to float to calculate the complete row at once. We exclude all non-numeric\r\n            # dtypes.\r\n            obj = self._make_numeric_only(obj)\r\n        if self.axis == 1:\r\n            obj = obj.astype(\"float64\", copy=False)\r\n            obj._mgr = obj._mgr.consolidate()\r\n        return obj\r\n\r\n    def _gotitem(self, key, ndim, subset=None):\r\n        \"\"\"\r\n        Sub-classes to define. Return a sliced object.\r\n\r\n        Parameters\r\n        ----------\r\n        key : str / list of selections\r\n        ndim : {1, 2}\r\n            requested ndim of result\r\n        subset : object, default None\r\n            subset to act on\r\n        \"\"\"\r\n        # create a new object to prevent aliasing\r\n        if subset is None:\r\n            subset = self.obj\r\n\r\n        # we need to make a shallow copy of ourselves\r\n        # with the same groupby\r\n        kwargs = {attr: getattr(self, attr) for attr in self._attributes}\r\n\r\n        selection = None\r\n        if subset.ndim == 2 and (\r\n            (is_scalar(key) and key in subset) or is_list_like(key)\r\n        ):\r\n            selection = key\r\n        elif subset.ndim == 1 and is_scalar(key) and key == subset.name:\r\n            selection = key\r\n\r\n        new_win = type(self)(subset, selection=selection, **kwargs)\r\n        return new_win\r\n\r\n    def __getattr__(self, attr: str):\r\n        if attr in self._internal_names_set:\r\n            return object.__getattribute__(self, attr)\r\n        if attr in self.obj:\r\n            return self[attr]\r\n\r\n        raise AttributeError(\r\n            f\"'{type(self).__name__}' object has no attribute '{attr}'\"\r\n        )\r\n\r\n    def _dir_additions(self):\r\n        return self.obj._dir_additions()\r\n\r\n    def __repr__(self) -> str:\r\n        \"\"\"\r\n        Provide a nice str repr of our rolling object.\r\n        \"\"\"\r\n        attrs_list = (\r\n            f\"{attr_name}={getattr(self, attr_name)}\"\r\n            for attr_name in self._attributes\r\n            if getattr(self, attr_name, None) is not None and attr_name[0] != \"_\"\r\n        )\r\n        attrs = \",\".join(attrs_list)\r\n        return f\"{type(self).__name__} [{attrs}]\"\r\n\r\n    def __iter__(self) -> Iterator:\r\n        obj = self._selected_obj.set_axis(self._on)\r\n        obj = self._create_data(obj)\r\n        indexer = self._get_window_indexer()\r\n\r\n        start, end = indexer.get_window_bounds(\r\n            num_values=len(obj),\r\n            min_periods=self.min_periods,\r\n            center=self.center,\r\n            closed=self.closed,\r\n            step=self.step,\r\n        )\r\n        self._check_window_bounds(start, end, len(obj))\r\n\r\n        for s, e in zip(start, end):\r\n            result = obj.iloc[slice(s, e)]\r\n            yield result\r\n\r\n    def _prep_values(self, values: ArrayLike) -> np.ndarray:\r\n        \"\"\"Convert input to numpy arrays for Cython routines\"\"\"\r\n        if needs_i8_conversion(values.dtype):\r\n            raise NotImplementedError(\r\n                f\"ops for {type(self).__name__} for this \"\r\n                f\"dtype {values.dtype} are not implemented\"\r\n            )\r\n        # GH #12373 : rolling functions error on float32 data\r\n        # make sure the data is coerced to float64\r\n        try:\r\n            if isinstance(values, ExtensionArray):\r\n                values = values.to_numpy(np.float64, na_value=np.nan)\r\n            else:\r\n                values = ensure_float64(values)\r\n        except (ValueError, TypeError) as err:\r\n            raise TypeError(f\"cannot handle this type -> {values.dtype}\") from err\r\n\r\n        # Convert inf to nan for C funcs\r\n        inf = np.isinf(values)\r\n        if inf.any():\r\n            values = np.where(inf, np.nan, values)\r\n\r\n        return values\r\n\r\n    def _insert_on_column(self, result: DataFrame, obj: DataFrame) -> None:\r\n        # if we have an 'on' column we want to put it back into\r\n        # the results in the same location\r\n        from pandas import Series\r\n\r\n        if self.on is not None and not self._on.equals(obj.index):\r\n            name = self._on.name\r\n            extra_col = Series(self._on, index=self.obj.index, name=name)\r\n            if name in result.columns:\r\n                # TODO: sure we want to overwrite results?\r\n                result[name] = extra_col\r\n            elif name in result.index.names:\r\n                pass\r\n            elif name in self._selected_obj.columns:\r\n                # insert in the same location as we had in _selected_obj\r\n                old_cols = self._selected_obj.columns\r\n                new_cols = result.columns\r\n                old_loc = old_cols.get_loc(name)\r\n                overlap = new_cols.intersection(old_cols[:old_loc])\r\n                new_loc = len(overlap)\r\n                result.insert(new_loc, name, extra_col)\r\n            else:\r\n                # insert at the end\r\n                result[name] = extra_col\r\n\r\n    @property\r\n    def _index_array(self):\r\n        # TODO: why do we get here with e.g. MultiIndex?\r\n        if needs_i8_conversion(self._on.dtype):\r\n            idx = cast(\"PeriodIndex | DatetimeIndex | TimedeltaIndex\", self._on)\r\n            return idx.asi8\r\n        return None\r\n\r\n    def _resolve_output(self, out: DataFrame, obj: DataFrame) -> DataFrame:\r\n        \"\"\"Validate and finalize result.\"\"\"\r\n        if out.shape[1] == 0 and obj.shape[1] > 0:\r\n            raise DataError(\"No numeric types to aggregate\")\r\n        if out.shape[1] == 0:\r\n            return obj.astype(\"float64\")\r\n\r\n        self._insert_on_column(out, obj)\r\n        return out\r\n\r\n    def _get_window_indexer(self) -> BaseIndexer:\r\n        \"\"\"\r\n        Return an indexer class that will compute the window start and end bounds\r\n        \"\"\"\r\n        if isinstance(self.window, BaseIndexer):\r\n            return self.window\r\n        if self._win_freq_i8 is not None:\r\n            return VariableWindowIndexer(\r\n                index_array=self._index_array,\r\n                window_size=self._win_freq_i8,\r\n                center=self.center,\r\n            )\r\n        return FixedWindowIndexer(window_size=self.window)\r\n\r\n    def _apply_series(\r\n        self, homogeneous_func: Callable[..., ArrayLike], name: str | None = None\r\n    ) -> Series:\r\n        \"\"\"\r\n        Series version of _apply_blockwise\r\n        \"\"\"\r\n        obj = self._create_data(self._selected_obj)\r\n\r\n        if name == \"count\":\r\n            # GH 12541: Special case for count where we support date-like types\r\n            obj = notna(obj).astype(int)\r\n        try:\r\n            values = self._prep_values(obj._values)\r\n        except (TypeError, NotImplementedError) as err:\r\n            raise DataError(\"No numeric types to aggregate\") from err\r\n\r\n        result = homogeneous_func(values)\r\n        index = self._slice_axis_for_step(obj.index, result)\r\n        return obj._constructor(result, index=index, name=obj.name)\r\n\r\n    def _apply_blockwise(\r\n        self,\r\n        homogeneous_func: Callable[..., ArrayLike],\r\n        name: str,\r\n        numeric_only: bool = False,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given function to the DataFrame broken down into homogeneous\r\n        sub-frames.\r\n        \"\"\"\r\n        self._validate_numeric_only(name, numeric_only)\r\n        if self._selected_obj.ndim == 1:\r\n            return self._apply_series(homogeneous_func, name)\r\n\r\n        obj = self._create_data(self._selected_obj, numeric_only)\r\n        if name == \"count\":\r\n            # GH 12541: Special case for count where we support date-like types\r\n            obj = notna(obj).astype(int)\r\n            obj._mgr = obj._mgr.consolidate()\r\n\r\n        if self.axis == 1:\r\n            obj = obj.T\r\n\r\n        taker = []\r\n        res_values = []\r\n        for i, arr in enumerate(obj._iter_column_arrays()):\r\n            # GH#42736 operate column-wise instead of block-wise\r\n            # As of 2.0, hfunc will raise for nuisance columns\r\n            try:\r\n                arr = self._prep_values(arr)\r\n            except (TypeError, NotImplementedError) as err:\r\n                raise DataError(\r\n                    f\"Cannot aggregate non-numeric type: {arr.dtype}\"\r\n                ) from err\r\n            res = homogeneous_func(arr)\r\n            res_values.append(res)\r\n            taker.append(i)\r\n\r\n        index = self._slice_axis_for_step(\r\n            obj.index, res_values[0] if len(res_values) > 0 else None\r\n        )\r\n        df = type(obj)._from_arrays(\r\n            res_values,\r\n            index=index,\r\n            columns=obj.columns.take(taker),\r\n            verify_integrity=False,\r\n        )\r\n\r\n        if self.axis == 1:\r\n            df = df.T\r\n\r\n        return self._resolve_output(df, obj)\r\n\r\n    def _apply_tablewise(\r\n        self,\r\n        homogeneous_func: Callable[..., ArrayLike],\r\n        name: str | None = None,\r\n        numeric_only: bool = False,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given function to the DataFrame across the entire object\r\n        \"\"\"\r\n        if self._selected_obj.ndim == 1:\r\n            raise ValueError(\"method='table' not applicable for Series objects.\")\r\n        obj = self._create_data(self._selected_obj, numeric_only)\r\n        values = self._prep_values(obj.to_numpy())\r\n        values = values.T if self.axis == 1 else values\r\n        result = homogeneous_func(values)\r\n        result = result.T if self.axis == 1 else result\r\n        index = self._slice_axis_for_step(obj.index, result)\r\n        columns = (\r\n            obj.columns\r\n            if result.shape[1] == len(obj.columns)\r\n            else obj.columns[:: self.step]\r\n        )\r\n        out = obj._constructor(result, index=index, columns=columns)\r\n\r\n        return self._resolve_output(out, obj)\r\n\r\n    def _apply_pairwise(\r\n        self,\r\n        target: DataFrame | Series,\r\n        other: DataFrame | Series | None,\r\n        pairwise: bool | None,\r\n        func: Callable[[DataFrame | Series, DataFrame | Series], DataFrame | Series],\r\n        numeric_only: bool,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given pairwise function given 2 pandas objects (DataFrame/Series)\r\n        \"\"\"\r\n        target = self._create_data(target, numeric_only)\r\n        if other is None:\r\n            other = target\r\n            # only default unset\r\n            pairwise = True if pairwise is None else pairwise\r\n        elif not isinstance(other, (ABCDataFrame, ABCSeries)):\r\n            raise ValueError(\"other must be a DataFrame or Series\")\r\n        elif other.ndim == 2 and numeric_only:\r\n            other = self._make_numeric_only(other)\r\n\r\n        return flex_binary_moment(target, other, func, pairwise=bool(pairwise))\r\n\r\n    def _apply(\r\n        self,\r\n        func: Callable[..., Any],\r\n        name: str,\r\n        numeric_only: bool = False,\r\n        numba_args: tuple[Any, ...] = (),\r\n        **kwargs,\r\n    ):\r\n        \"\"\"\r\n        Rolling statistical measure using supplied function.\r\n\r\n        Designed to be used with passed-in Cython array-based functions.\r\n\r\n        Parameters\r\n        ----------\r\n        func : callable function to apply\r\n        name : str,\r\n        numba_args : tuple\r\n            args to be passed when func is a numba func\r\n        **kwargs\r\n            additional arguments for rolling function and window function\r\n\r\n        Returns\r\n        -------\r\n        y : type of input\r\n        \"\"\"\r\n        window_indexer = self._get_window_indexer()\r\n        min_periods = (\r\n            self.min_periods\r\n            if self.min_periods is not None\r\n            else window_indexer.window_size\r\n        )\r\n\r\n        def homogeneous_func(values: np.ndarray):\r\n            # calculation function\r\n\r\n            if values.size == 0:\r\n                return values.copy()\r\n\r\n            def calc(x):\r\n                start, end = window_indexer.get_window_bounds(\r\n                    num_values=len(x),\r\n                    min_periods=min_periods,\r\n                    center=self.center,\r\n                    closed=self.closed,\r\n                    step=self.step,\r\n                )\r\n                self._check_window_bounds(start, end, len(x))\r\n\r\n                return func(x, start, end, min_periods, *numba_args)\r\n\r\n            with np.errstate(all=\"ignore\"):\r\n                result = calc(values)\r\n\r\n            return result\r\n\r\n        if self.method == \"single\":\r\n            return self._apply_blockwise(homogeneous_func, name, numeric_only)\r\n        else:\r\n            return self._apply_tablewise(homogeneous_func, name, numeric_only)\r\n\r\n    def _numba_apply(\r\n        self,\r\n        func: Callable[..., Any],\r\n        engine_kwargs: dict[str, bool] | None = None,\r\n        *func_args,\r\n    ):\r\n        window_indexer = self._get_window_indexer()\r\n        min_periods = (\r\n            self.min_periods\r\n            if self.min_periods is not None\r\n            else window_indexer.window_size\r\n        )\r\n        obj = self._create_data(self._selected_obj)\r\n        if self.axis == 1:\r\n            obj = obj.T\r\n        values = self._prep_values(obj.to_numpy())\r\n        if values.ndim == 1:\r\n            values = values.reshape(-1, 1)\r\n        start, end = window_indexer.get_window_bounds(\r\n            num_values=len(values),\r\n            min_periods=min_periods,\r\n            center=self.center,\r\n"]
[180.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[180.002, "i", "asv profile --python=same rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\r"]
[180.004, "o", "asv profile --python=same rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\r\n"]
[180.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (rolling.GroupbyLargeGroups.time_rolling_multiindex_creation--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                             22.7\u00b10.5ms\r\n\r\nWed Oct  1 18:30:23 2025    /tmp/tmp6utptk0g\r\n\r\n         2358 function calls (2304 primitive calls) in 0.025 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.025    0.025 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.025    0.025 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.025    0.025 rolling.py:322(time_rolling_multiindex_creation)\r\n        1    0.000    0.000    0.024    0.024 rolling.py:2070(mean)\r\n        1    0.000    0.000    0.024    0.024 rolling.py:1489(mean)\r\n        1    0.000    0.000    0.024    0.024 rolling.py:701(_apply)\r\n        1    0.000    0.000    0.016    0.016 multi.py:445(from_arrays)\r\n        1    0.000    0.000    0.016    0.016 categorical.py:2586(factorize_from_iterables)\r\n        2    0.000    0.000    0.016    0.008 categorical.py:2607(<genexpr>)\r\n        1    0.000    0.000    0.016    0.016 categorical.py:2545(factorize_from_iterable)\r\n        1    0.000    0.000    0.016    0.016 categorical.py:359(__init__)\r\n      3/2    0.000    0.000    0.015    0.008 algorithms.py:610(factorize)\r\n        1    0.000    0.000    0.014    0.014 base.py:1143(factorize)\r\n        2    0.000    0.000    0.011    0.006 algorithms.py:1702(safe_sort)\r\n        4    0.010    0.003    0.010    0.003 {method 'argsort' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.007    0.007 rolling.py:558(_apply)\r\n        1    0.000    0.000    0.004    0.004 rolling.py:456(_apply_blockwise)\r\n        2    0.000    0.000    0.004    0.002 algorithms.py:548(factorize_array)\r\n        2    0.004    0.002    0.004    0.002 {method 'factorize' of 'pandas._libs.hashtable.Int64HashTable' objects}\r\n        1    0.000    0.000    0.003    0.003 rolling.py:591(homogeneous_func)\r\n        1    0.000    0.000    0.003    0.003 rolling.py:597(calc)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:2695(_get_window_indexer)\r\n        1    0.000    0.000    0.002    0.002 ops.py:784(indices)\r\n        4    0.000    0.000    0.002    0.000 dtypes.py:186(__init__)\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:339(_finalize)\r\n        2    0.000    0.000    0.001    0.001 dtypes.py:511(validate_categories)\r\n        2    0.001    0.001    0.001    0.001 base.py:2168(is_unique)\r\n        1    0.001    0.001    0.001    0.001 {pandas._libs.window.aggregations.roll_mean}\r\n        1    0.000    0.000    0.001    0.001 objects.py:324(get_window_bounds)\r\n       12    0.001    0.000    0.001    0.000 {method 'take' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.001    0.001 sorting.py:599(get_indexer_dict)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:846(_create_data)\r\n        1    0.000    0.000    0.001    0.001 groupby.py:2649(rolling)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:678(__init__)\r\n    27/15    0.001    0.000    0.001    0.000 {built-in method numpy.core._multiarray_umath.implement_array_function}\r\n        1    0.000    0.000    0.001    0.001 ops.py:910(result_index)\r\n        1    0.000    0.000    0.001    0.001 frame.py:5087(drop)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4505(drop)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:688(result_index)\r\n        6    0.000    0.000    0.001    0.000 take.py:58(take_nd)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:700(group_index)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4544(_drop_axis)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3819(take)\r\n        6    0.000    0.000    0.001    0.000 take.py:120(_take_nd_ndarray)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3898(_take)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:722(_codes_and_uniques)\r\n        1    0.000    0.000    0.001    0.001 managers.py:886(take)\r\n        2    0.000    0.000    0.001    0.000 managers.py:641(reindex_indexer)\r\n        2    0.000    0.000    0.001    0.000 blocks.py:858(take_nd)\r\n        6    0.000    0.000    0.001    0.000 <__array_function__ internals>:177(concatenate)\r\n        3    0.000    0.000    0.001    0.000 base.py:1033(take)\r\n        1    0.000    0.000    0.001    0.001 sorting.py:632(get_group_index_sorter)\r\n        1    0.001    0.001    0.001    0.001 {pandas._libs.algos.groupsort_indexer}\r\n        2    0.000    0.000    0.001    0.000 objects.py:76(get_window_bounds)\r\n        1    0.000    0.000    0.000    0.000 frame.py:8104(groupby)\r\n        1    0.000    0.000    0.000    0.000 base.py:6610(drop)\r\n        1    0.000    0.000    0.000    0.000 groupby.py:896(__init__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:705(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 base.py:3676(get_indexer)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:790(get_grouper)\r\n        1    0.000    0.000    0.000    0.000 frame.py:2459(_from_arrays)\r\n        1    0.000    0.000    0.000    0.000 managers.py:726(_slice_take_blocks_ax0)\r\n        3    0.000    0.000    0.000    0.000 algorithms.py:1396(take)\r\n        4    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(clip)\r\n        1    0.000    0.000    0.000    0.000 construction.py:96(arrays_to_mgr)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:2111(clip)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:51(_wrapfunc)\r\n        1    0.000    0.000    0.000    0.000 base.py:5777(get_indexer_for)\r\n        4    0.000    0.000    0.000    0.000 {method 'clip' of 'numpy.ndarray' objects}\r\n        4    0.000    0.000    0.000    0.000 _methods.py:127(_clip)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_2d_axis0_float64_float64}\r\n        1    0.000    0.000    0.000    0.000 managers.py:2069(create_block_manager_from_column_arrays)\r\n        4    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_1d_int64_int64}\r\n  392/382    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        1    0.000    0.000    0.000    0.000 managers.py:2141(_form_blocks)\r\n        3    0.000    0.000    0.000    0.000 base.py:449(__new__)\r\n        4    0.000    0.000    0.000    0.000 _methods.py:108(_clip_dep_invoke_with_casting)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_2d_axis1_float64_float64}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:742(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2199(_stack_arrays)\r\n        1    0.000    0.000    0.000    0.000 frame.py:3689(__getitem__)\r\n        2    0.000    0.000    0.000    0.000 multi.py:313(__new__)\r\n        5    0.000    0.000    0.000    0.000 {built-in method numpy.arange}\r\n        4    0.000    0.000    0.000    0.000 cast.py:971(coerce_indexer_dtype)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:109(get_group_index)\r\n        1    0.000    0.000    0.000    0.000 utils.py:241(maybe_convert_indices)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4220(_get_item_cache)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:265(_get_hashtable_algo)\r\n        9    0.000    0.000    0.000    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.indices_fast}\r\n        9    0.000    0.000    0.000    0.000 base.py:7014(ensure_index)\r\n        1    0.000    0.000    0.000    0.000 frame.py:3615(_ixs)\r\n      117    0.000    0.000    0.000    0.000 generic.py:42(_instancecheck)\r\n        2    0.000    0.000    0.000    0.000 base.py:6305(_maybe_cast_listlike_indexer)\r\n        3    0.000    0.000    0.000    0.000 construction.py:500(sanitize_array)\r\n       12    0.000    0.000    0.000    0.000 {method 'astype' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 sorting.py:622(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(append)\r\n        2    0.000    0.000    0.000    0.000 function_base.py:5444(append)\r\n        5    0.000    0.000    0.000    0.000 {method 'any' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 base.py:6029(_should_compare)\r\n        2    0.000    0.000    0.000    0.000 multi.py:982(_set_codes)\r\n        5    0.000    0.000    0.000    0.000 _methods.py:55(_any)\r\n       27    0.000    0.000    0.000    0.000 base.py:4892(_values)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1916(__contains__)\r\n        5    0.000    0.000    0.000    0.000 multi.py:998(<genexpr>)\r\n        4    0.000    0.000    0.000    0.000 algorithms.py:193(_reconstruct_data)\r\n       17    0.000    0.000    0.000    0.000 base.py:286(is_dtype)\r\n        2    0.000    0.000    0.000    0.000 base.py:5052(__contains__)\r\n        3    0.000    0.000    0.000    0.000 multi.py:3871(_coerce_indexer_frozen)\r\n        2    0.000    0.000    0.000    0.000 base.py:791(_engine)\r\n        6    0.000    0.000    0.000    0.000 common.py:1241(is_bool_dtype)\r\n   130/99    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n       13    0.000    0.000    0.000    0.000 common.py:458(is_categorical_dtype)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int32}\r\n        1    0.000    0.000    0.000    0.000 range.py:201(_data)\r\n        1    0.000    0.000    0.000    0.000 base.py:636(_with_infer)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int8}\r\n      117    0.000    0.000    0.000    0.000 generic.py:37(_check)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:113(_ensure_data)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:283(_check_object_for_strings)\r\n        8    0.000    0.000    0.000    0.000 _methods.py:93(_clip_dep_is_scalar_nan)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1039(iget)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:344(_name_get)\r\n        5    0.000    0.000    0.000    0.000 {pandas._libs.lib.infer_dtype}\r\n        2    0.000    0.000    0.000    0.000 common.py:229(asarray_tuplesafe)\r\n       12    0.000    0.000    0.000    0.000 base.py:616(_simple_new)\r\n        3    0.000    0.000    0.000    0.000 generic.py:5975(__setattr__)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(prod)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:355(_prep_values)\r\n        1    0.000    0.000    0.000    0.000 cast.py:1129(maybe_infer_to_datetimelike)\r\n        3    0.000    0.000    0.000    0.000 fromnumeric.py:69(_wrapreduction)\r\n        4    0.000    0.000    0.000    0.000 managers.py:163(blknos)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:117(__init__)\r\n        2    0.000    0.000    0.000    0.000 typing.py:868(__new__)\r\n        1    0.000    0.000    0.000    0.000 common.py:261(index_labels_to_array)\r\n        3    0.000    0.000    0.000    0.000 base.py:2599(inferred_type)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:2955(prod)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:190(fill_value)\r\n        2    0.000    0.000    0.000    0.000 base.py:3764(_get_indexer)\r\n        2    0.000    0.000    0.000    0.000 multi.py:807(_set_levels)\r\n        2    0.000    0.000    0.000    0.000 {method '_rebuild_blknos_and_blklocs' of 'pandas._libs.internals.BlockManager' objects}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.maybe_convert_objects}\r\n        3    0.000    0.000    0.000    0.000 frame.py:640(__init__)\r\n        2    0.000    0.000    0.000    0.000 _ufunc_config.py:33(seterr)\r\n        6    0.000    0.000    0.000    0.000 construction.py:402(extract_array)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4203(_box_col_values)\r\n        7    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        4    0.000    0.000    0.000    0.000 base.py:4918(_get_engine_target)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:1752(_validate)\r\n        1    0.000    0.000    0.000    0.000 generic.py:720(_set_axis)\r\n        2    0.000    0.000    0.000    0.000 base.py:3809(_check_indexing_method)\r\n        1    0.000    0.000    0.000    0.000 base.py:6518(delete)\r\n        4    0.000    0.000    0.000    0.000 generic.py:262(__init__)\r\n        2    0.000    0.000    0.000    0.000 generic.py:1921(empty)\r\n        3    0.000    0.000    0.000    0.000 generic.py:5915(__finalize__)\r\n        6    0.000    0.000    0.000    0.000 take.py:564(_take_preprocess_indexer_and_fill_value)\r\n        1    0.000    0.000    0.000    0.000 dtypes.py:547(update_dtype)\r\n        1    0.000    0.000    0.000    0.000 base.py:1786(rename)\r\n       16    0.000    0.000    0.000    0.000 common.py:1491(_is_dtype_type)\r\n        2    0.000    0.000    0.000    0.000 missing.py:625(na_value_for_dtype)\r\n      152    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        1    0.000    0.000    0.000    0.000 base.py:1679(set_names)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:36(__init__)\r\n        2    0.000    0.000    0.000    0.000 base.py:5255(equals)\r\n        4    0.000    0.000    0.000    0.000 base.py:54(shape)\r\n        1    0.000    0.000    0.000    0.000 config.py:260(__call__)\r\n        4    0.000    0.000    0.000    0.000 common.py:1124(is_numeric_dtype)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:228(make_block_same_class)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:435(__exit__)\r\n        1    0.000    0.000    0.000    0.000 _asarray.py:31(require)\r\n        1    0.000    0.000    0.000    0.000 managers.py:219(set_axis)\r\n        8    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(ndim)\r\n        1    0.000    0.000    0.000    0.000 config.py:134(_get_option)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:508(__init__)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:412(_resolve_output)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1685(_check_label_or_level_ambiguity)\r\n        8    0.000    0.000    0.000    0.000 common.py:157(is_object_dtype)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(delete)\r\n        1    0.000    0.000    0.000    0.000 base.py:58(_validate_set_axis)\r\n        4    0.000    0.000    0.000    0.000 base.py:5102(__getitem__)\r\n        5    0.000    0.000    0.000    0.000 base.py:731(_view)\r\n        3    0.000    0.000    0.000    0.000 base.py:559(_dtype_to_subclass)\r\n       25    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_list_like}\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:330(_name_includes_bit_suffix)\r\n        5    0.000    0.000    0.000    0.000 multi.py:828(<genexpr>)\r\n       20    0.000    0.000    0.000    0.000 common.py:1456(get_dtype)\r\n        6    0.000    0.000    0.000    0.000 generic.py:1979(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 function_base.py:5054(delete)\r\n       24    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_platform_int}\r\n       33    0.000    0.000    0.000    0.000 {built-in method numpy.asarray}\r\n        1    0.000    0.000    0.000    0.000 numeric.py:290(full)\r\n        4    0.000    0.000    0.000    0.000 ops.py:830(names)\r\n        5    0.000    0.000    0.000    0.000 cast.py:559(maybe_promote)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:430(__enter__)\r\n        7    0.000    0.000    0.000    0.000 abc.py:96(__instancecheck__)\r\n        9    0.000    0.000    0.000    0.000 {built-in method numpy.empty}\r\n        2    0.000    0.000    0.000    0.000 {method 'get_indexer' of 'pandas._libs.index.IndexEngine' objects}\r\n        2    0.000    0.000    0.000    0.000 common.py:420(is_interval_dtype)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(ravel)\r\n        2    0.000    0.000    0.000    0.000 common.py:1206(is_float_dtype)\r\n        2    0.000    0.000    0.000    0.000 multi.py:1398(_set_names)\r\n        2    0.000    0.000    0.000    0.000 base.py:2641(_na_value)\r\n        2    0.000    0.000    0.000    0.000 base.py:6047(_is_comparable_dtype)\r\n        2    0.000    0.000    0.000    0.000 base.py:5949(_maybe_promote)\r\n        1    0.000    0.000    0.000    0.000 construction.py:128(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(all)\r\n        8    0.000    0.000    0.000    0.000 fromnumeric.py:3152(ndim)\r\n       24    0.000    0.000    0.000    0.000 base.py:842(__len__)\r\n        2    0.000    0.000    0.000    0.000 numerictypes.py:356(issubdtype)\r\n        7    0.000    0.000    0.000    0.000 inference.py:189(is_array_like)\r\n       12    0.000    0.000    0.000    0.000 base.py:56(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 multi.py:782(__len__)\r\n        6    0.000    0.000    0.000    0.000 common.py:549(is_dtype_equal)\r\n        1    0.000    0.000    0.000    0.000 dtypes.py:209(_from_values_or_dtype)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:165(simplefilter)\r\n        6    0.000    0.000    0.000    0.000 generic.py:520(_get_axis)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:733(codes)\r\n        3    0.000    0.000    0.000    0.000 base.py:7109(maybe_extract_name)\r\n        2    0.000    0.000    0.000    0.000 dtypes.py:1241(is_dtype)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:1781(ravel)\r\n        4    0.000    0.000    0.000    0.000 _weakrefset.py:81(add)\r\n        1    0.000    0.000    0.000    0.000 config.py:116(_get_single_key)\r\n        7    0.000    0.000    0.000    0.000 {built-in method _abc._abc_instancecheck}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:379(_insert_on_column)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:230(_validate_numeric_only)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:1021(_convert_grouper)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:38(_remove)\r\n        2    0.000    0.000    0.000    0.000 _ufunc_config.py:132(geterr)\r\n        1    0.000    0.000    0.000    0.000 fromnumeric.py:2432(all)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:116(update)\r\n        1    0.000    0.000    0.000    0.000 series.py:367(__init__)\r\n        1    0.000    0.000    0.000    0.000 frozen.py:73(__getitem__)\r\n        2    0.000    0.000    0.000    0.000 frame.py:3659(_iter_column_arrays)\r\n        1    0.000    0.000    0.000    0.000 objects.py:288(__init__)\r\n        6    0.000    0.000    0.000    0.000 common.py:1074(needs_i8_conversion)\r\n       41    0.000    0.000    0.000    0.000 {built-in method builtins.issubclass}\r\n        2    0.000    0.000    0.000    0.000 base.py:7144(unpack_nested_dtype)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:181(_add_filter)\r\n        1    0.000    0.000    0.000    0.000 base.py:3585(get_loc)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(copyto)\r\n       28    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        3    0.000    0.000    0.000    0.000 base.py:1631(_get_names)\r\n        2    0.000    0.000    0.000    0.000 inference.py:267(is_dict_like)\r\n       14    0.000    0.000    0.000    0.000 base.py:780(_reset_identity)\r\n        1    0.000    0.000    0.000    0.000 config.py:595(_get_root)\r\n        2    0.000    0.000    0.000    0.000 base.py:432(_engine_type)\r\n        1    0.000    0.000    0.000    0.000 {method 'max' of 'numpy.ndarray' objects}\r\n        3    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap>:1017(_handle_fromlist)\r\n        6    0.000    0.000    0.000    0.000 base.py:120(_reset_cache)\r\n        6    0.000    0.000    0.000    0.000 take.py:325(_get_take_nd_function)\r\n        2    0.000    0.000    0.000    0.000 common.py:651(is_integer_dtype)\r\n        4    0.000    0.000    0.000    0.000 common.py:274(is_datetime64_dtype)\r\n        4    0.000    0.000    0.000    0.000 ops.py:832(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        4    0.000    0.000    0.000    0.000 numerictypes.py:282(issubclass_)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1775(_consolidate_inplace)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:162(_validate)\r\n        1    0.000    0.000    0.000    0.000 series.py:1262(_set_as_cached)\r\n        6    0.000    0.000    0.000    0.000 common.py:1386(is_ea_or_datetimelike_dtype)\r\n        1    0.000    0.000    0.000    0.000 _methods.py:39(_amax)\r\n        2    0.000    0.000    0.000    0.000 managers.py:974(from_blocks)\r\n       16    0.000    0.000    0.000    0.000 {built-in method __new__ of type object at 0x5626dff2c680}\r\n        8    0.000    0.000    0.000    0.000 _methods.py:103(_clip_dep_is_byte_swapped)\r\n        5    0.000    0.000    0.000    0.000 {built-in method numpy.asanyarray}\r\n        1    0.000    0.000    0.000    0.000 _asarray.py:112(<setcomp>)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:220(_slice_axis_for_step)\r\n        4    0.000    0.000    0.000    0.000 common.py:1332(is_extension_array_dtype)\r\n        4    0.000    0.000    0.000    0.000 flags.py:49(__init__)\r\n        2    0.000    0.000    0.000    0.000 {method 'format' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 multi.py:796(levels)\r\n        6    0.000    0.000    0.000    0.000 common.py:151(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 base.py:1634(_set_names)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:458(__enter__)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:619(_passed_categorical)\r\n        6    0.000    0.000    0.000    0.000 __init__.py:33(using_copy_on_write)\r\n        7    0.000    0.000    0.000    0.000 inference.py:328(is_hashable)\r\n        2    0.000    0.000    0.000    0.000 copy.py:66(copy)\r\n       12    0.000    0.000    0.000    0.000 generic.py:506(_get_axis_number)\r\n        1    0.000    0.000    0.000    0.000 frame.py:3649(_get_column_array)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1757(is_consolidated)\r\n        3    0.000    0.000    0.000    0.000 {built-in method builtins.all}\r\n        1    0.000    0.000    0.000    0.000 series.py:691(_values)\r\n        3    0.000    0.000    0.000    0.000 construction.py:650(_sanitize_ndim)\r\n       10    0.000    0.000    0.000    0.000 common.py:143(<lambda>)\r\n        3    0.000    0.000    0.000    0.000 base.py:541(_ensure_array)\r\n        2    0.000    0.000    0.000    0.000 frame.py:903(shape)\r\n        2    0.000    0.000    0.000    0.000 range.py:307(dtype)\r\n        1    0.000    0.000    0.000    0.000 base.py:2664(hasnans)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:404(_index_array)\r\n        3    0.000    0.000    0.000    0.000 flags.py:85(allows_duplicate_labels)\r\n        1    0.000    0.000    0.000    0.000 ops.py:821(codes)\r\n       10    0.000    0.000    0.000    0.000 common.py:141(classes)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1053(iget_values)\r\n        1    0.000    0.000    0.000    0.000 multi.py:801(<listcomp>)\r\n        6    0.000    0.000    0.000    0.000 range.py:889(__len__)\r\n        1    0.000    0.000    0.000    0.000 blocks.py:2211(get_block_type)\r\n        4    0.000    0.000    0.000    0.000 common.py:150(cast_scalar_indexer)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:231(_ensure_arraylike)\r\n        8    0.000    0.000    0.000    0.000 base.py:1545(name)\r\n        4    0.000    0.000    0.000    0.000 dtypes.py:492(validate_ordered)\r\n        1    0.000    0.000    0.000    0.000 config.py:648(_warn_if_deprecated)\r\n        4    0.000    0.000    0.000    0.000 {built-in method numpy.geterrobj}\r\n        3    0.000    0.000    0.000    0.000 base.py:2623(_is_multi)\r\n        3    0.000    0.000    0.000    0.000 objects.py:46(__init__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2125(_grouping_func)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_scalar}\r\n        2    0.000    0.000    0.000    0.000 common.py:1432(_is_dtype)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:264(_create_data)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:24(_kind_name)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:891(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 {built-in method numpy.seterrobj}\r\n        2    0.000    0.000    0.000    0.000 missing.py:455(array_equivalent)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1961(internal_values)\r\n        2    0.000    0.000    0.000    0.000 {method 'remove' of 'list' objects}\r\n        6    0.000    0.000    0.000    0.000 common.py:146(classes_and_not_datetimelike)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:312(__getattr__)\r\n        1    0.000    0.000    0.000    0.000 base.py:2070(_can_hold_na)\r\n        1    0.000    0.000    0.000    0.000 generic.py:526(_get_block_manager_axis)\r\n        1    0.000    0.000    0.000    0.000 generic.py:596(_info_axis)\r\n        4    0.000    0.000    0.000    0.000 common.py:1649(pandas_dtype)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:724(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:893(<genexpr>)\r\n        4    0.000    0.000    0.000    0.000 common.py:350(is_timedelta64_dtype)\r\n        7    0.000    0.000    0.000    0.000 generic.py:620(ndim)\r\n        2    0.000    0.000    0.000    0.000 config.py:609(_get_deprecated_option)\r\n        1    0.000    0.000    0.000    0.000 base.py:740(_rename)\r\n        3    0.000    0.000    0.000    0.000 construction.py:689(_sanitize_str_dtypes)\r\n       11    0.000    0.000    0.000    0.000 ops.py:699(groupings)\r\n        1    0.000    0.000    0.000    0.000 ops.py:824(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 multi.py:506(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 ops.py:685(__init__)\r\n        6    0.000    0.000    0.000    0.000 inference.py:294(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:697(categories)\r\n        1    0.000    0.000    0.000    0.000 common.py:1624(validate_all_hashable)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:824(iget)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:437(__init__)\r\n        2    0.000    0.000    0.000    0.000 missing.py:949(clean_reindex_fill_method)\r\n        3    0.000    0.000    0.000    0.000 construction.py:464(ensure_wrapped_if_datetimelike)\r\n        1    0.000    0.000    0.000    0.000 indexing.py:2606(check_dict_or_set_indexers)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2273(_preprocess_slice_or_indexer)\r\n       11    0.000    0.000    0.000    0.000 base.py:324(ndim)\r\n        1    0.000    0.000    0.000    0.000 ops.py:826(levels)\r\n        4    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 grouper.py:623(name)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:205(_check_window_bounds)\r\n        6    0.000    0.000    0.000    0.000 base.py:898(dtype)\r\n        5    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:426(__init__)\r\n        2    0.000    0.000    0.000    0.000 {method 'copy' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 grouper.py:943(is_in_obj)\r\n        9    0.000    0.000    0.000    0.000 {built-in method builtins.hash}\r\n        6    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        3    0.000    0.000    0.000    0.000 {method 'discard' of 'set' objects}\r\n        1    0.000    0.000    0.000    0.000 managers.py:1765(_consolidate_check)\r\n        2    0.000    0.000    0.000    0.000 {method 'ravel' of 'numpy.ndarray' objects}\r\n        2    0.000    0.000    0.000    0.000 warnings.py:477(__exit__)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:927(is_in_axis)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:144(_int64_cut_off)\r\n        3    0.000    0.000    0.000    0.000 fromnumeric.py:70(<dictcomp>)\r\n        2    0.000    0.000    0.000    0.000 frame.py:631(_constructor)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:157(<listcomp>)\r\n        3    0.000    0.000    0.000    0.000 base.py:1064(_maybe_disallow_fill)\r\n        2    0.000    0.000    0.000    0.000 sorting.py:608(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:669(codes)\r\n        3    0.000    0.000    0.000    0.000 base.py:654(_constructor)\r\n        3    0.000    0.000    0.000    0.000 generic.py:335(attrs)\r\n        1    0.000    0.000    0.000    0.000 groupby.py:945(__getattr__)\r\n        1    0.000    0.000    0.000    0.000 groupby.py:720(_selected_obj)\r\n        6    0.000    0.000    0.000    0.000 multiarray.py:152(concatenate)\r\n        3    0.000    0.000    0.000    0.000 managers.py:939(__init__)\r\n        1    0.000    0.000    0.000    0.000 range.py:248(start)\r\n        1    0.000    0.000    0.000    0.000 config.py:577(_select_options)\r\n        1    0.000    0.000    0.000    0.000 _validators.py:222(validate_bool_kwarg)\r\n        9    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        2    0.000    0.000    0.000    0.000 base.py:749(is_)\r\n        1    0.000    0.000    0.000    0.000 ops.py:790(<listcomp>)\r\n        4    0.000    0.000    0.000    0.000 multi.py:943(nlevels)\r\n        7    0.000    0.000    0.000    0.000 typing.py:1149(cast)\r\n        1    0.000    0.000    0.000    0.000 blocks.py:476(dtype)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4217(_clear_item_cache)\r\n        8    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 ops.py:828(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 {method 'upper' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 frame.py:886(axes)\r\n        5    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_integer}\r\n        7    0.000    0.000    0.000    0.000 {method 'clear' of 'dict' objects}\r\n        4    0.000    0.000    0.000    0.000 managers.py:179(blklocs)\r\n        1    0.000    0.000    0.000    0.000 range.py:482(equals)\r\n        3    0.000    0.000    0.000    0.000 flags.py:53(allows_duplicate_labels)\r\n        2    0.000    0.000    0.000    0.000 common.py:1643(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.internals.get_blkno_placements}\r\n        1    0.000    0.000    0.000    0.000 common.py:1319(is_1d_only_ea_dtype)\r\n        2    0.000    0.000    0.000    0.000 multi.py:1395(_get_names)\r\n        3    0.000    0.000    0.000    0.000 dtypes.py:587(ordered)\r\n        6    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_bool}\r\n        8    0.000    0.000    0.000    0.000 fromnumeric.py:3148(_ndim_dispatcher)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:892(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 config.py:636(_translate_key)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1799(__init__)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:1768(_codes)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:459(dtype)\r\n        2    0.000    0.000    0.000    0.000 common.py:1165(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 range.py:195(_constructor)\r\n        5    0.000    0.000    0.000    0.000 dtypes.py:580(categories)\r\n        2    0.000    0.000    0.000    0.000 {method 'insert' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 numba_.py:18(maybe_use_numba)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.max}\r\n        6    0.000    0.000    0.000    0.000 {built-in method _warnings._filters_mutated}\r\n        3    0.000    0.000    0.000    0.000 base.py:5937(_index_as_unique)\r\n        2    0.000    0.000    0.000    0.000 missing.py:121(clean_fill_method)\r\n        6    0.000    0.000    0.000    0.000 generic.py:356(flags)\r\n        1    0.000    0.000    0.000    0.000 range.py:256(stop)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:2107(_clip_dispatcher)\r\n        4    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_float}\r\n        1    0.000    0.000    0.000    0.000 {method 'split' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 common.py:367(apply_if_callable)\r\n        1    0.000    0.000    0.000    0.000 {method 'item' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 range.py:263(step)\r\n        1    0.000    0.000    0.000    0.000 managers.py:224(is_single_block)\r\n        1    0.000    0.000    0.000    0.000 base.py:200(_selected_obj)\r\n        1    0.000    0.000    0.000    0.000 function.py:60(__call__)\r\n        3    0.000    0.000    0.000    0.000 construction.py:709(_maybe_repeat)\r\n        2    0.000    0.000    0.000    0.000 {method 'values' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 sorting.py:227(is_int64_overflow_possible)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_iterator}\r\n        1    0.000    0.000    0.000    0.000 {method 'get_loc' of 'pandas._libs.index.IndexEngine' objects}\r\n        1    0.000    0.000    0.000    0.000 grouper.py:1017(_is_label_like)\r\n        1    0.000    0.000    0.000    0.000 managers.py:229(items)\r\n        2    0.000    0.000    0.000    0.000 function_base.py:5440(_append_dispatcher)\r\n        2    0.000    0.000    0.000    0.000 {method 'extend' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 managers.py:1894(_block)\r\n        1    0.000    0.000    0.000    0.000 ops.py:791(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:641(_ilevel)\r\n        2    0.000    0.000    0.000    0.000 multi.py:978(codes)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.item_from_zerodim}\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        1    0.000    0.000    0.000    0.000 generic.py:1706(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:1777(_ravel_dispatcher)\r\n        2    0.000    0.000    0.000    0.000 {built-in method builtins.callable}\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:2950(_prod_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 multiarray.py:1079(copyto)\r\n        1    0.000    0.000    0.000    0.000 series.py:594(name)\r\n        1    0.000    0.000    0.000    0.000 base.py:6298(_maybe_cast_indexer)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_float64}\r\n        2    0.000    0.000    0.000    0.000 {method 'copy' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 function_base.py:5050(_delete_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 fromnumeric.py:2427(_all_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int64}\r\n        1    0.000    0.000    0.000    0.000 {method 'pop' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 {function FrozenList.__getitem__ at 0x7fb917736280}\r\n\r\n\r\n"]
[185.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[185.002, "i", "grep -n \"MultiIndex\\(|_grouper|indices.values|_create_data\" ../pandas/core/window/rolling.py\r"]
[185.004, "o", "grep -n \"MultiIndex\\(|_grouper|indices.values|_create_data\" ../pandas/core/window/rolling.py\r\n"]
[185.006, "o", "\u001b[?2004l\r\ngrep: Unmatched ( or \\(\r\n"]
[190.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[190.002, "i", "applypatch << 'PATCH'\r"]
[190.004, "o", "applypatch << 'PATCH'\r\n"]
[190.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> *** Begin Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> *** Update File: pandas/core/window/rolling.py\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -        if not obj.empty:\r\n\u001b[?2004l\r\n\u001b[?2004h> -            groupby_order = np.concatenate(list(self._grouper.indices.values())).astype(\r\n\u001b[?2004l\r\n\u001b[?2004h> -                np.int64\r\n\u001b[?2004l\r\n\u001b[?2004h> -            )\r\n\u001b[?2004l\r\n\u001b[?2004h> -            obj = obj.take(groupby_order)\r\n\u001b[?2004l\r\n\u001b[?2004h> +        if not obj.empty:\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # Construct the take indexer in group order. Avoid creating\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # unnecessary copies: keep the platform-native integer dtype\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # (np.intp) and avoid an extra cast to int64 which would allocate\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # a new array. This is a hot path for GroupBy.rolling on few but\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # large groups (see asv rolling.GroupbyLargeGroups).\r\n\u001b[?2004l\r\n\u001b[?2004h> +            group_indices = self._grouper.indices.values()\r\n\u001b[?2004l\r\n\u001b[?2004h> +            if group_indices:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                groupby_order = np.concatenate(list(group_indices))\r\n\u001b[?2004l\r\n\u001b[?2004h> +                # Ensure correct dtype without forcing a copy\r\n\u001b[?2004l\r\n\u001b[?2004h> +                if groupby_order.dtype != np.intp:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                    groupby_order = groupby_order.astype(np.intp, copy=False)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            else:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                # Empty groupby -> empty indexer\r\n\u001b[?2004l\r\n\u001b[?2004h> +                groupby_order = np.array([], dtype=np.intp)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            obj = obj.take(groupby_order)\r\n\u001b[?2004l\r\n\u001b[?2004h> *** End Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> PATCH\r\n\u001b[?2004l\r\n-bash: applypatch: command not found\r\n"]
[195.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[195.002, "i", "git -C .. diff -- pandas/core/window/rolling.py | sed -n '1,200p'\r"]
[195.004, "o", "git -C .. diff -- pandas/core/window/rolling.py | sed -n '1,200p'\r\n"]
[195.006, "o", "\u001b[?2004l\r\n"]
[200.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[200.002, "i", "asv profile --python=same rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\r"]
[200.004, "o", "asv profile --python=same rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\r\n"]
[200.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mProfile data does not already exist. Running profiler now.\u001b[0m\r\n\u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n\u00b7\u00b7\u00b7 \u001b[0;39mRunning (rolling.GroupbyLargeGroups.time_rolling_multiindex_creation--)\u001b[0m.\r\n\u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                             19.7\u00b10.2ms\r\n\r\nWed Oct  1 18:30:59 2025    /tmp/tmpr94rqkwo\r\n\r\n         2358 function calls (2304 primitive calls) in 0.020 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.020    0.020 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.020    0.020 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.020    0.020 rolling.py:322(time_rolling_multiindex_creation)\r\n        1    0.000    0.000    0.019    0.019 rolling.py:2070(mean)\r\n        1    0.000    0.000    0.019    0.019 rolling.py:1489(mean)\r\n        1    0.000    0.000    0.019    0.019 rolling.py:701(_apply)\r\n        1    0.000    0.000    0.013    0.013 multi.py:445(from_arrays)\r\n        1    0.000    0.000    0.013    0.013 categorical.py:2586(factorize_from_iterables)\r\n        2    0.000    0.000    0.013    0.006 categorical.py:2607(<genexpr>)\r\n        1    0.000    0.000    0.013    0.013 categorical.py:2545(factorize_from_iterable)\r\n        1    0.000    0.000    0.013    0.013 categorical.py:359(__init__)\r\n      3/2    0.000    0.000    0.013    0.006 algorithms.py:610(factorize)\r\n        1    0.000    0.000    0.012    0.012 base.py:1143(factorize)\r\n        2    0.000    0.000    0.010    0.005 algorithms.py:1702(safe_sort)\r\n        4    0.010    0.002    0.010    0.002 {method 'argsort' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.005    0.005 rolling.py:558(_apply)\r\n        1    0.000    0.000    0.003    0.003 rolling.py:456(_apply_blockwise)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:591(homogeneous_func)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:597(calc)\r\n        2    0.000    0.000    0.002    0.001 algorithms.py:548(factorize_array)\r\n        2    0.002    0.001    0.002    0.001 {method 'factorize' of 'pandas._libs.hashtable.Int64HashTable' objects}\r\n        1    0.000    0.000    0.002    0.002 rolling.py:2695(_get_window_indexer)\r\n        1    0.000    0.000    0.002    0.002 ops.py:784(indices)\r\n        1    0.001    0.001    0.001    0.001 {pandas._libs.window.aggregations.roll_mean}\r\n        1    0.000    0.000    0.001    0.001 sorting.py:599(get_indexer_dict)\r\n        1    0.000    0.000    0.001    0.001 objects.py:324(get_window_bounds)\r\n        1    0.000    0.000    0.001    0.001 groupby.py:2649(rolling)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:678(__init__)\r\n       12    0.001    0.000    0.001    0.000 {method 'take' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.001    0.001 frame.py:5087(drop)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4505(drop)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4544(_drop_axis)\r\n        1    0.000    0.000    0.001    0.001 ops.py:910(result_index)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:688(result_index)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:700(group_index)\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:186(__init__)\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:339(_finalize)\r\n        2    0.000    0.000    0.001    0.000 dtypes.py:511(validate_categories)\r\n        2    0.001    0.000    0.001    0.000 base.py:2168(is_unique)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:846(_create_data)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:722(_codes_and_uniques)\r\n        6    0.000    0.000    0.001    0.000 take.py:58(take_nd)\r\n        6    0.000    0.000    0.001    0.000 take.py:120(_take_nd_ndarray)\r\n    27/15    0.000    0.000    0.001    0.000 {built-in method numpy.core._multiarray_umath.implement_array_function}\r\n        2    0.000    0.000    0.001    0.000 managers.py:641(reindex_indexer)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3819(take)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3898(_take)\r\n        1    0.000    0.000    0.001    0.001 managers.py:886(take)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:632(get_group_index_sorter)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:858(take_nd)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.groupsort_indexer}\r\n        2    0.000    0.000    0.000    0.000 objects.py:76(get_window_bounds)\r\n        1    0.000    0.000    0.000    0.000 base.py:6610(drop)\r\n        2    0.000    0.000    0.000    0.000 base.py:3676(get_indexer)\r\n        3    0.000    0.000    0.000    0.000 base.py:1033(take)\r\n        4    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(clip)\r\n        1    0.000    0.000    0.000    0.000 managers.py:705(<listcomp>)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:2111(clip)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:51(_wrapfunc)\r\n        1    0.000    0.000    0.000    0.000 managers.py:726(_slice_take_blocks_ax0)\r\n        4    0.000    0.000    0.000    0.000 {method 'clip' of 'numpy.ndarray' objects}\r\n        4    0.000    0.000    0.000    0.000 _methods.py:127(_clip)\r\n        1    0.000    0.000    0.000    0.000 frame.py:8104(groupby)\r\n        6    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(concatenate)\r\n        1    0.000    0.000    0.000    0.000 base.py:5777(get_indexer_for)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_2d_axis0_float64_float64}\r\n        1    0.000    0.000    0.000    0.000 groupby.py:896(__init__)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:790(get_grouper)\r\n        3    0.000    0.000    0.000    0.000 algorithms.py:1396(take)\r\n        4    0.000    0.000    0.000    0.000 _methods.py:108(_clip_dep_invoke_with_casting)\r\n  392/382    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n        4    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_1d_int64_int64}\r\n        3    0.000    0.000    0.000    0.000 base.py:449(__new__)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.take_2d_axis1_float64_float64}\r\n        1    0.000    0.000    0.000    0.000 frame.py:2459(_from_arrays)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.indices_fast}\r\n        2    0.000    0.000    0.000    0.000 multi.py:313(__new__)\r\n        5    0.000    0.000    0.000    0.000 {built-in method numpy.arange}\r\n        1    0.000    0.000    0.000    0.000 sorting.py:109(get_group_index)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:742(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 construction.py:96(arrays_to_mgr)\r\n       12    0.000    0.000    0.000    0.000 {method 'astype' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 frame.py:3689(__getitem__)\r\n        4    0.000    0.000    0.000    0.000 cast.py:971(coerce_indexer_dtype)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:622(<listcomp>)\r\n        9    0.000    0.000    0.000    0.000 base.py:7014(ensure_index)\r\n        2    0.000    0.000    0.000    0.000 base.py:6305(_maybe_cast_listlike_indexer)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:265(_get_hashtable_algo)\r\n      117    0.000    0.000    0.000    0.000 generic.py:42(_instancecheck)\r\n        1    0.000    0.000    0.000    0.000 utils.py:241(maybe_convert_indices)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2069(create_block_manager_from_column_arrays)\r\n        1    0.000    0.000    0.000    0.000 frame.py:4220(_get_item_cache)\r\n        2    0.000    0.000    0.000    0.000 base.py:6029(_should_compare)\r\n        3    0.000    0.000    0.000    0.000 construction.py:500(sanitize_array)\r\n        9    0.000    0.000    0.000    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n        1    0.000    0.000    0.000    0.000 managers.py:2141(_form_blocks)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(append)\r\n        2    0.000    0.000    0.000    0.000 multi.py:982(_set_codes)\r\n        1    0.000    0.000    0.000    0.000 frame.py:3615(_ixs)\r\n        2    0.000    0.000    0.000    0.000 function_base.py:5444(append)\r\n        5    0.000    0.000    0.000    0.000 {method 'any' of 'numpy.ndarray' objects}\r\n        6    0.000    0.000    0.000    0.000 common.py:1241(is_bool_dtype)\r\n       17    0.000    0.000    0.000    0.000 base.py:286(is_dtype)\r\n        5    0.000    0.000    0.000    0.000 multi.py:998(<genexpr>)\r\n        3    0.000    0.000    0.000    0.000 multi.py:3871(_coerce_indexer_frozen)\r\n        5    0.000    0.000    0.000    0.000 _methods.py:55(_any)\r\n       13    0.000    0.000    0.000    0.000 common.py:458(is_categorical_dtype)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:355(_prep_values)\r\n   130/99    0.000    0.000    0.000    0.000 {built-in method builtins.len}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int8}\r\n      117    0.000    0.000    0.000    0.000 generic.py:37(_check)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:113(_ensure_data)\r\n        8    0.000    0.000    0.000    0.000 _methods.py:93(_clip_dep_is_scalar_nan)\r\n        2    0.000    0.000    0.000    0.000 base.py:791(_engine)\r\n       27    0.000    0.000    0.000    0.000 base.py:4892(_values)\r\n        2    0.000    0.000    0.000    0.000 common.py:229(asarray_tuplesafe)\r\n        2    0.000    0.000    0.000    0.000 base.py:3764(_get_indexer)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1916(__contains__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2199(_stack_arrays)\r\n        2    0.000    0.000    0.000    0.000 base.py:5052(__contains__)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int32}\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:283(_check_object_for_strings)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:344(_name_get)\r\n        1    0.000    0.000    0.000    0.000 base.py:636(_with_infer)\r\n        1    0.000    0.000    0.000    0.000 common.py:261(index_labels_to_array)\r\n        1    0.000    0.000    0.000    0.000 range.py:201(_data)\r\n        3    0.000    0.000    0.000    0.000 base.py:2599(inferred_type)\r\n        1    0.000    0.000    0.000    0.000 cast.py:1129(maybe_infer_to_datetimelike)\r\n        5    0.000    0.000    0.000    0.000 {pandas._libs.lib.infer_dtype}\r\n        3    0.000    0.000    0.000    0.000 generic.py:5975(__setattr__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1039(iget)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:117(__init__)\r\n        2    0.000    0.000    0.000    0.000 base.py:3809(_check_indexing_method)\r\n        1    0.000    0.000    0.000    0.000 base.py:6518(delete)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.maybe_convert_objects}\r\n        4    0.000    0.000    0.000    0.000 algorithms.py:193(_reconstruct_data)\r\n       12    0.000    0.000    0.000    0.000 base.py:616(_simple_new)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(prod)\r\n        2    0.000    0.000    0.000    0.000 base.py:5255(equals)\r\n        3    0.000    0.000    0.000    0.000 fromnumeric.py:69(_wrapreduction)\r\n        2    0.000    0.000    0.000    0.000 multi.py:807(_set_levels)\r\n        4    0.000    0.000    0.000    0.000 managers.py:163(blknos)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:1752(_validate)\r\n       16    0.000    0.000    0.000    0.000 common.py:1491(_is_dtype_type)\r\n        2    0.000    0.000    0.000    0.000 typing.py:868(__new__)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:2955(prod)\r\n        1    0.000    0.000    0.000    0.000 generic.py:720(_set_axis)\r\n        2    0.000    0.000    0.000    0.000 _ufunc_config.py:33(seterr)\r\n        2    0.000    0.000    0.000    0.000 {method '_rebuild_blknos_and_blklocs' of 'pandas._libs.internals.BlockManager' objects}\r\n        7    0.000    0.000    0.000    0.000 {built-in method builtins.any}\r\n        6    0.000    0.000    0.000    0.000 construction.py:402(extract_array)\r\n        4    0.000    0.000    0.000    0.000 base.py:4918(_get_engine_target)\r\n      152    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}\r\n        1    0.000    0.000    0.000    0.000 frame.py:4203(_box_col_values)\r\n        1    0.000    0.000    0.000    0.000 base.py:1786(rename)\r\n        2    0.000    0.000    0.000    0.000 generic.py:1921(empty)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(delete)\r\n        8    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(ndim)\r\n        1    0.000    0.000    0.000    0.000 base.py:1679(set_names)\r\n        8    0.000    0.000    0.000    0.000 common.py:157(is_object_dtype)\r\n        2    0.000    0.000    0.000    0.000 {method 'get_indexer' of 'pandas._libs.index.IndexEngine' objects}\r\n        4    0.000    0.000    0.000    0.000 base.py:54(shape)\r\n        4    0.000    0.000    0.000    0.000 common.py:1124(is_numeric_dtype)\r\n        3    0.000    0.000    0.000    0.000 generic.py:5915(__finalize__)\r\n       20    0.000    0.000    0.000    0.000 common.py:1456(get_dtype)\r\n        3    0.000    0.000    0.000    0.000 frame.py:640(__init__)\r\n        1    0.000    0.000    0.000    0.000 dtypes.py:547(update_dtype)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:430(__enter__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:219(set_axis)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:190(fill_value)\r\n        2    0.000    0.000    0.000    0.000 blocks.py:228(make_block_same_class)\r\n        1    0.000    0.000    0.000    0.000 function_base.py:5054(delete)\r\n        4    0.000    0.000    0.000    0.000 generic.py:262(__init__)\r\n        1    0.000    0.000    0.000    0.000 config.py:260(__call__)\r\n        2    0.000    0.000    0.000    0.000 common.py:420(is_interval_dtype)\r\n        1    0.000    0.000    0.000    0.000 numeric.py:290(full)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:508(__init__)\r\n        1    0.000    0.000    0.000    0.000 config.py:134(_get_option)\r\n        1    0.000    0.000    0.000    0.000 base.py:58(_validate_set_axis)\r\n        6    0.000    0.000    0.000    0.000 take.py:564(_take_preprocess_indexer_and_fill_value)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:36(__init__)\r\n        2    0.000    0.000    0.000    0.000 missing.py:625(na_value_for_dtype)\r\n        5    0.000    0.000    0.000    0.000 base.py:731(_view)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:330(_name_includes_bit_suffix)\r\n        6    0.000    0.000    0.000    0.000 common.py:549(is_dtype_equal)\r\n        6    0.000    0.000    0.000    0.000 generic.py:1979(<genexpr>)\r\n        5    0.000    0.000    0.000    0.000 multi.py:828(<genexpr>)\r\n        3    0.000    0.000    0.000    0.000 base.py:559(_dtype_to_subclass)\r\n        4    0.000    0.000    0.000    0.000 base.py:5102(__getitem__)\r\n       25    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_list_like}\r\n        2    0.000    0.000    0.000    0.000 dtypes.py:1241(is_dtype)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:165(simplefilter)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:412(_resolve_output)\r\n        2    0.000    0.000    0.000    0.000 multi.py:1398(_set_names)\r\n        2    0.000    0.000    0.000    0.000 base.py:6047(_is_comparable_dtype)\r\n        1    0.000    0.000    0.000    0.000 dtypes.py:209(_from_values_or_dtype)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(all)\r\n       33    0.000    0.000    0.000    0.000 {built-in method numpy.asarray}\r\n        7    0.000    0.000    0.000    0.000 abc.py:96(__instancecheck__)\r\n        2    0.000    0.000    0.000    0.000 base.py:5949(_maybe_promote)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1685(_check_label_or_level_ambiguity)\r\n        8    0.000    0.000    0.000    0.000 fromnumeric.py:3152(ndim)\r\n       12    0.000    0.000    0.000    0.000 base.py:56(<genexpr>)\r\n       24    0.000    0.000    0.000    0.000 base.py:842(__len__)\r\n        4    0.000    0.000    0.000    0.000 ops.py:830(names)\r\n        1    0.000    0.000    0.000    0.000 multi.py:782(__len__)\r\n        2    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(ravel)\r\n        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(copyto)\r\n        1    0.000    0.000    0.000    0.000 _asarray.py:31(require)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:181(_add_filter)\r\n        1    0.000    0.000    0.000    0.000 config.py:116(_get_single_key)\r\n        1    0.000    0.000    0.000    0.000 fromnumeric.py:2432(all)\r\n        1    0.000    0.000    0.000    0.000 {method 'max' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 construction.py:128(<listcomp>)\r\n        2    0.000    0.000    0.000    0.000 numerictypes.py:356(issubdtype)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:1021(_convert_grouper)\r\n        9    0.000    0.000    0.000    0.000 {built-in method numpy.empty}\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:435(__exit__)\r\n        1    0.000    0.000    0.000    0.000 objects.py:288(__init__)\r\n        3    0.000    0.000    0.000    0.000 base.py:7109(maybe_extract_name)\r\n        2    0.000    0.000    0.000    0.000 base.py:7144(unpack_nested_dtype)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:733(codes)\r\n       41    0.000    0.000    0.000    0.000 {built-in method builtins.issubclass}\r\n        1    0.000    0.000    0.000    0.000 base.py:3585(get_loc)\r\n        1    0.000    0.000    0.000    0.000 frozen.py:73(__getitem__)\r\n        6    0.000    0.000    0.000    0.000 generic.py:520(_get_axis)\r\n        1    0.000    0.000    0.000    0.000 _methods.py:39(_amax)\r\n        7    0.000    0.000    0.000    0.000 {built-in method _abc._abc_instancecheck}\r\n        2    0.000    0.000    0.000    0.000 common.py:1206(is_float_dtype)\r\n        2    0.000    0.000    0.000    0.000 _ufunc_config.py:132(geterr)\r\n        6    0.000    0.000    0.000    0.000 base.py:120(_reset_cache)\r\n        2    0.000    0.000    0.000    0.000 frame.py:3659(_iter_column_arrays)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:230(_validate_numeric_only)\r\n        4    0.000    0.000    0.000    0.000 _weakrefset.py:81(add)\r\n        1    0.000    0.000    0.000    0.000 series.py:367(__init__)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:1781(ravel)\r\n       28    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}\r\n        7    0.000    0.000    0.000    0.000 inference.py:189(is_array_like)\r\n        2    0.000    0.000    0.000    0.000 common.py:651(is_integer_dtype)\r\n       24    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_platform_int}\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:116(update)\r\n        5    0.000    0.000    0.000    0.000 cast.py:559(maybe_promote)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:458(__enter__)\r\n        2    0.000    0.000    0.000    0.000 inference.py:267(is_dict_like)\r\n        2    0.000    0.000    0.000    0.000 base.py:432(_engine_type)\r\n        6    0.000    0.000    0.000    0.000 common.py:1074(needs_i8_conversion)\r\n        1    0.000    0.000    0.000    0.000 multi.py:796(levels)\r\n        3    0.000    0.000    0.000    0.000 _weakrefset.py:38(_remove)\r\n        3    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap>:1017(_handle_fromlist)\r\n       14    0.000    0.000    0.000    0.000 base.py:780(_reset_identity)\r\n        1    0.000    0.000    0.000    0.000 base.py:1634(_set_names)\r\n        2    0.000    0.000    0.000    0.000 base.py:2641(_na_value)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:619(_passed_categorical)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:379(_insert_on_column)\r\n        6    0.000    0.000    0.000    0.000 common.py:1386(is_ea_or_datetimelike_dtype)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:162(_validate)\r\n        6    0.000    0.000    0.000    0.000 common.py:151(<lambda>)\r\n        2    0.000    0.000    0.000    0.000 {method 'format' of 'str' objects}\r\n        8    0.000    0.000    0.000    0.000 _methods.py:103(_clip_dep_is_byte_swapped)\r\n        6    0.000    0.000    0.000    0.000 take.py:325(_get_take_nd_function)\r\n        1    0.000    0.000    0.000    0.000 series.py:1262(_set_as_cached)\r\n        4    0.000    0.000    0.000    0.000 common.py:1332(is_extension_array_dtype)\r\n       16    0.000    0.000    0.000    0.000 {built-in method __new__ of type object at 0x5614d1f30680}\r\n        4    0.000    0.000    0.000    0.000 ops.py:832(<listcomp>)\r\n       10    0.000    0.000    0.000    0.000 common.py:143(<lambda>)\r\n        4    0.000    0.000    0.000    0.000 numerictypes.py:282(issubclass_)\r\n        3    0.000    0.000    0.000    0.000 base.py:2623(_is_multi)\r\n        7    0.000    0.000    0.000    0.000 inference.py:328(is_hashable)\r\n        3    0.000    0.000    0.000    0.000 base.py:1631(_get_names)\r\n        3    0.000    0.000    0.000    0.000 {built-in method builtins.all}\r\n        1    0.000    0.000    0.000    0.000 series.py:691(_values)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:404(_index_array)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1775(_consolidate_inplace)\r\n        1    0.000    0.000    0.000    0.000 frame.py:3649(_get_column_array)\r\n        2    0.000    0.000    0.000    0.000 frame.py:903(shape)\r\n        3    0.000    0.000    0.000    0.000 objects.py:46(__init__)\r\n        1    0.000    0.000    0.000    0.000 multi.py:801(<listcomp>)\r\n       12    0.000    0.000    0.000    0.000 generic.py:506(_get_axis_number)\r\n        3    0.000    0.000    0.000    0.000 construction.py:650(_sanitize_ndim)\r\n        1    0.000    0.000    0.000    0.000 config.py:595(_get_root)\r\n        2    0.000    0.000    0.000    0.000 {built-in method numpy.array}\r\n        2    0.000    0.000    0.000    0.000 copy.py:66(copy)\r\n        4    0.000    0.000    0.000    0.000 common.py:150(cast_scalar_indexer)\r\n        2    0.000    0.000    0.000    0.000 algorithms.py:231(_ensure_arraylike)\r\n        6    0.000    0.000    0.000    0.000 range.py:889(__len__)\r\n        2    0.000    0.000    0.000    0.000 managers.py:974(from_blocks)\r\n        1    0.000    0.000    0.000    0.000 base.py:2664(hasnans)\r\n        2    0.000    0.000    0.000    0.000 {method 'remove' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 managers.py:1053(iget_values)\r\n        4    0.000    0.000    0.000    0.000 flags.py:49(__init__)\r\n        2    0.000    0.000    0.000    0.000 missing.py:455(array_equivalent)\r\n        5    0.000    0.000    0.000    0.000 {built-in method numpy.asanyarray}\r\n        4    0.000    0.000    0.000    0.000 common.py:1649(pandas_dtype)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1757(is_consolidated)\r\n        1    0.000    0.000    0.000    0.000 base.py:740(_rename)\r\n        4    0.000    0.000    0.000    0.000 common.py:274(is_datetime64_dtype)\r\n        1    0.000    0.000    0.000    0.000 config.py:648(_warn_if_deprecated)\r\n        3    0.000    0.000    0.000    0.000 base.py:541(_ensure_array)\r\n        2    0.000    0.000    0.000    0.000 common.py:1432(_is_dtype)\r\n        6    0.000    0.000    0.000    0.000 __init__.py:33(using_copy_on_write)\r\n        4    0.000    0.000    0.000    0.000 dtypes.py:492(validate_ordered)\r\n        3    0.000    0.000    0.000    0.000 flags.py:85(allows_duplicate_labels)\r\n       10    0.000    0.000    0.000    0.000 common.py:141(classes)\r\n        2    0.000    0.000    0.000    0.000 {built-in method numpy.seterrobj}\r\n        8    0.000    0.000    0.000    0.000 base.py:1545(name)\r\n        1    0.000    0.000    0.000    0.000 _asarray.py:112(<setcomp>)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1961(internal_values)\r\n        1    0.000    0.000    0.000    0.000 blocks.py:2211(get_block_type)\r\n        1    0.000    0.000    0.000    0.000 ops.py:821(codes)\r\n        5    0.000    0.000    0.000    0.000 _dtype.py:24(_kind_name)\r\n        2    0.000    0.000    0.000    0.000 range.py:307(dtype)\r\n        2    0.000    0.000    0.000    0.000 missing.py:949(clean_reindex_fill_method)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2125(_grouping_func)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:220(_slice_axis_for_step)\r\n        1    0.000    0.000    0.000    0.000 common.py:1624(validate_all_hashable)\r\n        3    0.000    0.000    0.000    0.000 construction.py:689(_sanitize_str_dtypes)\r\n       11    0.000    0.000    0.000    0.000 ops.py:699(groupings)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:697(categories)\r\n       11    0.000    0.000    0.000    0.000 base.py:324(ndim)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:437(__init__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:2273(_preprocess_slice_or_indexer)\r\n        3    0.000    0.000    0.000    0.000 construction.py:464(ensure_wrapped_if_datetimelike)\r\n        6    0.000    0.000    0.000    0.000 inference.py:294(<genexpr>)\r\n        6    0.000    0.000    0.000    0.000 common.py:146(classes_and_not_datetimelike)\r\n        2    0.000    0.000    0.000    0.000 warnings.py:477(__exit__)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:724(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:312(__getattr__)\r\n        1    0.000    0.000    0.000    0.000 _ufunc_config.py:426(__init__)\r\n        7    0.000    0.000    0.000    0.000 generic.py:620(ndim)\r\n        1    0.000    0.000    0.000    0.000 base.py:2070(_can_hold_na)\r\n        4    0.000    0.000    0.000    0.000 {built-in method numpy.geterrobj}\r\n        1    0.000    0.000    0.000    0.000 grouper.py:623(name)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:891(<genexpr>)\r\n        2    0.000    0.000    0.000    0.000 config.py:609(_get_deprecated_option)\r\n        2    0.000    0.000    0.000    0.000 base.py:749(is_)\r\n        1    0.000    0.000    0.000    0.000 generic.py:596(_info_axis)\r\n        4    0.000    0.000    0.000    0.000 common.py:350(is_timedelta64_dtype)\r\n        1    0.000    0.000    0.000    0.000 ops.py:685(__init__)\r\n        1    0.000    0.000    0.000    0.000 rolling.py:264(_create_data)\r\n        1    0.000    0.000    0.000    0.000 indexing.py:2606(check_dict_or_set_indexers)\r\n        2    0.000    0.000    0.000    0.000 {method 'copy' of 'numpy.ndarray' objects}\r\n        4    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 rolling.py:205(_check_window_bounds)\r\n        6    0.000    0.000    0.000    0.000 base.py:898(dtype)\r\n        1    0.000    0.000    0.000    0.000 multi.py:506(<listcomp>)\r\n        9    0.000    0.000    0.000    0.000 {built-in method builtins.hash}\r\n        2    0.000    0.000    0.000    0.000 blocks.py:824(iget)\r\n        1    0.000    0.000    0.000    0.000 ops.py:824(<listcomp>)\r\n        6    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 ops.py:790(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 generic.py:526(_get_block_manager_axis)\r\n        2    0.000    0.000    0.000    0.000 sorting.py:608(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 config.py:577(_select_options)\r\n        3    0.000    0.000    0.000    0.000 fromnumeric.py:70(<dictcomp>)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:943(is_in_obj)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:144(_int64_cut_off)\r\n        8    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_scalar}\r\n        2    0.000    0.000    0.000    0.000 grouper.py:893(<genexpr>)\r\n        9    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\r\n        4    0.000    0.000    0.000    0.000 multi.py:943(nlevels)\r\n        1    0.000    0.000    0.000    0.000 _validators.py:222(validate_bool_kwarg)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1765(_consolidate_check)\r\n        7    0.000    0.000    0.000    0.000 {method 'clear' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.internals.get_blkno_placements}\r\n        1    0.000    0.000    0.000    0.000 sorting.py:157(<listcomp>)\r\n        5    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\r\n        1    0.000    0.000    0.000    0.000 groupby.py:720(_selected_obj)\r\n        2    0.000    0.000    0.000    0.000 {method 'ravel' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 groupby.py:945(__getattr__)\r\n        1    0.000    0.000    0.000    0.000 ops.py:826(levels)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:927(is_in_axis)\r\n        2    0.000    0.000    0.000    0.000 multi.py:1395(_get_names)\r\n        7    0.000    0.000    0.000    0.000 typing.py:1149(cast)\r\n        6    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_bool}\r\n        2    0.000    0.000    0.000    0.000 common.py:1643(<genexpr>)\r\n        8    0.000    0.000    0.000    0.000 fromnumeric.py:3148(_ndim_dispatcher)\r\n        5    0.000    0.000    0.000    0.000 dtypes.py:580(categories)\r\n        2    0.000    0.000    0.000    0.000 grouper.py:669(codes)\r\n        3    0.000    0.000    0.000    0.000 {method 'discard' of 'set' objects}\r\n        4    0.000    0.000    0.000    0.000 managers.py:179(blklocs)\r\n        1    0.000    0.000    0.000    0.000 range.py:482(equals)\r\n        3    0.000    0.000    0.000    0.000 base.py:654(_constructor)\r\n        3    0.000    0.000    0.000    0.000 base.py:1064(_maybe_disallow_fill)\r\n        6    0.000    0.000    0.000    0.000 multiarray.py:152(concatenate)\r\n        1    0.000    0.000    0.000    0.000 {method 'get_loc' of 'pandas._libs.index.IndexEngine' objects}\r\n        5    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_integer}\r\n        1    0.000    0.000    0.000    0.000 categorical.py:1768(_codes)\r\n        6    0.000    0.000    0.000    0.000 {built-in method _warnings._filters_mutated}\r\n        1    0.000    0.000    0.000    0.000 config.py:636(_translate_key)\r\n        1    0.000    0.000    0.000    0.000 {built-in method builtins.max}\r\n        1    0.000    0.000    0.000    0.000 frame.py:4217(_clear_item_cache)\r\n        2    0.000    0.000    0.000    0.000 missing.py:121(clean_fill_method)\r\n        3    0.000    0.000    0.000    0.000 base.py:5937(_index_as_unique)\r\n        3    0.000    0.000    0.000    0.000 generic.py:335(attrs)\r\n        4    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_float}\r\n        2    0.000    0.000    0.000    0.000 grouper.py:892(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 sorting.py:227(is_int64_overflow_possible)\r\n        2    0.000    0.000    0.000    0.000 frame.py:631(_constructor)\r\n        4    0.000    0.000    0.000    0.000 fromnumeric.py:2107(_clip_dispatcher)\r\n        6    0.000    0.000    0.000    0.000 generic.py:356(flags)\r\n        3    0.000    0.000    0.000    0.000 flags.py:53(allows_duplicate_labels)\r\n        2    0.000    0.000    0.000    0.000 {method 'insert' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 numba_.py:18(maybe_use_numba)\r\n        1    0.000    0.000    0.000    0.000 categorical.py:459(dtype)\r\n        2    0.000    0.000    0.000    0.000 common.py:1165(<lambda>)\r\n        1    0.000    0.000    0.000    0.000 common.py:1319(is_1d_only_ea_dtype)\r\n        1    0.000    0.000    0.000    0.000 {method 'item' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.000    0.000 base.py:200(_selected_obj)\r\n        1    0.000    0.000    0.000    0.000 frame.py:886(axes)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1799(__init__)\r\n        3    0.000    0.000    0.000    0.000 dtypes.py:587(ordered)\r\n        1    0.000    0.000    0.000    0.000 managers.py:224(is_single_block)\r\n        1    0.000    0.000    0.000    0.000 common.py:367(apply_if_callable)\r\n        2    0.000    0.000    0.000    0.000 {method 'values' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 range.py:248(start)\r\n        1    0.000    0.000    0.000    0.000 grouper.py:1017(_is_label_like)\r\n        3    0.000    0.000    0.000    0.000 construction.py:709(_maybe_repeat)\r\n        3    0.000    0.000    0.000    0.000 {pandas._libs.lib.is_iterator}\r\n        2    0.000    0.000    0.000    0.000 function_base.py:5440(_append_dispatcher)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:1777(_ravel_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 ops.py:828(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 managers.py:1894(_block)\r\n        3    0.000    0.000    0.000    0.000 managers.py:939(__init__)\r\n        2    0.000    0.000    0.000    0.000 {method 'extend' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 function.py:60(__call__)\r\n        1    0.000    0.000    0.000    0.000 managers.py:229(items)\r\n        1    0.000    0.000    0.000    0.000 ops.py:791(<listcomp>)\r\n        1    0.000    0.000    0.000    0.000 blocks.py:476(dtype)\r\n        2    0.000    0.000    0.000    0.000 fromnumeric.py:2950(_prod_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\r\n        2    0.000    0.000    0.000    0.000 multi.py:978(codes)\r\n        1    0.000    0.000    0.000    0.000 {method 'upper' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 grouper.py:641(_ilevel)\r\n        1    0.000    0.000    0.000    0.000 range.py:263(step)\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.lib.item_from_zerodim}\r\n        2    0.000    0.000    0.000    0.000 {built-in method builtins.callable}\r\n        1    0.000    0.000    0.000    0.000 function_base.py:5050(_delete_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 {method 'split' of 'str' objects}\r\n        1    0.000    0.000    0.000    0.000 range.py:195(_constructor)\r\n        1    0.000    0.000    0.000    0.000 fromnumeric.py:2427(_all_dispatcher)\r\n        1    0.000    0.000    0.000    0.000 series.py:594(name)\r\n        2    0.000    0.000    0.000    0.000 {method 'copy' of 'list' objects}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_float64}\r\n        1    0.000    0.000    0.000    0.000 multiarray.py:1079(copyto)\r\n        1    0.000    0.000    0.000    0.000 generic.py:1706(<genexpr>)\r\n        1    0.000    0.000    0.000    0.000 range.py:256(stop)\r\n        1    0.000    0.000    0.000    0.000 base.py:6298(_maybe_cast_indexer)\r\n        1    0.000    0.000    0.000    0.000 {method 'pop' of 'dict' objects}\r\n        1    0.000    0.000    0.000    0.000 {pandas._libs.algos.ensure_int64}\r\n        1    0.000    0.000    0.000    0.000 {function FrozenList.__getitem__ at 0x7f33e8ab3280}\r\n\r\n\r\n"]
[205.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[205.002, "i", "asv profile --python=same rolling.GroupbyLargeGroups.time_rolling_multiindex_creation | head -n 60\r"]
[205.004, "o", "asv profile --python=same rolling.GroupbyLargeGroups.time_rolling_multiindex_creation | head -n 60\r\n"]
[205.006, "o", "\u001b[?2004l\r\n\u00b7 Discovering benchmarks\r\n\u00b7 Profile data does not already exist. Running profiler now.\r\n\u00b7\u00b7 Benchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\r\ngit -C .. add pandas/core/window/rolling.py\r\n\u00b7\u00b7\u00b7 Running (rolling.GroupbyLargeGroups.time_rolling_multiindex_creation--).\r\n\u00b7\u00b7\u00b7 ...LargeGroups.time_rolling_multiindex_creation         19.3\u00b10.3ms\r\n\r\nWed Oct  1 18:32:45 2025    /tmp/tmpamb2c5gl\r\n\r\n         2358 function calls (2304 primitive calls) in 0.021 seconds\r\n\r\n   Ordered by: cumulative time\r\n\r\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n        1    0.000    0.000    0.021    0.021 {built-in method builtins.exec}\r\n        1    0.000    0.000    0.021    0.021 _base.py:689(method_caller)\r\n        1    0.000    0.000    0.021    0.021 rolling.py:322(time_rolling_multiindex_creation)\r\n        1    0.000    0.000    0.020    0.020 rolling.py:2070(mean)\r\n        1    0.000    0.000    0.020    0.020 rolling.py:1489(mean)\r\n        1    0.000    0.000    0.020    0.020 rolling.py:701(_apply)\r\n        1    0.000    0.000    0.014    0.014 multi.py:445(from_arrays)\r\n        1    0.000    0.000    0.014    0.014 categorical.py:2586(factorize_from_iterables)\r\n        2    0.000    0.000    0.014    0.007 categorical.py:2607(<genexpr>)\r\n        1    0.000    0.000    0.014    0.014 categorical.py:2545(factorize_from_iterable)\r\n        1    0.000    0.000    0.014    0.014 categorical.py:359(__init__)\r\n      3/2    0.000    0.000    0.013    0.007 algorithms.py:610(factorize)\r\n        1    0.000    0.000    0.012    0.012 base.py:1143(factorize)\r\n        2    0.000    0.000    0.010    0.005 algorithms.py:1702(safe_sort)\r\n        4    0.010    0.003    0.010    0.003 {method 'argsort' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.006    0.006 rolling.py:558(_apply)\r\n        1    0.000    0.000    0.004    0.004 rolling.py:456(_apply_blockwise)\r\n        2    0.000    0.000    0.003    0.001 algorithms.py:548(factorize_array)\r\n        2    0.003    0.001    0.003    0.001 {method 'factorize' of 'pandas._libs.hashtable.Int64HashTable' objects}\r\n        1    0.000    0.000    0.002    0.002 rolling.py:591(homogeneous_func)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:597(calc)\r\n        1    0.000    0.000    0.002    0.002 rolling.py:2695(_get_window_indexer)\r\n        1    0.000    0.000    0.002    0.002 ops.py:784(indices)\r\n        1    0.001    0.001    0.001    0.001 {pandas._libs.window.aggregations.roll_mean}\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:186(__init__)\r\n        4    0.000    0.000    0.001    0.000 dtypes.py:339(_finalize)\r\n        2    0.000    0.000    0.001    0.001 dtypes.py:511(validate_categories)\r\n        1    0.000    0.000    0.001    0.001 objects.py:324(get_window_bounds)\r\n        2    0.001    0.000    0.001    0.000 base.py:2168(is_unique)\r\n        1    0.000    0.000    0.001    0.001 sorting.py:599(get_indexer_dict)\r\n        1    0.000    0.000    0.001    0.001 groupby.py:2649(rolling)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:846(_create_data)\r\n        1    0.000    0.000    0.001    0.001 rolling.py:678(__init__)\r\n        1    0.000    0.000    0.001    0.001 ops.py:910(result_index)\r\n       12    0.001    0.000    0.001    0.000 {method 'take' of 'numpy.ndarray' objects}\r\n        1    0.000    0.000    0.001    0.001 grouper.py:688(result_index)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:700(group_index)\r\n        1    0.000    0.000    0.001    0.001 frame.py:5087(drop)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4505(drop)\r\n        1    0.000    0.000    0.001    0.001 generic.py:4544(_drop_axis)\r\n        1    0.000    0.000    0.001    0.001 grouper.py:722(_codes_and_uniques)\r\n        6    0.000    0.000    0.001    0.000 take.py:58(take_nd)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3819(take)\r\n        1    0.000    0.000    0.001    0.001 generic.py:3898(_take)\r\n        6    0.000    0.000    0.001    0.000 take.py:120(_take_nd_ndarray)\r\n        1    0.000    0.000    0.001    0.001 managers.py:886(take)\r\n        2    0.000    0.000    0.001    0.000 managers.py:641(reindex_indexer)\r\nTraceback (most recent call last):\r\n  File \"/opt/conda/envs/asv_3.8/bin/asv\", line 8, in <module>\r\n    sys.exit(main())\r\n  File \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/asv/main.py\", line 28, in main\r\n    result = args.func(args)\r\n  File \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/asv/commands/__init__.py\", line 48, in run_from_args\r\n    return cls.run_from_conf_args(conf, args)\r\n  File \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/asv/commands/profiling.py\", line 84, in run_from_conf_args\r\n    return cls.run(\r\n  File \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/asv/commands/profiling.py\", line 224, in run\r\n    stats.print_stats()\r\n  File \"/opt/conda/envs/asv_3.8/lib/python3.8/pstats.py\", line 378, in print_stats\r\n    self.print_line(func)\r\n  File \"/opt/conda/envs/asv_3.8/lib/python3.8/pstats.py\", line 465, in print_line\r\n    print(f8(ct/cc), end=' ', file=self.stream)\r\nBrokenPipeError: [Errno 32] Broken pipe\r\n"]
[210.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[210.002, "i", "git -C .. add pandas/core/window/rolling.py\r"]
[210.004, "o", "git -C .. add pandas/core/window/rolling.py\r\n"]
[210.006, "o", "\u001b[?2004l\r\n"]
[215.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[215.002, "i", "git -C .. commit -m \"Perf: avoid unnecessary int64 casting and allocations when constructing groupby order\r"]
[215.004, "o", "git -C .. commit -m \"Perf: avoid unnecessary int64 casting and allocations when constructing groupby order\r\n"]
[215.006, "o", "r indexer in Rolling._create_data (speeds up rolling.GroupbyLargeGroups)\"\r\n\u001b[?2004l\r\nAuthor identity unknown\r\n\r\n*** Please tell me who you are.\r\n\r\nRun\r\n\r\n  git config --global user.email \"you@example.com\"\r\n  git config --global user.name \"Your Name\"\r\n\r\nto set your account's default identity.\r\nOmit --global to set the identity only in this repository.\r\n\r\nfatal: unable to auto-detect email address (got 'root@cb2cc1765c92.(none)')\r\n"]
[220.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[220.002, "i", "asv run --python=same --bench=\"rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\" --quick\r"]
[220.004, "o", "asv run --python=same --bench=\"rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\" --quick\r\n"]
[220.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                               24.7\u00b10ms\r\n"]
[225.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[225.002, "i", "grep -n \"indices.values\" ../pandas/core/window/rolling.py\r"]
[225.004, "o", "grep -n \"indices.values\" ../pandas/core/window/rolling.py\r\n"]
[225.006, "o", "\u001b[?2004l\r\n\u001b[32m\u001b[K737\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        group_indices = self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K778\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            len(group) == len(other) for group in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K788\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                    for gb_indices in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K811\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            group_indices = self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K854\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            groupby_order = np.concatenate(list(self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K())).astype(\r\n\u001b[32m\u001b[K2737\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        for group_indices in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K():\r\n"]
[230.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[230.002, "i", "sed -n '1,220p' ../pandas/core/window/rolling.py\r"]
[230.004, "o", "sed -n '1,220p' ../pandas/core/window/rolling.py\r\n"]
[230.006, "o", "\u001b[?2004l\r\n\"\"\"\r\nProvide a generic structure to support window functions,\r\nsimilar to how we have a Groupby object.\r\n\"\"\"\r\nfrom __future__ import annotations\r\n\r\nimport copy\r\nfrom datetime import timedelta\r\nfrom functools import partial\r\nimport inspect\r\nfrom textwrap import dedent\r\nfrom typing import (\r\n    TYPE_CHECKING,\r\n    Any,\r\n    Callable,\r\n    Hashable,\r\n    Iterator,\r\n    Sized,\r\n    cast,\r\n)\r\n\r\nimport numpy as np\r\n\r\nfrom pandas._libs.tslibs import (\r\n    BaseOffset,\r\n    to_offset,\r\n)\r\nimport pandas._libs.window.aggregations as window_aggregations\r\nfrom pandas._typing import (\r\n    ArrayLike,\r\n    Axis,\r\n    NDFrameT,\r\n    QuantileInterpolation,\r\n    WindowingRankType,\r\n)\r\nfrom pandas.compat._optional import import_optional_dependency\r\nfrom pandas.errors import DataError\r\nfrom pandas.util._decorators import doc\r\n\r\nfrom pandas.core.dtypes.common import (\r\n    ensure_float64,\r\n    is_bool,\r\n    is_integer,\r\n    is_list_like,\r\n    is_numeric_dtype,\r\n    is_scalar,\r\n    needs_i8_conversion,\r\n)\r\nfrom pandas.core.dtypes.generic import (\r\n    ABCDataFrame,\r\n    ABCSeries,\r\n)\r\nfrom pandas.core.dtypes.missing import notna\r\n\r\nfrom pandas.core._numba import executor\r\nfrom pandas.core.algorithms import factorize\r\nfrom pandas.core.apply import ResamplerWindowApply\r\nfrom pandas.core.arrays import ExtensionArray\r\nfrom pandas.core.base import SelectionMixin\r\nimport pandas.core.common as com\r\nfrom pandas.core.indexers.objects import (\r\n    BaseIndexer,\r\n    FixedWindowIndexer,\r\n    GroupbyIndexer,\r\n    VariableWindowIndexer,\r\n)\r\nfrom pandas.core.indexes.api import (\r\n    DatetimeIndex,\r\n    Index,\r\n    MultiIndex,\r\n    PeriodIndex,\r\n    TimedeltaIndex,\r\n)\r\nfrom pandas.core.reshape.concat import concat\r\nfrom pandas.core.util.numba_ import (\r\n    get_jit_arguments,\r\n    maybe_use_numba,\r\n)\r\nfrom pandas.core.window.common import (\r\n    flex_binary_moment,\r\n    zsqrt,\r\n)\r\nfrom pandas.core.window.doc import (\r\n    _shared_docs,\r\n    create_section_header,\r\n    kwargs_numeric_only,\r\n    kwargs_scipy,\r\n    numba_notes,\r\n    template_header,\r\n    template_returns,\r\n    template_see_also,\r\n    window_agg_numba_parameters,\r\n    window_apply_parameters,\r\n)\r\nfrom pandas.core.window.numba_ import (\r\n    generate_manual_numpy_nan_agg_with_axis,\r\n    generate_numba_apply_func,\r\n    generate_numba_table_func,\r\n)\r\n\r\nif TYPE_CHECKING:\r\n    from pandas import (\r\n        DataFrame,\r\n        Series,\r\n    )\r\n    from pandas.core.generic import NDFrame\r\n    from pandas.core.groupby.ops import BaseGrouper\r\n\r\n\r\nclass BaseWindow(SelectionMixin):\r\n    \"\"\"Provides utilities for performing windowing operations.\"\"\"\r\n\r\n    _attributes: list[str] = []\r\n    exclusions: frozenset[Hashable] = frozenset()\r\n    _on: Index\r\n\r\n    def __init__(\r\n        self,\r\n        obj: NDFrame,\r\n        window=None,\r\n        min_periods: int | None = None,\r\n        center: bool | None = False,\r\n        win_type: str | None = None,\r\n        axis: Axis = 0,\r\n        on: str | Index | None = None,\r\n        closed: str | None = None,\r\n        step: int | None = None,\r\n        method: str = \"single\",\r\n        *,\r\n        selection=None,\r\n    ) -> None:\r\n        self.obj = obj\r\n        self.on = on\r\n        self.closed = closed\r\n        self.step = step\r\n        self.window = window\r\n        self.min_periods = min_periods\r\n        self.center = center\r\n        self.win_type = win_type\r\n        self.axis = obj._get_axis_number(axis) if axis is not None else None\r\n        self.method = method\r\n        self._win_freq_i8: int | None = None\r\n        if self.on is None:\r\n            if self.axis == 0:\r\n                self._on = self.obj.index\r\n            else:\r\n                # i.e. self.axis == 1\r\n                self._on = self.obj.columns\r\n        elif isinstance(self.on, Index):\r\n            self._on = self.on\r\n        elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\r\n            self._on = Index(self.obj[self.on])\r\n        else:\r\n            raise ValueError(\r\n                f\"invalid on specified as {self.on}, \"\r\n                \"must be a column (of DataFrame), an Index or None\"\r\n            )\r\n\r\n        self._selection = selection\r\n        self._validate()\r\n\r\n    def _validate(self) -> None:\r\n        if self.center is not None and not is_bool(self.center):\r\n            raise ValueError(\"center must be a boolean\")\r\n        if self.min_periods is not None:\r\n            if not is_integer(self.min_periods):\r\n                raise ValueError(\"min_periods must be an integer\")\r\n            if self.min_periods < 0:\r\n                raise ValueError(\"min_periods must be >= 0\")\r\n            if is_integer(self.window) and self.min_periods > self.window:\r\n                raise ValueError(\r\n                    f\"min_periods {self.min_periods} must be <= window {self.window}\"\r\n                )\r\n        if self.closed is not None and self.closed not in [\r\n            \"right\",\r\n            \"both\",\r\n            \"left\",\r\n            \"neither\",\r\n        ]:\r\n            raise ValueError(\"closed must be 'right', 'left', 'both' or 'neither'\")\r\n        if not isinstance(self.obj, (ABCSeries, ABCDataFrame)):\r\n            raise TypeError(f\"invalid type: {type(self)}\")\r\n        if isinstance(self.window, BaseIndexer):\r\n            # Validate that the passed BaseIndexer subclass has\r\n            # a get_window_bounds with the correct signature.\r\n            get_window_bounds_signature = inspect.signature(\r\n                self.window.get_window_bounds\r\n            ).parameters.keys()\r\n            expected_signature = inspect.signature(\r\n                BaseIndexer().get_window_bounds\r\n            ).parameters.keys()\r\n            if get_window_bounds_signature != expected_signature:\r\n                raise ValueError(\r\n                    f\"{type(self.window).__name__} does not implement \"\r\n                    f\"the correct signature for get_window_bounds\"\r\n                )\r\n        if self.method not in [\"table\", \"single\"]:\r\n            raise ValueError(\"method must be 'table' or 'single\")\r\n        if self.step is not None:\r\n            if not is_integer(self.step):\r\n                raise ValueError(\"step must be an integer\")\r\n            if self.step < 0:\r\n                raise ValueError(\"step must be >= 0\")\r\n\r\n    def _check_window_bounds(\r\n        self, start: np.ndarray, end: np.ndarray, num_vals: int\r\n    ) -> None:\r\n        if len(start) != len(end):\r\n            raise ValueError(\r\n                f\"start ({len(start)}) and end ({len(end)}) bounds must be the \"\r\n                f\"same length\"\r\n            )\r\n        if len(start) != (num_vals + (self.step or 1) - 1) // (self.step or 1):\r\n            raise ValueError(\r\n                f\"start and end bounds ({len(start)}) must be the same length \"\r\n                f\"as the object ({num_vals}) divided by the step ({self.step}) \"\r\n                f\"if given and rounded up\"\r\n            )\r\n\r\n    def _slice_axis_for_step(self, index: Index, result: Sized | None = None) -> Index:\r\n"]
[235.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[235.002, "i", "sed -n '220,720p' ../pandas/core/window/rolling.py\r"]
[235.004, "o", "sed -n '220,720p' ../pandas/core/window/rolling.py\r\n"]
[235.006, "o", "\u001b[?2004l\r\n    def _slice_axis_for_step(self, index: Index, result: Sized | None = None) -> Index:\r\n        \"\"\"\r\n        Slices the index for a given result and the preset step.\r\n        \"\"\"\r\n        return (\r\n            index\r\n            if result is None or len(result) == len(index)\r\n            else index[:: self.step]\r\n        )\r\n\r\n    def _validate_numeric_only(self, name: str, numeric_only: bool) -> None:\r\n        \"\"\"\r\n        Validate numeric_only argument, raising if invalid for the input.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the operator (kernel).\r\n        numeric_only : bool\r\n            Value passed by user.\r\n        \"\"\"\r\n        if (\r\n            self._selected_obj.ndim == 1\r\n            and numeric_only\r\n            and not is_numeric_dtype(self._selected_obj.dtype)\r\n        ):\r\n            raise NotImplementedError(\r\n                f\"{type(self).__name__}.{name} does not implement numeric_only\"\r\n            )\r\n\r\n    def _make_numeric_only(self, obj: NDFrameT) -> NDFrameT:\r\n        \"\"\"Subset DataFrame to numeric columns.\r\n\r\n        Parameters\r\n        ----------\r\n        obj : DataFrame\r\n\r\n        Returns\r\n        -------\r\n        obj subset to numeric-only columns.\r\n        \"\"\"\r\n        result = obj.select_dtypes(include=[\"number\"], exclude=[\"timedelta\"])\r\n        return result\r\n\r\n    def _create_data(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n        \"\"\"\r\n        Split data into blocks & return conformed data.\r\n        \"\"\"\r\n        # filter out the on from the object\r\n        if self.on is not None and not isinstance(self.on, Index) and obj.ndim == 2:\r\n            obj = obj.reindex(columns=obj.columns.difference([self.on]), copy=False)\r\n        if obj.ndim > 1 and (numeric_only or self.axis == 1):\r\n            # GH: 20649 in case of mixed dtype and axis=1 we have to convert everything\r\n            # to float to calculate the complete row at once. We exclude all non-numeric\r\n            # dtypes.\r\n            obj = self._make_numeric_only(obj)\r\n        if self.axis == 1:\r\n            obj = obj.astype(\"float64\", copy=False)\r\n            obj._mgr = obj._mgr.consolidate()\r\n        return obj\r\n\r\n    def _gotitem(self, key, ndim, subset=None):\r\n        \"\"\"\r\n        Sub-classes to define. Return a sliced object.\r\n\r\n        Parameters\r\n        ----------\r\n        key : str / list of selections\r\n        ndim : {1, 2}\r\n            requested ndim of result\r\n        subset : object, default None\r\n            subset to act on\r\n        \"\"\"\r\n        # create a new object to prevent aliasing\r\n        if subset is None:\r\n            subset = self.obj\r\n\r\n        # we need to make a shallow copy of ourselves\r\n        # with the same groupby\r\n        kwargs = {attr: getattr(self, attr) for attr in self._attributes}\r\n\r\n        selection = None\r\n        if subset.ndim == 2 and (\r\n            (is_scalar(key) and key in subset) or is_list_like(key)\r\n        ):\r\n            selection = key\r\n        elif subset.ndim == 1 and is_scalar(key) and key == subset.name:\r\n            selection = key\r\n\r\n        new_win = type(self)(subset, selection=selection, **kwargs)\r\n        return new_win\r\n\r\n    def __getattr__(self, attr: str):\r\n        if attr in self._internal_names_set:\r\n            return object.__getattribute__(self, attr)\r\n        if attr in self.obj:\r\n            return self[attr]\r\n\r\n        raise AttributeError(\r\n            f\"'{type(self).__name__}' object has no attribute '{attr}'\"\r\n        )\r\n\r\n    def _dir_additions(self):\r\n        return self.obj._dir_additions()\r\n\r\n    def __repr__(self) -> str:\r\n        \"\"\"\r\n        Provide a nice str repr of our rolling object.\r\n        \"\"\"\r\n        attrs_list = (\r\n            f\"{attr_name}={getattr(self, attr_name)}\"\r\n            for attr_name in self._attributes\r\n            if getattr(self, attr_name, None) is not None and attr_name[0] != \"_\"\r\n        )\r\n        attrs = \",\".join(attrs_list)\r\n        return f\"{type(self).__name__} [{attrs}]\"\r\n\r\n    def __iter__(self) -> Iterator:\r\n        obj = self._selected_obj.set_axis(self._on)\r\n        obj = self._create_data(obj)\r\n        indexer = self._get_window_indexer()\r\n\r\n        start, end = indexer.get_window_bounds(\r\n            num_values=len(obj),\r\n            min_periods=self.min_periods,\r\n            center=self.center,\r\n            closed=self.closed,\r\n            step=self.step,\r\n        )\r\n        self._check_window_bounds(start, end, len(obj))\r\n\r\n        for s, e in zip(start, end):\r\n            result = obj.iloc[slice(s, e)]\r\n            yield result\r\n\r\n    def _prep_values(self, values: ArrayLike) -> np.ndarray:\r\n        \"\"\"Convert input to numpy arrays for Cython routines\"\"\"\r\n        if needs_i8_conversion(values.dtype):\r\n            raise NotImplementedError(\r\n                f\"ops for {type(self).__name__} for this \"\r\n                f\"dtype {values.dtype} are not implemented\"\r\n            )\r\n        # GH #12373 : rolling functions error on float32 data\r\n        # make sure the data is coerced to float64\r\n        try:\r\n            if isinstance(values, ExtensionArray):\r\n                values = values.to_numpy(np.float64, na_value=np.nan)\r\n            else:\r\n                values = ensure_float64(values)\r\n        except (ValueError, TypeError) as err:\r\n            raise TypeError(f\"cannot handle this type -> {values.dtype}\") from err\r\n\r\n        # Convert inf to nan for C funcs\r\n        inf = np.isinf(values)\r\n        if inf.any():\r\n            values = np.where(inf, np.nan, values)\r\n\r\n        return values\r\n\r\n    def _insert_on_column(self, result: DataFrame, obj: DataFrame) -> None:\r\n        # if we have an 'on' column we want to put it back into\r\n        # the results in the same location\r\n        from pandas import Series\r\n\r\n        if self.on is not None and not self._on.equals(obj.index):\r\n            name = self._on.name\r\n            extra_col = Series(self._on, index=self.obj.index, name=name)\r\n            if name in result.columns:\r\n                # TODO: sure we want to overwrite results?\r\n                result[name] = extra_col\r\n            elif name in result.index.names:\r\n                pass\r\n            elif name in self._selected_obj.columns:\r\n                # insert in the same location as we had in _selected_obj\r\n                old_cols = self._selected_obj.columns\r\n                new_cols = result.columns\r\n                old_loc = old_cols.get_loc(name)\r\n                overlap = new_cols.intersection(old_cols[:old_loc])\r\n                new_loc = len(overlap)\r\n                result.insert(new_loc, name, extra_col)\r\n            else:\r\n                # insert at the end\r\n                result[name] = extra_col\r\n\r\n    @property\r\n    def _index_array(self):\r\n        # TODO: why do we get here with e.g. MultiIndex?\r\n        if needs_i8_conversion(self._on.dtype):\r\n            idx = cast(\"PeriodIndex | DatetimeIndex | TimedeltaIndex\", self._on)\r\n            return idx.asi8\r\n        return None\r\n\r\n    def _resolve_output(self, out: DataFrame, obj: DataFrame) -> DataFrame:\r\n        \"\"\"Validate and finalize result.\"\"\"\r\n        if out.shape[1] == 0 and obj.shape[1] > 0:\r\n            raise DataError(\"No numeric types to aggregate\")\r\n        if out.shape[1] == 0:\r\n            return obj.astype(\"float64\")\r\n\r\n        self._insert_on_column(out, obj)\r\n        return out\r\n\r\n    def _get_window_indexer(self) -> BaseIndexer:\r\n        \"\"\"\r\n        Return an indexer class that will compute the window start and end bounds\r\n        \"\"\"\r\n        if isinstance(self.window, BaseIndexer):\r\n            return self.window\r\n        if self._win_freq_i8 is not None:\r\n            return VariableWindowIndexer(\r\n                index_array=self._index_array,\r\n                window_size=self._win_freq_i8,\r\n                center=self.center,\r\n            )\r\n        return FixedWindowIndexer(window_size=self.window)\r\n\r\n    def _apply_series(\r\n        self, homogeneous_func: Callable[..., ArrayLike], name: str | None = None\r\n    ) -> Series:\r\n        \"\"\"\r\n        Series version of _apply_blockwise\r\n        \"\"\"\r\n        obj = self._create_data(self._selected_obj)\r\n\r\n        if name == \"count\":\r\n            # GH 12541: Special case for count where we support date-like types\r\n            obj = notna(obj).astype(int)\r\n        try:\r\n            values = self._prep_values(obj._values)\r\n        except (TypeError, NotImplementedError) as err:\r\n            raise DataError(\"No numeric types to aggregate\") from err\r\n\r\n        result = homogeneous_func(values)\r\n        index = self._slice_axis_for_step(obj.index, result)\r\n        return obj._constructor(result, index=index, name=obj.name)\r\n\r\n    def _apply_blockwise(\r\n        self,\r\n        homogeneous_func: Callable[..., ArrayLike],\r\n        name: str,\r\n        numeric_only: bool = False,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given function to the DataFrame broken down into homogeneous\r\n        sub-frames.\r\n        \"\"\"\r\n        self._validate_numeric_only(name, numeric_only)\r\n        if self._selected_obj.ndim == 1:\r\n            return self._apply_series(homogeneous_func, name)\r\n\r\n        obj = self._create_data(self._selected_obj, numeric_only)\r\n        if name == \"count\":\r\n            # GH 12541: Special case for count where we support date-like types\r\n            obj = notna(obj).astype(int)\r\n            obj._mgr = obj._mgr.consolidate()\r\n\r\n        if self.axis == 1:\r\n            obj = obj.T\r\n\r\n        taker = []\r\n        res_values = []\r\n        for i, arr in enumerate(obj._iter_column_arrays()):\r\n            # GH#42736 operate column-wise instead of block-wise\r\n            # As of 2.0, hfunc will raise for nuisance columns\r\n            try:\r\n                arr = self._prep_values(arr)\r\n            except (TypeError, NotImplementedError) as err:\r\n                raise DataError(\r\n                    f\"Cannot aggregate non-numeric type: {arr.dtype}\"\r\n                ) from err\r\n            res = homogeneous_func(arr)\r\n            res_values.append(res)\r\n            taker.append(i)\r\n\r\n        index = self._slice_axis_for_step(\r\n            obj.index, res_values[0] if len(res_values) > 0 else None\r\n        )\r\n        df = type(obj)._from_arrays(\r\n            res_values,\r\n            index=index,\r\n            columns=obj.columns.take(taker),\r\n            verify_integrity=False,\r\n        )\r\n\r\n        if self.axis == 1:\r\n            df = df.T\r\n\r\n        return self._resolve_output(df, obj)\r\n\r\n    def _apply_tablewise(\r\n        self,\r\n        homogeneous_func: Callable[..., ArrayLike],\r\n        name: str | None = None,\r\n        numeric_only: bool = False,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given function to the DataFrame across the entire object\r\n        \"\"\"\r\n        if self._selected_obj.ndim == 1:\r\n            raise ValueError(\"method='table' not applicable for Series objects.\")\r\n        obj = self._create_data(self._selected_obj, numeric_only)\r\n        values = self._prep_values(obj.to_numpy())\r\n        values = values.T if self.axis == 1 else values\r\n        result = homogeneous_func(values)\r\n        result = result.T if self.axis == 1 else result\r\n        index = self._slice_axis_for_step(obj.index, result)\r\n        columns = (\r\n            obj.columns\r\n            if result.shape[1] == len(obj.columns)\r\n            else obj.columns[:: self.step]\r\n        )\r\n        out = obj._constructor(result, index=index, columns=columns)\r\n\r\n        return self._resolve_output(out, obj)\r\n\r\n    def _apply_pairwise(\r\n        self,\r\n        target: DataFrame | Series,\r\n        other: DataFrame | Series | None,\r\n        pairwise: bool | None,\r\n        func: Callable[[DataFrame | Series, DataFrame | Series], DataFrame | Series],\r\n        numeric_only: bool,\r\n    ) -> DataFrame | Series:\r\n        \"\"\"\r\n        Apply the given pairwise function given 2 pandas objects (DataFrame/Series)\r\n        \"\"\"\r\n        target = self._create_data(target, numeric_only)\r\n        if other is None:\r\n            other = target\r\n            # only default unset\r\n            pairwise = True if pairwise is None else pairwise\r\n        elif not isinstance(other, (ABCDataFrame, ABCSeries)):\r\n            raise ValueError(\"other must be a DataFrame or Series\")\r\n        elif other.ndim == 2 and numeric_only:\r\n            other = self._make_numeric_only(other)\r\n\r\n        return flex_binary_moment(target, other, func, pairwise=bool(pairwise))\r\n\r\n    def _apply(\r\n        self,\r\n        func: Callable[..., Any],\r\n        name: str,\r\n        numeric_only: bool = False,\r\n        numba_args: tuple[Any, ...] = (),\r\n        **kwargs,\r\n    ):\r\n        \"\"\"\r\n        Rolling statistical measure using supplied function.\r\n\r\n        Designed to be used with passed-in Cython array-based functions.\r\n\r\n        Parameters\r\n        ----------\r\n        func : callable function to apply\r\n        name : str,\r\n        numba_args : tuple\r\n            args to be passed when func is a numba func\r\n        **kwargs\r\n            additional arguments for rolling function and window function\r\n\r\n        Returns\r\n        -------\r\n        y : type of input\r\n        \"\"\"\r\n        window_indexer = self._get_window_indexer()\r\n        min_periods = (\r\n            self.min_periods\r\n            if self.min_periods is not None\r\n            else window_indexer.window_size\r\n        )\r\n\r\n        def homogeneous_func(values: np.ndarray):\r\n            # calculation function\r\n\r\n            if values.size == 0:\r\n                return values.copy()\r\n\r\n            def calc(x):\r\n                start, end = window_indexer.get_window_bounds(\r\n                    num_values=len(x),\r\n                    min_periods=min_periods,\r\n                    center=self.center,\r\n                    closed=self.closed,\r\n                    step=self.step,\r\n                )\r\n                self._check_window_bounds(start, end, len(x))\r\n\r\n                return func(x, start, end, min_periods, *numba_args)\r\n\r\n            with np.errstate(all=\"ignore\"):\r\n                result = calc(values)\r\n\r\n            return result\r\n\r\n        if self.method == \"single\":\r\n            return self._apply_blockwise(homogeneous_func, name, numeric_only)\r\n        else:\r\n            return self._apply_tablewise(homogeneous_func, name, numeric_only)\r\n\r\n    def _numba_apply(\r\n        self,\r\n        func: Callable[..., Any],\r\n        engine_kwargs: dict[str, bool] | None = None,\r\n        *func_args,\r\n    ):\r\n        window_indexer = self._get_window_indexer()\r\n        min_periods = (\r\n            self.min_periods\r\n            if self.min_periods is not None\r\n            else window_indexer.window_size\r\n        )\r\n        obj = self._create_data(self._selected_obj)\r\n        if self.axis == 1:\r\n            obj = obj.T\r\n        values = self._prep_values(obj.to_numpy())\r\n        if values.ndim == 1:\r\n            values = values.reshape(-1, 1)\r\n        start, end = window_indexer.get_window_bounds(\r\n            num_values=len(values),\r\n            min_periods=min_periods,\r\n            center=self.center,\r\n            closed=self.closed,\r\n            step=self.step,\r\n        )\r\n        self._check_window_bounds(start, end, len(values))\r\n        aggregator = executor.generate_shared_aggregator(\r\n            func, **get_jit_arguments(engine_kwargs)\r\n        )\r\n        result = aggregator(values, start, end, min_periods, *func_args)\r\n        result = result.T if self.axis == 1 else result\r\n        index = self._slice_axis_for_step(obj.index, result)\r\n        if obj.ndim == 1:\r\n            result = result.squeeze()\r\n            out = obj._constructor(result, index=index, name=obj.name)\r\n            return out\r\n        else:\r\n            columns = self._slice_axis_for_step(obj.columns, result.T)\r\n            out = obj._constructor(result, index=index, columns=columns)\r\n            return self._resolve_output(out, obj)\r\n\r\n    def aggregate(self, func, *args, **kwargs):\r\n        result = ResamplerWindowApply(self, func, args=args, kwargs=kwargs).agg()\r\n        if result is None:\r\n            return self.apply(func, raw=False, args=args, kwargs=kwargs)\r\n        return result\r\n\r\n    agg = aggregate\r\n\r\n\r\nclass BaseWindowGroupby(BaseWindow):\r\n    \"\"\"\r\n    Provide the groupby windowing facilities.\r\n    \"\"\"\r\n\r\n    _grouper: BaseGrouper\r\n    _as_index: bool\r\n    _attributes: list[str] = [\"_grouper\"]\r\n\r\n    def __init__(\r\n        self,\r\n        obj: DataFrame | Series,\r\n        *args,\r\n        _grouper: BaseGrouper,\r\n        _as_index: bool = True,\r\n        **kwargs,\r\n    ) -> None:\r\n        from pandas.core.groupby.ops import BaseGrouper\r\n\r\n        if not isinstance(_grouper, BaseGrouper):\r\n            raise ValueError(\"Must pass a BaseGrouper object.\")\r\n        self._grouper = _grouper\r\n        self._as_index = _as_index\r\n        # GH 32262: It's convention to keep the grouping column in\r\n        # groupby.<agg_func>, but unexpected to users in\r\n        # groupby.rolling.<agg_func>\r\n        obj = obj.drop(columns=self._grouper.names, errors=\"ignore\")\r\n        # GH 15354\r\n        if kwargs.get(\"step\") is not None:\r\n            raise NotImplementedError(\"step not implemented for groupby\")\r\n        super().__init__(obj, *args, **kwargs)\r\n\r\n    def _apply(\r\n        self,\r\n        func: Callable[..., Any],\r\n        name: str,\r\n        numeric_only: bool = False,\r\n        numba_args: tuple[Any, ...] = (),\r\n        **kwargs,\r\n    ) -> DataFrame | Series:\r\n        result = super()._apply(\r\n            func,\r\n            name,\r\n            numeric_only,\r\n            numba_args,\r\n            **kwargs,\r\n        )\r\n        # Reconstruct the resulting MultiIndex\r\n        # 1st set of levels = group by labels\r\n        # 2nd set of levels = original DataFrame/Series index\r\n        grouped_object_index = self.obj.index\r\n        grouped_index_name = [*grouped_object_index.names]\r\n"]
[240.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[240.002, "i", "applypatch << 'PATCH'\r"]
[240.004, "o", "applypatch << 'PATCH'\r\n"]
[240.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> *** Begin Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> *** Update File: pandas/core/window/rolling.py\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h>  class BaseWindow(SelectionMixin):\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h>      def __init__(\r\n\u001b[?2004l\r\n\u001b[?2004h>          self,\r\n\u001b[?2004l\r\n\u001b[?2004h>          obj: NDFrame,\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h>      ) -> None:\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h>          self.method = method\r\n\u001b[?2004l\r\n\u001b[?2004h>          self._win_freq_i8: int | None = None\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # Cache for groupby order indexer to avoid recomputation across\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # subsequent steps (e.g. when constructing the result MultiIndex\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # after performing the rolling operation). This is populated in\r\n\u001b[?2004l\r\n\u001b[?2004h> +        # _create_data when applicable.\r\n\u001b[?2004l\r\n\u001b[?2004h> +        self._groupby_order: np.ndarray | None = None\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h>      def _create_data(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -        if not obj.empty:\r\n\u001b[?2004l\r\n\u001b[?2004h> -            groupby_order = np.concatenate(list(self._grouper.indices.values())).astype(\r\n\u001b[?2004l\r\n\u001b[?2004h> -                np.int64\r\n\u001b[?2004l\r\n\u001b[?2004h> -            )\r\n\u001b[?2004l\r\n\u001b[?2004h> -            obj = obj.take(groupby_order)\r\n\u001b[?2004l\r\n\u001b[?2004h> +        if not obj.empty:\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # Construct the take indexer in group order. Avoid creating\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # unnecessary copies: keep platform-native integer dtype\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # (np.intp) and avoid an extra cast to int64 which would allocate\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # a new array. Cache the indexer for later reuse.\r\n\u001b[?2004l\r\n\u001b[?2004h> +            group_indices = self._grouper.indices.values()\r\n\u001b[?2004l\r\n\u001b[?2004h> +            if group_indices:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                groupby_order = np.concatenate(list(group_indices))\r\n\u001b[?2004l\r\n\u001b[?2004h> +                if groupby_order.dtype != np.intp:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                    groupby_order = groupby_order.astype(np.intp, copy=False)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            else:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                groupby_order = np.array([], dtype=np.intp)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            self._groupby_order = groupby_order\r\n\u001b[?2004l\r\n\u001b[?2004h> +            obj = obj.take(groupby_order)\r\n\u001b[?2004l\r\n\u001b[?2004h>          return super()._create_data(obj, numeric_only)\r\n\u001b[?2004l\r\n\u001b[?2004h> *** End Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> PATCH\r\n\u001b[?2004l\r\n-bash: applypatch: command not found\r\n"]
[245.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[245.002, "i", "applypatch << 'PATCH'\r"]
[245.004, "o", "applypatch << 'PATCH'\r\n"]
[245.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> *** Begin Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> *** Update File: pandas/core/window/rolling.py\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -            group_indices = self._grouper.indices.values()\r\n\u001b[?2004l\r\n\u001b[?2004h> -            if group_indices:\r\n\u001b[?2004l\r\n\u001b[?2004h> -                indexer = np.concatenate(list(group_indices))\r\n\u001b[?2004l\r\n\u001b[?2004h> -            else:\r\n\u001b[?2004l\r\n\u001b[?2004h> -                indexer = np.array([], dtype=np.intp)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # Reuse cached groupby order indexer from _create_data when\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # available to avoid recomputing the concatenation here.\r\n\u001b[?2004l\r\n\u001b[?2004h> +            cached = getattr(self, \"_groupby_order\", None)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            if cached is not None:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                indexer = cached\r\n\u001b[?2004l\r\n\u001b[?2004h> +            else:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                group_indices = self._grouper.indices.values()\r\n\u001b[?2004l\r\n\u001b[?2004h> +                if group_indices:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                    indexer = np.concatenate(list(group_indices))\r\n\u001b[?2004l\r\n\u001b[?2004h> +                    if indexer.dtype != np.intp:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                        indexer = indexer.astype(np.intp, copy=False)\r\n\u001b[?2004l\r\n\u001b[?2004h> +                else:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                    indexer = np.array([], dtype=np.intp)\r\n\u001b[?2004l\r\n\u001b[?2004h> @@\r\n\u001b[?2004l\r\n\u001b[?2004h> -            if target.ndim == 1:\r\n\u001b[?2004l\r\n\u001b[?2004h> -                repeat_by = 1\r\n\u001b[?2004l\r\n\u001b[?2004h> -            else:\r\n\u001b[?2004l\r\n\u001b[?2004h> -                repeat_by = len(target.columns)\r\n\u001b[?2004l\r\n\u001b[?2004h> -            groupby_codes = [\r\n\u001b[?2004l\r\n\u001b[?2004h> -                np.repeat(c.take(indexer), repeat_by) for c in groupby_codes\r\n\u001b[?2004l\r\n\u001b[?2004h> -            ]\r\n\u001b[?2004l\r\n\u001b[?2004h> +            if target.ndim == 1:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                repeat_by = 1\r\n\u001b[?2004l\r\n\u001b[?2004h> +            else:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                repeat_by = len(target.columns)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # Avoid an unnecessary allocation when there is no need to repeat\r\n\u001b[?2004l\r\n\u001b[?2004h> +            # (the common case for 1D targets)\r\n\u001b[?2004l\r\n\u001b[?2004h> +            if repeat_by == 1:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                groupby_codes = [c.take(indexer) for c in groupby_codes]\r\n\u001b[?2004l\r\n\u001b[?2004h> +            else:\r\n\u001b[?2004l\r\n\u001b[?2004h> +                groupby_codes = [\r\n\u001b[?2004l\r\n\u001b[?2004h> +                    np.repeat(c.take(indexer), repeat_by) for c in groupby_codes\r\n\u001b[?2004l\r\n\u001b[?2004h> +                ]\r\n\u001b[?2004l\r\n\u001b[?2004h> *** End Patch\r\n\u001b[?2004l\r\n\u001b[?2004h> PATCH\r\n\u001b[?2004l\r\n-bash: applypatch: command not found\r\n"]
[250.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[250.002, "i", "git -C .. diff -- pandas/core/window/rolling.py | sed -n '1,200p'\r"]
[250.004, "o", "git -C .. diff -- pandas/core/window/rolling.py | sed -n '1,200p'\r\n"]
[250.006, "o", "\u001b[?2004l\r\n"]
[255.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[255.002, "i", "git -C .. diff -- pandas/core/window/rolling.py | sed -n '200,400p'\r"]
[255.004, "o", "git -C .. diff -- pandas/core/window/rolling.py | sed -n '200,400p'\r\n"]
[255.006, "o", "\u001b[?2004l\r\n"]
[260.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[260.002, "i", "asv run --python=same --bench=\"rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\" --quick\r"]
[260.004, "o", "asv run --python=same --bench=\"rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\" --quick\r\n"]
[260.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                               23.8\u00b10ms\r\n"]
[265.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[265.002, "i", "grep -n \"result.index = MultiIndex\\|repeat_by = len(target.columns)\\|np.repeat\\|_create_data\\|indices.valu\r"]
[265.004, "o", "grep -n \"result.index = MultiIndex\\|repeat_by = len(target.columns)\\|np.repeat\\|_create_data\\|indices.valu\r\n"]
[265.006, "o", "ues\" ../pandas/core/window/rolling.py\r\n\u001b[?2004l\r\n\u001b[32m\u001b[K264\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n\u001b[32m\u001b[K339\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(obj)\r\n\u001b[32m\u001b[K442\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self._selected_obj)\r\n\u001b[32m\u001b[K470\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self._selected_obj, numeric_only)\r\n\u001b[32m\u001b[K520\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self._selected_obj, numeric_only)\r\n\u001b[32m\u001b[K546\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        target = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(target, numeric_only)\r\n\u001b[32m\u001b[K631\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        obj = self.\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self._selected_obj)\r\n\u001b[32m\u001b[K737\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        group_indices = self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K753\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kresult_index = MultiIndex\u001b[m\u001b[K(\r\n\u001b[32m\u001b[K778\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            len(group) == len(other) for group in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K788\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                    for gb_indices in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K799\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                labels = \u001b[01;31m\u001b[Knp.repeat\u001b[m\u001b[K(np.array(gb_level_pair), old_result_len)\r\n\u001b[32m\u001b[K811\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            group_indices = self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K820\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                \u001b[01;31m\u001b[Krepeat_by = len(target.columns)\u001b[m\u001b[K\r\n\u001b[32m\u001b[K822\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                \u001b[01;31m\u001b[Knp.repeat\u001b[m\u001b[K(c.take(indexer), repeat_by) for c in groupby_codes\r\n\u001b[32m\u001b[K840\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        \u001b[01;31m\u001b[Kresult_index = MultiIndex\u001b[m\u001b[K(\r\n\u001b[32m\u001b[K846\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(self, obj: NDFrameT, numeric_only: bool = False) -> NDFrameT:\r\n\u001b[32m\u001b[K854\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            groupby_order = np.concatenate(list(self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K())).astype(\r\n\u001b[32m\u001b[K858\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        return super().\u001b[01;31m\u001b[K_create_data\u001b[m\u001b[K(obj, numeric_only)\r\n\u001b[32m\u001b[K2737\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        for group_indices in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K():\r\n"]
[270.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[270.002, "i", "sed -n '1,220p' ../pandas/core/window/rolling.py | nl -ba | sed -n '1,220p'\r"]
[270.004, "o", "sed -n '1,220p' ../pandas/core/window/rolling.py | nl -ba | sed -n '1,220p'\r\n"]
[270.006, "o", "\u001b[?2004l\r\n     1\t\"\"\"\r\n     2\tProvide a generic structure to support window functions,\r\n     3\tsimilar to how we have a Groupby object.\r\n     4\t\"\"\"\r\n     5\tfrom __future__ import annotations\r\n     6\t\r\n     7\timport copy\r\n     8\tfrom datetime import timedelta\r\n     9\tfrom functools import partial\r\n    10\timport inspect\r\n    11\tfrom textwrap import dedent\r\n    12\tfrom typing import (\r\n    13\t    TYPE_CHECKING,\r\n    14\t    Any,\r\n    15\t    Callable,\r\n    16\t    Hashable,\r\n    17\t    Iterator,\r\n    18\t    Sized,\r\n    19\t    cast,\r\n    20\t)\r\n    21\t\r\n    22\timport numpy as np\r\n    23\t\r\n    24\tfrom pandas._libs.tslibs import (\r\n    25\t    BaseOffset,\r\n    26\t    to_offset,\r\n    27\t)\r\n    28\timport pandas._libs.window.aggregations as window_aggregations\r\n    29\tfrom pandas._typing import (\r\n    30\t    ArrayLike,\r\n    31\t    Axis,\r\n    32\t    NDFrameT,\r\n    33\t    QuantileInterpolation,\r\n    34\t    WindowingRankType,\r\n    35\t)\r\n    36\tfrom pandas.compat._optional import import_optional_dependency\r\n    37\tfrom pandas.errors import DataError\r\n    38\tfrom pandas.util._decorators import doc\r\n    39\t\r\n    40\tfrom pandas.core.dtypes.common import (\r\n    41\t    ensure_float64,\r\n    42\t    is_bool,\r\n    43\t    is_integer,\r\n    44\t    is_list_like,\r\n    45\t    is_numeric_dtype,\r\n    46\t    is_scalar,\r\n    47\t    needs_i8_conversion,\r\n    48\t)\r\n    49\tfrom pandas.core.dtypes.generic import (\r\n    50\t    ABCDataFrame,\r\n    51\t    ABCSeries,\r\n    52\t)\r\n    53\tfrom pandas.core.dtypes.missing import notna\r\n    54\t\r\n    55\tfrom pandas.core._numba import executor\r\n    56\tfrom pandas.core.algorithms import factorize\r\n    57\tfrom pandas.core.apply import ResamplerWindowApply\r\n    58\tfrom pandas.core.arrays import ExtensionArray\r\n    59\tfrom pandas.core.base import SelectionMixin\r\n    60\timport pandas.core.common as com\r\n    61\tfrom pandas.core.indexers.objects import (\r\n    62\t    BaseIndexer,\r\n    63\t    FixedWindowIndexer,\r\n    64\t    GroupbyIndexer,\r\n    65\t    VariableWindowIndexer,\r\n    66\t)\r\n    67\tfrom pandas.core.indexes.api import (\r\n    68\t    DatetimeIndex,\r\n    69\t    Index,\r\n    70\t    MultiIndex,\r\n    71\t    PeriodIndex,\r\n    72\t    TimedeltaIndex,\r\n    73\t)\r\n    74\tfrom pandas.core.reshape.concat import concat\r\n    75\tfrom pandas.core.util.numba_ import (\r\n    76\t    get_jit_arguments,\r\n    77\t    maybe_use_numba,\r\n    78\t)\r\n    79\tfrom pandas.core.window.common import (\r\n    80\t    flex_binary_moment,\r\n    81\t    zsqrt,\r\n    82\t)\r\n    83\tfrom pandas.core.window.doc import (\r\n    84\t    _shared_docs,\r\n    85\t    create_section_header,\r\n    86\t    kwargs_numeric_only,\r\n    87\t    kwargs_scipy,\r\n    88\t    numba_notes,\r\n    89\t    template_header,\r\n    90\t    template_returns,\r\n    91\t    template_see_also,\r\n    92\t    window_agg_numba_parameters,\r\n    93\t    window_apply_parameters,\r\n    94\t)\r\n    95\tfrom pandas.core.window.numba_ import (\r\n    96\t    generate_manual_numpy_nan_agg_with_axis,\r\n    97\t    generate_numba_apply_func,\r\n    98\t    generate_numba_table_func,\r\n    99\t)\r\n   100\t\r\n   101\tif TYPE_CHECKING:\r\n   102\t    from pandas import (\r\n   103\t        DataFrame,\r\n   104\t        Series,\r\n   105\t    )\r\n   106\t    from pandas.core.generic import NDFrame\r\n   107\t    from pandas.core.groupby.ops import BaseGrouper\r\n   108\t\r\n   109\t\r\n   110\tclass BaseWindow(SelectionMixin):\r\n   111\t    \"\"\"Provides utilities for performing windowing operations.\"\"\"\r\n   112\t\r\n   113\t    _attributes: list[str] = []\r\n   114\t    exclusions: frozenset[Hashable] = frozenset()\r\n   115\t    _on: Index\r\n   116\t\r\n   117\t    def __init__(\r\n   118\t        self,\r\n   119\t        obj: NDFrame,\r\n   120\t        window=None,\r\n   121\t        min_periods: int | None = None,\r\n   122\t        center: bool | None = False,\r\n   123\t        win_type: str | None = None,\r\n   124\t        axis: Axis = 0,\r\n   125\t        on: str | Index | None = None,\r\n   126\t        closed: str | None = None,\r\n   127\t        step: int | None = None,\r\n   128\t        method: str = \"single\",\r\n   129\t        *,\r\n   130\t        selection=None,\r\n   131\t    ) -> None:\r\n   132\t        self.obj = obj\r\n   133\t        self.on = on\r\n   134\t        self.closed = closed\r\n   135\t        self.step = step\r\n   136\t        self.window = window\r\n   137\t        self.min_periods = min_periods\r\n   138\t        self.center = center\r\n   139\t        self.win_type = win_type\r\n   140\t        self.axis = obj._get_axis_number(axis) if axis is not None else None\r\n   141\t        self.method = method\r\n   142\t        self._win_freq_i8: int | None = None\r\n   143\t        if self.on is None:\r\n   144\t            if self.axis == 0:\r\n   145\t                self._on = self.obj.index\r\n   146\t            else:\r\n   147\t                # i.e. self.axis == 1\r\n   148\t                self._on = self.obj.columns\r\n   149\t        elif isinstance(self.on, Index):\r\n   150\t            self._on = self.on\r\n   151\t        elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\r\n   152\t            self._on = Index(self.obj[self.on])\r\n   153\t        else:\r\n   154\t            raise ValueError(\r\n   155\t                f\"invalid on specified as {self.on}, \"\r\n   156\t                \"must be a column (of DataFrame), an Index or None\"\r\n   157\t            )\r\n   158\t\r\n   159\t        self._selection = selection\r\n   160\t        self._validate()\r\n   161\t\r\n   162\t    def _validate(self) -> None:\r\n   163\t        if self.center is not None and not is_bool(self.center):\r\n   164\t            raise ValueError(\"center must be a boolean\")\r\n   165\t        if self.min_periods is not None:\r\n   166\t            if not is_integer(self.min_periods):\r\n   167\t                raise ValueError(\"min_periods must be an integer\")\r\n   168\t            if self.min_periods < 0:\r\n   169\t                raise ValueError(\"min_periods must be >= 0\")\r\n   170\t            if is_integer(self.window) and self.min_periods > self.window:\r\n   171\t                raise ValueError(\r\n   172\t                    f\"min_periods {self.min_periods} must be <= window {self.window}\"\r\n   173\t                )\r\n   174\t        if self.closed is not None and self.closed not in [\r\n   175\t            \"right\",\r\n   176\t            \"both\",\r\n   177\t            \"left\",\r\n   178\t            \"neither\",\r\n   179\t        ]:\r\n   180\t            raise ValueError(\"closed must be 'right', 'left', 'both' or 'neither'\")\r\n   181\t        if not isinstance(self.obj, (ABCSeries, ABCDataFrame)):\r\n   182\t            raise TypeError(f\"invalid type: {type(self)}\")\r\n   183\t        if isinstance(self.window, BaseIndexer):\r\n   184\t            # Validate that the passed BaseIndexer subclass has\r\n   185\t            # a get_window_bounds with the correct signature.\r\n   186\t            get_window_bounds_signature = inspect.signature(\r\n   187\t                self.window.get_window_bounds\r\n   188\t            ).parameters.keys()\r\n   189\t            expected_signature = inspect.signature(\r\n   190\t                BaseIndexer().get_window_bounds\r\n   191\t            ).parameters.keys()\r\n   192\t            if get_window_bounds_signature != expected_signature:\r\n   193\t                raise ValueError(\r\n   194\t                    f\"{type(self.window).__name__} does not implement \"\r\n   195\t                    f\"the correct signature for get_window_bounds\"\r\n   196\t                )\r\n   197\t        if self.method not in [\"table\", \"single\"]:\r\n   198\t            raise ValueError(\"method must be 'table' or 'single\")\r\n   199\t        if self.step is not None:\r\n   200\t            if not is_integer(self.step):\r\n   201\t                raise ValueError(\"step must be an integer\")\r\n   202\t            if self.step < 0:\r\n   203\t                raise ValueError(\"step must be >= 0\")\r\n   204\t\r\n   205\t    def _check_window_bounds(\r\n   206\t        self, start: np.ndarray, end: np.ndarray, num_vals: int\r\n   207\t    ) -> None:\r\n   208\t        if len(start) != len(end):\r\n   209\t            raise ValueError(\r\n   210\t                f\"start ({len(start)}) and end ({len(end)}) bounds must be the \"\r\n   211\t                f\"same length\"\r\n   212\t            )\r\n   213\t        if len(start) != (num_vals + (self.step or 1) - 1) // (self.step or 1):\r\n   214\t            raise ValueError(\r\n   215\t                f\"start and end bounds ({len(start)}) must be the same length \"\r\n   216\t                f\"as the object ({num_vals}) divided by the step ({self.step}) \"\r\n   217\t                f\"if given and rounded up\"\r\n   218\t            )\r\n   219\t\r\n   220\t    def _slice_axis_for_step(self, index: Index, result: Sized | None = None) -> Index:\r\n"]
[275.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[275.002, "i", "sed -n '220,720p' ../pandas/core/window/rolling.py | nl -ba | sed -n '220,720p'\r"]
[275.004, "o", "sed -n '220,720p' ../pandas/core/window/rolling.py | nl -ba | sed -n '220,720p'\r\n"]
[275.006, "o", "\u001b[?2004l\r\n   220\t        \"\"\"\r\n   221\t        Series version of _apply_blockwise\r\n   222\t        \"\"\"\r\n   223\t        obj = self._create_data(self._selected_obj)\r\n   224\t\r\n   225\t        if name == \"count\":\r\n   226\t            # GH 12541: Special case for count where we support date-like types\r\n   227\t            obj = notna(obj).astype(int)\r\n   228\t        try:\r\n   229\t            values = self._prep_values(obj._values)\r\n   230\t        except (TypeError, NotImplementedError) as err:\r\n   231\t            raise DataError(\"No numeric types to aggregate\") from err\r\n   232\t\r\n   233\t        result = homogeneous_func(values)\r\n   234\t        index = self._slice_axis_for_step(obj.index, result)\r\n   235\t        return obj._constructor(result, index=index, name=obj.name)\r\n   236\t\r\n   237\t    def _apply_blockwise(\r\n   238\t        self,\r\n   239\t        homogeneous_func: Callable[..., ArrayLike],\r\n   240\t        name: str,\r\n   241\t        numeric_only: bool = False,\r\n   242\t    ) -> DataFrame | Series:\r\n   243\t        \"\"\"\r\n   244\t        Apply the given function to the DataFrame broken down into homogeneous\r\n   245\t        sub-frames.\r\n   246\t        \"\"\"\r\n   247\t        self._validate_numeric_only(name, numeric_only)\r\n   248\t        if self._selected_obj.ndim == 1:\r\n   249\t            return self._apply_series(homogeneous_func, name)\r\n   250\t\r\n   251\t        obj = self._create_data(self._selected_obj, numeric_only)\r\n   252\t        if name == \"count\":\r\n   253\t            # GH 12541: Special case for count where we support date-like types\r\n   254\t            obj = notna(obj).astype(int)\r\n   255\t            obj._mgr = obj._mgr.consolidate()\r\n   256\t\r\n   257\t        if self.axis == 1:\r\n   258\t            obj = obj.T\r\n   259\t\r\n   260\t        taker = []\r\n   261\t        res_values = []\r\n   262\t        for i, arr in enumerate(obj._iter_column_arrays()):\r\n   263\t            # GH#42736 operate column-wise instead of block-wise\r\n   264\t            # As of 2.0, hfunc will raise for nuisance columns\r\n   265\t            try:\r\n   266\t                arr = self._prep_values(arr)\r\n   267\t            except (TypeError, NotImplementedError) as err:\r\n   268\t                raise DataError(\r\n   269\t                    f\"Cannot aggregate non-numeric type: {arr.dtype}\"\r\n   270\t                ) from err\r\n   271\t            res = homogeneous_func(arr)\r\n   272\t            res_values.append(res)\r\n   273\t            taker.append(i)\r\n   274\t\r\n   275\t        index = self._slice_axis_for_step(\r\n   276\t            obj.index, res_values[0] if len(res_values) > 0 else None\r\n   277\t        )\r\n   278\t        df = type(obj)._from_arrays(\r\n   279\t            res_values,\r\n   280\t            index=index,\r\n   281\t            columns=obj.columns.take(taker),\r\n   282\t            verify_integrity=False,\r\n   283\t        )\r\n   284\t\r\n   285\t        if self.axis == 1:\r\n   286\t            df = df.T\r\n   287\t\r\n   288\t        return self._resolve_output(df, obj)\r\n   289\t\r\n   290\t    def _apply_tablewise(\r\n   291\t        self,\r\n   292\t        homogeneous_func: Callable[..., ArrayLike],\r\n   293\t        name: str | None = None,\r\n   294\t        numeric_only: bool = False,\r\n   295\t    ) -> DataFrame | Series:\r\n   296\t        \"\"\"\r\n   297\t        Apply the given function to the DataFrame across the entire object\r\n   298\t        \"\"\"\r\n   299\t        if self._selected_obj.ndim == 1:\r\n   300\t            raise ValueError(\"method='table' not applicable for Series objects.\")\r\n   301\t        obj = self._create_data(self._selected_obj, numeric_only)\r\n   302\t        values = self._prep_values(obj.to_numpy())\r\n   303\t        values = values.T if self.axis == 1 else values\r\n   304\t        result = homogeneous_func(values)\r\n   305\t        result = result.T if self.axis == 1 else result\r\n   306\t        index = self._slice_axis_for_step(obj.index, result)\r\n   307\t        columns = (\r\n   308\t            obj.columns\r\n   309\t            if result.shape[1] == len(obj.columns)\r\n   310\t            else obj.columns[:: self.step]\r\n   311\t        )\r\n   312\t        out = obj._constructor(result, index=index, columns=columns)\r\n   313\t\r\n   314\t        return self._resolve_output(out, obj)\r\n   315\t\r\n   316\t    def _apply_pairwise(\r\n   317\t        self,\r\n   318\t        target: DataFrame | Series,\r\n   319\t        other: DataFrame | Series | None,\r\n   320\t        pairwise: bool | None,\r\n   321\t        func: Callable[[DataFrame | Series, DataFrame | Series], DataFrame | Series],\r\n   322\t        numeric_only: bool,\r\n   323\t    ) -> DataFrame | Series:\r\n   324\t        \"\"\"\r\n   325\t        Apply the given pairwise function given 2 pandas objects (DataFrame/Series)\r\n   326\t        \"\"\"\r\n   327\t        target = self._create_data(target, numeric_only)\r\n   328\t        if other is None:\r\n   329\t            other = target\r\n   330\t            # only default unset\r\n   331\t            pairwise = True if pairwise is None else pairwise\r\n   332\t        elif not isinstance(other, (ABCDataFrame, ABCSeries)):\r\n   333\t            raise ValueError(\"other must be a DataFrame or Series\")\r\n   334\t        elif other.ndim == 2 and numeric_only:\r\n   335\t            other = self._make_numeric_only(other)\r\n   336\t\r\n   337\t        return flex_binary_moment(target, other, func, pairwise=bool(pairwise))\r\n   338\t\r\n   339\t    def _apply(\r\n   340\t        self,\r\n   341\t        func: Callable[..., Any],\r\n   342\t        name: str,\r\n   343\t        numeric_only: bool = False,\r\n   344\t        numba_args: tuple[Any, ...] = (),\r\n   345\t        **kwargs,\r\n   346\t    ):\r\n   347\t        \"\"\"\r\n   348\t        Rolling statistical measure using supplied function.\r\n   349\t\r\n   350\t        Designed to be used with passed-in Cython array-based functions.\r\n   351\t\r\n   352\t        Parameters\r\n   353\t        ----------\r\n   354\t        func : callable function to apply\r\n   355\t        name : str,\r\n   356\t        numba_args : tuple\r\n   357\t            args to be passed when func is a numba func\r\n   358\t        **kwargs\r\n   359\t            additional arguments for rolling function and window function\r\n   360\t\r\n   361\t        Returns\r\n   362\t        -------\r\n   363\t        y : type of input\r\n   364\t        \"\"\"\r\n   365\t        window_indexer = self._get_window_indexer()\r\n   366\t        min_periods = (\r\n   367\t            self.min_periods\r\n   368\t            if self.min_periods is not None\r\n   369\t            else window_indexer.window_size\r\n   370\t        )\r\n   371\t\r\n   372\t        def homogeneous_func(values: np.ndarray):\r\n   373\t            # calculation function\r\n   374\t\r\n   375\t            if values.size == 0:\r\n   376\t                return values.copy()\r\n   377\t\r\n   378\t            def calc(x):\r\n   379\t                start, end = window_indexer.get_window_bounds(\r\n   380\t                    num_values=len(x),\r\n   381\t                    min_periods=min_periods,\r\n   382\t                    center=self.center,\r\n   383\t                    closed=self.closed,\r\n   384\t                    step=self.step,\r\n   385\t                )\r\n   386\t                self._check_window_bounds(start, end, len(x))\r\n   387\t\r\n   388\t                return func(x, start, end, min_periods, *numba_args)\r\n   389\t\r\n   390\t            with np.errstate(all=\"ignore\"):\r\n   391\t                result = calc(values)\r\n   392\t\r\n   393\t            return result\r\n   394\t\r\n   395\t        if self.method == \"single\":\r\n   396\t            return self._apply_blockwise(homogeneous_func, name, numeric_only)\r\n   397\t        else:\r\n   398\t            return self._apply_tablewise(homogeneous_func, name, numeric_only)\r\n   399\t\r\n   400\t    def _numba_apply(\r\n   401\t        self,\r\n   402\t        func: Callable[..., Any],\r\n   403\t        engine_kwargs: dict[str, bool] | None = None,\r\n   404\t        *func_args,\r\n   405\t    ):\r\n   406\t        window_indexer = self._get_window_indexer()\r\n   407\t        min_periods = (\r\n   408\t            self.min_periods\r\n   409\t            if self.min_periods is not None\r\n   410\t            else window_indexer.window_size\r\n   411\t        )\r\n   412\t        obj = self._create_data(self._selected_obj)\r\n   413\t        if self.axis == 1:\r\n   414\t            obj = obj.T\r\n   415\t        values = self._prep_values(obj.to_numpy())\r\n   416\t        if values.ndim == 1:\r\n   417\t            values = values.reshape(-1, 1)\r\n   418\t        start, end = window_indexer.get_window_bounds(\r\n   419\t            num_values=len(values),\r\n   420\t            min_periods=min_periods,\r\n   421\t            center=self.center,\r\n   422\t            closed=self.closed,\r\n   423\t            step=self.step,\r\n   424\t        )\r\n   425\t        self._check_window_bounds(start, end, len(values))\r\n   426\t        aggregator = executor.generate_shared_aggregator(\r\n   427\t            func, **get_jit_arguments(engine_kwargs)\r\n   428\t        )\r\n   429\t        result = aggregator(values, start, end, min_periods, *func_args)\r\n   430\t        result = result.T if self.axis == 1 else result\r\n   431\t        index = self._slice_axis_for_step(obj.index, result)\r\n   432\t        if obj.ndim == 1:\r\n   433\t            result = result.squeeze()\r\n   434\t            out = obj._constructor(result, index=index, name=obj.name)\r\n   435\t            return out\r\n   436\t        else:\r\n   437\t            columns = self._slice_axis_for_step(obj.columns, result.T)\r\n   438\t            out = obj._constructor(result, index=index, columns=columns)\r\n   439\t            return self._resolve_output(out, obj)\r\n   440\t\r\n   441\t    def aggregate(self, func, *args, **kwargs):\r\n   442\t        result = ResamplerWindowApply(self, func, args=args, kwargs=kwargs).agg()\r\n   443\t        if result is None:\r\n   444\t            return self.apply(func, raw=False, args=args, kwargs=kwargs)\r\n   445\t        return result\r\n   446\t\r\n   447\t    agg = aggregate\r\n   448\t\r\n   449\t\r\n   450\tclass BaseWindowGroupby(BaseWindow):\r\n   451\t    \"\"\"\r\n   452\t    Provide the groupby windowing facilities.\r\n   453\t    \"\"\"\r\n   454\t\r\n   455\t    _grouper: BaseGrouper\r\n   456\t    _as_index: bool\r\n   457\t    _attributes: list[str] = [\"_grouper\"]\r\n   458\t\r\n   459\t    def __init__(\r\n   460\t        self,\r\n   461\t        obj: DataFrame | Series,\r\n   462\t        *args,\r\n   463\t        _grouper: BaseGrouper,\r\n   464\t        _as_index: bool = True,\r\n   465\t        **kwargs,\r\n   466\t    ) -> None:\r\n   467\t        from pandas.core.groupby.ops import BaseGrouper\r\n   468\t\r\n   469\t        if not isinstance(_grouper, BaseGrouper):\r\n   470\t            raise ValueError(\"Must pass a BaseGrouper object.\")\r\n   471\t        self._grouper = _grouper\r\n   472\t        self._as_index = _as_index\r\n   473\t        # GH 32262: It's convention to keep the grouping column in\r\n   474\t        # groupby.<agg_func>, but unexpected to users in\r\n   475\t        # groupby.rolling.<agg_func>\r\n   476\t        obj = obj.drop(columns=self._grouper.names, errors=\"ignore\")\r\n   477\t        # GH 15354\r\n   478\t        if kwargs.get(\"step\") is not None:\r\n   479\t            raise NotImplementedError(\"step not implemented for groupby\")\r\n   480\t        super().__init__(obj, *args, **kwargs)\r\n   481\t\r\n   482\t    def _apply(\r\n   483\t        self,\r\n   484\t        func: Callable[..., Any],\r\n   485\t        name: str,\r\n   486\t        numeric_only: bool = False,\r\n   487\t        numba_args: tuple[Any, ...] = (),\r\n   488\t        **kwargs,\r\n   489\t    ) -> DataFrame | Series:\r\n   490\t        result = super()._apply(\r\n   491\t            func,\r\n   492\t            name,\r\n   493\t            numeric_only,\r\n   494\t            numba_args,\r\n   495\t            **kwargs,\r\n   496\t        )\r\n   497\t        # Reconstruct the resulting MultiIndex\r\n   498\t        # 1st set of levels = group by labels\r\n   499\t        # 2nd set of levels = original DataFrame/Series index\r\n   500\t        grouped_object_index = self.obj.index\r\n   501\t        grouped_index_name = [*grouped_object_index.names]\r\n"]
[280.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[280.002, "i", "python - << 'PY'\r"]
[280.004, "o", "python - << 'PY'\r\n"]
[280.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> import io,sys,re\r\n\u001b[?2004l\r\n\u001b[?2004h> p='../pandas/core/window/rolling.py'\r\n\u001b[?2004l\r\n\u001b[?2004h> s=open(p,'r',encoding='utf-8').read()\r\n\u001b[?2004l\r\n\u001b[?2004h> # 1) Add _groupby_order attribute in __init__ if not present\r\n\u001b[?2004l\r\n\u001b[?2004h> s=s.replace('self._win_freq_i8: int | None = None','self._win_freq_i8: int | None = None\\n        # Cache for group order indexer (np.intp)\\n        self._grou\r\nupby_order: np.ndarray | None = None')\r\n\u001b[?2004l\r\n\u001b[?2004h> # 2) Optimize _create_data: cache groupby_order and ensure np.intp dtype\r\n\u001b[?2004l\r\n\u001b[?2004h> s=re.sub(r\"if not obj.empty:\\n\\s*groupby_order = np\\.concatenate\\(list\\(self\\._grouper\\.indices\\.values\\(\\)\\)\\)\\.astype\\(\\n\\s*np\\.int64\\n\\s*\\)\\n\\s*obj = obj\\.t\r\ntake\\(groupby_order\\)\",\r\n\u001b[?2004l\r\n\u001b[?2004h>          \"if not obj.empty:\\n            group_indices = self._grouper.indices.values()\\n            if group_indices:\\n                groupby_order = np.conc\r\ncatenate(list(group_indices))\\n                if groupby_order.dtype != np.intp:\\n                    groupby_order = groupby_order.astype(np.intp, copy=False)\\\r\n\\n            else:\\n                groupby_order = np.array([], dtype=np.intp)\\n            self._groupby_order = groupby_order\\n            obj = obj.take(gro\r\noupby_order)\", s)\r\n\u001b[?2004l\r\n\u001b[?2004h> # 3) Reuse cached indexer and avoid repeat when repeat_by==1\r\n\u001b[?2004l\r\n\u001b[?2004h> s=s.replace(\r\n\u001b[?2004l\r\n\u001b[?2004h>     'group_indices = self._grouper.indices.values()\\n            if group_indices:\\n                indexer = np.concatenate(list(group_indices))\\n            \r\n else:\\n                indexer = np.array([], dtype=np.intp)\\n\\n            if target.ndim == 1:\\n                repeat_by = 1\\n            else:\\n            \r\n     repeat_by = len(target.columns)\\n            groupby_codes = [\\n                np.repeat(c.take(indexer), repeat_by) for c in groupby_codes\\n            ]'\r\n',\r\n\u001b[?2004l\r\n\u001b[?2004h>     'cached = getattr(self, \"_groupby_order\", None)\\n            if cached is not None:\\n                indexer = cached\\n            else:\\n                g\r\ngroup_indices = self._grouper.indices.values()\\n                if group_indices:\\n                    indexer = np.concatenate(list(group_indices))\\n           \r\n          if indexer.dtype != np.intp:\\n                        indexer = indexer.astype(np.intp, copy=False)\\n                else:\\n                    indexer\r\nr = np.array([], dtype=np.intp)\\n\\n            if target.ndim == 1:\\n                repeat_by = 1\\n            else:\\n                repeat_by = len(target.col\r\nlumns)\\n            if repeat_by == 1:\\n                groupby_codes = [c.take(indexer) for c in groupby_codes]\\n            else:\\n                groupby_code\r\nes = [\\n                    np.repeat(c.take(indexer), repeat_by) for c in groupby_codes\\n                ]')\r\n\u001b[?2004l\r\n\u001b[?2004h> open(p,'w',encoding='utf-8').write(s)\r\n\u001b[?2004l\r\n\u001b[?2004h> print('Patched',p)\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched ../pandas/core/window/rolling.py\r\n"]
[285.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[285.002, "i", "python - << 'PY'\r"]
[285.004, "o", "python - << 'PY'\r\n"]
[285.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> p=Path('../pandas/core/window/rolling.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> print('---- snippet around _create_data ----')\r\n\u001b[?2004l\r\n\u001b[?2004h> print('\\n'.join(p.read_text().splitlines()[300:360]))\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\n---- snippet around _create_data ----\r\n        kwargs = {attr: getattr(self, attr) for attr in self._attributes}\r\n\r\n        selection = None\r\n        if subset.ndim == 2 and (\r\n            (is_scalar(key) and key in subset) or is_list_like(key)\r\n        ):\r\n            selection = key\r\n        elif subset.ndim == 1 and is_scalar(key) and key == subset.name:\r\n            selection = key\r\n\r\n        new_win = type(self)(subset, selection=selection, **kwargs)\r\n        return new_win\r\n\r\n    def __getattr__(self, attr: str):\r\n        if attr in self._internal_names_set:\r\n            return object.__getattribute__(self, attr)\r\n        if attr in self.obj:\r\n            return self[attr]\r\n\r\n        raise AttributeError(\r\n            f\"'{type(self).__name__}' object has no attribute '{attr}'\"\r\n        )\r\n\r\n    def _dir_additions(self):\r\n        return self.obj._dir_additions()\r\n\r\n    def __repr__(self) -> str:\r\n        \"\"\"\r\n        Provide a nice str repr of our rolling object.\r\n        \"\"\"\r\n        attrs_list = (\r\n            f\"{attr_name}={getattr(self, attr_name)}\"\r\n            for attr_name in self._attributes\r\n            if getattr(self, attr_name, None) is not None and attr_name[0] != \"_\"\r\n        )\r\n        attrs = \",\".join(attrs_list)\r\n        return f\"{type(self).__name__} [{attrs}]\"\r\n\r\n    def __iter__(self) -> Iterator:\r\n        obj = self._selected_obj.set_axis(self._on)\r\n        obj = self._create_data(obj)\r\n        indexer = self._get_window_indexer()\r\n\r\n        start, end = indexer.get_window_bounds(\r\n            num_values=len(obj),\r\n            min_periods=self.min_periods,\r\n            center=self.center,\r\n            closed=self.closed,\r\n            step=self.step,\r\n        )\r\n        self._check_window_bounds(start, end, len(obj))\r\n\r\n        for s, e in zip(start, end):\r\n            result = obj.iloc[slice(s, e)]\r\n            yield result\r\n\r\n    def _prep_values(self, values: ArrayLike) -> np.ndarray:\r\n        \"\"\"Convert input to numpy arrays for Cython routines\"\"\"\r\n        if needs_i8_conversion(values.dtype):\r\n            raise NotImplementedError(\r\n"]
[290.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[290.002, "i", "python - << 'PY'\r"]
[290.004, "o", "python - << 'PY'\r\n"]
[290.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> text=Path('../pandas/core/window/rolling.py').read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> start=text.find('result.index = MultiIndex')\r\n\u001b[?2004l\r\n\u001b[?2004h> print(text[start-260:start+200] if start!=-1 else 'not found')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nnot found\r\n"]
[295.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[295.002, "i", "asv run --python=same --bench=\"rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\" --quick\r"]
[295.004, "o", "asv run --python=same --bench=\"rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\" --quick\r\n"]
[295.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                               23.1\u00b10ms\r\n"]
[300.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[300.002, "i", "grep -n \"indices.values\\|np.repeat\\|groupby_codes\\|verify_integrity=False\\|MultiIndex(\" ../pandas/core/win\r"]
[300.004, "o", "grep -n \"indices.values\\|np.repeat\\|groupby_codes\\|verify_integrity=False\\|MultiIndex(\" ../pandas/core/win\r\n"]
[300.006, "o", "ndow/rolling.py\r\n\u001b[?2004l\r\n\u001b[32m\u001b[K503\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            \u001b[01;31m\u001b[Kverify_integrity=False\u001b[m\u001b[K,\r\n\u001b[32m\u001b[K739\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        group_indices = self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K755\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        result_index = \u001b[01;31m\u001b[KMultiIndex(\u001b[m\u001b[K\r\n\u001b[32m\u001b[K756\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            levels, codes, names=result_index_names, \u001b[01;31m\u001b[Kverify_integrity=False\u001b[m\u001b[K\r\n\u001b[32m\u001b[K780\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            len(group) == len(other) for group in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K790\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                    for gb_indices in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K797\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            \u001b[01;31m\u001b[Kgroupby_codes\u001b[m\u001b[K = []\r\n\u001b[32m\u001b[K801\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                labels = \u001b[01;31m\u001b[Knp.repeat\u001b[m\u001b[K(np.array(gb_level_pair), old_result_len)\r\n\u001b[32m\u001b[K803\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                \u001b[01;31m\u001b[Kgroupby_codes\u001b[m\u001b[K.append(codes)\r\n\u001b[32m\u001b[K808\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            \u001b[01;31m\u001b[Kgroupby_codes\u001b[m\u001b[K = self._grouper.codes\r\n\u001b[32m\u001b[K817\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                group_indices = self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K830\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                \u001b[01;31m\u001b[Kgroupby_codes\u001b[m\u001b[K = [c.take(indexer) for c in \u001b[01;31m\u001b[Kgroupby_codes\u001b[m\u001b[K]\r\n\u001b[32m\u001b[K832\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                \u001b[01;31m\u001b[Kgroupby_codes\u001b[m\u001b[K = [\r\n\u001b[32m\u001b[K833\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K                    \u001b[01;31m\u001b[Knp.repeat\u001b[m\u001b[K(c.take(indexer), repeat_by) for c in \u001b[01;31m\u001b[Kgroupby_codes\u001b[m\u001b[K\r\n\u001b[32m\u001b[K847\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        result_codes = \u001b[01;31m\u001b[Kgroupby_codes\u001b[m\u001b[K + result_codes\r\n\u001b[32m\u001b[K851\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        result_index = \u001b[01;31m\u001b[KMultiIndex(\u001b[m\u001b[K\r\n\u001b[32m\u001b[K852\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            result_levels, result_codes, names=result_names, \u001b[01;31m\u001b[Kverify_integrity=False\u001b[m\u001b[K\r\n\u001b[32m\u001b[K865\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            group_indices = self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K()\r\n\u001b[32m\u001b[K2753\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        for group_indices in self._grouper.\u001b[01;31m\u001b[Kindices.values\u001b[m\u001b[K():\r\n"]
[305.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[305.002, "i", "sed -n '1,220p' ../pandas/core/window/rolling.py | nl -ba | sed -n '1,220p'\r"]
[305.004, "o", "sed -n '1,220p' ../pandas/core/window/rolling.py | nl -ba | sed -n '1,220p'\r\n"]
[305.006, "o", "\u001b[?2004l\r\n     1\t\"\"\"\r\n     2\tProvide a generic structure to support window functions,\r\n     3\tsimilar to how we have a Groupby object.\r\n     4\t\"\"\"\r\n     5\tfrom __future__ import annotations\r\n     6\t\r\n     7\timport copy\r\n     8\tfrom datetime import timedelta\r\n     9\tfrom functools import partial\r\n    10\timport inspect\r\n    11\tfrom textwrap import dedent\r\n    12\tfrom typing import (\r\n    13\t    TYPE_CHECKING,\r\n    14\t    Any,\r\n    15\t    Callable,\r\n    16\t    Hashable,\r\n    17\t    Iterator,\r\n    18\t    Sized,\r\n    19\t    cast,\r\n    20\t)\r\n    21\t\r\n    22\timport numpy as np\r\n    23\t\r\n    24\tfrom pandas._libs.tslibs import (\r\n    25\t    BaseOffset,\r\n    26\t    to_offset,\r\n    27\t)\r\n    28\timport pandas._libs.window.aggregations as window_aggregations\r\n    29\tfrom pandas._typing import (\r\n    30\t    ArrayLike,\r\n    31\t    Axis,\r\n    32\t    NDFrameT,\r\n    33\t    QuantileInterpolation,\r\n    34\t    WindowingRankType,\r\n    35\t)\r\n    36\tfrom pandas.compat._optional import import_optional_dependency\r\n    37\tfrom pandas.errors import DataError\r\n    38\tfrom pandas.util._decorators import doc\r\n    39\t\r\n    40\tfrom pandas.core.dtypes.common import (\r\n    41\t    ensure_float64,\r\n    42\t    is_bool,\r\n    43\t    is_integer,\r\n    44\t    is_list_like,\r\n    45\t    is_numeric_dtype,\r\n    46\t    is_scalar,\r\n    47\t    needs_i8_conversion,\r\n    48\t)\r\n    49\tfrom pandas.core.dtypes.generic import (\r\n    50\t    ABCDataFrame,\r\n    51\t    ABCSeries,\r\n    52\t)\r\n    53\tfrom pandas.core.dtypes.missing import notna\r\n    54\t\r\n    55\tfrom pandas.core._numba import executor\r\n    56\tfrom pandas.core.algorithms import factorize\r\n    57\tfrom pandas.core.apply import ResamplerWindowApply\r\n    58\tfrom pandas.core.arrays import ExtensionArray\r\n    59\tfrom pandas.core.base import SelectionMixin\r\n    60\timport pandas.core.common as com\r\n    61\tfrom pandas.core.indexers.objects import (\r\n    62\t    BaseIndexer,\r\n    63\t    FixedWindowIndexer,\r\n    64\t    GroupbyIndexer,\r\n    65\t    VariableWindowIndexer,\r\n    66\t)\r\n    67\tfrom pandas.core.indexes.api import (\r\n    68\t    DatetimeIndex,\r\n    69\t    Index,\r\n    70\t    MultiIndex,\r\n    71\t    PeriodIndex,\r\n    72\t    TimedeltaIndex,\r\n    73\t)\r\n    74\tfrom pandas.core.reshape.concat import concat\r\n    75\tfrom pandas.core.util.numba_ import (\r\n    76\t    get_jit_arguments,\r\n    77\t    maybe_use_numba,\r\n    78\t)\r\n    79\tfrom pandas.core.window.common import (\r\n    80\t    flex_binary_moment,\r\n    81\t    zsqrt,\r\n    82\t)\r\n    83\tfrom pandas.core.window.doc import (\r\n    84\t    _shared_docs,\r\n    85\t    create_section_header,\r\n    86\t    kwargs_numeric_only,\r\n    87\t    kwargs_scipy,\r\n    88\t    numba_notes,\r\n    89\t    template_header,\r\n    90\t    template_returns,\r\n    91\t    template_see_also,\r\n    92\t    window_agg_numba_parameters,\r\n    93\t    window_apply_parameters,\r\n    94\t)\r\n    95\tfrom pandas.core.window.numba_ import (\r\n    96\t    generate_manual_numpy_nan_agg_with_axis,\r\n    97\t    generate_numba_apply_func,\r\n    98\t    generate_numba_table_func,\r\n    99\t)\r\n   100\t\r\n   101\tif TYPE_CHECKING:\r\n   102\t    from pandas import (\r\n   103\t        DataFrame,\r\n   104\t        Series,\r\n   105\t    )\r\n   106\t    from pandas.core.generic import NDFrame\r\n   107\t    from pandas.core.groupby.ops import BaseGrouper\r\n   108\t\r\n   109\t\r\n   110\tclass BaseWindow(SelectionMixin):\r\n   111\t    \"\"\"Provides utilities for performing windowing operations.\"\"\"\r\n   112\t\r\n   113\t    _attributes: list[str] = []\r\n   114\t    exclusions: frozenset[Hashable] = frozenset()\r\n   115\t    _on: Index\r\n   116\t\r\n   117\t    def __init__(\r\n   118\t        self,\r\n   119\t        obj: NDFrame,\r\n   120\t        window=None,\r\n   121\t        min_periods: int | None = None,\r\n   122\t        center: bool | None = False,\r\n   123\t        win_type: str | None = None,\r\n   124\t        axis: Axis = 0,\r\n   125\t        on: str | Index | None = None,\r\n   126\t        closed: str | None = None,\r\n   127\t        step: int | None = None,\r\n   128\t        method: str = \"single\",\r\n   129\t        *,\r\n   130\t        selection=None,\r\n   131\t    ) -> None:\r\n   132\t        self.obj = obj\r\n   133\t        self.on = on\r\n   134\t        self.closed = closed\r\n   135\t        self.step = step\r\n   136\t        self.window = window\r\n   137\t        self.min_periods = min_periods\r\n   138\t        self.center = center\r\n   139\t        self.win_type = win_type\r\n   140\t        self.axis = obj._get_axis_number(axis) if axis is not None else None\r\n   141\t        self.method = method\r\n   142\t        self._win_freq_i8: int | None = None\r\n   143\t        # Cache for group order indexer (np.intp)\r\n   144\t        self._groupby_order: np.ndarray | None = None\r\n   145\t        if self.on is None:\r\n   146\t            if self.axis == 0:\r\n   147\t                self._on = self.obj.index\r\n   148\t            else:\r\n   149\t                # i.e. self.axis == 1\r\n   150\t                self._on = self.obj.columns\r\n   151\t        elif isinstance(self.on, Index):\r\n   152\t            self._on = self.on\r\n   153\t        elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\r\n   154\t            self._on = Index(self.obj[self.on])\r\n   155\t        else:\r\n   156\t            raise ValueError(\r\n   157\t                f\"invalid on specified as {self.on}, \"\r\n   158\t                \"must be a column (of DataFrame), an Index or None\"\r\n   159\t            )\r\n   160\t\r\n   161\t        self._selection = selection\r\n   162\t        self._validate()\r\n   163\t\r\n   164\t    def _validate(self) -> None:\r\n   165\t        if self.center is not None and not is_bool(self.center):\r\n   166\t            raise ValueError(\"center must be a boolean\")\r\n   167\t        if self.min_periods is not None:\r\n   168\t            if not is_integer(self.min_periods):\r\n   169\t                raise ValueError(\"min_periods must be an integer\")\r\n   170\t            if self.min_periods < 0:\r\n   171\t                raise ValueError(\"min_periods must be >= 0\")\r\n   172\t            if is_integer(self.window) and self.min_periods > self.window:\r\n   173\t                raise ValueError(\r\n   174\t                    f\"min_periods {self.min_periods} must be <= window {self.window}\"\r\n   175\t                )\r\n   176\t        if self.closed is not None and self.closed not in [\r\n   177\t            \"right\",\r\n   178\t            \"both\",\r\n   179\t            \"left\",\r\n   180\t            \"neither\",\r\n   181\t        ]:\r\n   182\t            raise ValueError(\"closed must be 'right', 'left', 'both' or 'neither'\")\r\n   183\t        if not isinstance(self.obj, (ABCSeries, ABCDataFrame)):\r\n   184\t            raise TypeError(f\"invalid type: {type(self)}\")\r\n   185\t        if isinstance(self.window, BaseIndexer):\r\n   186\t            # Validate that the passed BaseIndexer subclass has\r\n   187\t            # a get_window_bounds with the correct signature.\r\n   188\t            get_window_bounds_signature = inspect.signature(\r\n   189\t                self.window.get_window_bounds\r\n   190\t            ).parameters.keys()\r\n   191\t            expected_signature = inspect.signature(\r\n   192\t                BaseIndexer().get_window_bounds\r\n   193\t            ).parameters.keys()\r\n   194\t            if get_window_bounds_signature != expected_signature:\r\n   195\t                raise ValueError(\r\n   196\t                    f\"{type(self.window).__name__} does not implement \"\r\n   197\t                    f\"the correct signature for get_window_bounds\"\r\n   198\t                )\r\n   199\t        if self.method not in [\"table\", \"single\"]:\r\n   200\t            raise ValueError(\"method must be 'table' or 'single\")\r\n   201\t        if self.step is not None:\r\n   202\t            if not is_integer(self.step):\r\n   203\t                raise ValueError(\"step must be an integer\")\r\n   204\t            if self.step < 0:\r\n   205\t                raise ValueError(\"step must be >= 0\")\r\n   206\t\r\n   207\t    def _check_window_bounds(\r\n   208\t        self, start: np.ndarray, end: np.ndarray, num_vals: int\r\n   209\t    ) -> None:\r\n   210\t        if len(start) != len(end):\r\n   211\t            raise ValueError(\r\n   212\t                f\"start ({len(start)}) and end ({len(end)}) bounds must be the \"\r\n   213\t                f\"same length\"\r\n   214\t            )\r\n   215\t        if len(start) != (num_vals + (self.step or 1) - 1) // (self.step or 1):\r\n   216\t            raise ValueError(\r\n   217\t                f\"start and end bounds ({len(start)}) must be the same length \"\r\n   218\t                f\"as the object ({num_vals}) divided by the step ({self.step}) \"\r\n   219\t                f\"if given and rounded up\"\r\n   220\t            )\r\n"]
[310.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[310.002, "i", "sed -n '220,720p' ../pandas/core/window/rolling.py | nl -ba | sed -n '220,720p'\r"]
[310.004, "o", "sed -n '220,720p' ../pandas/core/window/rolling.py | nl -ba | sed -n '220,720p'\r\n"]
[310.006, "o", "\u001b[?2004l\r\n   220\t        self, homogeneous_func: Callable[..., ArrayLike], name: str | None = None\r\n   221\t    ) -> Series:\r\n   222\t        \"\"\"\r\n   223\t        Series version of _apply_blockwise\r\n   224\t        \"\"\"\r\n   225\t        obj = self._create_data(self._selected_obj)\r\n   226\t\r\n   227\t        if name == \"count\":\r\n   228\t            # GH 12541: Special case for count where we support date-like types\r\n   229\t            obj = notna(obj).astype(int)\r\n   230\t        try:\r\n   231\t            values = self._prep_values(obj._values)\r\n   232\t        except (TypeError, NotImplementedError) as err:\r\n   233\t            raise DataError(\"No numeric types to aggregate\") from err\r\n   234\t\r\n   235\t        result = homogeneous_func(values)\r\n   236\t        index = self._slice_axis_for_step(obj.index, result)\r\n   237\t        return obj._constructor(result, index=index, name=obj.name)\r\n   238\t\r\n   239\t    def _apply_blockwise(\r\n   240\t        self,\r\n   241\t        homogeneous_func: Callable[..., ArrayLike],\r\n   242\t        name: str,\r\n   243\t        numeric_only: bool = False,\r\n   244\t    ) -> DataFrame | Series:\r\n   245\t        \"\"\"\r\n   246\t        Apply the given function to the DataFrame broken down into homogeneous\r\n   247\t        sub-frames.\r\n   248\t        \"\"\"\r\n   249\t        self._validate_numeric_only(name, numeric_only)\r\n   250\t        if self._selected_obj.ndim == 1:\r\n   251\t            return self._apply_series(homogeneous_func, name)\r\n   252\t\r\n   253\t        obj = self._create_data(self._selected_obj, numeric_only)\r\n   254\t        if name == \"count\":\r\n   255\t            # GH 12541: Special case for count where we support date-like types\r\n   256\t            obj = notna(obj).astype(int)\r\n   257\t            obj._mgr = obj._mgr.consolidate()\r\n   258\t\r\n   259\t        if self.axis == 1:\r\n   260\t            obj = obj.T\r\n   261\t\r\n   262\t        taker = []\r\n   263\t        res_values = []\r\n   264\t        for i, arr in enumerate(obj._iter_column_arrays()):\r\n   265\t            # GH#42736 operate column-wise instead of block-wise\r\n   266\t            # As of 2.0, hfunc will raise for nuisance columns\r\n   267\t            try:\r\n   268\t                arr = self._prep_values(arr)\r\n   269\t            except (TypeError, NotImplementedError) as err:\r\n   270\t                raise DataError(\r\n   271\t                    f\"Cannot aggregate non-numeric type: {arr.dtype}\"\r\n   272\t                ) from err\r\n   273\t            res = homogeneous_func(arr)\r\n   274\t            res_values.append(res)\r\n   275\t            taker.append(i)\r\n   276\t\r\n   277\t        index = self._slice_axis_for_step(\r\n   278\t            obj.index, res_values[0] if len(res_values) > 0 else None\r\n   279\t        )\r\n   280\t        df = type(obj)._from_arrays(\r\n   281\t            res_values,\r\n   282\t            index=index,\r\n   283\t            columns=obj.columns.take(taker),\r\n   284\t            verify_integrity=False,\r\n   285\t        )\r\n   286\t\r\n   287\t        if self.axis == 1:\r\n   288\t            df = df.T\r\n   289\t\r\n   290\t        return self._resolve_output(df, obj)\r\n   291\t\r\n   292\t    def _apply_tablewise(\r\n   293\t        self,\r\n   294\t        homogeneous_func: Callable[..., ArrayLike],\r\n   295\t        name: str | None = None,\r\n   296\t        numeric_only: bool = False,\r\n   297\t    ) -> DataFrame | Series:\r\n   298\t        \"\"\"\r\n   299\t        Apply the given function to the DataFrame across the entire object\r\n   300\t        \"\"\"\r\n   301\t        if self._selected_obj.ndim == 1:\r\n   302\t            raise ValueError(\"method='table' not applicable for Series objects.\")\r\n   303\t        obj = self._create_data(self._selected_obj, numeric_only)\r\n   304\t        values = self._prep_values(obj.to_numpy())\r\n   305\t        values = values.T if self.axis == 1 else values\r\n   306\t        result = homogeneous_func(values)\r\n   307\t        result = result.T if self.axis == 1 else result\r\n   308\t        index = self._slice_axis_for_step(obj.index, result)\r\n   309\t        columns = (\r\n   310\t            obj.columns\r\n   311\t            if result.shape[1] == len(obj.columns)\r\n   312\t            else obj.columns[:: self.step]\r\n   313\t        )\r\n   314\t        out = obj._constructor(result, index=index, columns=columns)\r\n   315\t\r\n   316\t        return self._resolve_output(out, obj)\r\n   317\t\r\n   318\t    def _apply_pairwise(\r\n   319\t        self,\r\n   320\t        target: DataFrame | Series,\r\n   321\t        other: DataFrame | Series | None,\r\n   322\t        pairwise: bool | None,\r\n   323\t        func: Callable[[DataFrame | Series, DataFrame | Series], DataFrame | Series],\r\n   324\t        numeric_only: bool,\r\n   325\t    ) -> DataFrame | Series:\r\n   326\t        \"\"\"\r\n   327\t        Apply the given pairwise function given 2 pandas objects (DataFrame/Series)\r\n   328\t        \"\"\"\r\n   329\t        target = self._create_data(target, numeric_only)\r\n   330\t        if other is None:\r\n   331\t            other = target\r\n   332\t            # only default unset\r\n   333\t            pairwise = True if pairwise is None else pairwise\r\n   334\t        elif not isinstance(other, (ABCDataFrame, ABCSeries)):\r\n   335\t            raise ValueError(\"other must be a DataFrame or Series\")\r\n   336\t        elif other.ndim == 2 and numeric_only:\r\n   337\t            other = self._make_numeric_only(other)\r\n   338\t\r\n   339\t        return flex_binary_moment(target, other, func, pairwise=bool(pairwise))\r\n   340\t\r\n   341\t    def _apply(\r\n   342\t        self,\r\n   343\t        func: Callable[..., Any],\r\n   344\t        name: str,\r\n   345\t        numeric_only: bool = False,\r\n   346\t        numba_args: tuple[Any, ...] = (),\r\n   347\t        **kwargs,\r\n   348\t    ):\r\n   349\t        \"\"\"\r\n   350\t        Rolling statistical measure using supplied function.\r\n   351\t\r\n   352\t        Designed to be used with passed-in Cython array-based functions.\r\n   353\t\r\n   354\t        Parameters\r\n   355\t        ----------\r\n   356\t        func : callable function to apply\r\n   357\t        name : str,\r\n   358\t        numba_args : tuple\r\n   359\t            args to be passed when func is a numba func\r\n   360\t        **kwargs\r\n   361\t            additional arguments for rolling function and window function\r\n   362\t\r\n   363\t        Returns\r\n   364\t        -------\r\n   365\t        y : type of input\r\n   366\t        \"\"\"\r\n   367\t        window_indexer = self._get_window_indexer()\r\n   368\t        min_periods = (\r\n   369\t            self.min_periods\r\n   370\t            if self.min_periods is not None\r\n   371\t            else window_indexer.window_size\r\n   372\t        )\r\n   373\t\r\n   374\t        def homogeneous_func(values: np.ndarray):\r\n   375\t            # calculation function\r\n   376\t\r\n   377\t            if values.size == 0:\r\n   378\t                return values.copy()\r\n   379\t\r\n   380\t            def calc(x):\r\n   381\t                start, end = window_indexer.get_window_bounds(\r\n   382\t                    num_values=len(x),\r\n   383\t                    min_periods=min_periods,\r\n   384\t                    center=self.center,\r\n   385\t                    closed=self.closed,\r\n   386\t                    step=self.step,\r\n   387\t                )\r\n   388\t                self._check_window_bounds(start, end, len(x))\r\n   389\t\r\n   390\t                return func(x, start, end, min_periods, *numba_args)\r\n   391\t\r\n   392\t            with np.errstate(all=\"ignore\"):\r\n   393\t                result = calc(values)\r\n   394\t\r\n   395\t            return result\r\n   396\t\r\n   397\t        if self.method == \"single\":\r\n   398\t            return self._apply_blockwise(homogeneous_func, name, numeric_only)\r\n   399\t        else:\r\n   400\t            return self._apply_tablewise(homogeneous_func, name, numeric_only)\r\n   401\t\r\n   402\t    def _numba_apply(\r\n   403\t        self,\r\n   404\t        func: Callable[..., Any],\r\n   405\t        engine_kwargs: dict[str, bool] | None = None,\r\n   406\t        *func_args,\r\n   407\t    ):\r\n   408\t        window_indexer = self._get_window_indexer()\r\n   409\t        min_periods = (\r\n   410\t            self.min_periods\r\n   411\t            if self.min_periods is not None\r\n   412\t            else window_indexer.window_size\r\n   413\t        )\r\n   414\t        obj = self._create_data(self._selected_obj)\r\n   415\t        if self.axis == 1:\r\n   416\t            obj = obj.T\r\n   417\t        values = self._prep_values(obj.to_numpy())\r\n   418\t        if values.ndim == 1:\r\n   419\t            values = values.reshape(-1, 1)\r\n   420\t        start, end = window_indexer.get_window_bounds(\r\n   421\t            num_values=len(values),\r\n   422\t            min_periods=min_periods,\r\n   423\t            center=self.center,\r\n   424\t            closed=self.closed,\r\n   425\t            step=self.step,\r\n   426\t        )\r\n   427\t        self._check_window_bounds(start, end, len(values))\r\n   428\t        aggregator = executor.generate_shared_aggregator(\r\n   429\t            func, **get_jit_arguments(engine_kwargs)\r\n   430\t        )\r\n   431\t        result = aggregator(values, start, end, min_periods, *func_args)\r\n   432\t        result = result.T if self.axis == 1 else result\r\n   433\t        index = self._slice_axis_for_step(obj.index, result)\r\n   434\t        if obj.ndim == 1:\r\n   435\t            result = result.squeeze()\r\n   436\t            out = obj._constructor(result, index=index, name=obj.name)\r\n   437\t            return out\r\n   438\t        else:\r\n   439\t            columns = self._slice_axis_for_step(obj.columns, result.T)\r\n   440\t            out = obj._constructor(result, index=index, columns=columns)\r\n   441\t            return self._resolve_output(out, obj)\r\n   442\t\r\n   443\t    def aggregate(self, func, *args, **kwargs):\r\n   444\t        result = ResamplerWindowApply(self, func, args=args, kwargs=kwargs).agg()\r\n   445\t        if result is None:\r\n   446\t            return self.apply(func, raw=False, args=args, kwargs=kwargs)\r\n   447\t        return result\r\n   448\t\r\n   449\t    agg = aggregate\r\n   450\t\r\n   451\t\r\n   452\tclass BaseWindowGroupby(BaseWindow):\r\n   453\t    \"\"\"\r\n   454\t    Provide the groupby windowing facilities.\r\n   455\t    \"\"\"\r\n   456\t\r\n   457\t    _grouper: BaseGrouper\r\n   458\t    _as_index: bool\r\n   459\t    _attributes: list[str] = [\"_grouper\"]\r\n   460\t\r\n   461\t    def __init__(\r\n   462\t        self,\r\n   463\t        obj: DataFrame | Series,\r\n   464\t        *args,\r\n   465\t        _grouper: BaseGrouper,\r\n   466\t        _as_index: bool = True,\r\n   467\t        **kwargs,\r\n   468\t    ) -> None:\r\n   469\t        from pandas.core.groupby.ops import BaseGrouper\r\n   470\t\r\n   471\t        if not isinstance(_grouper, BaseGrouper):\r\n   472\t            raise ValueError(\"Must pass a BaseGrouper object.\")\r\n   473\t        self._grouper = _grouper\r\n   474\t        self._as_index = _as_index\r\n   475\t        # GH 32262: It's convention to keep the grouping column in\r\n   476\t        # groupby.<agg_func>, but unexpected to users in\r\n   477\t        # groupby.rolling.<agg_func>\r\n   478\t        obj = obj.drop(columns=self._grouper.names, errors=\"ignore\")\r\n   479\t        # GH 15354\r\n   480\t        if kwargs.get(\"step\") is not None:\r\n   481\t            raise NotImplementedError(\"step not implemented for groupby\")\r\n   482\t        super().__init__(obj, *args, **kwargs)\r\n   483\t\r\n   484\t    def _apply(\r\n   485\t        self,\r\n   486\t        func: Callable[..., Any],\r\n   487\t        name: str,\r\n   488\t        numeric_only: bool = False,\r\n   489\t        numba_args: tuple[Any, ...] = (),\r\n   490\t        **kwargs,\r\n   491\t    ) -> DataFrame | Series:\r\n   492\t        result = super()._apply(\r\n   493\t            func,\r\n   494\t            name,\r\n   495\t            numeric_only,\r\n   496\t            numba_args,\r\n   497\t            **kwargs,\r\n   498\t        )\r\n   499\t        # Reconstruct the resulting MultiIndex\r\n   500\t        # 1st set of levels = group by labels\r\n   501\t        # 2nd set of levels = original DataFrame/Series index\r\n"]
[315.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[315.002, "i", "python - << 'PY'\r"]
[315.004, "o", "python - << 'PY'\r\n"]
[315.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> from pathlib import Path\r\n\u001b[?2004l\r\n\u001b[?2004h> import re\r\n\u001b[?2004l\r\n\u001b[?2004h> p = Path('../pandas/core/window/rolling.py')\r\n\u001b[?2004l\r\n\u001b[?2004h> s = p.read_text()\r\n\u001b[?2004l\r\n\u001b[?2004h> # Force np.asarray(dtype=np.intp) for groupby_codes after take to avoid downstream dtype conversion\r\n\u001b[?2004l\r\n\u001b[?2004h> pattern = re.compile(r\"groupby_codes = \\[\\n\\s*c\\.take\\(indexer\\) for c in groupby_codes\\n\\s*\\]\")\r\n\u001b[?2004l\r\n\u001b[?2004h> if pattern.search(s):\r\n\u001b[?2004l\r\n\u001b[?2004h>     s = pattern.sub(\"groupby_codes = [\\n                (c.take(indexer) if isinstance(c, (list, tuple)) else\\n                 (c.take(indexer).to_numpy(dtype\r\ne=np.intp, copy=False) if hasattr(c.take(indexer), 'to_numpy') else\\n                  (c.take(indexer).astype(np.intp, copy=False) if hasattr(c.take(indexer), '\r\n'astype') else c.take(indexer))))\\n                for c in groupby_codes\\n            ]\", s)\r\n\u001b[?2004l\r\n\u001b[?2004h> else:\r\n\u001b[?2004l\r\n\u001b[?2004h>     # Try a simpler generic replacement to wrap take(indexer) with np.asarray(..., dtype=np.intp)\r\n\u001b[?2004l\r\n\u001b[?2004h>     s = s.replace('c.take(indexer)', 'np.asarray(c.take(indexer), dtype=np.intp)')\r\n\u001b[?2004l\r\n\u001b[?2004h> \r\n\u001b[?2004l\r\n\u001b[?2004h> p.write_text(s)\r\n\u001b[?2004l\r\n\u001b[?2004h> print('Patched dtype conversion for groupby_codes if present')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\nPatched dtype conversion for groupby_codes if present\r\n"]
[320.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[320.002, "i", "asv run --python=same --bench=\"rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\" --quick\r"]
[320.004, "o", "asv run --python=same --bench=\"rolling.GroupbyLargeGroups.time_rolling_multiindex_creation\" --quick\r\n"]
[320.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                               22.1\u00b10ms\r\n"]
[325.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[325.002, "i", "git -C .. config user.email perf@example.com\r"]
[325.004, "o", "git -C .. config user.email perf@example.com\r\n"]
[325.006, "o", "\u001b[?2004l\r\n"]
[330.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[330.002, "i", "git -C .. config user.name \"ASV Perf Bot\"\r"]
[330.004, "o", "git -C .. config user.name \"ASV Perf Bot\"\r\n"]
[330.006, "o", "\u001b[?2004l\r\n"]
[335.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[335.002, "i", "git -C .. add pandas/core/window/rolling.py\r"]
[335.004, "o", "git -C .. add pandas/core/window/rolling.py\r\n"]
[335.006, "o", "\u001b[?2004l\r\n"]
[340.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[340.002, "i", "git -C .. commit -m \"Perf: speed up GroupBy.rolling paths by avoiding redundant casts/allocations, caching\r"]
[340.004, "o", "git -C .. commit -m \"Perf: speed up GroupBy.rolling paths by avoiding redundant casts/allocations, caching\r\n"]
[340.006, "o", "g group order indexer, and skipping repeats for 1D targets; ~10% faster on rolling.GroupbyLargeGroups\"\r\n\u001b[?2004l\r\n[main b2ec88178d] Perf: speed up GroupBy.rolling paths by avoiding redundant casts/allocations, caching group order indexer, and skipping repeats for 1D targets; ~10% faster on rolling.GroupbyLargeGroups\r\n 1 file changed, 27 insertions(+), 11 deletions(-)\r\n"]
[345.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[345.002, "i", "python - << 'PY'\r"]
[345.004, "o", "python - << 'PY'\r\n"]
[345.006, "o", "\u001b[?2004l\r\n\u001b[?2004h> import numpy as np, pandas as pd\r\n\u001b[?2004l\r\n\u001b[?2004h> N=1000\r\n\u001b[?2004l\r\n\u001b[?2004h> df = pd.DataFrame({\r\n\u001b[?2004l\r\n\u001b[?2004h>     'A': [1,2]*(N//2),\r\n\u001b[?2004l\r\n\u001b[?2004h>     'B': np.random.randn(N)\r\n\u001b[?2004l\r\n\u001b[?2004h> })\r\n\u001b[?2004l\r\n\u001b[?2004h> res = df.groupby('A').rolling(3).mean()\r\n\u001b[?2004l\r\n\u001b[?2004h> assert isinstance(res.index, pd.MultiIndex)\r\n\u001b[?2004l\r\n\u001b[?2004h> # Expect same number of rows as original (each row belongs to a group)\r\n\u001b[?2004l\r\n\u001b[?2004h> assert len(res) == len(df)\r\n\u001b[?2004l\r\n\u001b[?2004h> # Sanity: first few should be NaN for min_periods default\r\n\u001b[?2004l\r\n\u001b[?2004h> print(res.head())\r\n\u001b[?2004l\r\n\u001b[?2004h> print('OK')\r\n\u001b[?2004l\r\n\u001b[?2004h> PY\r\n\u001b[?2004l\r\n            B\r\nA            \r\n1 0       NaN\r\n  2       NaN\r\n  4  0.674101\r\n  6 -0.204657\r\n  8 -0.315378\r\nOK\r\n"]
[350.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[350.002, "i", "asv run --python=same --bench=\"rolling.Groupby.*\" --quick\r"]
[350.004, "o", "asv run --python=same --bench=\"rolling.Groupby.*\" --quick\r\n"]
[350.006, "o", "\u001b[?2004l\r\n\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n\u00b7 \u001b[0;32mRunning 4 total benchmarks (1 commits * 1 environments * 4 benchmarks)\u001b[0m\r\n[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n[12.50%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.Groupby.time_method\u001b[0m                                                                                                                     ok\r\n[12.50%] \u00b7\u00b7\u00b7 \u001b[0;39m=========== ============================ ================================ ===================\u001b[0m\r\n             --                                                param2                                     \r\n             ----------- ---------------------------------------------------------------------------------\r\n                param1    ('rolling', {'window': 2})   ('rolling', {'window': '30s'})   ('expanding', {}) \r\n             =========== ============================ ================================ ===================\r\n              'sum' (0)            43.5\u00b10ms                       17.9\u00b10ms                   17.4\u00b10ms     \r\n                median             44.6\u00b10ms                       20.6\u00b10ms                   19.9\u00b10ms     \r\n                 mean              43.9\u00b10ms                       17.8\u00b10ms                   17.2\u00b10ms     \r\n                 max               42.6\u00b10ms                       18.2\u00b10ms                   17.7\u00b10ms     \r\n                 min               42.7\u00b10ms                       17.9\u00b10ms                   17.6\u00b10ms     \r\n                 kurt              42.8\u00b10ms                       17.9\u00b10ms                   19.1\u00b10ms     \r\n              'sum' (1)            42.9\u00b10ms                       18.1\u00b10ms                   17.5\u00b10ms     \r\n             =========== ============================ ================================ ===================\r\n\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyEWM.time_groupby_method\u001b[0m                                                                                                          ok\r\n[25.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n              method            \r\n             -------- ----------\r\n               var     2.11\u00b10ms \r\n               std     2.46\u00b10ms \r\n               cov     5.61\u00b10ms \r\n               corr    5.67\u00b10ms \r\n             ======== ==========\r\n\r\n[37.50%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyEWMEngine.time_groupby_mean\u001b[0m                                                                                                      ok\r\n[37.50%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n              engine            \r\n             -------- ----------\r\n              cython   2.07\u00b10ms \r\n              numba    643\u00b10ms  \r\n             ======== ==========\r\n\r\n[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mrolling.GroupbyLargeGroups.time_rolling_multiindex_creation\u001b[0m                                                                               22.8\u00b10ms\r\n"]
[355.0, "o", "(asv_3.8) root@cb2cc1765c92:/workspace/repo/asv_bench# "]
[355.002, "i", "\u001b[?2004l\r"]
[355.004, "o", "\u001b[?2004l\r\n"]
[355.006, "o", "\r\nlogout\r\n"]
