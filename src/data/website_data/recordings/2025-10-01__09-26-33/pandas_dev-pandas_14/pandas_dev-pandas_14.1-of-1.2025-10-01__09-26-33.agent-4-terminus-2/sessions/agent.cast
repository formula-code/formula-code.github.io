{"version": 2, "width": 160, "height": 40, "timestamp": 1762994861, "env": {"SHELL": "/bin/bash", "TERM": "screen"}}
[0.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[0.002, "i", "asciinema rec --stdin /logs/agent.cast\r"]
[0.004, "o", "asciinema rec --stdin /logs/agent.cast\r\n"]
[1.242, "o", "\u001b[?2004l\r\n"]
[2.478, "o", "\u001b[0;31masciinema: /logs/agent.cast already exists, aborting\u001b[0m\r\n"]
[3.714, "o", "\u001b[0;31masciinema: use --overwrite option if you want to overwrite existing recording\u001b[0m\r\n"]
[5.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[5.002, "i", "clear\r"]
[5.004, "o", "clear\r\n"]
[7.478, "o", "\u001b[?2004l\r\n"]
[10.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[10.002, "i", "ls -la\r"]
[10.004, "o", "ls -la\r\n"]
[10.139622, "o", "\u001b[?2004l\r\n"]
[10.273243, "o", "total 208\r\n"]
[10.406865, "o", "drwxr-xr-x 1 root root  4096 Oct  1 18:15 \u001b[0m\u001b[01;34m.\u001b[0m\r\n"]
[10.540486, "o", "drwxr-xr-x 1 root root  4096 Sep 15 17:10 \u001b[01;34m..\u001b[0m\r\n"]
[10.674108, "o", "drwxr-xr-x 2 root root  4096 Sep 13 19:16 \u001b[01;34m.circleci\u001b[0m\r\n"]
[10.80773, "o", "-rw-r--r-- 1 root root  1021 Sep 13 19:16 .devcontainer.json\r\n"]
[10.941351, "o", "drwxr-xr-x 1 root root  4096 Oct  1 18:15 \u001b[01;34m.git\u001b[0m\r\n"]
[11.074973, "o", "-rw-r--r-- 1 root root   229 Sep 13 19:16 .gitattributes\r\n"]
[11.208595, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 \u001b[01;34m.github\u001b[0m\r\n"]
[11.342216, "o", "-rw-r--r-- 1 root root  1740 Sep 13 19:16 .gitignore\r\n"]
[11.475838, "o", "-rw-r--r-- 1 root root  2322 Sep 13 19:16 .gitpod.yml\r\n"]
[11.609459, "o", "-rw-r--r-- 1 root root   761 Sep 13 19:16 .libcst.codemod.yaml\r\n"]
[11.743081, "o", "-rw-r--r-- 1 root root   109 Sep 13 19:16 .pep8speaks.yml\r\n"]
[11.876703, "o", "-rw-r--r-- 1 root root 16108 Sep 13 19:16 .pre-commit-config.yaml\r\n"]
[12.010324, "o", "-rw-r--r-- 1 root root  2284 Sep 13 19:16 AUTHORS.md\r\n"]
[12.143946, "o", "-rw-r--r-- 1 root root   372 Sep 13 19:16 CITATION.cff\r\n"]
[12.277568, "o", "-rw-r--r-- 1 root root   369 Sep 13 19:16 Dockerfile\r\n"]
[12.411189, "o", "-rw-r--r-- 1 root root  1634 Sep 13 19:16 LICENSE\r\n"]
[12.544811, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 \u001b[01;34mLICENSES\u001b[0m\r\n"]
[12.678432, "o", "-rw-r--r-- 1 root root  1228 Sep 13 19:16 MANIFEST.in\r\n"]
[12.812054, "o", "-rw-r--r-- 1 root root 10387 Sep 13 19:16 README.md\r\n"]
[12.945676, "o", "-rw-r--r-- 1 root root   246 Sep 13 19:16 RELEASE.md\r\n"]
[13.079297, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 \u001b[01;34masv_bench\u001b[0m\r\n"]
[13.212919, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 \u001b[01;34mci\u001b[0m\r\n"]
[13.346541, "o", "-rw-r--r-- 1 root root   256 Sep 13 19:14 codecov.yml\r\n"]
[13.480162, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 \u001b[01;34mdoc\u001b[0m\r\n"]
[13.613784, "o", "-rw-r--r-- 1 root root  2103 Sep 13 19:16 environment.yml\r\n"]
[13.747405, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 \u001b[01;34mgitpod\u001b[0m\r\n"]
[13.881027, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:57 \u001b[01;34mpandas\u001b[0m\r\n"]
[14.014649, "o", "-rw-r--r-- 1 root root 15627 Sep 13 19:16 pyproject.toml\r\n"]
[14.14827, "o", "-rw-r--r-- 1 root root  4429 Sep 13 19:16 pyright_reportGeneralTypeIssues.json\r\n"]
[14.281892, "o", "-rw-r--r-- 1 root root  1090 Sep 13 19:16 requirements-dev.txt\r\n"]
[14.415514, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 \u001b[01;34mscripts\u001b[0m\r\n"]
[14.549135, "o", "-rw-r--r-- 1 root root  2095 Sep 13 19:16 setup.cfg\r\n"]
[14.682757, "o", "-rwxr-xr-x 1 root root 21964 Sep 13 19:16 \u001b[01;32msetup.py\u001b[0m\r\n"]
[14.816378, "o", "drwxr-xr-x 2 root root  4096 Sep 13 19:14 \u001b[01;34mtypings\u001b[0m\r\n"]
[15.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[15.002, "i", "git rev-parse --is-inside-work-tree 2>/dev/null && git status -sb || echo 'not a git repo'\r"]
[15.004, "o", "git rev-parse --is-inside-work-tree 2>/dev/null && git status -sb || echo 'not a git repo'\r\n"]
[16.654, "o", "\u001b[?2004l\r\n"]
[18.302, "o", "true\r\n"]
[20.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[20.002, "i", "ls -la | sed -n '1,200p'\r"]
[20.004, "o", "ls -la | sed -n '1,200p'\r\n"]
[20.139622, "o", "\u001b[?2004l\r\n"]
[20.273243, "o", "total 208\r\n"]
[20.406865, "o", "drwxr-xr-x 1 root root  4096 Oct  1 18:15 .\r\n"]
[20.540486, "o", "drwxr-xr-x 1 root root  4096 Sep 15 17:10 ..\r\n"]
[20.674108, "o", "drwxr-xr-x 2 root root  4096 Sep 13 19:16 .circleci\r\n"]
[20.80773, "o", "-rw-r--r-- 1 root root  1021 Sep 13 19:16 .devcontainer.json\r\n"]
[20.941351, "o", "drwxr-xr-x 1 root root  4096 Oct  1 18:17 .git\r\n"]
[21.074973, "o", "-rw-r--r-- 1 root root   229 Sep 13 19:16 .gitattributes\r\n"]
[21.208595, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 .github\r\n"]
[21.342216, "o", "-rw-r--r-- 1 root root  1740 Sep 13 19:16 .gitignore\r\n"]
[21.475838, "o", "-rw-r--r-- 1 root root  2322 Sep 13 19:16 .gitpod.yml\r\n"]
[21.609459, "o", "-rw-r--r-- 1 root root   761 Sep 13 19:16 .libcst.codemod.yaml\r\n"]
[21.743081, "o", "-rw-r--r-- 1 root root   109 Sep 13 19:16 .pep8speaks.yml\r\n"]
[21.876703, "o", "-rw-r--r-- 1 root root 16108 Sep 13 19:16 .pre-commit-config.yaml\r\n"]
[22.010324, "o", "-rw-r--r-- 1 root root  2284 Sep 13 19:16 AUTHORS.md\r\n"]
[22.143946, "o", "-rw-r--r-- 1 root root   372 Sep 13 19:16 CITATION.cff\r\n"]
[22.277568, "o", "-rw-r--r-- 1 root root   369 Sep 13 19:16 Dockerfile\r\n"]
[22.411189, "o", "-rw-r--r-- 1 root root  1634 Sep 13 19:16 LICENSE\r\n"]
[22.544811, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 LICENSES\r\n"]
[22.678432, "o", "-rw-r--r-- 1 root root  1228 Sep 13 19:16 MANIFEST.in\r\n"]
[22.812054, "o", "-rw-r--r-- 1 root root 10387 Sep 13 19:16 README.md\r\n"]
[22.945676, "o", "-rw-r--r-- 1 root root   246 Sep 13 19:16 RELEASE.md\r\n"]
[23.079297, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 asv_bench\r\n"]
[23.212919, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 ci\r\n"]
[23.346541, "o", "-rw-r--r-- 1 root root   256 Sep 13 19:14 codecov.yml\r\n"]
[23.480162, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 doc\r\n"]
[23.613784, "o", "-rw-r--r-- 1 root root  2103 Sep 13 19:16 environment.yml\r\n"]
[23.747405, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 gitpod\r\n"]
[23.881027, "o", "drwxr-xr-x 1 root root  4096 Sep 13 21:57 pandas\r\n"]
[24.014649, "o", "-rw-r--r-- 1 root root 15627 Sep 13 19:16 pyproject.toml\r\n"]
[24.14827, "o", "-rw-r--r-- 1 root root  4429 Sep 13 19:16 pyright_reportGeneralTypeIssues.json\r\n"]
[24.281892, "o", "-rw-r--r-- 1 root root  1090 Sep 13 19:16 requirements-dev.txt\r\n"]
[24.415514, "o", "drwxr-xr-x 1 root root  4096 Sep 13 19:16 scripts\r\n"]
[24.549135, "o", "-rw-r--r-- 1 root root  2095 Sep 13 19:16 setup.cfg\r\n"]
[24.682757, "o", "-rwxr-xr-x 1 root root 21964 Sep 13 19:16 setup.py\r\n"]
[24.816378, "o", "drwxr-xr-x 2 root root  4096 Sep 13 19:14 typings\r\n"]
[25.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[25.002, "i", "test -f asv.conf.json && echo asv.conf.json || (test -f asv.conf.asv.json && echo asv.conf.asv.json) || (test -f asv\r"]
[25.004, "o", "test -f asv.conf.json && echo asv.conf.json || (test -f asv.conf.asv.json && echo asv.conf.asv.json) || (test -f asv\r\n"]
[26.654, "o", "v_bench/asv.conf.json && echo asv_bench/asv.conf.json) || echo 'no asv config found'\r\n"]
[28.302, "o", "\u001b[?2004l\r\n"]
[30.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[30.002, "i", "grep -R \"asv\" -n -- */ 2>/dev/null | head -n 50\r"]
[30.004, "o", "grep -R \"asv\" -n -- */ 2>/dev/null | head -n 50\r\n"]
[30.102941, "o", "\u001b[?2004l\r\n"]
[30.199882, "o", "asv_bench/asv.conf.json:31:    // to the current version of Python used to run `asv`.\r\n"]
[30.296824, "o", "asv_bench/asv.conf.json:109:    // `asv` will cache wheels of the recent builds in each\r\n"]
[30.393765, "o", "asv_bench/asv.conf.json:114:    // The commits after which the regression search in `asv publish`\r\n"]
[30.490706, "o", "asv_bench/benchmarks/io/parsers.py:9:    # Avoid whole benchmark suite import failure on asv (currently 0.4)\r\n"]
[30.587647, "o", "asv_bench/benchmarks/pandas_vb_common.py:59:    # https://asv.readthedocs.io/en/latest/writing_benchmarks.html\r\n"]
[30.684588, "o", "doc/source/whatsnew/v0.17.0.rst:51:- Development support for benchmarking with the `Air Speed Velocity library <https://github.com/spacetelescope/asv/>`_ (:issue:`8361`)\r\n"]
[30.781529, "o", "doc/source/whatsnew/v0.17.0.rst:1022:- Development support for benchmarking with the `Air Speed Velocity library <https://github.com/spacetelescope/asv/>`_ (:issue:`8361`)\r\n"]
[30.878471, "o", "doc/source/development/contributing_codebase.rst:898:`asv benchmarks <https://github.com/airspeed-velocity/asv>`__\r\n"]
[30.975412, "o", "doc/source/development/contributing_codebase.rst:900:These benchmarks are all found in the ``pandas/asv_bench`` directory, and the\r\n"]
[31.072353, "o", "doc/source/development/contributing_codebase.rst:903:To use all features of asv, you will need either ``conda`` or\r\n"]
[31.169294, "o", "doc/source/development/contributing_codebase.rst:904:``virtualenv``. For more details please check the `asv installation\r\n"]
[31.266235, "o", "doc/source/development/contributing_codebase.rst:905:webpage <https://asv.readthedocs.io/en/latest/installing.html>`_.\r\n"]
[31.363176, "o", "doc/source/development/contributing_codebase.rst:907:To install asv::\r\n"]
[31.460118, "o", "doc/source/development/contributing_codebase.rst:909:    pip install git+https://github.com/airspeed-velocity/asv\r\n"]
[31.557059, "o", "doc/source/development/contributing_codebase.rst:911:If you need to run a benchmark, change your directory to ``asv_bench/`` and run::\r\n"]
[31.654, "o", "doc/source/development/contributing_codebase.rst:913:    asv continuous -f 1.1 upstream/main HEAD\r\n"]
[31.750941, "o", "doc/source/development/contributing_codebase.rst:920:    asv continuous -f 1.1 -E virtualenv upstream/main HEAD\r\n"]
[31.847882, "o", "doc/source/development/contributing_codebase.rst:922:The ``-E virtualenv`` option should be added to all ``asv`` commands\r\n"]
[31.944824, "o", "doc/source/development/contributing_codebase.rst:923:that run benchmarks. The default value is defined in ``asv.conf.json``.\r\n"]
[32.041765, "o", "doc/source/development/contributing_codebase.rst:930:only run benchmarks from a ``pandas/asv_bench/benchmarks/groupby.py`` file::\r\n"]
[32.138706, "o", "doc/source/development/contributing_codebase.rst:932:    asv continuous -f 1.1 upstream/main HEAD -b ^groupby\r\n"]
[32.235647, "o", "doc/source/development/contributing_codebase.rst:937:    asv continuous -f 1.1 upstream/main HEAD -b groupby.GroupByMethods\r\n"]
[32.332588, "o", "doc/source/development/contributing_codebase.rst:946:``PYTHONPATH=\"$PWD/..\" asv [remaining arguments]``.\r\n"]
[32.429529, "o", "doc/source/development/contributing_codebase.rst:950:    asv run -e -E existing\r\n"]
[32.526471, "o", "doc/source/development/contributing_codebase.rst:954:    asv run -e -E existing:python3.6\r\n"]
[32.623412, "o", "doc/source/development/contributing_codebase.rst:959:Information on how to write a benchmark and how to use asv can be found in the\r\n"]
[32.720353, "o", "doc/source/development/contributing_codebase.rst:960:`asv documentation <https://asv.readthedocs.io/en/latest/writing_benchmarks.html>`_.\r\n"]
[32.817294, "o", "doc/source/development/maintaining.rst:315:.. _maintaining.asv-machine:\r\n"]
[32.914235, "o", "doc/source/development/maintaining.rst:321:are published to https://asv-runner.github.io/asv-collection/pandas/\r\n"]
[33.011176, "o", "doc/source/development/maintaining.rst:326:The machine can be configured with the `Ansible <http://docs.ansible.com/ansible/latest/index.html>`_ playbook in https://github.com/tomaugspurger/asv-runner.\r\n"]
[33.108118, "o", "doc/source/development/maintaining.rst:331:The results are published to another GitHub repository, https://github.com/tomaugspurger/asv-collection.\r\n"]
[33.205059, "o", "doc/source/development/maintaining.rst:332:Finally, we have a cron job on our docs server to pull from https://github.com/tomaugspurger/asv-collection, to serve them from ``/speed``.\r\n"]
[33.302, "o", "doc/source/development/roadmap.rst:189:pandas uses `airspeed velocity <https://asv.readthedocs.io/en/stable/>`__ to\r\n"]
[33.398941, "o", "doc/source/development/roadmap.rst:193:The `asv-runner <https://github.com/asv-runner>`__ organization, currently made up\r\n"]
[33.495882, "o", "pandas/io/sas/byteswap.c:14:            \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/include\"\r\n"]
[33.592824, "o", "pandas/io/sas/sas.c:14:            \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/include\"\r\n"]
[33.689765, "o", "pandas/tests/reshape/concat/test_dataframe.py:200:        # based on asv ConcatDataFrames\r\n"]
[33.786706, "o", "pandas/tests/io/data/csv/banklist.csv:6:Douglas County Bank,Douglasville,GA,21649,Hamilton State Bank,26-Apr-13,16-May-13\r\n"]
[33.883647, "o", "pandas/tests/io/data/csv/banklist.csv:194:First Commerce Community Bank,Douglasville,GA,57448,Community & Southern Bank,17-Sep-10,15-Jan-13\r\n"]
[33.980588, "o", "pandas/tests/io/data/html/banklist.html:300:\t\t\t\t<td class=\"city\">Douglasville</td>\r\n"]
[34.077529, "o", "pandas/tests/io/data/html/banklist.html:1992:\t\t\t\t<td class=\"city\">Douglasville</td>\r\n"]
[34.174471, "o", "pandas/tests/frame/methods/test_reindex.py:124:        # based on asv time_reindex_axis1\r\n"]
[34.271412, "o", "pandas/tests/tools/test_to_datetime.py:1140:        # inspired by asv timeseries.ToDatetimeNONISO8601 benchmark\r\n"]
[34.368353, "o", "pandas/_libs/tslibs/base.c:14:            \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/include\"\r\n"]
[34.465294, "o", "pandas/_libs/tslibs/timestamps.c:13:            \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/include/numpy/arrayobject.h\",\r\n"]
[34.562235, "o", "pandas/_libs/tslibs/timestamps.c:14:            \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/include/numpy/arrayscalars.h\",\r\n"]
[34.659176, "o", "pandas/_libs/tslibs/timestamps.c:15:            \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/include/numpy/ndarrayobject.h\",\r\n"]
[34.756118, "o", "pandas/_libs/tslibs/timestamps.c:16:            \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/include/numpy/ndarraytypes.h\",\r\n"]
[34.853059, "o", "pandas/_libs/tslibs/timestamps.c:17:            \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/include/numpy/npy_common.h\",\r\n"]
[35.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[35.002, "i", "find . -maxdepth 3 -type d -iname '*bench*' -or -iname 'asv*' | sed -n '1,200p'\r"]
[35.004, "o", "find . -maxdepth 3 -type d -iname '*bench*' -or -iname 'asv*' | sed -n '1,200p'\r\n"]
[35.9948, "o", "\u001b[?2004l\r\n"]
[36.9836, "o", "./asv_bench\r\n"]
[37.9724, "o", "./asv_bench/asv.conf.json\r\n"]
[38.9612, "o", "./asv_bench/benchmarks\r\n"]
[40.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[40.002, "i", "grep -R \"tslibs.timestamp\" -n . 2>/dev/null | head -n 50\r"]
[40.004, "o", "grep -R \"tslibs.timestamp\" -n . 2>/dev/null | head -n 50\r\n"]
[40.102941, "o", "\u001b[?2004l\r\n"]
[40.199882, "o", "./setup.py:217:        \"pandas/_libs/tslibs/timestamps.pyx\",\r\n"]
[40.296824, "o", "./setup.py:549:    \"_libs.tslibs.timestamps\": {\r\n"]
[40.393765, "o", "./setup.py:550:        \"pyxfile\": \"_libs/tslibs/timestamps\",\r\n"]
[40.490706, "o", "./pandas/core/arrays/datetimelike.py:54:from pandas._libs.tslibs.timestamps import integer_op_not_supported\r\n"]
[40.587647, "o", "./pandas/tests/tslibs/test_timezones.py:144:    msg = \"<class 'pandas._libs.tslibs.timestamps.Timestamp'>\"\r\n"]
[40.684588, "o", "./pandas/_libs/tslibs/timedeltas.pyx:759:            from pandas._libs.tslibs.timestamps import Timestamp\r\n"]
[40.781529, "o", "./pandas/_libs/tslibs/__init__.py:75:from pandas._libs.tslibs.timestamps import Timestamp\r\n"]
[40.878471, "o", "./pandas/_libs/tslibs/tzconversion.pyx:453:    from pandas._libs.tslibs.timestamps import Timestamp\r\n"]
[40.975412, "o", "./pandas/_libs/tslibs/period.pyi:8:from pandas._libs.tslibs.timestamps import Timestamp\r\n"]
[41.072353, "o", "./pandas/_libs/tslibs/strptime.pyx:67:from pandas._libs.tslibs.timestamps cimport _Timestamp\r\n"]
[41.169294, "o", "./pandas/_libs/tslibs/strptime.pyx:74:from pandas._libs.tslibs.timestamps import Timestamp\r\n"]
[41.266235, "o", "./pandas/_libs/tslibs/conversion.pyx:60:from pandas._libs.tslibs.timestamps cimport _Timestamp\r\n"]
[41.363176, "o", "./pandas/_libs/tslibs/conversion.pyx:591:            from pandas._libs.tslibs.timestamps import Timestamp\r\n"]
[41.460118, "o", "./pandas/_libs/tslibs/conversion.pyx:599:            from pandas._libs.tslibs.timestamps import Timestamp\r\n"]
[41.557059, "o", "./pandas/_libs/tslibs/period.pyx:57:from pandas._libs.tslibs.timestamps import Timestamp\r\n"]
[41.654, "o", "./pandas/_libs/tslibs/conversion.pxd:15:from pandas._libs.tslibs.timestamps cimport _Timestamp\r\n"]
[41.750941, "o", "./pandas/_libs/tslibs/timestamps.c:28:        \"name\": \"pandas._libs.tslibs.timestamps\",\r\n"]
[41.847882, "o", "./pandas/_libs/tslibs/timestamps.c:30:            \"pandas/_libs/tslibs/timestamps.pyx\",\r\n"]
[41.944824, "o", "./pandas/_libs/tslibs/timestamps.c:34:    \"module_name\": \"pandas._libs.tslibs.timestamps\"\r\n"]
[42.041765, "o", "./pandas/_libs/tslibs/timestamps.c:1033:  \"pandas/_libs/tslibs/timestamps.pyx\",\r\n"]
[42.138706, "o", "./pandas/_libs/tslibs/timestamps.c:1034:  \"pandas/_libs/tslibs/timestamps.pxd\",\r\n"]
[42.235647, "o", "./pandas/_libs/tslibs/timestamps.c:1767:/* \"pandas/_libs/tslibs/timestamps.pxd\":15\r\n"]
[42.332588, "o", "./pandas/_libs/tslibs/timestamps.c:1779:/* \"pandas/_libs/tslibs/timestamps.pxd\":32\r\n"]
[42.429529, "o", "./pandas/_libs/tslibs/timestamps.c:1791:/* \"pandas/_libs/tslibs/timestamps.pxd\":36\r\n"]
[42.526471, "o", "./pandas/_libs/tslibs/timestamps.c:1923:/* \"pandas/_libs/tslibs/timestamps.pxd\":22\r\n"]
[42.623412, "o", "./pandas/_libs/tslibs/timestamps.c:1940:/* \"pandas/_libs/tslibs/timestamps.pyx\":1518\r\n"]
[42.720353, "o", "./pandas/_libs/tslibs/timestamps.c:1953:/* \"pandas/_libs/tslibs/timestamps.pyx\":1612\r\n"]
[42.817294, "o", "./pandas/_libs/tslibs/timestamps.c:2107:/* \"pandas/_libs/tslibs/timestamps.pyx\":224\r\n"]
[42.914235, "o", "./pandas/_libs/tslibs/timestamps.c:3465:/* Module declarations from 'pandas._libs.tslibs.timestamps' */\r\n"]
[43.011176, "o", "./pandas/_libs/tslibs/timestamps.c:3517:#define __Pyx_MODULE_NAME \"pandas._libs.tslibs.timestamps\"\r\n"]
[43.108118, "o", "./pandas/_libs/tslibs/timestamps.c:3521:/* Implementation of 'pandas._libs.tslibs.timestamps' */\r\n"]
[43.205059, "o", "./pandas/_libs/tslibs/timestamps.c:3875:static const char __pyx_k_pandas__libs_tslibs_timestamps[] = \"pandas._libs.tslibs.timestamps\";\r\n"]
[43.302, "o", "./pandas/_libs/tslibs/timestamps.c:3961:static const char __pyx_k_pandas__libs_tslibs_timestamps_p[] = \"pandas/_libs/tslibs/timestamps.pyx\";\r\n"]
[43.398941, "o", "./pandas/_libs/tslibs/timestamps.c:4300:static PyObject *__pyx_n_s_pandas__libs_tslibs_timestamps;\r\n"]
[43.495882, "o", "./pandas/_libs/tslibs/timestamps.c:4301:static PyObject *__pyx_kp_s_pandas__libs_tslibs_timestamps_p;\r\n"]
[43.592824, "o", "./pandas/_libs/tslibs/timestamps.c:4686:/* \"pandas/_libs/tslibs/timestamps.pyx\":129\r\n"]
[43.689765, "o", "./pandas/_libs/tslibs/timestamps.c:4723:  /* \"pandas/_libs/tslibs/timestamps.pyx\":139\r\n"]
[43.786706, "o", "./pandas/_libs/tslibs/timestamps.c:4733:  /* \"pandas/_libs/tslibs/timestamps.pyx\":145\r\n"]
[43.883647, "o", "./pandas/_libs/tslibs/timestamps.c:4749:  /* \"pandas/_libs/tslibs/timestamps.pyx\":148\r\n"]
[43.980588, "o", "./pandas/_libs/tslibs/timestamps.c:4759:    /* \"pandas/_libs/tslibs/timestamps.pyx\":149\r\n"]
[44.077529, "o", "./pandas/_libs/tslibs/timestamps.c:4768:    /* \"pandas/_libs/tslibs/timestamps.pyx\":148\r\n"]
[44.174471, "o", "./pandas/_libs/tslibs/timestamps.c:4778:  /* \"pandas/_libs/tslibs/timestamps.pyx\":151\r\n"]
[44.271412, "o", "./pandas/_libs/tslibs/timestamps.c:4790:  /* \"pandas/_libs/tslibs/timestamps.pyx\":153\r\n"]
[44.368353, "o", "./pandas/_libs/tslibs/timestamps.c:4806:  /* \"pandas/_libs/tslibs/timestamps.pyx\":154\r\n"]
[44.465294, "o", "./pandas/_libs/tslibs/timestamps.c:4820:  /* \"pandas/_libs/tslibs/timestamps.pyx\":155\r\n"]
[44.562235, "o", "./pandas/_libs/tslibs/timestamps.c:4832:  /* \"pandas/_libs/tslibs/timestamps.pyx\":153\r\n"]
[44.659176, "o", "./pandas/_libs/tslibs/timestamps.c:4869:  /* \"pandas/_libs/tslibs/timestamps.pyx\":155\r\n"]
[44.756118, "o", "./pandas/_libs/tslibs/timestamps.c:4883:  /* \"pandas/_libs/tslibs/timestamps.pyx\":153\r\n"]
[44.853059, "o", "./pandas/_libs/tslibs/timestamps.c:4899:  /* \"pandas/_libs/tslibs/timestamps.pyx\":157\r\n"]
[45.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[45.002, "i", "grep -R \"SumMultiLevel\" -n . 2>/dev/null | head -n 50\r"]
[45.004, "o", "grep -R \"SumMultiLevel\" -n . 2>/dev/null | head -n 50\r\n"]
[47.478, "o", "\u001b[?2004l\r\n"]
[50.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[50.002, "i", "grep -R \"IntervalIndexMethod\" -n . 2>/dev/null | head -n 50\r"]
[50.004, "o", "grep -R \"IntervalIndexMethod\" -n . 2>/dev/null | head -n 50\r\n"]
[51.654, "o", "\u001b[?2004l\r\n"]
[53.302, "o", "./pandas/core/indexes/interval.py:907:        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[55.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[55.002, "i", "asv run --python=same --quick --bench=\"tslibs.timestamp.*\"\r"]
[55.004, "o", "asv run --python=same --quick --bench=\"tslibs.timestamp.*\"\r\n"]
[57.478, "o", "\u001b[?2004l\r\n"]
[60.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[60.002, "i", "asv run --python=same --quick --bench=\"groupby.SumMultiLevel.*\"\r"]
[60.004, "o", "asv run --python=same --quick --bench=\"groupby.SumMultiLevel.*\"\r\n"]
[62.478, "o", "\u001b[?2004l\r\n"]
[65.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[65.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.*\"\r"]
[65.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.*\"\r\n"]
[67.478, "o", "\u001b[?2004l\r\n"]
[70.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[70.002, "i", "asv find --python=same --bench \"tslibs.timestamp.*\"\r"]
[70.004, "o", "asv find --python=same --bench \"tslibs.timestamp.*\"\r\n"]
[70.220957, "o", "\u001b[?2004l\r\n"]
[70.435913, "o", "Traceback (most recent call last):\r\n"]
[70.65087, "o", "  File \"/opt/conda/envs/asv_3.8/bin/asv\", line 8, in <module>\r\n"]
[70.865826, "o", "    sys.exit(main())\r\n"]
[71.080783, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/site-packages/asv/main.py\", line 13, in main\r\n"]
[71.295739, "o", "    args = parser.parse_args()\r\n"]
[71.510696, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/argparse.py\", line 1768, in parse_args\r\n"]
[71.725652, "o", "    args, argv = self.parse_known_args(args, namespace)\r\n"]
[71.940609, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/argparse.py\", line 1800, in parse_known_args\r\n"]
[72.155565, "o", "    namespace, args = self._parse_known_args(args, namespace)\r\n"]
[72.370522, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/argparse.py\", line 1988, in _parse_known_args\r\n"]
[72.585478, "o", "    positionals_end_index = consume_positionals(start_index)\r\n"]
[72.800435, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/argparse.py\", line 1965, in consume_positionals\r\n"]
[73.015391, "o", "    take_action(action, args)\r\n"]
[73.230348, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/argparse.py\", line 1874, in take_action\r\n"]
[73.445304, "o", "    action(self, namespace, argument_values, option_string)\r\n"]
[73.660261, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/argparse.py\", line 1159, in __call__\r\n"]
[73.875217, "o", "    subnamespace, arg_strings = parser.parse_known_args(arg_strings, None)\r\n"]
[74.090174, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/argparse.py\", line 1800, in parse_known_args\r\n"]
[74.30513, "o", "    namespace, args = self._parse_known_args(args, namespace)\r\n"]
[74.520087, "o", "  File \"/opt/conda/envs/asv_3.8/lib/python3.8/argparse.py\", line 2035, in _parse_known_args\r\n"]
[74.735043, "o", "    ', '.join(required_actions))\r\n"]
[75.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[75.002, "i", "asv profile --python=same \"tslibs.timestamp.*\" 2>/dev/null | sed -n '1,200p'\r"]
[75.004, "o", "asv profile --python=same \"tslibs.timestamp.*\" 2>/dev/null | sed -n '1,200p'\r\n"]
[77.478, "o", "\u001b[?2004l\r\n"]
[80.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[80.002, "i", "sed -n '1,200p' asv_bench/asv.conf.json\r"]
[80.004, "o", "sed -n '1,200p' asv_bench/asv.conf.json\r\n"]
[80.043455, "o", "\u001b[?2004l\r\n"]
[80.080909, "o", "{\r\n"]
[80.118364, "o", "    // The version of the config file format.  Do not change, unless\r\n"]
[80.155818, "o", "    // you know what you are doing.\r\n"]
[80.193273, "o", "    \"version\": 1,\r\n"]
[80.230727, "o", "\r\n"]
[80.268182, "o", "    // The name of the project being benchmarked\r\n"]
[80.305636, "o", "    \"project\": \"pandas\",\r\n"]
[80.343091, "o", "\r\n"]
[80.380545, "o", "    // The project's homepage\r\n"]
[80.418, "o", "    \"project_url\": \"https://pandas.pydata.org/\",\r\n"]
[80.455455, "o", "\r\n"]
[80.492909, "o", "    // The URL of the source code repository for the project being\r\n"]
[80.530364, "o", "    // benchmarked\r\n"]
[80.567818, "o", "    \"repo\": \"..\",\r\n"]
[80.605273, "o", "\r\n"]
[80.642727, "o", "    // List of branches to benchmark. If not provided, defaults to \"master\"\r\n"]
[80.680182, "o", "    // (for git) or \"default\" (for mercurial).\r\n"]
[80.717636, "o", "    \"branches\": [\"main\"],\r\n"]
[80.755091, "o", "\r\n"]
[80.792545, "o", "    // The tool to use to create environments.  May be \"conda\",\r\n"]
[80.83, "o", "    // \"virtualenv\" or other value depending on the plugins in use.\r\n"]
[80.867455, "o", "    // If missing or the empty string, the tool will be automatically\r\n"]
[80.904909, "o", "    // determined by looking for tools on the PATH environment\r\n"]
[80.942364, "o", "    // variable.\r\n"]
[80.979818, "o", "    \"environment_type\": \"conda\",\r\n"]
[81.017273, "o", "\r\n"]
[81.054727, "o", "    // the base URL to show a commit for the project.\r\n"]
[81.092182, "o", "    \"show_commit_url\": \"https://github.com/pandas-dev/pandas/commit/\",\r\n"]
[81.129636, "o", "\r\n"]
[81.167091, "o", "    // The Pythons you'd like to test against.  If not provided, defaults\r\n"]
[81.204545, "o", "    // to the current version of Python used to run `asv`.\r\n"]
[81.242, "o", "    \"pythons\": [\"3.8\"],\r\n"]
[81.279455, "o", "\r\n"]
[81.316909, "o", "    // The matrix of dependencies to test.  Each key is the name of a\r\n"]
[81.354364, "o", "    // package (in PyPI) and the values are version numbers.  An empty\r\n"]
[81.391818, "o", "    // list or empty string indicates to just test against the default\r\n"]
[81.429273, "o", "    // (latest) version. null indicates that the package is to not be\r\n"]
[81.466727, "o", "    // installed. If the package to be tested is only available from\r\n"]
[81.504182, "o", "    // PyPi, and the 'environment_type' is conda, then you can preface\r\n"]
[81.541636, "o", "    // the package name by 'pip+', and the package will be installed via\r\n"]
[81.579091, "o", "    // pip (with all the conda available packages installed first,\r\n"]
[81.616545, "o", "    // followed by the pip installed packages).\r\n"]
[81.654, "o", "    \"matrix\": {\r\n"]
[81.691455, "o", "        \"numpy\": [],\r\n"]
[81.728909, "o", "        \"Cython\": [\"0.29.32\"],\r\n"]
[81.766364, "o", "        \"matplotlib\": [],\r\n"]
[81.803818, "o", "        \"sqlalchemy\": [],\r\n"]
[81.841273, "o", "        \"scipy\": [],\r\n"]
[81.878727, "o", "        \"numba\": [],\r\n"]
[81.916182, "o", "        \"numexpr\": [],\r\n"]
[81.953636, "o", "        \"pytables\": [null, \"\"],  // platform dependent, see excludes below\r\n"]
[81.991091, "o", "        \"pyarrow\": [],\r\n"]
[82.028545, "o", "        \"tables\": [null, \"\"],\r\n"]
[82.066, "o", "        \"openpyxl\": [],\r\n"]
[82.103455, "o", "        \"xlsxwriter\": [],\r\n"]
[82.140909, "o", "        \"xlrd\": [],\r\n"]
[82.178364, "o", "        \"odfpy\": [],\r\n"]
[82.215818, "o", "        \"jinja2\": [],\r\n"]
[82.253273, "o", "    },\r\n"]
[82.290727, "o", "    \"conda_channels\": [\"conda-forge\"],\r\n"]
[82.328182, "o", "    // Combinations of libraries/python versions can be excluded/included\r\n"]
[82.365636, "o", "    // from the set to test. Each entry is a dictionary containing additional\r\n"]
[82.403091, "o", "    // key-value pairs to include/exclude.\r\n"]
[82.440545, "o", "    //\r\n"]
[82.478, "o", "    // An exclude entry excludes entries where all values match. The\r\n"]
[82.515455, "o", "    // values are regexps that should match the whole string.\r\n"]
[82.552909, "o", "    //\r\n"]
[82.590364, "o", "    // An include entry adds an environment. Only the packages listed\r\n"]
[82.627818, "o", "    // are installed. The 'python' key is required. The exclude rules\r\n"]
[82.665273, "o", "    // do not apply to includes.\r\n"]
[82.702727, "o", "    //\r\n"]
[82.740182, "o", "    // In addition to package names, the following keys are available:\r\n"]
[82.777636, "o", "    //\r\n"]
[82.815091, "o", "    // - python\r\n"]
[82.852545, "o", "    //     Python version, as in the *pythons* variable above.\r\n"]
[82.89, "o", "    // - environment_type\r\n"]
[82.927455, "o", "    //     Environment type, as above.\r\n"]
[82.964909, "o", "    // - sys_platform\r\n"]
[83.002364, "o", "    //     Platform, as in sys.platform. Possible values for the common\r\n"]
[83.039818, "o", "    //     cases: 'linux2', 'win32', 'cygwin', 'darwin'.\r\n"]
[83.077273, "o", "    \"exclude\": [\r\n"]
[83.114727, "o", "        // On conda install pytables, otherwise tables\r\n"]
[83.152182, "o", "        {\"environment_type\": \"conda\", \"tables\": \"\"},\r\n"]
[83.189636, "o", "        {\"environment_type\": \"conda\", \"pytables\": null},\r\n"]
[83.227091, "o", "        {\"environment_type\": \"(?!conda).*\", \"tables\": null},\r\n"]
[83.264545, "o", "        {\"environment_type\": \"(?!conda).*\", \"pytables\": \"\"},\r\n"]
[83.302, "o", "    ],\r\n"]
[83.339455, "o", "    \"include\": [],\r\n"]
[83.376909, "o", "\r\n"]
[83.414364, "o", "    // The directory (relative to the current directory) that benchmarks are\r\n"]
[83.451818, "o", "    // stored in.  If not provided, defaults to \"benchmarks\"\r\n"]
[83.489273, "o", "    // \"benchmark_dir\": \"benchmarks\",\r\n"]
[83.526727, "o", "\r\n"]
[83.564182, "o", "    // The directory (relative to the current directory) to cache the Python\r\n"]
[83.601636, "o", "    // environments in.  If not provided, defaults to \"env\"\r\n"]
[83.639091, "o", "    // \"env_dir\": \"env\",\r\n"]
[83.676545, "o", "\r\n"]
[83.714, "o", "    // The directory (relative to the current directory) that raw benchmark\r\n"]
[83.751455, "o", "    // results are stored in.  If not provided, defaults to \"results\".\r\n"]
[83.788909, "o", "    // \"results_dir\": \"results\",\r\n"]
[83.826364, "o", "\r\n"]
[83.863818, "o", "    // The directory (relative to the current directory) that the html tree\r\n"]
[83.901273, "o", "    // should be written to.  If not provided, defaults to \"html\".\r\n"]
[83.938727, "o", "    // \"html_dir\": \"html\",\r\n"]
[83.976182, "o", "\r\n"]
[84.013636, "o", "    // The number of characters to retain in the commit hashes.\r\n"]
[84.051091, "o", "    // \"hash_length\": 8,\r\n"]
[84.088545, "o", "\r\n"]
[84.126, "o", "    // `asv` will cache wheels of the recent builds in each\r\n"]
[84.163455, "o", "    // environment, making them faster to install next time.  This is\r\n"]
[84.200909, "o", "    // number of builds to keep, per environment.\r\n"]
[84.238364, "o", "    \"build_cache_size\": 8,\r\n"]
[84.275818, "o", "\r\n"]
[84.313273, "o", "    // The commits after which the regression search in `asv publish`\r\n"]
[84.350727, "o", "    // should start looking for regressions. Dictionary whose keys are\r\n"]
[84.388182, "o", "    // regexps matching to benchmark names, and values corresponding to\r\n"]
[84.425636, "o", "    // the commit (exclusive) after which to start looking for\r\n"]
[84.463091, "o", "    // regressions.  The default is to start from the first commit\r\n"]
[84.500545, "o", "    // with results. If the commit is `null`, regression detection is\r\n"]
[84.538, "o", "    // skipped for the matching benchmark.\r\n"]
[84.575455, "o", "    //\r\n"]
[84.612909, "o", "    \"regressions_first_commits\": {\r\n"]
[84.650364, "o", "        \".*\": \"0409521665\"\r\n"]
[84.687818, "o", "    },\r\n"]
[84.725273, "o", "    \"regression_thresholds\": {\r\n"]
[84.762727, "o", "    },\r\n"]
[84.800182, "o", "    \"build_command\":\r\n"]
[84.837636, "o", "    [\"python -m pip install versioneer[toml]\",\r\n"]
[84.875091, "o", "     \"python setup.py build -j4\",\r\n"]
[84.912545, "o", "     \"PIP_NO_BUILD_ISOLATION=false python -mpip wheel --no-deps --no-index -w {build_cache_dir} {build_dir}\"],\r\n"]
[85.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[85.002, "i", "find pandas -name '*.so' | head -n 20\r"]
[85.004, "o", "find pandas -name '*.so' | head -n 20\r\n"]
[85.241429, "o", "\u001b[?2004l\r\n"]
[85.476857, "o", "pandas/io/sas/_byteswap.cpython-38-x86_64-linux-gnu.so\r\n"]
[85.712286, "o", "pandas/io/sas/_sas.cpython-38-x86_64-linux-gnu.so\r\n"]
[85.947714, "o", "pandas/_libs/tslibs/fields.cpython-38-x86_64-linux-gnu.so\r\n"]
[86.183143, "o", "pandas/_libs/tslibs/nattype.cpython-38-x86_64-linux-gnu.so\r\n"]
[86.418571, "o", "pandas/_libs/tslibs/timestamps.cpython-38-x86_64-linux-gnu.so\r\n"]
[86.654, "o", "pandas/_libs/tslibs/ccalendar.cpython-38-x86_64-linux-gnu.so\r\n"]
[86.889429, "o", "pandas/_libs/tslibs/strptime.cpython-38-x86_64-linux-gnu.so\r\n"]
[87.124857, "o", "pandas/_libs/tslibs/np_datetime.cpython-38-x86_64-linux-gnu.so\r\n"]
[87.360286, "o", "pandas/_libs/tslibs/dtypes.cpython-38-x86_64-linux-gnu.so\r\n"]
[87.595714, "o", "pandas/_libs/tslibs/timezones.cpython-38-x86_64-linux-gnu.so\r\n"]
[87.831143, "o", "pandas/_libs/tslibs/vectorized.cpython-38-x86_64-linux-gnu.so\r\n"]
[88.066571, "o", "pandas/_libs/tslibs/tzconversion.cpython-38-x86_64-linux-gnu.so\r\n"]
[88.302, "o", "pandas/_libs/tslibs/timedeltas.cpython-38-x86_64-linux-gnu.so\r\n"]
[88.537429, "o", "pandas/_libs/tslibs/period.cpython-38-x86_64-linux-gnu.so\r\n"]
[88.772857, "o", "pandas/_libs/tslibs/conversion.cpython-38-x86_64-linux-gnu.so\r\n"]
[89.008286, "o", "pandas/_libs/tslibs/base.cpython-38-x86_64-linux-gnu.so\r\n"]
[89.243714, "o", "pandas/_libs/tslibs/offsets.cpython-38-x86_64-linux-gnu.so\r\n"]
[89.479143, "o", "pandas/_libs/tslibs/parsing.cpython-38-x86_64-linux-gnu.so\r\n"]
[89.714571, "o", "pandas/_libs/window/aggregations.cpython-38-x86_64-linux-gnu.so\r\n"]
[90.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[90.002, "i", "python - << 'PY'\r"]
[90.004, "o", "python - << 'PY'\r\n"]
[90.266211, "o", "\u001b[?2004l\r\n"]
[90.526421, "o", "\u001b[?2004h> import sys\r\n"]
[90.786632, "o", "\u001b[?2004l\r\n"]
[91.046842, "o", "\u001b[?2004h> try:\r\n"]
[91.307053, "o", "\u001b[?2004l\r\n"]
[91.567263, "o", "\u001b[?2004h>     import pandas as pd\r\n"]
[91.827474, "o", "\u001b[?2004l\r\n"]
[92.087684, "o", "\u001b[?2004h>     print('pandas_version:', pd.__version__)\r\n"]
[92.347895, "o", "\u001b[?2004l\r\n"]
[92.608105, "o", "\u001b[?2004h>     print('pandas_file:', pd.__file__)\r\n"]
[92.868316, "o", "\u001b[?2004l\r\n"]
[93.128526, "o", "\u001b[?2004h> except Exception as e:\r\n"]
[93.388737, "o", "\u001b[?2004l\r\n"]
[93.648947, "o", "\u001b[?2004h>     print('import_error:', repr(e))\r\n"]
[93.909158, "o", "\u001b[?2004l\r\n"]
[94.169368, "o", "\u001b[?2004h> PY\r\n"]
[94.429579, "o", "\u001b[?2004l\r\n"]
[94.689789, "o", "pandas_version: 0+untagged.31506.g5f584bd\r\n"]
[95.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[95.002, "i", "asv dev -h\r"]
[95.004, "o", "asv dev -h\r\n"]
[96.242, "o", "\u001b[?2004l\r\n"]
[97.478, "o", "usage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n"]
[98.714, "o", "           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\n"]
[100.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[100.002, "i", "asv run -h\r"]
[100.004, "o", "asv run -h\r\n"]
[100.07192, "o", "\u001b[?2004l\r\n"]
[100.13784, "o", "usage: asv run [-h] [--date-period DATE_PERIOD] [--steps STEPS] [--bench BENCH] [--attribute ATTRIBUTE] [--cpu-affinity ATTRIBUTE] [--profile]\r\n"]
[100.20376, "o", "               [--parallel [PARALLEL]] [--show-stderr] [--durations [N]] [--quick] [-E ENV_SPEC] [--python PYTHON] [--set-commit-hash SET_COMMIT_HASH]\r\n"]
[100.26968, "o", "               [--launch-method {auto,spawn,forkserver}] [--dry-run] [--machine MACHINE] [--skip-existing-successful] [--skip-existing-failed]\r\n"]
[100.3356, "o", "               [--skip-existing-commits] [--skip-existing] [--record-samples] [--append-samples] [--interleave-rounds] [--no-interleave-rounds] [--no-pull]\r\n"]
[100.40152, "o", "               [--verbose] [--config CONFIG] [--version]\r\n"]
[100.46744, "o", "               [range]\r\n"]
[100.53336, "o", "\r\n"]
[100.59928, "o", "Run a benchmark suite.\r\n"]
[100.6652, "o", "\r\n"]
[100.73112, "o", "examples:\r\n"]
[100.79704, "o", "  asv run main             run for one branch\r\n"]
[100.86296, "o", "  asv run main^!           run for one commit (git)\r\n"]
[100.92888, "o", "  asv run \"--merges main\"  run for only merge commits (git)\r\n"]
[100.9948, "o", "\r\n"]
[101.06072, "o", "positional arguments:\r\n"]
[101.12664, "o", "  range                 Range of commits to benchmark. For a git repository, this is passed as the first argument to ``git rev-list``; or Mercurial log\r\n"]
[101.19256, "o", "                        command. See 'specifying ranges' section of the `gitrevisions` manpage, or 'hg help revisions', for more info. Also accepts the\r\n"]
[101.25848, "o", "                        special values 'NEW', 'ALL', 'EXISTING', 'TAGS', and 'HASHFILE:xxx'. 'NEW' will benchmark all commits since the latest benchmarked on\r\n"]
[101.3244, "o", "                        this machine. 'ALL' will benchmark all commits in the project. 'EXISTING' will benchmark against all commits for which there are\r\n"]
[101.39032, "o", "                        existing benchmarks on any machine. 'TAGS' will benchmark against all tags in the project. 'HASHFILE:xxx' will benchmark only a\r\n"]
[101.45624, "o", "                        specific set of hashes given in the file named 'xxx' ('-' means stdin), which must have one hash per line. By default, will benchmark\r\n"]
[101.52216, "o", "                        the head of each configured of the branches.\r\n"]
[101.58808, "o", "\r\n"]
[101.654, "o", "optional arguments:\r\n"]
[101.71992, "o", "  -h, --help            show this help message and exit\r\n"]
[101.78584, "o", "  --date-period DATE_PERIOD\r\n"]
[101.85176, "o", "                        Pick only one commit in each given time period. For example: 1d (daily), 1w (weekly), 1y (yearly).\r\n"]
[101.91768, "o", "  --steps STEPS, -s STEPS\r\n"]
[101.9836, "o", "                        Maximum number of steps to benchmark. This is used to subsample the commits determined by range to a reasonable number.\r\n"]
[102.04952, "o", "  --bench BENCH, -b BENCH\r\n"]
[102.11544, "o", "                        Regular expression(s) for benchmark to run. When not provided, all benchmarks are run.\r\n"]
[102.18136, "o", "  --attribute ATTRIBUTE, -a ATTRIBUTE\r\n"]
[102.24728, "o", "                        Override a benchmark attribute, e.g. `-a repeat=10`.\r\n"]
[102.3132, "o", "  --cpu-affinity ATTRIBUTE\r\n"]
[102.37912, "o", "                        Set CPU affinity for running the benchmark, in format: 0 or 0,1,2 or 0-3. Default: not set\r\n"]
[102.44504, "o", "  --profile, -p         In addition to timing, run the benchmarks through the `cProfile` profiler and store the results.\r\n"]
[102.51096, "o", "  --parallel [PARALLEL], -j [PARALLEL]\r\n"]
[102.57688, "o", "                        Build (but don't benchmark) in parallel. The value is the number of CPUs to use, or if no number provided, use the number of cores on\r\n"]
[102.6428, "o", "                        this machine.\r\n"]
[102.70872, "o", "  --show-stderr, -e     Display the stderr output from the benchmarks.\r\n"]
[102.77464, "o", "  --durations [N]       Display total duration for N (or 'all') slowest benchmarks\r\n"]
[102.84056, "o", "  --quick, -q           Do a \"quick\" run, where each benchmark function is run only once. This is useful to find basic errors in the benchmark functions\r\n"]
[102.90648, "o", "                        faster. The results are unlikely to be useful, and thus are not saved.\r\n"]
[102.9724, "o", "  -E ENV_SPEC, --environment ENV_SPEC\r\n"]
[103.03832, "o", "                        Specify the environment and Python versions for running the benchmarks. String of the format 'environment_type:python_version', for\r\n"]
[103.10424, "o", "                        example 'conda:3.12'. If the Python version is not specified, all those listed in the configuration file are run. The special\r\n"]
[103.17016, "o", "                        environment type 'existing:/path/to/python' runs the benchmarks using the given Python interpreter; if the path is omitted, the Python\r\n"]
[103.23608, "o", "                        running asv is used. For 'existing', the benchmarked project must be already installed, including all dependencies. By default, uses\r\n"]
[103.302, "o", "                        the values specified in the configuration file.\r\n"]
[103.36792, "o", "  --python PYTHON       Same as --environment=:PYTHON\r\n"]
[103.43384, "o", "  --set-commit-hash SET_COMMIT_HASH\r\n"]
[103.49976, "o", "                        Set the commit hash to use when recording benchmark results. This makes results to be saved also when using an existing environment.\r\n"]
[103.56568, "o", "  --launch-method {auto,spawn,forkserver}\r\n"]
[103.6316, "o", "                        How to launch benchmarks. Choices: auto, spawn, forkserver\r\n"]
[103.69752, "o", "  --dry-run, -n         Do not save any results to disk.\r\n"]
[103.76344, "o", "  --machine MACHINE, -m MACHINE\r\n"]
[103.82936, "o", "                        Use the given name to retrieve machine information. If not provided, the hostname is used. If no entry with that name is found, and\r\n"]
[103.89528, "o", "                        there is only one entry in ~/.asv-machine.json, that one entry will be used.\r\n"]
[103.9612, "o", "  --skip-existing-successful\r\n"]
[104.02712, "o", "                        Skip running benchmarks that have previous successful results\r\n"]
[104.09304, "o", "  --skip-existing-failed\r\n"]
[104.15896, "o", "                        Skip running benchmarks that have previous failed results\r\n"]
[104.22488, "o", "  --skip-existing-commits\r\n"]
[104.2908, "o", "                        Skip running benchmarks for commits that have existing results\r\n"]
[104.35672, "o", "  --skip-existing, -k   Skip running benchmarks that have previous successful or failed results\r\n"]
[104.42264, "o", "  --record-samples      Store raw measurement samples, not only statistics\r\n"]
[104.48856, "o", "  --append-samples      Combine new measurement samples with previous results, instead of discarding old results. Implies --record-samples. The previous run\r\n"]
[104.55448, "o", "                        must also have been run with --record/append-samples.\r\n"]
[104.6204, "o", "  --interleave-rounds   Interleave benchmarks with multiple rounds across commits. This can avoid measurement biases from commit ordering, can take longer.\r\n"]
[104.68632, "o", "  --no-interleave-rounds\r\n"]
[104.75224, "o", "  --no-pull             Do not pull the repository\r\n"]
[104.81816, "o", "  --verbose, -v         Increase verbosity\r\n"]
[104.88408, "o", "  --config CONFIG       Benchmark configuration file\r\n"]
[105.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[105.002, "i", "ls asv_bench/benchmarks | sed -n '1,200p'\r"]
[105.004, "o", "ls asv_bench/benchmarks | sed -n '1,200p'\r\n"]
[105.120977, "o", "\u001b[?2004l\r\n"]
[105.235953, "o", "__init__.py\r\n"]
[105.35093, "o", "algorithms.py\r\n"]
[105.465907, "o", "algos\r\n"]
[105.580884, "o", "arithmetic.py\r\n"]
[105.69586, "o", "array.py\r\n"]
[105.810837, "o", "attrs_caching.py\r\n"]
[105.925814, "o", "boolean.py\r\n"]
[106.040791, "o", "categoricals.py\r\n"]
[106.155767, "o", "ctors.py\r\n"]
[106.270744, "o", "dtypes.py\r\n"]
[106.385721, "o", "eval.py\r\n"]
[106.500698, "o", "finalize.py\r\n"]
[106.615674, "o", "frame_ctor.py\r\n"]
[106.730651, "o", "frame_methods.py\r\n"]
[106.845628, "o", "gil.py\r\n"]
[106.960605, "o", "groupby.py\r\n"]
[107.075581, "o", "hash_functions.py\r\n"]
[107.190558, "o", "index_cached_properties.py\r\n"]
[107.305535, "o", "index_object.py\r\n"]
[107.420512, "o", "indexing.py\r\n"]
[107.535488, "o", "indexing_engines.py\r\n"]
[107.650465, "o", "inference.py\r\n"]
[107.765442, "o", "io\r\n"]
[107.880419, "o", "join_merge.py\r\n"]
[107.995395, "o", "libs.py\r\n"]
[108.110372, "o", "multiindex_object.py\r\n"]
[108.225349, "o", "package.py\r\n"]
[108.340326, "o", "pandas_vb_common.py\r\n"]
[108.455302, "o", "period.py\r\n"]
[108.570279, "o", "plotting.py\r\n"]
[108.685256, "o", "reindex.py\r\n"]
[108.800233, "o", "replace.py\r\n"]
[108.915209, "o", "reshape.py\r\n"]
[109.030186, "o", "rolling.py\r\n"]
[109.145163, "o", "series_methods.py\r\n"]
[109.26014, "o", "sparse.py\r\n"]
[109.375116, "o", "stat_ops.py\r\n"]
[109.490093, "o", "strftime.py\r\n"]
[109.60507, "o", "strings.py\r\n"]
[109.720047, "o", "timedelta.py\r\n"]
[109.835023, "o", "timeseries.py\r\n"]
[110.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[110.002, "i", "sed -n '700,820p' asv_bench/benchmarks/groupby.py\r"]
[110.004, "o", "sed -n '700,820p' asv_bench/benchmarks/groupby.py\r\n"]
[110.046525, "o", "\u001b[?2004l\r\n"]
[110.087049, "o", "        self.df = DataFrame(data)\r\n"]
[110.127574, "o", "        data = {\r\n"]
[110.168098, "o", "            \"a\": Categorical(np.random.randint(10000, size=N), ordered=True),\r\n"]
[110.208623, "o", "            \"b\": arr,\r\n"]
[110.249148, "o", "        }\r\n"]
[110.289672, "o", "        self.df_ordered = DataFrame(data)\r\n"]
[110.330197, "o", "        data = {\r\n"]
[110.370721, "o", "            \"a\": Categorical(\r\n"]
[110.411246, "o", "                np.random.randint(100, size=N), categories=np.arange(10000)\r\n"]
[110.45177, "o", "            ),\r\n"]
[110.492295, "o", "            \"b\": arr,\r\n"]
[110.53282, "o", "        }\r\n"]
[110.573344, "o", "        self.df_extra_cat = DataFrame(data)\r\n"]
[110.613869, "o", "\r\n"]
[110.654393, "o", "    def time_groupby_sort(self):\r\n"]
[110.694918, "o", "        self.df.groupby(\"a\")[\"b\"].count()\r\n"]
[110.735443, "o", "\r\n"]
[110.775967, "o", "    def time_groupby_nosort(self):\r\n"]
[110.816492, "o", "        self.df.groupby(\"a\", sort=False)[\"b\"].count()\r\n"]
[110.857016, "o", "\r\n"]
[110.897541, "o", "    def time_groupby_ordered_sort(self):\r\n"]
[110.938066, "o", "        self.df_ordered.groupby(\"a\")[\"b\"].count()\r\n"]
[110.97859, "o", "\r\n"]
[111.019115, "o", "    def time_groupby_ordered_nosort(self):\r\n"]
[111.059639, "o", "        self.df_ordered.groupby(\"a\", sort=False)[\"b\"].count()\r\n"]
[111.100164, "o", "\r\n"]
[111.140689, "o", "    def time_groupby_extra_cat_sort(self):\r\n"]
[111.181213, "o", "        self.df_extra_cat.groupby(\"a\")[\"b\"].count()\r\n"]
[111.221738, "o", "\r\n"]
[111.262262, "o", "    def time_groupby_extra_cat_nosort(self):\r\n"]
[111.302787, "o", "        self.df_extra_cat.groupby(\"a\", sort=False)[\"b\"].count()\r\n"]
[111.343311, "o", "\r\n"]
[111.383836, "o", "\r\n"]
[111.424361, "o", "class Datelike:\r\n"]
[111.464885, "o", "    # GH 14338\r\n"]
[111.50541, "o", "    params = [\"period_range\", \"date_range\", \"date_range_tz\"]\r\n"]
[111.545934, "o", "    param_names = [\"grouper\"]\r\n"]
[111.586459, "o", "\r\n"]
[111.626984, "o", "    def setup(self, grouper):\r\n"]
[111.667508, "o", "        N = 10**4\r\n"]
[111.708033, "o", "        rng_map = {\r\n"]
[111.748557, "o", "            \"period_range\": period_range,\r\n"]
[111.789082, "o", "            \"date_range\": date_range,\r\n"]
[111.829607, "o", "            \"date_range_tz\": partial(date_range, tz=\"US/Central\"),\r\n"]
[111.870131, "o", "        }\r\n"]
[111.910656, "o", "        self.grouper = rng_map[grouper](\"1900-01-01\", freq=\"D\", periods=N)\r\n"]
[111.95118, "o", "        self.df = DataFrame(np.random.randn(10**4, 2))\r\n"]
[111.991705, "o", "\r\n"]
[112.03223, "o", "    def time_sum(self, grouper):\r\n"]
[112.072754, "o", "        self.df.groupby(self.grouper).sum()\r\n"]
[112.113279, "o", "\r\n"]
[112.153803, "o", "\r\n"]
[112.194328, "o", "class SumBools:\r\n"]
[112.234852, "o", "    # GH 2692\r\n"]
[112.275377, "o", "    def setup(self):\r\n"]
[112.315902, "o", "        N = 500\r\n"]
[112.356426, "o", "        self.df = DataFrame({\"ii\": range(N), \"bb\": [True] * N})\r\n"]
[112.396951, "o", "\r\n"]
[112.437475, "o", "    def time_groupby_sum_booleans(self):\r\n"]
[112.478, "o", "        self.df.groupby(\"ii\").sum()\r\n"]
[112.518525, "o", "\r\n"]
[112.559049, "o", "\r\n"]
[112.599574, "o", "class SumMultiLevel:\r\n"]
[112.640098, "o", "    # GH 9049\r\n"]
[112.680623, "o", "    timeout = 120.0\r\n"]
[112.721148, "o", "\r\n"]
[112.761672, "o", "    def setup(self):\r\n"]
[112.802197, "o", "        N = 50\r\n"]
[112.842721, "o", "        self.df = DataFrame(\r\n"]
[112.883246, "o", "            {\"A\": list(range(N)) * 2, \"B\": range(N * 2), \"C\": 1}\r\n"]
[112.92377, "o", "        ).set_index([\"A\", \"B\"])\r\n"]
[112.964295, "o", "\r\n"]
[113.00482, "o", "    def time_groupby_sum_multiindex(self):\r\n"]
[113.045344, "o", "        self.df.groupby(level=[0, 1]).sum()\r\n"]
[113.085869, "o", "\r\n"]
[113.126393, "o", "\r\n"]
[113.166918, "o", "class Transform:\r\n"]
[113.207443, "o", "    def setup(self):\r\n"]
[113.247967, "o", "        n1 = 400\r\n"]
[113.288492, "o", "        n2 = 250\r\n"]
[113.329016, "o", "        index = MultiIndex(\r\n"]
[113.369541, "o", "            levels=[np.arange(n1), tm.makeStringIndex(n2)],\r\n"]
[113.410066, "o", "            codes=[np.repeat(range(n1), n2).tolist(), list(range(n2)) * n1],\r\n"]
[113.45059, "o", "            names=[\"lev1\", \"lev2\"],\r\n"]
[113.491115, "o", "        )\r\n"]
[113.531639, "o", "        arr = np.random.randn(n1 * n2, 3)\r\n"]
[113.572164, "o", "        arr[::10000, 0] = np.nan\r\n"]
[113.612689, "o", "        arr[1::10000, 1] = np.nan\r\n"]
[113.653213, "o", "        arr[2::10000, 2] = np.nan\r\n"]
[113.693738, "o", "        data = DataFrame(arr, index=index, columns=[\"col1\", \"col20\", \"col3\"])\r\n"]
[113.734262, "o", "        self.df = data\r\n"]
[113.774787, "o", "\r\n"]
[113.815311, "o", "        n = 1000\r\n"]
[113.855836, "o", "        self.df_wide = DataFrame(\r\n"]
[113.896361, "o", "            np.random.randn(n, n),\r\n"]
[113.936885, "o", "            index=np.random.choice(range(10), n),\r\n"]
[113.97741, "o", "        )\r\n"]
[114.017934, "o", "\r\n"]
[114.058459, "o", "        n = 1_000_000\r\n"]
[114.098984, "o", "        self.df_tall = DataFrame(\r\n"]
[114.139508, "o", "            np.random.randn(n, 3),\r\n"]
[114.180033, "o", "            index=np.random.randint(0, 5, n),\r\n"]
[114.220557, "o", "        )\r\n"]
[114.261082, "o", "\r\n"]
[114.301607, "o", "        n = 20000\r\n"]
[114.342131, "o", "        self.df1 = DataFrame(\r\n"]
[114.382656, "o", "            np.random.randint(1, n, (n, 3)), columns=[\"jim\", \"joe\", \"jolie\"]\r\n"]
[114.42318, "o", "        )\r\n"]
[114.463705, "o", "        self.df2 = self.df1.copy()\r\n"]
[114.50423, "o", "        self.df2[\"jim\"] = self.df2[\"joe\"]\r\n"]
[114.544754, "o", "\r\n"]
[114.585279, "o", "        self.df3 = DataFrame(\r\n"]
[114.625803, "o", "            np.random.randint(1, (n / 10), (n, 3)), columns=[\"jim\", \"joe\", \"jolie\"]\r\n"]
[114.666328, "o", "        )\r\n"]
[114.706852, "o", "        self.df4 = self.df3.copy()\r\n"]
[114.747377, "o", "        self.df4[\"jim\"] = self.df4[\"joe\"]\r\n"]
[114.787902, "o", "\r\n"]
[114.828426, "o", "    def time_transform_lambda_max(self):\r\n"]
[114.868951, "o", "        self.df.groupby(level=\"lev1\").transform(lambda x: max(x))\r\n"]
[114.909475, "o", "\r\n"]
[115.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[115.002, "i", "sed -n '180,260p' asv_bench/benchmarks/index_object.py\r"]
[115.004, "o", "sed -n '180,260p' asv_bench/benchmarks/index_object.py\r\n"]
[115.066293, "o", "\u001b[?2004l\r\n"]
[115.126585, "o", "\r\n"]
[115.186878, "o", "    def time_slice(self, dtype):\r\n"]
[115.247171, "o", "        self.idx[:-1]\r\n"]
[115.307463, "o", "\r\n"]
[115.367756, "o", "    def time_slice_step(self, dtype):\r\n"]
[115.428049, "o", "        self.idx[::2]\r\n"]
[115.488341, "o", "\r\n"]
[115.548634, "o", "    def time_get_loc(self, dtype):\r\n"]
[115.608927, "o", "        self.idx.get_loc(self.key)\r\n"]
[115.66922, "o", "\r\n"]
[115.729512, "o", "    def time_get_loc_sorted(self, dtype):\r\n"]
[115.789805, "o", "        self.sorted.get_loc(self.key)\r\n"]
[115.850098, "o", "\r\n"]
[115.91039, "o", "    def time_get_loc_non_unique(self, dtype):\r\n"]
[115.970683, "o", "        self.non_unique.get_loc(self.key)\r\n"]
[116.030976, "o", "\r\n"]
[116.091268, "o", "    def time_get_loc_non_unique_sorted(self, dtype):\r\n"]
[116.151561, "o", "        self.non_unique_sorted.get_loc(self.key)\r\n"]
[116.211854, "o", "\r\n"]
[116.272146, "o", "\r\n"]
[116.332439, "o", "class Float64IndexMethod:\r\n"]
[116.392732, "o", "    # GH 13166\r\n"]
[116.453024, "o", "    def setup(self):\r\n"]
[116.513317, "o", "        N = 100_000\r\n"]
[116.57361, "o", "        a = np.arange(N, dtype=np.float64)\r\n"]
[116.633902, "o", "        self.ind = Index(a * 4.8000000418824129e-08)\r\n"]
[116.694195, "o", "\r\n"]
[116.754488, "o", "    def time_get_loc(self):\r\n"]
[116.81478, "o", "        self.ind.get_loc(0)\r\n"]
[116.875073, "o", "\r\n"]
[116.935366, "o", "\r\n"]
[116.995659, "o", "class IntervalIndexMethod:\r\n"]
[117.055951, "o", "    # GH 24813\r\n"]
[117.116244, "o", "    params = [10**3, 10**5]\r\n"]
[117.176537, "o", "\r\n"]
[117.236829, "o", "    def setup(self, N):\r\n"]
[117.297122, "o", "        left = np.append(np.arange(N), np.array(0))\r\n"]
[117.357415, "o", "        right = np.append(np.arange(1, N + 1), np.array(1))\r\n"]
[117.417707, "o", "        self.intv = IntervalIndex.from_arrays(left, right)\r\n"]
[117.478, "o", "        self.intv._engine\r\n"]
[117.538293, "o", "\r\n"]
[117.598585, "o", "        self.intv2 = IntervalIndex.from_arrays(left + 1, right + 1)\r\n"]
[117.658878, "o", "        self.intv2._engine\r\n"]
[117.719171, "o", "\r\n"]
[117.779463, "o", "        self.left = IntervalIndex.from_breaks(np.arange(N))\r\n"]
[117.839756, "o", "        self.right = IntervalIndex.from_breaks(np.arange(N - 3, 2 * N - 3))\r\n"]
[117.900049, "o", "\r\n"]
[117.960341, "o", "    def time_monotonic_inc(self, N):\r\n"]
[118.020634, "o", "        self.intv.is_monotonic_increasing\r\n"]
[118.080927, "o", "\r\n"]
[118.14122, "o", "    def time_is_unique(self, N):\r\n"]
[118.201512, "o", "        self.intv.is_unique\r\n"]
[118.261805, "o", "\r\n"]
[118.322098, "o", "    def time_intersection(self, N):\r\n"]
[118.38239, "o", "        self.left.intersection(self.right)\r\n"]
[118.442683, "o", "\r\n"]
[118.502976, "o", "    def time_intersection_one_duplicate(self, N):\r\n"]
[118.563268, "o", "        self.intv.intersection(self.right)\r\n"]
[118.623561, "o", "\r\n"]
[118.683854, "o", "    def time_intersection_both_duplicate(self, N):\r\n"]
[118.744146, "o", "        self.intv.intersection(self.intv2)\r\n"]
[118.804439, "o", "\r\n"]
[118.864732, "o", "\r\n"]
[118.925024, "o", "class GC:\r\n"]
[118.985317, "o", "    params = [1, 2, 5]\r\n"]
[119.04561, "o", "\r\n"]
[119.105902, "o", "    def create_use_drop(self):\r\n"]
[119.166195, "o", "        idx = Index(list(range(1_000_000)))\r\n"]
[119.226488, "o", "        idx._engine\r\n"]
[119.28678, "o", "\r\n"]
[119.347073, "o", "    def peakmem_gc_instances(self, N):\r\n"]
[119.407366, "o", "        try:\r\n"]
[119.467659, "o", "            gc.disable()\r\n"]
[119.527951, "o", "\r\n"]
[119.588244, "o", "            for _ in range(N):\r\n"]
[119.648537, "o", "                self.create_use_drop()\r\n"]
[119.708829, "o", "        finally:\r\n"]
[119.769122, "o", "            gc.enable()\r\n"]
[119.829415, "o", "\r\n"]
[119.889707, "o", "\r\n"]
[120.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[120.002, "i", "asv dev --config asv_bench/asv.conf.json -b \"groupby.SumMultiLevel.*\"\r"]
[120.004, "o", "asv dev --config asv_bench/asv.conf.json -b \"groupby.SumMultiLevel.*\"\r\n"]
[121.242, "o", "\u001b[?2004l\r\n"]
[122.478, "o", "usage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n"]
[123.714, "o", "           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\n"]
[125.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[125.002, "i", "asv dev --config asv_bench/asv.conf.json -b \"index_object.IntervalIndexMethod.*\"\r"]
[125.004, "o", "asv dev --config asv_bench/asv.conf.json -b \"index_object.IntervalIndexMethod.*\"\r\n"]
[126.242, "o", "\u001b[?2004l\r\n"]
[127.478, "o", "usage: asv [-h] [--verbose] [--config CONFIG] [--version]\r\n"]
[128.714, "o", "           {help,quickstart,machine,setup,run,continuous,find,rm,publish,preview,profile,update,show,compare,check,gh-pages} ...\r\n"]
[130.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[130.002, "i", "asv run --python=same --config asv_bench/asv.conf.json --quick --bench=\"groupby.SumMultiLevel.*\"\r"]
[130.004, "o", "asv run --python=same --config asv_bench/asv.conf.json --quick --bench=\"groupby.SumMultiLevel.*\"\r\n"]
[132.478, "o", "\u001b[?2004l\r\n"]
[135.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[135.002, "i", "asv run --python=same --config asv_bench/asv.conf.json --quick --bench=\"index_object.IntervalIndexMethod.*\"\r"]
[135.004, "o", "asv run --python=same --config asv_bench/asv.conf.json --quick --bench=\"index_object.IntervalIndexMethod.*\"\r\n"]
[137.478, "o", "\u001b[?2004l\r\n"]
[140.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[140.002, "i", "find pandas -name '*.so' | head -n 20\r"]
[140.004, "o", "find pandas -name '*.so' | head -n 20\r\n"]
[140.241429, "o", "\u001b[?2004l\r\n"]
[140.476857, "o", "pandas/io/sas/_byteswap.cpython-38-x86_64-linux-gnu.so\r\n"]
[140.712286, "o", "pandas/io/sas/_sas.cpython-38-x86_64-linux-gnu.so\r\n"]
[140.947714, "o", "pandas/_libs/tslibs/fields.cpython-38-x86_64-linux-gnu.so\r\n"]
[141.183143, "o", "pandas/_libs/tslibs/nattype.cpython-38-x86_64-linux-gnu.so\r\n"]
[141.418571, "o", "pandas/_libs/tslibs/timestamps.cpython-38-x86_64-linux-gnu.so\r\n"]
[141.654, "o", "pandas/_libs/tslibs/ccalendar.cpython-38-x86_64-linux-gnu.so\r\n"]
[141.889429, "o", "pandas/_libs/tslibs/strptime.cpython-38-x86_64-linux-gnu.so\r\n"]
[142.124857, "o", "pandas/_libs/tslibs/np_datetime.cpython-38-x86_64-linux-gnu.so\r\n"]
[142.360286, "o", "pandas/_libs/tslibs/dtypes.cpython-38-x86_64-linux-gnu.so\r\n"]
[142.595714, "o", "pandas/_libs/tslibs/timezones.cpython-38-x86_64-linux-gnu.so\r\n"]
[142.831143, "o", "pandas/_libs/tslibs/vectorized.cpython-38-x86_64-linux-gnu.so\r\n"]
[143.066571, "o", "pandas/_libs/tslibs/tzconversion.cpython-38-x86_64-linux-gnu.so\r\n"]
[143.302, "o", "pandas/_libs/tslibs/timedeltas.cpython-38-x86_64-linux-gnu.so\r\n"]
[143.537429, "o", "pandas/_libs/tslibs/period.cpython-38-x86_64-linux-gnu.so\r\n"]
[143.772857, "o", "pandas/_libs/tslibs/conversion.cpython-38-x86_64-linux-gnu.so\r\n"]
[144.008286, "o", "pandas/_libs/tslibs/base.cpython-38-x86_64-linux-gnu.so\r\n"]
[144.243714, "o", "pandas/_libs/tslibs/offsets.cpython-38-x86_64-linux-gnu.so\r\n"]
[144.479143, "o", "pandas/_libs/tslibs/parsing.cpython-38-x86_64-linux-gnu.so\r\n"]
[144.714571, "o", "pandas/_libs/window/aggregations.cpython-38-x86_64-linux-gnu.so\r\n"]
[145.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[145.002, "i", "python - << 'PY'\r"]
[145.004, "o", "python - << 'PY'\r\n"]
[145.455455, "o", "\u001b[?2004l\r\n"]
[145.904909, "o", "\u001b[?2004h> import pandas as pd, sys\r\n"]
[146.354364, "o", "\u001b[?2004l\r\n"]
[146.803818, "o", "\u001b[?2004h> print('pandas_version:', pd.__version__)\r\n"]
[147.253273, "o", "\u001b[?2004l\r\n"]
[147.702727, "o", "\u001b[?2004h> print('pandas_file:', pd.__file__)\r\n"]
[148.152182, "o", "\u001b[?2004l\r\n"]
[148.601636, "o", "\u001b[?2004h> PY\r\n"]
[149.051091, "o", "\u001b[?2004l\r\n"]
[149.500545, "o", "pandas_version: 0+untagged.31506.g5f584bd\r\n"]
[150.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[150.002, "i", "cd asv_bench\r"]
[150.004, "o", "cd asv_bench\r\n"]
[150.006, "o", "\u001b[?2004l\r\n"]
[155.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[155.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.*\"\r"]
[155.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.*\"\r\n"]
[155.118364, "o", "\u001b[?2004l\r\n"]
[155.230727, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[155.343091, "o", "\u00b7 \u001b[0;32mRunning 5 total benchmarks (1 commits * 1 environments * 5 benchmarks)\u001b[0m\r\n"]
[155.455455, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[155.567818, "o", "[10.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection\u001b[0m                                                                                              ok\r\n"]
[155.680182, "o", "[10.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[155.792545, "o", "              param1            \r\n"]
[155.904909, "o", "             -------- ----------\r\n"]
[156.017273, "o", "               1000    889\u00b10\u03bcs  \r\n"]
[156.129636, "o", "              100000   8.35\u00b10ms \r\n"]
[156.242, "o", "             ======== ==========\r\n"]
[156.354364, "o", "\r\n"]
[156.466727, "o", "[20.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[156.579091, "o", "[20.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[156.691455, "o", "              param1            \r\n"]
[156.803818, "o", "             -------- ----------\r\n"]
[156.916182, "o", "               1000    1.18\u00b10ms \r\n"]
[157.028545, "o", "              100000   92.6\u00b10ms \r\n"]
[157.140909, "o", "             ======== ==========\r\n"]
[157.253273, "o", "\r\n"]
[157.365636, "o", "[30.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_one_duplicate\u001b[0m                                                                                ok\r\n"]
[157.478, "o", "[30.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[157.590364, "o", "              param1            \r\n"]
[157.702727, "o", "             -------- ----------\r\n"]
[157.815091, "o", "               1000    788\u00b10\u03bcs  \r\n"]
[157.927455, "o", "              100000   8.05\u00b10ms \r\n"]
[158.039818, "o", "             ======== ==========\r\n"]
[158.152182, "o", "\r\n"]
[158.264545, "o", "[40.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_is_unique\u001b[0m                                                                                                 ok\r\n"]
[158.376909, "o", "[40.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[158.489273, "o", "              param1            \r\n"]
[158.601636, "o", "             -------- ----------\r\n"]
[158.714, "o", "               1000    250\u00b10\u03bcs  \r\n"]
[158.826364, "o", "              100000   3.65\u00b10ms \r\n"]
[158.938727, "o", "             ======== ==========\r\n"]
[159.051091, "o", "\r\n"]
[159.163455, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_monotonic_inc\u001b[0m                                                                                             ok\r\n"]
[159.275818, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[159.388182, "o", "              param1            \r\n"]
[159.500545, "o", "             -------- ----------\r\n"]
[159.612909, "o", "               1000    77.7\u00b10\u03bcs \r\n"]
[159.725273, "o", "              100000   326\u00b10\u03bcs  \r\n"]
[159.837636, "o", "             ======== ==========\r\n"]
[160.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[160.002, "i", "asv run --python=same --quick --bench=\"groupby.SumMultiLevel.*\"\r"]
[160.004, "o", "asv run --python=same --quick --bench=\"groupby.SumMultiLevel.*\"\r\n"]
[160.9948, "o", "\u001b[?2004l\r\n"]
[161.9836, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[162.9724, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[163.9612, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[165.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[165.002, "i", "asv run --python=same --quick --bench=\"tslibs.timestamp.*\"\r"]
[165.004, "o", "asv run --python=same --quick --bench=\"tslibs.timestamp.*\"\r\n"]
[165.021646, "o", "\u001b[?2004l\r\n"]
[165.037291, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[165.052937, "o", "\u00b7 \u001b[0;32mRunning 37 total benchmarks (1 commits * 1 environments * 37 benchmarks)\u001b[0m\r\n"]
[165.068582, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[165.084228, "o", "[ 1.35%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampAcrossDst.time_replace_across_dst\u001b[0m                                                                               95.5\u00b10\u03bcs\r\n"]
[165.099873, "o", "[ 2.70%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_from_datetime_aware\u001b[0m                                                                           14.2\u00b10\u03bcs\r\n"]
[165.115519, "o", "[ 4.05%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_from_datetime_unaware\u001b[0m                                                                         17.6\u00b10\u03bcs\r\n"]
[165.131165, "o", "[ 5.41%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_from_npdatetime64\u001b[0m                                                                             17.7\u00b10\u03bcs\r\n"]
[165.14681, "o", "[ 6.76%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_from_pd_timestamp\u001b[0m                                                                             1.93\u00b10\u03bcs\r\n"]
[165.162456, "o", "[ 8.11%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_fromordinal\u001b[0m                                                                                   33.6\u00b10\u03bcs\r\n"]
[165.178101, "o", "[ 9.46%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_fromtimestamp\u001b[0m                                                                                 31.9\u00b10\u03bcs\r\n"]
[165.193747, "o", "[10.81%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_parse_dateutil\u001b[0m                                                                                1.34\u00b10ms\r\n"]
[165.209392, "o", "[12.16%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_parse_iso8601_no_tz\u001b[0m                                                                           10.9\u00b10\u03bcs\r\n"]
[165.225038, "o", "[13.51%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_parse_iso8601_tz\u001b[0m                                                                               189\u00b10\u03bcs\r\n"]
[165.240684, "o", "[14.86%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_parse_now\u001b[0m                                                                                     17.7\u00b10\u03bcs\r\n"]
[165.256329, "o", "[16.22%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampConstruction.time_parse_today\u001b[0m                                                                                   18.8\u00b10\u03bcs\r\n"]
[165.271975, "o", "[17.57%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_ceil\u001b[0m                                                                                                         ok\r\n"]
[165.28762, "o", "[17.57%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== =========\u001b[0m\r\n"]
[165.303266, "o", "                                       tz                                   \r\n"]
[165.318911, "o", "             ----------------------------------------------------- ---------\r\n"]
[165.334557, "o", "                                      None                          711\u00b10\u03bcs \r\n"]
[165.350203, "o", "                             datetime.timezone.utc                  717\u00b10\u03bcs \r\n"]
[165.365848, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   562\u00b10\u03bcs \r\n"]
[165.381494, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    707\u00b10\u03bcs \r\n"]
[165.397139, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        486\u00b10\u03bcs \r\n"]
[165.412785, "o", "                                   tzlocal()                        706\u00b10\u03bcs \r\n"]
[165.42843, "o", "             ===================================================== =========\r\n"]
[165.444076, "o", "\r\n"]
[165.459722, "o", "[18.92%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_floor\u001b[0m                                                                                                        ok\r\n"]
[165.475367, "o", "[18.92%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== =========\u001b[0m\r\n"]
[165.491013, "o", "                                       tz                                   \r\n"]
[165.506658, "o", "             ----------------------------------------------------- ---------\r\n"]
[165.522304, "o", "                                      None                          606\u00b10\u03bcs \r\n"]
[165.537949, "o", "                             datetime.timezone.utc                  582\u00b10\u03bcs \r\n"]
[165.553595, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   639\u00b10\u03bcs \r\n"]
[165.569241, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    498\u00b10\u03bcs \r\n"]
[165.584886, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        466\u00b10\u03bcs \r\n"]
[165.600532, "o", "                                   tzlocal()                        635\u00b10\u03bcs \r\n"]
[165.616177, "o", "             ===================================================== =========\r\n"]
[165.631823, "o", "\r\n"]
[165.647468, "o", "[20.27%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_normalize\u001b[0m                                                                                                    ok\r\n"]
[165.663114, "o", "[20.27%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[165.678759, "o", "                                       tz                                    \r\n"]
[165.694405, "o", "             ----------------------------------------------------- ----------\r\n"]
[165.710051, "o", "                                      None                          124\u00b10\u03bcs  \r\n"]
[165.725696, "o", "                             datetime.timezone.utc                  32.2\u00b10\u03bcs \r\n"]
[165.741342, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   60.9\u00b10\u03bcs \r\n"]
[165.756987, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    67.3\u00b10\u03bcs \r\n"]
[165.772633, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        60.4\u00b10\u03bcs \r\n"]
[165.788278, "o", "                                   tzlocal()                        54.0\u00b10\u03bcs \r\n"]
[165.803924, "o", "             ===================================================== ==========\r\n"]
[165.81957, "o", "\r\n"]
[165.835215, "o", "[21.62%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_replace_None\u001b[0m                                                                                                 ok\r\n"]
[165.850861, "o", "[21.62%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[165.866506, "o", "                                       tz                                    \r\n"]
[165.882152, "o", "             ----------------------------------------------------- ----------\r\n"]
[165.897797, "o", "                                      None                          32.0\u00b10\u03bcs \r\n"]
[165.913443, "o", "                             datetime.timezone.utc                  37.4\u00b10\u03bcs \r\n"]
[165.929089, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   54.7\u00b10\u03bcs \r\n"]
[165.944734, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    53.2\u00b10\u03bcs \r\n"]
[165.96038, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        42.4\u00b10\u03bcs \r\n"]
[165.976025, "o", "                                   tzlocal()                        53.1\u00b10\u03bcs \r\n"]
[165.991671, "o", "             ===================================================== ==========\r\n"]
[166.007316, "o", "\r\n"]
[166.022962, "o", "[22.97%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_replace_tz\u001b[0m                                                                                                   ok\r\n"]
[166.038608, "o", "[22.97%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== =========\u001b[0m\r\n"]
[166.054253, "o", "                                       tz                                   \r\n"]
[166.069899, "o", "             ----------------------------------------------------- ---------\r\n"]
[166.085544, "o", "                                      None                          755\u00b10\u03bcs \r\n"]
[166.10119, "o", "                             datetime.timezone.utc                  756\u00b10\u03bcs \r\n"]
[166.116835, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   812\u00b10\u03bcs \r\n"]
[166.132481, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    756\u00b10\u03bcs \r\n"]
[166.148127, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        779\u00b10\u03bcs \r\n"]
[166.163772, "o", "                                   tzlocal()                        751\u00b10\u03bcs \r\n"]
[166.179418, "o", "             ===================================================== =========\r\n"]
[166.195063, "o", "\r\n"]
[166.210709, "o", "[24.32%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_to_julian_date\u001b[0m                                                                                               ok\r\n"]
[166.226354, "o", "[24.32%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== =========\u001b[0m\r\n"]
[166.242, "o", "                                       tz                                   \r\n"]
[166.257646, "o", "             ----------------------------------------------------- ---------\r\n"]
[166.273291, "o", "                                      None                          215\u00b10\u03bcs \r\n"]
[166.288937, "o", "                             datetime.timezone.utc                  233\u00b10\u03bcs \r\n"]
[166.304582, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   130\u00b10\u03bcs \r\n"]
[166.320228, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    127\u00b10\u03bcs \r\n"]
[166.335873, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        116\u00b10\u03bcs \r\n"]
[166.351519, "o", "                                   tzlocal()                        247\u00b10\u03bcs \r\n"]
[166.367165, "o", "             ===================================================== =========\r\n"]
[166.38281, "o", "\r\n"]
[166.398456, "o", "[25.68%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_to_pydatetime\u001b[0m                                                                                                ok\r\n"]
[166.414101, "o", "[25.68%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[166.429747, "o", "                                       tz                                    \r\n"]
[166.445392, "o", "             ----------------------------------------------------- ----------\r\n"]
[166.461038, "o", "                                      None                          16.8\u00b10\u03bcs \r\n"]
[166.476684, "o", "                             datetime.timezone.utc                  20.4\u00b10\u03bcs \r\n"]
[166.492329, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   15.7\u00b10\u03bcs \r\n"]
[166.507975, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    14.1\u00b10\u03bcs \r\n"]
[166.52362, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        19.3\u00b10\u03bcs \r\n"]
[166.539266, "o", "                                   tzlocal()                        15.1\u00b10\u03bcs \r\n"]
[166.554911, "o", "             ===================================================== ==========\r\n"]
[166.570557, "o", "\r\n"]
[166.586203, "o", "[27.03%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_tz_convert\u001b[0m                                                                                                   ok\r\n"]
[166.601848, "o", "[27.03%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[166.617494, "o", "                                       tz                                    \r\n"]
[166.633139, "o", "             ----------------------------------------------------- ----------\r\n"]
[166.648785, "o", "                                      None                          8.97\u00b10\u03bcs \r\n"]
[166.66443, "o", "                             datetime.timezone.utc                  24.3\u00b10\u03bcs \r\n"]
[166.680076, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   44.0\u00b10\u03bcs \r\n"]
[166.695722, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    42.9\u00b10\u03bcs \r\n"]
[166.711367, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        37.6\u00b10\u03bcs \r\n"]
[166.727013, "o", "                                   tzlocal()                        45.2\u00b10\u03bcs \r\n"]
[166.742658, "o", "             ===================================================== ==========\r\n"]
[166.758304, "o", "\r\n"]
[166.773949, "o", "[28.38%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampOps.time_tz_localize\u001b[0m                                                                                                  ok\r\n"]
[166.789595, "o", "[28.38%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[166.805241, "o", "                                       tz                                    \r\n"]
[166.820886, "o", "             ----------------------------------------------------- ----------\r\n"]
[166.836532, "o", "                                      None                          37.0\u00b10\u03bcs \r\n"]
[166.852177, "o", "                             datetime.timezone.utc                  10.8\u00b10\u03bcs \r\n"]
[166.867823, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   7.03\u00b10\u03bcs \r\n"]
[166.883468, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    6.21\u00b10\u03bcs \r\n"]
[166.899114, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        7.24\u00b10\u03bcs \r\n"]
[166.914759, "o", "                                   tzlocal()                        8.07\u00b10\u03bcs \r\n"]
[166.930405, "o", "             ===================================================== ==========\r\n"]
[166.946051, "o", "\r\n"]
[166.961696, "o", "[29.73%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_dayofweek\u001b[0m                                                                                             ok\r\n"]
[166.977342, "o", "[29.73%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[166.992987, "o", "                                       tz                                    \r\n"]
[167.008633, "o", "             ----------------------------------------------------- ----------\r\n"]
[167.024278, "o", "                                      None                          12.0\u00b10\u03bcs \r\n"]
[167.039924, "o", "                             datetime.timezone.utc                  13.8\u00b10\u03bcs \r\n"]
[167.05557, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   9.89\u00b10\u03bcs \r\n"]
[167.071215, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    11.1\u00b10\u03bcs \r\n"]
[167.086861, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        15.5\u00b10\u03bcs \r\n"]
[167.102506, "o", "                                   tzlocal()                        12.4\u00b10\u03bcs \r\n"]
[167.118152, "o", "             ===================================================== ==========\r\n"]
[167.133797, "o", "\r\n"]
[167.149443, "o", "[31.08%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_dayofyear\u001b[0m                                                                                             ok\r\n"]
[167.165089, "o", "[31.08%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[167.180734, "o", "                                       tz                                    \r\n"]
[167.19638, "o", "             ----------------------------------------------------- ----------\r\n"]
[167.212025, "o", "                                      None                          10.7\u00b10\u03bcs \r\n"]
[167.227671, "o", "                             datetime.timezone.utc                  9.65\u00b10\u03bcs \r\n"]
[167.243316, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   8.55\u00b10\u03bcs \r\n"]
[167.258962, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    8.32\u00b10\u03bcs \r\n"]
[167.274608, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        9.38\u00b10\u03bcs \r\n"]
[167.290253, "o", "                                   tzlocal()                        6.49\u00b10\u03bcs \r\n"]
[167.305899, "o", "             ===================================================== ==========\r\n"]
[167.321544, "o", "\r\n"]
[167.33719, "o", "[32.43%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_days_in_month\u001b[0m                                                                                         ok\r\n"]
[167.352835, "o", "[32.43%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[167.368481, "o", "                                       tz                                    \r\n"]
[167.384127, "o", "             ----------------------------------------------------- ----------\r\n"]
[167.399772, "o", "                                      None                          10.6\u00b10\u03bcs \r\n"]
[167.415418, "o", "                             datetime.timezone.utc                  11.2\u00b10\u03bcs \r\n"]
[167.431063, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   9.44\u00b10\u03bcs \r\n"]
[167.446709, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    9.49\u00b10\u03bcs \r\n"]
[167.462354, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        9.97\u00b10\u03bcs \r\n"]
[167.478, "o", "                                   tzlocal()                        10.5\u00b10\u03bcs \r\n"]
[167.493646, "o", "             ===================================================== ==========\r\n"]
[167.509291, "o", "\r\n"]
[167.524937, "o", "[33.78%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_is_leap_year\u001b[0m                                                                                          ok\r\n"]
[167.540582, "o", "[33.78%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[167.556228, "o", "                                       tz                                    \r\n"]
[167.571873, "o", "             ----------------------------------------------------- ----------\r\n"]
[167.587519, "o", "                                      None                          6.10\u00b10\u03bcs \r\n"]
[167.603165, "o", "                             datetime.timezone.utc                  6.01\u00b10\u03bcs \r\n"]
[167.61881, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   5.92\u00b10\u03bcs \r\n"]
[167.634456, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    4.58\u00b10\u03bcs \r\n"]
[167.650101, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        5.25\u00b10\u03bcs \r\n"]
[167.665747, "o", "                                   tzlocal()                        5.45\u00b10\u03bcs \r\n"]
[167.681392, "o", "             ===================================================== ==========\r\n"]
[167.697038, "o", "\r\n"]
[167.712684, "o", "[35.14%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_is_month_end\u001b[0m                                                                                          ok\r\n"]
[167.728329, "o", "[35.14%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[167.743975, "o", "                                       tz                                    \r\n"]
[167.75962, "o", "             ----------------------------------------------------- ----------\r\n"]
[167.775266, "o", "                                      None                          12.7\u00b10\u03bcs \r\n"]
[167.790911, "o", "                             datetime.timezone.utc                  10.9\u00b10\u03bcs \r\n"]
[167.806557, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   8.55\u00b10\u03bcs \r\n"]
[167.822203, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    10.3\u00b10\u03bcs \r\n"]
[167.837848, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        10.6\u00b10\u03bcs \r\n"]
[167.853494, "o", "                                   tzlocal()                        8.09\u00b10\u03bcs \r\n"]
[167.869139, "o", "             ===================================================== ==========\r\n"]
[167.884785, "o", "\r\n"]
[167.90043, "o", "[36.49%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_is_month_start\u001b[0m                                                                                        ok\r\n"]
[167.916076, "o", "[36.49%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[167.931722, "o", "                                       tz                                    \r\n"]
[167.947367, "o", "             ----------------------------------------------------- ----------\r\n"]
[167.963013, "o", "                                      None                          5.12\u00b10\u03bcs \r\n"]
[167.978658, "o", "                             datetime.timezone.utc                  5.32\u00b10\u03bcs \r\n"]
[167.994304, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   4.21\u00b10\u03bcs \r\n"]
[168.009949, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    3.36\u00b10\u03bcs \r\n"]
[168.025595, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        6.51\u00b10\u03bcs \r\n"]
[168.041241, "o", "                                   tzlocal()                        4.49\u00b10\u03bcs \r\n"]
[168.056886, "o", "             ===================================================== ==========\r\n"]
[168.072532, "o", "\r\n"]
[168.088177, "o", "[37.84%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_is_quarter_end\u001b[0m                                                                                        ok\r\n"]
[168.103823, "o", "[37.84%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[168.119468, "o", "                                       tz                                    \r\n"]
[168.135114, "o", "             ----------------------------------------------------- ----------\r\n"]
[168.150759, "o", "                                      None                          5.78\u00b10\u03bcs \r\n"]
[168.166405, "o", "                             datetime.timezone.utc                  6.38\u00b10\u03bcs \r\n"]
[168.182051, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   5.51\u00b10\u03bcs \r\n"]
[168.197696, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    6.39\u00b10\u03bcs \r\n"]
[168.213342, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        6.26\u00b10\u03bcs \r\n"]
[168.228987, "o", "                                   tzlocal()                        3.67\u00b10\u03bcs \r\n"]
[168.244633, "o", "             ===================================================== ==========\r\n"]
[168.260278, "o", "\r\n"]
[168.275924, "o", "[39.19%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_is_quarter_start\u001b[0m                                                                                      ok\r\n"]
[168.29157, "o", "[39.19%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[168.307215, "o", "                                       tz                                    \r\n"]
[168.322861, "o", "             ----------------------------------------------------- ----------\r\n"]
[168.338506, "o", "                                      None                          6.66\u00b10\u03bcs \r\n"]
[168.354152, "o", "                             datetime.timezone.utc                  7.51\u00b10\u03bcs \r\n"]
[168.369797, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   6.17\u00b10\u03bcs \r\n"]
[168.385443, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    5.38\u00b10\u03bcs \r\n"]
[168.401089, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        6.66\u00b10\u03bcs \r\n"]
[168.416734, "o", "                                   tzlocal()                        6.33\u00b10\u03bcs \r\n"]
[168.43238, "o", "             ===================================================== ==========\r\n"]
[168.448025, "o", "\r\n"]
[168.463671, "o", "[40.54%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_is_year_end\u001b[0m                                                                                           ok\r\n"]
[168.479316, "o", "[40.54%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[168.494962, "o", "                                       tz                                    \r\n"]
[168.510608, "o", "             ----------------------------------------------------- ----------\r\n"]
[168.526253, "o", "                                      None                          6.30\u00b10\u03bcs \r\n"]
[168.541899, "o", "                             datetime.timezone.utc                  5.18\u00b10\u03bcs \r\n"]
[168.557544, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   4.21\u00b10\u03bcs \r\n"]
[168.57319, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    4.61\u00b10\u03bcs \r\n"]
[168.588835, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        6.79\u00b10\u03bcs \r\n"]
[168.604481, "o", "                                   tzlocal()                        4.58\u00b10\u03bcs \r\n"]
[168.620127, "o", "             ===================================================== ==========\r\n"]
[168.635772, "o", "\r\n"]
[168.651418, "o", "[41.89%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_is_year_start\u001b[0m                                                                                         ok\r\n"]
[168.667063, "o", "[41.89%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[168.682709, "o", "                                       tz                                    \r\n"]
[168.698354, "o", "             ----------------------------------------------------- ----------\r\n"]
[168.714, "o", "                                      None                          6.42\u00b10\u03bcs \r\n"]
[168.729646, "o", "                             datetime.timezone.utc                  5.45\u00b10\u03bcs \r\n"]
[168.745291, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   5.46\u00b10\u03bcs \r\n"]
[168.760937, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    6.09\u00b10\u03bcs \r\n"]
[168.776582, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        5.29\u00b10\u03bcs \r\n"]
[168.792228, "o", "                                   tzlocal()                        3.99\u00b10\u03bcs \r\n"]
[168.807873, "o", "             ===================================================== ==========\r\n"]
[168.823519, "o", "\r\n"]
[168.839165, "o", "[43.24%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_microsecond\u001b[0m                                                                                           ok\r\n"]
[168.85481, "o", "[43.24%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[168.870456, "o", "                                       tz                                    \r\n"]
[168.886101, "o", "             ----------------------------------------------------- ----------\r\n"]
[168.901747, "o", "                                      None                          3.79\u00b10\u03bcs \r\n"]
[168.917392, "o", "                             datetime.timezone.utc                  4.32\u00b10\u03bcs \r\n"]
[168.933038, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   1.84\u00b10\u03bcs \r\n"]
[168.948684, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    1.76\u00b10\u03bcs \r\n"]
[168.964329, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        3.28\u00b10\u03bcs \r\n"]
[168.979975, "o", "                                   tzlocal()                        2.16\u00b10\u03bcs \r\n"]
[168.99562, "o", "             ===================================================== ==========\r\n"]
[169.011266, "o", "\r\n"]
[169.026911, "o", "[44.59%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_month_name\u001b[0m                                                                                            ok\r\n"]
[169.042557, "o", "[44.59%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[169.058203, "o", "                                       tz                                    \r\n"]
[169.073848, "o", "             ----------------------------------------------------- ----------\r\n"]
[169.089494, "o", "                                      None                          163\u00b10\u03bcs  \r\n"]
[169.105139, "o", "                             datetime.timezone.utc                  148\u00b10\u03bcs  \r\n"]
[169.120785, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   78.4\u00b10\u03bcs \r\n"]
[169.13643, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    70.2\u00b10\u03bcs \r\n"]
[169.152076, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        84.9\u00b10\u03bcs \r\n"]
[169.167722, "o", "                                   tzlocal()                        139\u00b10\u03bcs  \r\n"]
[169.183367, "o", "             ===================================================== ==========\r\n"]
[169.199013, "o", "\r\n"]
[169.214658, "o", "[45.95%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_quarter\u001b[0m                                                                                               ok\r\n"]
[169.230304, "o", "[45.95%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[169.245949, "o", "                                       tz                                    \r\n"]
[169.261595, "o", "             ----------------------------------------------------- ----------\r\n"]
[169.277241, "o", "                                      None                          8.44\u00b10\u03bcs \r\n"]
[169.292886, "o", "                             datetime.timezone.utc                  6.76\u00b10\u03bcs \r\n"]
[169.308532, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   5.79\u00b10\u03bcs \r\n"]
[169.324177, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    5.70\u00b10\u03bcs \r\n"]
[169.339823, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        7.33\u00b10\u03bcs \r\n"]
[169.355468, "o", "                                   tzlocal()                        5.36\u00b10\u03bcs \r\n"]
[169.371114, "o", "             ===================================================== ==========\r\n"]
[169.386759, "o", "\r\n"]
[169.402405, "o", "[47.30%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_tz\u001b[0m                                                                                                    ok\r\n"]
[169.418051, "o", "[47.30%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[169.433696, "o", "                                       tz                                    \r\n"]
[169.449342, "o", "             ----------------------------------------------------- ----------\r\n"]
[169.464987, "o", "                                      None                          10.0\u00b10\u03bcs \r\n"]
[169.480633, "o", "                             datetime.timezone.utc                  8.69\u00b10\u03bcs \r\n"]
[169.496278, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   9.03\u00b10\u03bcs \r\n"]
[169.511924, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    6.45\u00b10\u03bcs \r\n"]
[169.52757, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        8.21\u00b10\u03bcs \r\n"]
[169.543215, "o", "                                   tzlocal()                        6.61\u00b10\u03bcs \r\n"]
[169.558861, "o", "             ===================================================== ==========\r\n"]
[169.574506, "o", "\r\n"]
[169.590152, "o", "[48.65%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_week\u001b[0m                                                                                                  ok\r\n"]
[169.605797, "o", "[48.65%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[169.621443, "o", "                                       tz                                    \r\n"]
[169.637089, "o", "             ----------------------------------------------------- ----------\r\n"]
[169.652734, "o", "                                      None                          11.0\u00b10\u03bcs \r\n"]
[169.66838, "o", "                             datetime.timezone.utc                  8.99\u00b10\u03bcs \r\n"]
[169.684025, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   8.65\u00b10\u03bcs \r\n"]
[169.699671, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    8.90\u00b10\u03bcs \r\n"]
[169.715316, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        8.86\u00b10\u03bcs \r\n"]
[169.730962, "o", "                                   tzlocal()                        8.90\u00b10\u03bcs \r\n"]
[169.746608, "o", "             ===================================================== ==========\r\n"]
[169.762253, "o", "\r\n"]
[169.777899, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mtslibs.timestamp.TimestampProperties.time_weekday_name\u001b[0m                                                                                          ok\r\n"]
[169.793544, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m===================================================== ==========\u001b[0m\r\n"]
[169.80919, "o", "                                       tz                                    \r\n"]
[169.824835, "o", "             ----------------------------------------------------- ----------\r\n"]
[169.840481, "o", "                                      None                          148\u00b10\u03bcs  \r\n"]
[169.856127, "o", "                             datetime.timezone.utc                  146\u00b10\u03bcs  \r\n"]
[169.871772, "o", "              datetime.timezone(datetime.timedelta(seconds=3600))   87.3\u00b10\u03bcs \r\n"]
[169.887418, "o", "                <DstTzInfo 'US/Pacific' LMT-1 day, 16:07:00 STD>    110\u00b10\u03bcs  \r\n"]
[169.903063, "o", "                    tzfile('/usr/share/zoneinfo/Asia/Tokyo')        64.4\u00b10\u03bcs \r\n"]
[169.918709, "o", "                                   tzlocal()                        142\u00b10\u03bcs  \r\n"]
[169.934354, "o", "             ===================================================== ==========\r\n"]
[170.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[170.002, "i", "asv profile --python=same IntervalIndexMethod.time_intersection\r"]
[170.004, "o", "asv profile --python=same IntervalIndexMethod.time_intersection\r\n"]
[171.654, "o", "\u001b[?2004l\r\n"]
[173.302, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[175.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[175.002, "i", "cd ..\r"]
[175.004, "o", "cd ..\r\n"]
[175.006, "o", "\u001b[?2004l\r\n"]
[180.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[180.002, "i", "sed -n '1,260p' pandas/core/indexes/interval.py\r"]
[180.004, "o", "sed -n '1,260p' pandas/core/indexes/interval.py\r\n"]
[180.024943, "o", "\u001b[?2004l\r\n"]
[180.043885, "o", "\"\"\" define the IntervalIndex \"\"\"\r\n"]
[180.062828, "o", "from __future__ import annotations\r\n"]
[180.08177, "o", "\r\n"]
[180.100713, "o", "from operator import (\r\n"]
[180.119655, "o", "    le,\r\n"]
[180.138598, "o", "    lt,\r\n"]
[180.15754, "o", ")\r\n"]
[180.176483, "o", "import textwrap\r\n"]
[180.195425, "o", "from typing import (\r\n"]
[180.214368, "o", "    Any,\r\n"]
[180.23331, "o", "    Hashable,\r\n"]
[180.252253, "o", "    Literal,\r\n"]
[180.271195, "o", ")\r\n"]
[180.290138, "o", "\r\n"]
[180.30908, "o", "import numpy as np\r\n"]
[180.328023, "o", "\r\n"]
[180.346966, "o", "from pandas._libs import lib\r\n"]
[180.365908, "o", "from pandas._libs.interval import (\r\n"]
[180.384851, "o", "    Interval,\r\n"]
[180.403793, "o", "    IntervalMixin,\r\n"]
[180.422736, "o", "    IntervalTree,\r\n"]
[180.441678, "o", ")\r\n"]
[180.460621, "o", "from pandas._libs.tslibs import (\r\n"]
[180.479563, "o", "    BaseOffset,\r\n"]
[180.498506, "o", "    Timedelta,\r\n"]
[180.517448, "o", "    Timestamp,\r\n"]
[180.536391, "o", "    to_offset,\r\n"]
[180.555333, "o", ")\r\n"]
[180.574276, "o", "from pandas._typing import (\r\n"]
[180.593218, "o", "    Dtype,\r\n"]
[180.612161, "o", "    DtypeObj,\r\n"]
[180.631103, "o", "    IntervalClosedType,\r\n"]
[180.650046, "o", "    npt,\r\n"]
[180.668989, "o", ")\r\n"]
[180.687931, "o", "from pandas.errors import InvalidIndexError\r\n"]
[180.706874, "o", "from pandas.util._decorators import (\r\n"]
[180.725816, "o", "    Appender,\r\n"]
[180.744759, "o", "    cache_readonly,\r\n"]
[180.763701, "o", ")\r\n"]
[180.782644, "o", "from pandas.util._exceptions import rewrite_exception\r\n"]
[180.801586, "o", "\r\n"]
[180.820529, "o", "from pandas.core.dtypes.cast import (\r\n"]
[180.839471, "o", "    find_common_type,\r\n"]
[180.858414, "o", "    infer_dtype_from_scalar,\r\n"]
[180.877356, "o", "    maybe_box_datetimelike,\r\n"]
[180.896299, "o", "    maybe_downcast_numeric,\r\n"]
[180.915241, "o", "    maybe_upcast_numeric_to_64bit,\r\n"]
[180.934184, "o", ")\r\n"]
[180.953126, "o", "from pandas.core.dtypes.common import (\r\n"]
[180.972069, "o", "    ensure_platform_int,\r\n"]
[180.991011, "o", "    is_datetime64tz_dtype,\r\n"]
[181.009954, "o", "    is_datetime_or_timedelta_dtype,\r\n"]
[181.028897, "o", "    is_dtype_equal,\r\n"]
[181.047839, "o", "    is_float,\r\n"]
[181.066782, "o", "    is_float_dtype,\r\n"]
[181.085724, "o", "    is_integer,\r\n"]
[181.104667, "o", "    is_integer_dtype,\r\n"]
[181.123609, "o", "    is_interval_dtype,\r\n"]
[181.142552, "o", "    is_list_like,\r\n"]
[181.161494, "o", "    is_number,\r\n"]
[181.180437, "o", "    is_object_dtype,\r\n"]
[181.199379, "o", "    is_scalar,\r\n"]
[181.218322, "o", ")\r\n"]
[181.237264, "o", "from pandas.core.dtypes.dtypes import IntervalDtype\r\n"]
[181.256207, "o", "from pandas.core.dtypes.missing import is_valid_na_for_dtype\r\n"]
[181.275149, "o", "\r\n"]
[181.294092, "o", "from pandas.core.algorithms import unique\r\n"]
[181.313034, "o", "from pandas.core.arrays.interval import (\r\n"]
[181.331977, "o", "    IntervalArray,\r\n"]
[181.35092, "o", "    _interval_shared_docs,\r\n"]
[181.369862, "o", ")\r\n"]
[181.388805, "o", "import pandas.core.common as com\r\n"]
[181.407747, "o", "from pandas.core.indexers import is_valid_positional_slice\r\n"]
[181.42669, "o", "import pandas.core.indexes.base as ibase\r\n"]
[181.445632, "o", "from pandas.core.indexes.base import (\r\n"]
[181.464575, "o", "    Index,\r\n"]
[181.483517, "o", "    _index_shared_docs,\r\n"]
[181.50246, "o", "    ensure_index,\r\n"]
[181.521402, "o", "    maybe_extract_name,\r\n"]
[181.540345, "o", ")\r\n"]
[181.559287, "o", "from pandas.core.indexes.datetimes import (\r\n"]
[181.57823, "o", "    DatetimeIndex,\r\n"]
[181.597172, "o", "    date_range,\r\n"]
[181.616115, "o", ")\r\n"]
[181.635057, "o", "from pandas.core.indexes.extension import (\r\n"]
[181.654, "o", "    ExtensionIndex,\r\n"]
[181.672943, "o", "    inherit_names,\r\n"]
[181.691885, "o", ")\r\n"]
[181.710828, "o", "from pandas.core.indexes.multi import MultiIndex\r\n"]
[181.72977, "o", "from pandas.core.indexes.timedeltas import (\r\n"]
[181.748713, "o", "    TimedeltaIndex,\r\n"]
[181.767655, "o", "    timedelta_range,\r\n"]
[181.786598, "o", ")\r\n"]
[181.80554, "o", "\r\n"]
[181.824483, "o", "_index_doc_kwargs = dict(ibase._index_doc_kwargs)\r\n"]
[181.843425, "o", "\r\n"]
[181.862368, "o", "_index_doc_kwargs.update(\r\n"]
[181.88131, "o", "    {\r\n"]
[181.900253, "o", "        \"klass\": \"IntervalIndex\",\r\n"]
[181.919195, "o", "        \"qualname\": \"IntervalIndex\",\r\n"]
[181.938138, "o", "        \"target_klass\": \"IntervalIndex or list of Intervals\",\r\n"]
[181.95708, "o", "        \"name\": textwrap.dedent(\r\n"]
[181.976023, "o", "            \"\"\"\\\r\n"]
[181.994966, "o", "         name : object, optional\r\n"]
[182.013908, "o", "              Name to be stored in the index.\r\n"]
[182.032851, "o", "         \"\"\"\r\n"]
[182.051793, "o", "        ),\r\n"]
[182.070736, "o", "    }\r\n"]
[182.089678, "o", ")\r\n"]
[182.108621, "o", "\r\n"]
[182.127563, "o", "\r\n"]
[182.146506, "o", "def _get_next_label(label):\r\n"]
[182.165448, "o", "    dtype = getattr(label, \"dtype\", type(label))\r\n"]
[182.184391, "o", "    if isinstance(label, (Timestamp, Timedelta)):\r\n"]
[182.203333, "o", "        dtype = \"datetime64\"\r\n"]
[182.222276, "o", "    if is_datetime_or_timedelta_dtype(dtype) or is_datetime64tz_dtype(dtype):\r\n"]
[182.241218, "o", "        return label + np.timedelta64(1, \"ns\")\r\n"]
[182.260161, "o", "    elif is_integer_dtype(dtype):\r\n"]
[182.279103, "o", "        return label + 1\r\n"]
[182.298046, "o", "    elif is_float_dtype(dtype):\r\n"]
[182.316989, "o", "        return np.nextafter(label, np.infty)\r\n"]
[182.335931, "o", "    else:\r\n"]
[182.354874, "o", "        raise TypeError(f\"cannot determine next label for type {repr(type(label))}\")\r\n"]
[182.373816, "o", "\r\n"]
[182.392759, "o", "\r\n"]
[182.411701, "o", "def _get_prev_label(label):\r\n"]
[182.430644, "o", "    dtype = getattr(label, \"dtype\", type(label))\r\n"]
[182.449586, "o", "    if isinstance(label, (Timestamp, Timedelta)):\r\n"]
[182.468529, "o", "        dtype = \"datetime64\"\r\n"]
[182.487471, "o", "    if is_datetime_or_timedelta_dtype(dtype) or is_datetime64tz_dtype(dtype):\r\n"]
[182.506414, "o", "        return label - np.timedelta64(1, \"ns\")\r\n"]
[182.525356, "o", "    elif is_integer_dtype(dtype):\r\n"]
[182.544299, "o", "        return label - 1\r\n"]
[182.563241, "o", "    elif is_float_dtype(dtype):\r\n"]
[182.582184, "o", "        return np.nextafter(label, -np.infty)\r\n"]
[182.601126, "o", "    else:\r\n"]
[182.620069, "o", "        raise TypeError(f\"cannot determine next label for type {repr(type(label))}\")\r\n"]
[182.639011, "o", "\r\n"]
[182.657954, "o", "\r\n"]
[182.676897, "o", "def _new_IntervalIndex(cls, d):\r\n"]
[182.695839, "o", "    \"\"\"\r\n"]
[182.714782, "o", "    This is called upon unpickling, rather than the default which doesn't have\r\n"]
[182.733724, "o", "    arguments and breaks __new__.\r\n"]
[182.752667, "o", "    \"\"\"\r\n"]
[182.771609, "o", "    return cls.from_arrays(**d)\r\n"]
[182.790552, "o", "\r\n"]
[182.809494, "o", "\r\n"]
[182.828437, "o", "@Appender(\r\n"]
[182.847379, "o", "    _interval_shared_docs[\"class\"]\r\n"]
[182.866322, "o", "    % {\r\n"]
[182.885264, "o", "        \"klass\": \"IntervalIndex\",\r\n"]
[182.904207, "o", "        \"summary\": \"Immutable index of intervals that are closed on the same side.\",\r\n"]
[182.923149, "o", "        \"name\": _index_doc_kwargs[\"name\"],\r\n"]
[182.942092, "o", "        \"versionadded\": \"0.20.0\",\r\n"]
[182.961034, "o", "        \"extra_attributes\": \"is_overlapping\\nvalues\\n\",\r\n"]
[182.979977, "o", "        \"extra_methods\": \"\",\r\n"]
[182.99892, "o", "        \"examples\": textwrap.dedent(\r\n"]
[183.017862, "o", "            \"\"\"\\\r\n"]
[183.036805, "o", "    Examples\r\n"]
[183.055747, "o", "    --------\r\n"]
[183.07469, "o", "    A new ``IntervalIndex`` is typically constructed using\r\n"]
[183.093632, "o", "    :func:`interval_range`:\r\n"]
[183.112575, "o", "\r\n"]
[183.131517, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[183.15046, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[183.169402, "o", "                  dtype='interval[int64, right]')\r\n"]
[183.188345, "o", "\r\n"]
[183.207287, "o", "    It may also be constructed using one of the constructor\r\n"]
[183.22623, "o", "    methods: :meth:`IntervalIndex.from_arrays`,\r\n"]
[183.245172, "o", "    :meth:`IntervalIndex.from_breaks`, and :meth:`IntervalIndex.from_tuples`.\r\n"]
[183.264115, "o", "\r\n"]
[183.283057, "o", "    See further examples in the doc strings of ``interval_range`` and the\r\n"]
[183.302, "o", "    mentioned constructor methods.\r\n"]
[183.320943, "o", "    \"\"\"\r\n"]
[183.339885, "o", "        ),\r\n"]
[183.358828, "o", "    }\r\n"]
[183.37777, "o", ")\r\n"]
[183.396713, "o", "@inherit_names([\"set_closed\", \"to_tuples\"], IntervalArray, wrap=True)\r\n"]
[183.415655, "o", "@inherit_names(\r\n"]
[183.434598, "o", "    [\r\n"]
[183.45354, "o", "        \"__array__\",\r\n"]
[183.472483, "o", "        \"overlaps\",\r\n"]
[183.491425, "o", "        \"contains\",\r\n"]
[183.510368, "o", "        \"closed_left\",\r\n"]
[183.52931, "o", "        \"closed_right\",\r\n"]
[183.548253, "o", "        \"open_left\",\r\n"]
[183.567195, "o", "        \"open_right\",\r\n"]
[183.586138, "o", "        \"is_empty\",\r\n"]
[183.60508, "o", "    ],\r\n"]
[183.624023, "o", "    IntervalArray,\r\n"]
[183.642966, "o", ")\r\n"]
[183.661908, "o", "@inherit_names([\"is_non_overlapping_monotonic\", \"closed\"], IntervalArray, cache=True)\r\n"]
[183.680851, "o", "class IntervalIndex(ExtensionIndex):\r\n"]
[183.699793, "o", "    _typ = \"intervalindex\"\r\n"]
[183.718736, "o", "\r\n"]
[183.737678, "o", "    # annotate properties pinned via inherit_names\r\n"]
[183.756621, "o", "    closed: IntervalClosedType\r\n"]
[183.775563, "o", "    is_non_overlapping_monotonic: bool\r\n"]
[183.794506, "o", "    closed_left: bool\r\n"]
[183.813448, "o", "    closed_right: bool\r\n"]
[183.832391, "o", "    open_left: bool\r\n"]
[183.851333, "o", "    open_right: bool\r\n"]
[183.870276, "o", "\r\n"]
[183.889218, "o", "    _data: IntervalArray\r\n"]
[183.908161, "o", "    _values: IntervalArray\r\n"]
[183.927103, "o", "    _can_hold_strings = False\r\n"]
[183.946046, "o", "    _data_cls = IntervalArray\r\n"]
[183.964989, "o", "\r\n"]
[183.983931, "o", "    # --------------------------------------------------------------------\r\n"]
[184.002874, "o", "    # Constructors\r\n"]
[184.021816, "o", "\r\n"]
[184.040759, "o", "    def __new__(\r\n"]
[184.059701, "o", "        cls,\r\n"]
[184.078644, "o", "        data,\r\n"]
[184.097586, "o", "        closed=None,\r\n"]
[184.116529, "o", "        dtype: Dtype | None = None,\r\n"]
[184.135471, "o", "        copy: bool = False,\r\n"]
[184.154414, "o", "        name: Hashable = None,\r\n"]
[184.173356, "o", "        verify_integrity: bool = True,\r\n"]
[184.192299, "o", "    ) -> IntervalIndex:\r\n"]
[184.211241, "o", "\r\n"]
[184.230184, "o", "        name = maybe_extract_name(name, data, cls)\r\n"]
[184.249126, "o", "\r\n"]
[184.268069, "o", "        with rewrite_exception(\"IntervalArray\", cls.__name__):\r\n"]
[184.287011, "o", "            array = IntervalArray(\r\n"]
[184.305954, "o", "                data,\r\n"]
[184.324897, "o", "                closed=closed,\r\n"]
[184.343839, "o", "                copy=copy,\r\n"]
[184.362782, "o", "                dtype=dtype,\r\n"]
[184.381724, "o", "                verify_integrity=verify_integrity,\r\n"]
[184.400667, "o", "            )\r\n"]
[184.419609, "o", "\r\n"]
[184.438552, "o", "        return cls._simple_new(array, name)\r\n"]
[184.457494, "o", "\r\n"]
[184.476437, "o", "    @classmethod\r\n"]
[184.495379, "o", "    @Appender(\r\n"]
[184.514322, "o", "        _interval_shared_docs[\"from_breaks\"]\r\n"]
[184.533264, "o", "        % {\r\n"]
[184.552207, "o", "            \"klass\": \"IntervalIndex\",\r\n"]
[184.571149, "o", "            \"name\": textwrap.dedent(\r\n"]
[184.590092, "o", "                \"\"\"\r\n"]
[184.609034, "o", "             name : str, optional\r\n"]
[184.627977, "o", "                  Name of the resulting IntervalIndex.\"\"\"\r\n"]
[184.64692, "o", "            ),\r\n"]
[184.665862, "o", "            \"examples\": textwrap.dedent(\r\n"]
[184.684805, "o", "                \"\"\"\\\r\n"]
[184.703747, "o", "        Examples\r\n"]
[184.72269, "o", "        --------\r\n"]
[184.741632, "o", "        >>> pd.IntervalIndex.from_breaks([0, 1, 2, 3])\r\n"]
[184.760575, "o", "        IntervalIndex([(0, 1], (1, 2], (2, 3]],\r\n"]
[184.779517, "o", "                      dtype='interval[int64, right]')\r\n"]
[184.79846, "o", "        \"\"\"\r\n"]
[184.817402, "o", "            ),\r\n"]
[184.836345, "o", "        }\r\n"]
[184.855287, "o", "    )\r\n"]
[184.87423, "o", "    def from_breaks(\r\n"]
[184.893172, "o", "        cls,\r\n"]
[184.912115, "o", "        breaks,\r\n"]
[184.931057, "o", "        closed: IntervalClosedType | None = \"right\",\r\n"]
[185.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[185.002, "i", "grep -n \"def intersection\" -n pandas/core/indexes/interval.py\r"]
[185.004, "o", "grep -n \"def intersection\" -n pandas/core/indexes/interval.py\r\n"]
[185.006, "o", "\u001b[?2004l\r\n"]
[190.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[190.002, "i", "sed -n '1,500p' pandas/core/indexes/interval.py | sed -n '1,500p'\r"]
[190.004, "o", "sed -n '1,500p' pandas/core/indexes/interval.py | sed -n '1,500p'\r\n"]
[190.016, "o", "\u001b[?2004l\r\n"]
[190.026, "o", "\"\"\" define the IntervalIndex \"\"\"\r\n"]
[190.036, "o", "from __future__ import annotations\r\n"]
[190.046, "o", "\r\n"]
[190.056, "o", "from operator import (\r\n"]
[190.066, "o", "    le,\r\n"]
[190.076, "o", "    lt,\r\n"]
[190.086, "o", ")\r\n"]
[190.096, "o", "import textwrap\r\n"]
[190.106, "o", "from typing import (\r\n"]
[190.116, "o", "    Any,\r\n"]
[190.126, "o", "    Hashable,\r\n"]
[190.136, "o", "    Literal,\r\n"]
[190.146, "o", ")\r\n"]
[190.156, "o", "\r\n"]
[190.166, "o", "import numpy as np\r\n"]
[190.176, "o", "\r\n"]
[190.186, "o", "from pandas._libs import lib\r\n"]
[190.196, "o", "from pandas._libs.interval import (\r\n"]
[190.206, "o", "    Interval,\r\n"]
[190.216, "o", "    IntervalMixin,\r\n"]
[190.226, "o", "    IntervalTree,\r\n"]
[190.236, "o", ")\r\n"]
[190.246, "o", "from pandas._libs.tslibs import (\r\n"]
[190.256, "o", "    BaseOffset,\r\n"]
[190.266, "o", "    Timedelta,\r\n"]
[190.276, "o", "    Timestamp,\r\n"]
[190.286, "o", "    to_offset,\r\n"]
[190.296, "o", ")\r\n"]
[190.306, "o", "from pandas._typing import (\r\n"]
[190.316, "o", "    Dtype,\r\n"]
[190.326, "o", "    DtypeObj,\r\n"]
[190.336, "o", "    IntervalClosedType,\r\n"]
[190.346, "o", "    npt,\r\n"]
[190.356, "o", ")\r\n"]
[190.366, "o", "from pandas.errors import InvalidIndexError\r\n"]
[190.376, "o", "from pandas.util._decorators import (\r\n"]
[190.386, "o", "    Appender,\r\n"]
[190.396, "o", "    cache_readonly,\r\n"]
[190.406, "o", ")\r\n"]
[190.416, "o", "from pandas.util._exceptions import rewrite_exception\r\n"]
[190.426, "o", "\r\n"]
[190.436, "o", "from pandas.core.dtypes.cast import (\r\n"]
[190.446, "o", "    find_common_type,\r\n"]
[190.456, "o", "    infer_dtype_from_scalar,\r\n"]
[190.466, "o", "    maybe_box_datetimelike,\r\n"]
[190.476, "o", "    maybe_downcast_numeric,\r\n"]
[190.486, "o", "    maybe_upcast_numeric_to_64bit,\r\n"]
[190.496, "o", ")\r\n"]
[190.506, "o", "from pandas.core.dtypes.common import (\r\n"]
[190.516, "o", "    ensure_platform_int,\r\n"]
[190.526, "o", "    is_datetime64tz_dtype,\r\n"]
[190.536, "o", "    is_datetime_or_timedelta_dtype,\r\n"]
[190.546, "o", "    is_dtype_equal,\r\n"]
[190.556, "o", "    is_float,\r\n"]
[190.566, "o", "    is_float_dtype,\r\n"]
[190.576, "o", "    is_integer,\r\n"]
[190.586, "o", "    is_integer_dtype,\r\n"]
[190.596, "o", "    is_interval_dtype,\r\n"]
[190.606, "o", "    is_list_like,\r\n"]
[190.616, "o", "    is_number,\r\n"]
[190.626, "o", "    is_object_dtype,\r\n"]
[190.636, "o", "    is_scalar,\r\n"]
[190.646, "o", ")\r\n"]
[190.656, "o", "from pandas.core.dtypes.dtypes import IntervalDtype\r\n"]
[190.666, "o", "from pandas.core.dtypes.missing import is_valid_na_for_dtype\r\n"]
[190.676, "o", "\r\n"]
[190.686, "o", "from pandas.core.algorithms import unique\r\n"]
[190.696, "o", "from pandas.core.arrays.interval import (\r\n"]
[190.706, "o", "    IntervalArray,\r\n"]
[190.716, "o", "    _interval_shared_docs,\r\n"]
[190.726, "o", ")\r\n"]
[190.736, "o", "import pandas.core.common as com\r\n"]
[190.746, "o", "from pandas.core.indexers import is_valid_positional_slice\r\n"]
[190.756, "o", "import pandas.core.indexes.base as ibase\r\n"]
[190.766, "o", "from pandas.core.indexes.base import (\r\n"]
[190.776, "o", "    Index,\r\n"]
[190.786, "o", "    _index_shared_docs,\r\n"]
[190.796, "o", "    ensure_index,\r\n"]
[190.806, "o", "    maybe_extract_name,\r\n"]
[190.816, "o", ")\r\n"]
[190.826, "o", "from pandas.core.indexes.datetimes import (\r\n"]
[190.836, "o", "    DatetimeIndex,\r\n"]
[190.846, "o", "    date_range,\r\n"]
[190.856, "o", ")\r\n"]
[190.866, "o", "from pandas.core.indexes.extension import (\r\n"]
[190.876, "o", "    ExtensionIndex,\r\n"]
[190.886, "o", "    inherit_names,\r\n"]
[190.896, "o", ")\r\n"]
[190.906, "o", "from pandas.core.indexes.multi import MultiIndex\r\n"]
[190.916, "o", "from pandas.core.indexes.timedeltas import (\r\n"]
[190.926, "o", "    TimedeltaIndex,\r\n"]
[190.936, "o", "    timedelta_range,\r\n"]
[190.946, "o", ")\r\n"]
[190.956, "o", "\r\n"]
[190.966, "o", "_index_doc_kwargs = dict(ibase._index_doc_kwargs)\r\n"]
[190.976, "o", "\r\n"]
[190.986, "o", "_index_doc_kwargs.update(\r\n"]
[190.996, "o", "    {\r\n"]
[191.006, "o", "        \"klass\": \"IntervalIndex\",\r\n"]
[191.016, "o", "        \"qualname\": \"IntervalIndex\",\r\n"]
[191.026, "o", "        \"target_klass\": \"IntervalIndex or list of Intervals\",\r\n"]
[191.036, "o", "        \"name\": textwrap.dedent(\r\n"]
[191.046, "o", "            \"\"\"\\\r\n"]
[191.056, "o", "         name : object, optional\r\n"]
[191.066, "o", "              Name to be stored in the index.\r\n"]
[191.076, "o", "         \"\"\"\r\n"]
[191.086, "o", "        ),\r\n"]
[191.096, "o", "    }\r\n"]
[191.106, "o", ")\r\n"]
[191.116, "o", "\r\n"]
[191.126, "o", "\r\n"]
[191.136, "o", "def _get_next_label(label):\r\n"]
[191.146, "o", "    dtype = getattr(label, \"dtype\", type(label))\r\n"]
[191.156, "o", "    if isinstance(label, (Timestamp, Timedelta)):\r\n"]
[191.166, "o", "        dtype = \"datetime64\"\r\n"]
[191.176, "o", "    if is_datetime_or_timedelta_dtype(dtype) or is_datetime64tz_dtype(dtype):\r\n"]
[191.186, "o", "        return label + np.timedelta64(1, \"ns\")\r\n"]
[191.196, "o", "    elif is_integer_dtype(dtype):\r\n"]
[191.206, "o", "        return label + 1\r\n"]
[191.216, "o", "    elif is_float_dtype(dtype):\r\n"]
[191.226, "o", "        return np.nextafter(label, np.infty)\r\n"]
[191.236, "o", "    else:\r\n"]
[191.246, "o", "        raise TypeError(f\"cannot determine next label for type {repr(type(label))}\")\r\n"]
[191.256, "o", "\r\n"]
[191.266, "o", "\r\n"]
[191.276, "o", "def _get_prev_label(label):\r\n"]
[191.286, "o", "    dtype = getattr(label, \"dtype\", type(label))\r\n"]
[191.296, "o", "    if isinstance(label, (Timestamp, Timedelta)):\r\n"]
[191.306, "o", "        dtype = \"datetime64\"\r\n"]
[191.316, "o", "    if is_datetime_or_timedelta_dtype(dtype) or is_datetime64tz_dtype(dtype):\r\n"]
[191.326, "o", "        return label - np.timedelta64(1, \"ns\")\r\n"]
[191.336, "o", "    elif is_integer_dtype(dtype):\r\n"]
[191.346, "o", "        return label - 1\r\n"]
[191.356, "o", "    elif is_float_dtype(dtype):\r\n"]
[191.366, "o", "        return np.nextafter(label, -np.infty)\r\n"]
[191.376, "o", "    else:\r\n"]
[191.386, "o", "        raise TypeError(f\"cannot determine next label for type {repr(type(label))}\")\r\n"]
[191.396, "o", "\r\n"]
[191.406, "o", "\r\n"]
[191.416, "o", "def _new_IntervalIndex(cls, d):\r\n"]
[191.426, "o", "    \"\"\"\r\n"]
[191.436, "o", "    This is called upon unpickling, rather than the default which doesn't have\r\n"]
[191.446, "o", "    arguments and breaks __new__.\r\n"]
[191.456, "o", "    \"\"\"\r\n"]
[191.466, "o", "    return cls.from_arrays(**d)\r\n"]
[191.476, "o", "\r\n"]
[191.486, "o", "\r\n"]
[191.496, "o", "@Appender(\r\n"]
[191.506, "o", "    _interval_shared_docs[\"class\"]\r\n"]
[191.516, "o", "    % {\r\n"]
[191.526, "o", "        \"klass\": \"IntervalIndex\",\r\n"]
[191.536, "o", "        \"summary\": \"Immutable index of intervals that are closed on the same side.\",\r\n"]
[191.546, "o", "        \"name\": _index_doc_kwargs[\"name\"],\r\n"]
[191.556, "o", "        \"versionadded\": \"0.20.0\",\r\n"]
[191.566, "o", "        \"extra_attributes\": \"is_overlapping\\nvalues\\n\",\r\n"]
[191.576, "o", "        \"extra_methods\": \"\",\r\n"]
[191.586, "o", "        \"examples\": textwrap.dedent(\r\n"]
[191.596, "o", "            \"\"\"\\\r\n"]
[191.606, "o", "    Examples\r\n"]
[191.616, "o", "    --------\r\n"]
[191.626, "o", "    A new ``IntervalIndex`` is typically constructed using\r\n"]
[191.636, "o", "    :func:`interval_range`:\r\n"]
[191.646, "o", "\r\n"]
[191.656, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[191.666, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[191.676, "o", "                  dtype='interval[int64, right]')\r\n"]
[191.686, "o", "\r\n"]
[191.696, "o", "    It may also be constructed using one of the constructor\r\n"]
[191.706, "o", "    methods: :meth:`IntervalIndex.from_arrays`,\r\n"]
[191.716, "o", "    :meth:`IntervalIndex.from_breaks`, and :meth:`IntervalIndex.from_tuples`.\r\n"]
[191.726, "o", "\r\n"]
[191.736, "o", "    See further examples in the doc strings of ``interval_range`` and the\r\n"]
[191.746, "o", "    mentioned constructor methods.\r\n"]
[191.756, "o", "    \"\"\"\r\n"]
[191.766, "o", "        ),\r\n"]
[191.776, "o", "    }\r\n"]
[191.786, "o", ")\r\n"]
[191.796, "o", "@inherit_names([\"set_closed\", \"to_tuples\"], IntervalArray, wrap=True)\r\n"]
[191.806, "o", "@inherit_names(\r\n"]
[191.816, "o", "    [\r\n"]
[191.826, "o", "        \"__array__\",\r\n"]
[191.836, "o", "        \"overlaps\",\r\n"]
[191.846, "o", "        \"contains\",\r\n"]
[191.856, "o", "        \"closed_left\",\r\n"]
[191.866, "o", "        \"closed_right\",\r\n"]
[191.876, "o", "        \"open_left\",\r\n"]
[191.886, "o", "        \"open_right\",\r\n"]
[191.896, "o", "        \"is_empty\",\r\n"]
[191.906, "o", "    ],\r\n"]
[191.916, "o", "    IntervalArray,\r\n"]
[191.926, "o", ")\r\n"]
[191.936, "o", "@inherit_names([\"is_non_overlapping_monotonic\", \"closed\"], IntervalArray, cache=True)\r\n"]
[191.946, "o", "class IntervalIndex(ExtensionIndex):\r\n"]
[191.956, "o", "    _typ = \"intervalindex\"\r\n"]
[191.966, "o", "\r\n"]
[191.976, "o", "    # annotate properties pinned via inherit_names\r\n"]
[191.986, "o", "    closed: IntervalClosedType\r\n"]
[191.996, "o", "    is_non_overlapping_monotonic: bool\r\n"]
[192.006, "o", "    closed_left: bool\r\n"]
[192.016, "o", "    closed_right: bool\r\n"]
[192.026, "o", "    open_left: bool\r\n"]
[192.036, "o", "    open_right: bool\r\n"]
[192.046, "o", "\r\n"]
[192.056, "o", "    _data: IntervalArray\r\n"]
[192.066, "o", "    _values: IntervalArray\r\n"]
[192.076, "o", "    _can_hold_strings = False\r\n"]
[192.086, "o", "    _data_cls = IntervalArray\r\n"]
[192.096, "o", "\r\n"]
[192.106, "o", "    # --------------------------------------------------------------------\r\n"]
[192.116, "o", "    # Constructors\r\n"]
[192.126, "o", "\r\n"]
[192.136, "o", "    def __new__(\r\n"]
[192.146, "o", "        cls,\r\n"]
[192.156, "o", "        data,\r\n"]
[192.166, "o", "        closed=None,\r\n"]
[192.176, "o", "        dtype: Dtype | None = None,\r\n"]
[192.186, "o", "        copy: bool = False,\r\n"]
[192.196, "o", "        name: Hashable = None,\r\n"]
[192.206, "o", "        verify_integrity: bool = True,\r\n"]
[192.216, "o", "    ) -> IntervalIndex:\r\n"]
[192.226, "o", "\r\n"]
[192.236, "o", "        name = maybe_extract_name(name, data, cls)\r\n"]
[192.246, "o", "\r\n"]
[192.256, "o", "        with rewrite_exception(\"IntervalArray\", cls.__name__):\r\n"]
[192.266, "o", "            array = IntervalArray(\r\n"]
[192.276, "o", "                data,\r\n"]
[192.286, "o", "                closed=closed,\r\n"]
[192.296, "o", "                copy=copy,\r\n"]
[192.306, "o", "                dtype=dtype,\r\n"]
[192.316, "o", "                verify_integrity=verify_integrity,\r\n"]
[192.326, "o", "            )\r\n"]
[192.336, "o", "\r\n"]
[192.346, "o", "        return cls._simple_new(array, name)\r\n"]
[192.356, "o", "\r\n"]
[192.366, "o", "    @classmethod\r\n"]
[192.376, "o", "    @Appender(\r\n"]
[192.386, "o", "        _interval_shared_docs[\"from_breaks\"]\r\n"]
[192.396, "o", "        % {\r\n"]
[192.406, "o", "            \"klass\": \"IntervalIndex\",\r\n"]
[192.416, "o", "            \"name\": textwrap.dedent(\r\n"]
[192.426, "o", "                \"\"\"\r\n"]
[192.436, "o", "             name : str, optional\r\n"]
[192.446, "o", "                  Name of the resulting IntervalIndex.\"\"\"\r\n"]
[192.456, "o", "            ),\r\n"]
[192.466, "o", "            \"examples\": textwrap.dedent(\r\n"]
[192.476, "o", "                \"\"\"\\\r\n"]
[192.486, "o", "        Examples\r\n"]
[192.496, "o", "        --------\r\n"]
[192.506, "o", "        >>> pd.IntervalIndex.from_breaks([0, 1, 2, 3])\r\n"]
[192.516, "o", "        IntervalIndex([(0, 1], (1, 2], (2, 3]],\r\n"]
[192.526, "o", "                      dtype='interval[int64, right]')\r\n"]
[192.536, "o", "        \"\"\"\r\n"]
[192.546, "o", "            ),\r\n"]
[192.556, "o", "        }\r\n"]
[192.566, "o", "    )\r\n"]
[192.576, "o", "    def from_breaks(\r\n"]
[192.586, "o", "        cls,\r\n"]
[192.596, "o", "        breaks,\r\n"]
[192.606, "o", "        closed: IntervalClosedType | None = \"right\",\r\n"]
[192.616, "o", "        name: Hashable = None,\r\n"]
[192.626, "o", "        copy: bool = False,\r\n"]
[192.636, "o", "        dtype: Dtype | None = None,\r\n"]
[192.646, "o", "    ) -> IntervalIndex:\r\n"]
[192.656, "o", "        with rewrite_exception(\"IntervalArray\", cls.__name__):\r\n"]
[192.666, "o", "            array = IntervalArray.from_breaks(\r\n"]
[192.676, "o", "                breaks, closed=closed, copy=copy, dtype=dtype\r\n"]
[192.686, "o", "            )\r\n"]
[192.696, "o", "        return cls._simple_new(array, name=name)\r\n"]
[192.706, "o", "\r\n"]
[192.716, "o", "    @classmethod\r\n"]
[192.726, "o", "    @Appender(\r\n"]
[192.736, "o", "        _interval_shared_docs[\"from_arrays\"]\r\n"]
[192.746, "o", "        % {\r\n"]
[192.756, "o", "            \"klass\": \"IntervalIndex\",\r\n"]
[192.766, "o", "            \"name\": textwrap.dedent(\r\n"]
[192.776, "o", "                \"\"\"\r\n"]
[192.786, "o", "             name : str, optional\r\n"]
[192.796, "o", "                  Name of the resulting IntervalIndex.\"\"\"\r\n"]
[192.806, "o", "            ),\r\n"]
[192.816, "o", "            \"examples\": textwrap.dedent(\r\n"]
[192.826, "o", "                \"\"\"\\\r\n"]
[192.836, "o", "        Examples\r\n"]
[192.846, "o", "        --------\r\n"]
[192.856, "o", "        >>> pd.IntervalIndex.from_arrays([0, 1, 2], [1, 2, 3])\r\n"]
[192.866, "o", "        IntervalIndex([(0, 1], (1, 2], (2, 3]],\r\n"]
[192.876, "o", "                      dtype='interval[int64, right]')\r\n"]
[192.886, "o", "        \"\"\"\r\n"]
[192.896, "o", "            ),\r\n"]
[192.906, "o", "        }\r\n"]
[192.916, "o", "    )\r\n"]
[192.926, "o", "    def from_arrays(\r\n"]
[192.936, "o", "        cls,\r\n"]
[192.946, "o", "        left,\r\n"]
[192.956, "o", "        right,\r\n"]
[192.966, "o", "        closed: IntervalClosedType = \"right\",\r\n"]
[192.976, "o", "        name: Hashable = None,\r\n"]
[192.986, "o", "        copy: bool = False,\r\n"]
[192.996, "o", "        dtype: Dtype | None = None,\r\n"]
[193.006, "o", "    ) -> IntervalIndex:\r\n"]
[193.016, "o", "        with rewrite_exception(\"IntervalArray\", cls.__name__):\r\n"]
[193.026, "o", "            array = IntervalArray.from_arrays(\r\n"]
[193.036, "o", "                left, right, closed, copy=copy, dtype=dtype\r\n"]
[193.046, "o", "            )\r\n"]
[193.056, "o", "        return cls._simple_new(array, name=name)\r\n"]
[193.066, "o", "\r\n"]
[193.076, "o", "    @classmethod\r\n"]
[193.086, "o", "    @Appender(\r\n"]
[193.096, "o", "        _interval_shared_docs[\"from_tuples\"]\r\n"]
[193.106, "o", "        % {\r\n"]
[193.116, "o", "            \"klass\": \"IntervalIndex\",\r\n"]
[193.126, "o", "            \"name\": textwrap.dedent(\r\n"]
[193.136, "o", "                \"\"\"\r\n"]
[193.146, "o", "             name : str, optional\r\n"]
[193.156, "o", "                  Name of the resulting IntervalIndex.\"\"\"\r\n"]
[193.166, "o", "            ),\r\n"]
[193.176, "o", "            \"examples\": textwrap.dedent(\r\n"]
[193.186, "o", "                \"\"\"\\\r\n"]
[193.196, "o", "        Examples\r\n"]
[193.206, "o", "        --------\r\n"]
[193.216, "o", "        >>> pd.IntervalIndex.from_tuples([(0, 1), (1, 2)])\r\n"]
[193.226, "o", "        IntervalIndex([(0, 1], (1, 2]],\r\n"]
[193.236, "o", "                       dtype='interval[int64, right]')\r\n"]
[193.246, "o", "        \"\"\"\r\n"]
[193.256, "o", "            ),\r\n"]
[193.266, "o", "        }\r\n"]
[193.276, "o", "    )\r\n"]
[193.286, "o", "    def from_tuples(\r\n"]
[193.296, "o", "        cls,\r\n"]
[193.306, "o", "        data,\r\n"]
[193.316, "o", "        closed: IntervalClosedType = \"right\",\r\n"]
[193.326, "o", "        name: Hashable = None,\r\n"]
[193.336, "o", "        copy: bool = False,\r\n"]
[193.346, "o", "        dtype: Dtype | None = None,\r\n"]
[193.356, "o", "    ) -> IntervalIndex:\r\n"]
[193.366, "o", "        with rewrite_exception(\"IntervalArray\", cls.__name__):\r\n"]
[193.376, "o", "            arr = IntervalArray.from_tuples(data, closed=closed, copy=copy, dtype=dtype)\r\n"]
[193.386, "o", "        return cls._simple_new(arr, name=name)\r\n"]
[193.396, "o", "\r\n"]
[193.406, "o", "    # --------------------------------------------------------------------\r\n"]
[193.416, "o", "    # error: Return type \"IntervalTree\" of \"_engine\" incompatible with return type\r\n"]
[193.426, "o", "    # \"Union[IndexEngine, ExtensionEngine]\" in supertype \"Index\"\r\n"]
[193.436, "o", "    @cache_readonly\r\n"]
[193.446, "o", "    def _engine(self) -> IntervalTree:  # type: ignore[override]\r\n"]
[193.456, "o", "        # IntervalTree does not supports numpy array unless they are 64 bit\r\n"]
[193.466, "o", "        left = self._maybe_convert_i8(self.left)\r\n"]
[193.476, "o", "        left = maybe_upcast_numeric_to_64bit(left)\r\n"]
[193.486, "o", "        right = self._maybe_convert_i8(self.right)\r\n"]
[193.496, "o", "        right = maybe_upcast_numeric_to_64bit(right)\r\n"]
[193.506, "o", "        return IntervalTree(left, right, closed=self.closed)\r\n"]
[193.516, "o", "\r\n"]
[193.526, "o", "    def __contains__(self, key: Any) -> bool:\r\n"]
[193.536, "o", "        \"\"\"\r\n"]
[193.546, "o", "        return a boolean if this key is IN the index\r\n"]
[193.556, "o", "        We *only* accept an Interval\r\n"]
[193.566, "o", "\r\n"]
[193.576, "o", "        Parameters\r\n"]
[193.586, "o", "        ----------\r\n"]
[193.596, "o", "        key : Interval\r\n"]
[193.606, "o", "\r\n"]
[193.616, "o", "        Returns\r\n"]
[193.626, "o", "        -------\r\n"]
[193.636, "o", "        bool\r\n"]
[193.646, "o", "        \"\"\"\r\n"]
[193.656, "o", "        hash(key)\r\n"]
[193.666, "o", "        if not isinstance(key, Interval):\r\n"]
[193.676, "o", "            if is_valid_na_for_dtype(key, self.dtype):\r\n"]
[193.686, "o", "                return self.hasnans\r\n"]
[193.696, "o", "            return False\r\n"]
[193.706, "o", "\r\n"]
[193.716, "o", "        try:\r\n"]
[193.726, "o", "            self.get_loc(key)\r\n"]
[193.736, "o", "            return True\r\n"]
[193.746, "o", "        except KeyError:\r\n"]
[193.756, "o", "            return False\r\n"]
[193.766, "o", "\r\n"]
[193.776, "o", "    @cache_readonly\r\n"]
[193.786, "o", "    def _multiindex(self) -> MultiIndex:\r\n"]
[193.796, "o", "        return MultiIndex.from_arrays([self.left, self.right], names=[\"left\", \"right\"])\r\n"]
[193.806, "o", "\r\n"]
[193.816, "o", "    def __reduce__(self):\r\n"]
[193.826, "o", "        d = {\r\n"]
[193.836, "o", "            \"left\": self.left,\r\n"]
[193.846, "o", "            \"right\": self.right,\r\n"]
[193.856, "o", "            \"closed\": self.closed,\r\n"]
[193.866, "o", "            \"name\": self.name,\r\n"]
[193.876, "o", "        }\r\n"]
[193.886, "o", "        return _new_IntervalIndex, (type(self), d), None\r\n"]
[193.896, "o", "\r\n"]
[193.906, "o", "    @property\r\n"]
[193.916, "o", "    def inferred_type(self) -> str:\r\n"]
[193.926, "o", "        \"\"\"Return a string of the type inferred from the values\"\"\"\r\n"]
[193.936, "o", "        return \"interval\"\r\n"]
[193.946, "o", "\r\n"]
[193.956, "o", "    @Appender(Index.memory_usage.__doc__)\r\n"]
[193.966, "o", "    def memory_usage(self, deep: bool = False) -> int:\r\n"]
[193.976, "o", "        # we don't use an explicit engine\r\n"]
[193.986, "o", "        # so return the bytes here\r\n"]
[193.996, "o", "        return self.left.memory_usage(deep=deep) + self.right.memory_usage(deep=deep)\r\n"]
[194.006, "o", "\r\n"]
[194.016, "o", "    # IntervalTree doesn't have a is_monotonic_decreasing, so have to override\r\n"]
[194.026, "o", "    #  the Index implementation\r\n"]
[194.036, "o", "    @cache_readonly\r\n"]
[194.046, "o", "    def is_monotonic_decreasing(self) -> bool:\r\n"]
[194.056, "o", "        \"\"\"\r\n"]
[194.066, "o", "        Return True if the IntervalIndex is monotonic decreasing (only equal or\r\n"]
[194.076, "o", "        decreasing values), else False\r\n"]
[194.086, "o", "        \"\"\"\r\n"]
[194.096, "o", "        return self[::-1].is_monotonic_increasing\r\n"]
[194.106, "o", "\r\n"]
[194.116, "o", "    @cache_readonly\r\n"]
[194.126, "o", "    def is_unique(self) -> bool:\r\n"]
[194.136, "o", "        \"\"\"\r\n"]
[194.146, "o", "        Return True if the IntervalIndex contains unique elements, else False.\r\n"]
[194.156, "o", "        \"\"\"\r\n"]
[194.166, "o", "        left = self.left\r\n"]
[194.176, "o", "        right = self.right\r\n"]
[194.186, "o", "\r\n"]
[194.196, "o", "        if self.isna().sum() > 1:\r\n"]
[194.206, "o", "            return False\r\n"]
[194.216, "o", "\r\n"]
[194.226, "o", "        if left.is_unique or right.is_unique:\r\n"]
[194.236, "o", "            return True\r\n"]
[194.246, "o", "\r\n"]
[194.256, "o", "        seen_pairs = set()\r\n"]
[194.266, "o", "        check_idx = np.where(left.duplicated(keep=False))[0]\r\n"]
[194.276, "o", "        for idx in check_idx:\r\n"]
[194.286, "o", "            pair = (left[idx], right[idx])\r\n"]
[194.296, "o", "            if pair in seen_pairs:\r\n"]
[194.306, "o", "                return False\r\n"]
[194.316, "o", "            seen_pairs.add(pair)\r\n"]
[194.326, "o", "\r\n"]
[194.336, "o", "        return True\r\n"]
[194.346, "o", "\r\n"]
[194.356, "o", "    @property\r\n"]
[194.366, "o", "    def is_overlapping(self) -> bool:\r\n"]
[194.376, "o", "        \"\"\"\r\n"]
[194.386, "o", "        Return True if the IntervalIndex has overlapping intervals, else False.\r\n"]
[194.396, "o", "\r\n"]
[194.406, "o", "        Two intervals overlap if they share a common point, including closed\r\n"]
[194.416, "o", "        endpoints. Intervals that only have an open endpoint in common do not\r\n"]
[194.426, "o", "        overlap.\r\n"]
[194.436, "o", "\r\n"]
[194.446, "o", "        Returns\r\n"]
[194.456, "o", "        -------\r\n"]
[194.466, "o", "        bool\r\n"]
[194.476, "o", "            Boolean indicating if the IntervalIndex has overlapping intervals.\r\n"]
[194.486, "o", "\r\n"]
[194.496, "o", "        See Also\r\n"]
[194.506, "o", "        --------\r\n"]
[194.516, "o", "        Interval.overlaps : Check whether two Interval objects overlap.\r\n"]
[194.526, "o", "        IntervalIndex.overlaps : Check an IntervalIndex elementwise for\r\n"]
[194.536, "o", "            overlaps.\r\n"]
[194.546, "o", "\r\n"]
[194.556, "o", "        Examples\r\n"]
[194.566, "o", "        --------\r\n"]
[194.576, "o", "        >>> index = pd.IntervalIndex.from_tuples([(0, 2), (1, 3), (4, 5)])\r\n"]
[194.586, "o", "        >>> index\r\n"]
[194.596, "o", "        IntervalIndex([(0, 2], (1, 3], (4, 5]],\r\n"]
[194.606, "o", "              dtype='interval[int64, right]')\r\n"]
[194.616, "o", "        >>> index.is_overlapping\r\n"]
[194.626, "o", "        True\r\n"]
[194.636, "o", "\r\n"]
[194.646, "o", "        Intervals that share closed endpoints overlap:\r\n"]
[194.656, "o", "\r\n"]
[194.666, "o", "        >>> index = pd.interval_range(0, 3, closed='both')\r\n"]
[194.676, "o", "        >>> index\r\n"]
[194.686, "o", "        IntervalIndex([[0, 1], [1, 2], [2, 3]],\r\n"]
[194.696, "o", "              dtype='interval[int64, both]')\r\n"]
[194.706, "o", "        >>> index.is_overlapping\r\n"]
[194.716, "o", "        True\r\n"]
[194.726, "o", "\r\n"]
[194.736, "o", "        Intervals that only have an open endpoint in common do not overlap:\r\n"]
[194.746, "o", "\r\n"]
[194.756, "o", "        >>> index = pd.interval_range(0, 3, closed='left')\r\n"]
[194.766, "o", "        >>> index\r\n"]
[194.776, "o", "        IntervalIndex([[0, 1), [1, 2), [2, 3)],\r\n"]
[194.786, "o", "              dtype='interval[int64, left]')\r\n"]
[194.796, "o", "        >>> index.is_overlapping\r\n"]
[194.806, "o", "        False\r\n"]
[194.816, "o", "        \"\"\"\r\n"]
[194.826, "o", "        # GH 23309\r\n"]
[194.836, "o", "        return self._engine.is_overlapping\r\n"]
[194.846, "o", "\r\n"]
[194.856, "o", "    def _needs_i8_conversion(self, key) -> bool:\r\n"]
[194.866, "o", "        \"\"\"\r\n"]
[194.876, "o", "        Check if a given key needs i8 conversion. Conversion is necessary for\r\n"]
[194.886, "o", "        Timestamp, Timedelta, DatetimeIndex, and TimedeltaIndex keys. An\r\n"]
[194.896, "o", "        Interval-like requires conversion if its endpoints are one of the\r\n"]
[194.906, "o", "        aforementioned types.\r\n"]
[194.916, "o", "\r\n"]
[194.926, "o", "        Assumes that any list-like data has already been cast to an Index.\r\n"]
[194.936, "o", "\r\n"]
[195.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[195.002, "i", "grep -n \"intersection(\" pandas/core/indexes/interval.py\r"]
[195.004, "o", "grep -n \"intersection(\" pandas/core/indexes/interval.py\r\n"]
[196.242, "o", "\u001b[?2004l\r\n"]
[197.478, "o", "\u001b[32m\u001b[K850\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def _\u001b[01;31m\u001b[Kintersection(\u001b[m\u001b[Kself, other, sort):\r\n"]
[198.714, "o", "\u001b[32m\u001b[K882\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is much more performant than super()._\u001b[01;31m\u001b[Kintersection(\u001b[m\u001b[Kother)\r\n"]
[200.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[200.002, "i", "python - << 'PY'\r"]
[200.004, "o", "python - << 'PY'\r\n"]
[200.059161, "o", "\u001b[?2004l\r\n"]
[200.112323, "o", "\u001b[?2004h> import numpy as np\r\n"]
[200.165484, "o", "\u001b[?2004l\r\n"]
[200.218645, "o", "\u001b[?2004h> from pandas.core.indexes.interval import IntervalIndex\r\n"]
[200.271806, "o", "\u001b[?2004l\r\n"]
[200.324968, "o", "\u001b[?2004h> import cProfile, pstats, io\r\n"]
[200.378129, "o", "\u001b[?2004l\r\n"]
[200.43129, "o", "\u001b[?2004h> \r\n"]
[200.484452, "o", "\u001b[?2004l\r\n"]
[200.537613, "o", "\u001b[?2004h> def setup(N):\r\n"]
[200.590774, "o", "\u001b[?2004l\r\n"]
[200.643935, "o", "\u001b[?2004h>     left = np.append(np.arange(N), np.array(0))\r\n"]
[200.697097, "o", "\u001b[?2004l\r\n"]
[200.750258, "o", "\u001b[?2004h>     right = np.append(np.arange(1, N + 1), np.array(1))\r\n"]
[200.803419, "o", "\u001b[?2004l\r\n"]
[200.856581, "o", "\u001b[?2004h>     intv = IntervalIndex.from_arrays(left, right)\r\n"]
[200.909742, "o", "\u001b[?2004l\r\n"]
[200.962903, "o", "\u001b[?2004h>     intv._engine\r\n"]
[201.016065, "o", "\u001b[?2004l\r\n"]
[201.069226, "o", "\u001b[?2004h>     intv2 = IntervalIndex.from_arrays(left + 1, right + 1)\r\n"]
[201.122387, "o", "\u001b[?2004l\r\n"]
[201.175548, "o", "\u001b[?2004h>     intv2._engine\r\n"]
[201.22871, "o", "\u001b[?2004l\r\n"]
[201.281871, "o", "\u001b[?2004h>     return intv, intv2\r\n"]
[201.335032, "o", "\u001b[?2004l\r\n"]
[201.388194, "o", "\u001b[?2004h> \r\n"]
[201.441355, "o", "\u001b[?2004l\r\n"]
[201.494516, "o", "\u001b[?2004h> N = 100_000\r\n"]
[201.547677, "o", "\u001b[?2004l\r\n"]
[201.600839, "o", "\u001b[?2004h> intv, intv2 = setup(N)\r\n"]
[201.654, "o", "\u001b[?2004l\r\n"]
[201.707161, "o", "\u001b[?2004h> pr = cProfile.Profile()\r\n"]
[201.760323, "o", "\u001b[?2004l\r\n"]
[201.813484, "o", "\u001b[?2004h> pr.enable()\r\n"]
[201.866645, "o", "\u001b[?2004l\r\n"]
[201.919806, "o", "\u001b[?2004h> # both duplicate case from benchmark\r\n"]
[201.972968, "o", "\u001b[?2004l\r\n"]
[202.026129, "o", "\u001b[?2004h> res = intv.intersection(intv2)\r\n"]
[202.07929, "o", "\u001b[?2004l\r\n"]
[202.132452, "o", "\u001b[?2004h> pr.disable()\r\n"]
[202.185613, "o", "\u001b[?2004l\r\n"]
[202.238774, "o", "\u001b[?2004h> s = io.StringIO()\r\n"]
[202.291935, "o", "\u001b[?2004l\r\n"]
[202.345097, "o", "\u001b[?2004h> ps = pstats.Stats(pr, stream=s).sort_stats('cumtime')\r\n"]
[202.398258, "o", "\u001b[?2004l\r\n"]
[202.451419, "o", "\u001b[?2004h> ps.print_stats(30)\r\n"]
[202.504581, "o", "\u001b[?2004l\r\n"]
[202.557742, "o", "\u001b[?2004h> print(s.getvalue())\r\n"]
[202.610903, "o", "\u001b[?2004l\r\n"]
[202.664065, "o", "\u001b[?2004h> print('result_len:', len(res))\r\n"]
[202.717226, "o", "\u001b[?2004l\r\n"]
[202.770387, "o", "\u001b[?2004h> PY\r\n"]
[202.823548, "o", "\u001b[?2004l\r\n"]
[202.87671, "o", "         1105 function calls (1089 primitive calls) in 0.101 seconds\r\n"]
[202.929871, "o", "\r\n"]
[202.983032, "o", "   Ordered by: cumulative time\r\n"]
[203.036194, "o", "   List reduced from 154 to 30 due to restriction <30>\r\n"]
[203.089355, "o", "\r\n"]
[203.142516, "o", "   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n"]
[203.195677, "o", "        1    0.000    0.000    0.101    0.101 /workspace/repo/pandas/core/indexes/base.py:3251(intersection)\r\n"]
[203.248839, "o", "        1    0.009    0.009    0.100    0.100 /workspace/repo/pandas/core/indexes/interval.py:850(_intersection)\r\n"]
[203.302, "o", "        1    0.087    0.087    0.088    0.088 /workspace/repo/pandas/core/indexes/interval.py:892(_intersection_non_unique)\r\n"]
[203.355161, "o", "        2    0.002    0.001    0.002    0.001 /workspace/repo/pandas/core/indexes/base.py:2174(is_unique)\r\n"]
[203.408323, "o", "        1    0.000    0.000    0.002    0.002 /workspace/repo/pandas/core/indexes/base.py:5100(__getitem__)\r\n"]
[203.461484, "o", "        1    0.001    0.001    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:715(__getitem__)\r\n"]
[203.514645, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:665(_shallow_copy)\r\n"]
[203.567806, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:635(_validate)\r\n"]
[203.620968, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:297(_ensure_simple_new_inputs)\r\n"]
[203.674129, "o", "      2/1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:5253(equals)\r\n"]
[203.72729, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:997(equals)\r\n"]
[203.780452, "o", "        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:449(__new__)\r\n"]
[203.833613, "o", "  312/306    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n"]
[203.886774, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:456(array_equivalent)\r\n"]
[203.939935, "o", "        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(array_equal)\r\n"]
[203.993097, "o", "        2    0.000    0.000    0.000    0.000 {built-in method numpy.core._multiarray_umath.implement_array_function}\r\n"]
[204.046258, "o", "        1    0.000    0.000    0.000    0.000 /opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/numeric.py:2407(array_equal)\r\n"]
[204.099419, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:1281(left)\r\n"]
[204.152581, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:955(astype)\r\n"]
[204.205742, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:7010(ensure_index)\r\n"]
[204.258903, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/dtypes.py:1083(__new__)\r\n"]
[204.312065, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:1143(copy)\r\n"]
[204.365226, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:2670(hasnans)\r\n"]
[204.418387, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:106(isna)\r\n"]
[204.471548, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:794(_engine)\r\n"]
[204.52471, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:189(_isna)\r\n"]
[204.577871, "o", "       55    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/generic.py:42(_instancecheck)\r\n"]
[204.631032, "o", "        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/construction.py:500(sanitize_array)\r\n"]
[204.684194, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:353(notna)\r\n"]
[204.737355, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:6025(_should_compare)\r\n"]
[204.790516, "o", "\r\n"]
[204.843677, "o", "\r\n"]
[204.896839, "o", "\r\n"]
[205.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[205.002, "i", "python - << 'PY'\r"]
[205.004, "o", "python - << 'PY'\r\n"]
[205.066293, "o", "\u001b[?2004l\r\n"]
[205.126585, "o", "\u001b[?2004h> import numpy as np\r\n"]
[205.186878, "o", "\u001b[?2004l\r\n"]
[205.247171, "o", "\u001b[?2004h> from pandas.core.indexes.interval import IntervalIndex\r\n"]
[205.307463, "o", "\u001b[?2004l\r\n"]
[205.367756, "o", "\u001b[?2004h> import cProfile, pstats, io\r\n"]
[205.428049, "o", "\u001b[?2004l\r\n"]
[205.488341, "o", "\u001b[?2004h> \r\n"]
[205.548634, "o", "\u001b[?2004l\r\n"]
[205.608927, "o", "\u001b[?2004h> N = 100_000\r\n"]
[205.66922, "o", "\u001b[?2004l\r\n"]
[205.729512, "o", "\u001b[?2004h> left = np.arange(N)\r\n"]
[205.789805, "o", "\u001b[?2004l\r\n"]
[205.850098, "o", "\u001b[?2004h> right = np.arange(1, N + 1)\r\n"]
[205.91039, "o", "\u001b[?2004l\r\n"]
[205.970683, "o", "\u001b[?2004h> left2 = np.arange(N-3, 2*N-3)\r\n"]
[206.030976, "o", "\u001b[?2004l\r\n"]
[206.091268, "o", "\u001b[?2004h> right2 = left2 + 1\r\n"]
[206.151561, "o", "\u001b[?2004l\r\n"]
[206.211854, "o", "\u001b[?2004h> left_idx = IntervalIndex.from_breaks(np.arange(N))\r\n"]
[206.272146, "o", "\u001b[?2004l\r\n"]
[206.332439, "o", "\u001b[?2004h> right_idx = IntervalIndex.from_breaks(np.arange(N - 3, 2 * N - 3))\r\n"]
[206.392732, "o", "\u001b[?2004l\r\n"]
[206.453024, "o", "\u001b[?2004h> pr = cProfile.Profile()\r\n"]
[206.513317, "o", "\u001b[?2004l\r\n"]
[206.57361, "o", "\u001b[?2004h> pr.enable()\r\n"]
[206.633902, "o", "\u001b[?2004l\r\n"]
[206.694195, "o", "\u001b[?2004h> res = left_idx.intersection(right_idx)\r\n"]
[206.754488, "o", "\u001b[?2004l\r\n"]
[206.81478, "o", "\u001b[?2004h> pr.disable()\r\n"]
[206.875073, "o", "\u001b[?2004l\r\n"]
[206.935366, "o", "\u001b[?2004h> import sys\r\n"]
[206.995659, "o", "\u001b[?2004l\r\n"]
[207.055951, "o", "\u001b[?2004h> import pstats\r\n"]
[207.116244, "o", "\u001b[?2004l\r\n"]
[207.176537, "o", "\u001b[?2004h> ps = pstats.Stats(pr).sort_stats('cumtime')\r\n"]
[207.236829, "o", "\u001b[?2004l\r\n"]
[207.297122, "o", "\u001b[?2004h> ps.print_stats(30)\r\n"]
[207.357415, "o", "\u001b[?2004l\r\n"]
[207.417707, "o", "\u001b[?2004h> print('result_len:', len(res))\r\n"]
[207.478, "o", "\u001b[?2004l\r\n"]
[207.538293, "o", "\u001b[?2004h> PY\r\n"]
[207.598585, "o", "\u001b[?2004l\r\n"]
[207.658878, "o", "         2175 function calls (2152 primitive calls) in 0.009 seconds\r\n"]
[207.719171, "o", "\r\n"]
[207.779463, "o", "   Ordered by: cumulative time\r\n"]
[207.839756, "o", "   List reduced from 175 to 30 due to restriction <30>\r\n"]
[207.900049, "o", "\r\n"]
[207.960341, "o", "   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n"]
[208.020634, "o", "        1    0.000    0.000    0.009    0.009 /workspace/repo/pandas/core/indexes/base.py:3251(intersection)\r\n"]
[208.080927, "o", "        1    0.000    0.000    0.009    0.009 /workspace/repo/pandas/core/indexes/interval.py:850(_intersection)\r\n"]
[208.14122, "o", "        1    0.000    0.000    0.007    0.007 /workspace/repo/pandas/core/indexes/interval.py:870(_intersection_unique)\r\n"]
[208.201512, "o", "        2    0.000    0.000    0.006    0.003 /workspace/repo/pandas/core/indexes/base.py:3662(get_indexer)\r\n"]
[208.261805, "o", "        2    0.000    0.000    0.005    0.003 /workspace/repo/pandas/core/indexes/base.py:3749(_get_indexer)\r\n"]
[208.322098, "o", "        2    0.005    0.003    0.005    0.003 {method 'get_indexer' of 'pandas._libs.index.IndexEngine' objects}\r\n"]
[208.38239, "o", "        2    0.002    0.001    0.002    0.001 /workspace/repo/pandas/core/indexes/base.py:2174(is_unique)\r\n"]
[208.442683, "o", "      4/3    0.000    0.000    0.001    0.000 /workspace/repo/pandas/core/indexes/base.py:5253(equals)\r\n"]
[208.502976, "o", "       12    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:449(__new__)\r\n"]
[208.563268, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:1038(take)\r\n"]
[208.623561, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:1078(take)\r\n"]
[208.683854, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:456(array_equivalent)\r\n"]
[208.744146, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:665(_shallow_copy)\r\n"]
[208.804439, "o", "        3    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(array_equal)\r\n"]
[208.864732, "o", "        3    0.000    0.000    0.000    0.000 {built-in method numpy.core._multiarray_umath.implement_array_function}\r\n"]
[208.925024, "o", "        3    0.000    0.000    0.000    0.000 /opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/numeric.py:2407(array_equal)\r\n"]
[208.985317, "o", "  607/593    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n"]
[209.04561, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:297(_ensure_simple_new_inputs)\r\n"]
[209.105902, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:997(equals)\r\n"]
[209.166195, "o", "        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:1281(left)\r\n"]
[209.226488, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/interval.py:816(right)\r\n"]
[209.28678, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/interval.py:812(left)\r\n"]
[209.347073, "o", "       12    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/construction.py:500(sanitize_array)\r\n"]
[209.407366, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/algorithms.py:312(unique)\r\n"]
[209.467659, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/algorithms.py:432(unique_with_mask)\r\n"]
[209.527951, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:6025(_should_compare)\r\n"]
[209.588244, "o", "      142    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/generic.py:42(_instancecheck)\r\n"]
[209.648537, "o", "       41    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/common.py:1487(_is_dtype_type)\r\n"]
[209.708829, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:1290(right)\r\n"]
[209.769122, "o", "       12    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:562(_dtype_to_subclass)\r\n"]
[209.829415, "o", "\r\n"]
[209.889707, "o", "\r\n"]
[210.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[210.002, "i", "grep -n \"_intersection\" pandas/core/indexes/interval.py\r"]
[210.004, "o", "grep -n \"_intersection\" pandas/core/indexes/interval.py\r\n"]
[210.5004, "o", "\u001b[?2004l\r\n"]
[210.9948, "o", "\u001b[32m\u001b[K850\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(self, other, sort):\r\n"]
[211.4892, "o", "\u001b[32m\u001b[K856\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(other)\r\n"]
[211.9836, "o", "\u001b[32m\u001b[K860\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = other.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self)\r\n"]
[212.478, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(other)\r\n"]
[212.9724, "o", "\u001b[32m\u001b[K870\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[213.4668, "o", "\u001b[32m\u001b[K882\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is much more performant than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[213.9612, "o", "\u001b[32m\u001b[K892\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[214.4556, "o", "\u001b[32m\u001b[K906\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is about 3.25x faster than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[215.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[215.002, "i", "sed -n '760,980p' pandas/core/indexes/interval.py\r"]
[215.004, "o", "sed -n '760,980p' pandas/core/indexes/interval.py\r\n"]
[215.02827, "o", "\u001b[?2004l\r\n"]
[215.050541, "o", "            except InvalidIndexError:\r\n"]
[215.072811, "o", "                # i.e. non-scalar key e.g. a tuple.\r\n"]
[215.095081, "o", "                # see test_append_different_columns_types_raises\r\n"]
[215.117351, "o", "                missing.append(i)\r\n"]
[215.139622, "o", "                locs = np.array([-1])\r\n"]
[215.161892, "o", "\r\n"]
[215.184162, "o", "            indexer.append(locs)\r\n"]
[215.206432, "o", "\r\n"]
[215.228703, "o", "        indexer = np.concatenate(indexer)\r\n"]
[215.250973, "o", "        return ensure_platform_int(indexer), ensure_platform_int(missing)\r\n"]
[215.273243, "o", "\r\n"]
[215.295514, "o", "    @cache_readonly\r\n"]
[215.317784, "o", "    def _index_as_unique(self) -> bool:\r\n"]
[215.340054, "o", "        return not self.is_overlapping and self._engine._na_count < 2\r\n"]
[215.362324, "o", "\r\n"]
[215.384595, "o", "    _requires_unique_msg = (\r\n"]
[215.406865, "o", "        \"cannot handle overlapping indices; use IntervalIndex.get_indexer_non_unique\"\r\n"]
[215.429135, "o", "    )\r\n"]
[215.451405, "o", "\r\n"]
[215.473676, "o", "    def _convert_slice_indexer(self, key: slice, kind: str):\r\n"]
[215.495946, "o", "        if not (key.step is None or key.step == 1):\r\n"]
[215.518216, "o", "            # GH#31658 if label-based, we require step == 1,\r\n"]
[215.540486, "o", "            #  if positional, we disallow float start/stop\r\n"]
[215.562757, "o", "            msg = \"label-based slicing with step!=1 is not supported for IntervalIndex\"\r\n"]
[215.585027, "o", "            if kind == \"loc\":\r\n"]
[215.607297, "o", "                raise ValueError(msg)\r\n"]
[215.629568, "o", "            if kind == \"getitem\":\r\n"]
[215.651838, "o", "                if not is_valid_positional_slice(key):\r\n"]
[215.674108, "o", "                    # i.e. this cannot be interpreted as a positional slice\r\n"]
[215.696378, "o", "                    raise ValueError(msg)\r\n"]
[215.718649, "o", "\r\n"]
[215.740919, "o", "        return super()._convert_slice_indexer(key, kind)\r\n"]
[215.763189, "o", "\r\n"]
[215.785459, "o", "    @cache_readonly\r\n"]
[215.80773, "o", "    def _should_fallback_to_positional(self) -> bool:\r\n"]
[215.83, "o", "        # integer lookups in Series.__getitem__ are unambiguously\r\n"]
[215.85227, "o", "        #  positional in this case\r\n"]
[215.874541, "o", "        # error: Item \"ExtensionDtype\"/\"dtype[Any]\" of \"Union[dtype[Any],\r\n"]
[215.896811, "o", "        # ExtensionDtype]\" has no attribute \"subtype\"\r\n"]
[215.919081, "o", "        return self.dtype.subtype.kind in [\"m\", \"M\"]  # type: ignore[union-attr]\r\n"]
[215.941351, "o", "\r\n"]
[215.963622, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[215.985892, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[216.008162, "o", "\r\n"]
[216.030432, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[216.052703, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[216.074973, "o", "            return False\r\n"]
[216.097243, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[216.119514, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[216.141784, "o", "\r\n"]
[216.164054, "o", "    # --------------------------------------------------------------------\r\n"]
[216.186324, "o", "\r\n"]
[216.208595, "o", "    @cache_readonly\r\n"]
[216.230865, "o", "    def left(self) -> Index:\r\n"]
[216.253135, "o", "        return Index(self._data.left, copy=False)\r\n"]
[216.275405, "o", "\r\n"]
[216.297676, "o", "    @cache_readonly\r\n"]
[216.319946, "o", "    def right(self) -> Index:\r\n"]
[216.342216, "o", "        return Index(self._data.right, copy=False)\r\n"]
[216.364486, "o", "\r\n"]
[216.386757, "o", "    @cache_readonly\r\n"]
[216.409027, "o", "    def mid(self) -> Index:\r\n"]
[216.431297, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[216.453568, "o", "\r\n"]
[216.475838, "o", "    @property\r\n"]
[216.498108, "o", "    def length(self) -> Index:\r\n"]
[216.520378, "o", "        return Index(self._data.length, copy=False)\r\n"]
[216.542649, "o", "\r\n"]
[216.564919, "o", "    # --------------------------------------------------------------------\r\n"]
[216.587189, "o", "    # Rendering Methods\r\n"]
[216.609459, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[216.63173, "o", "\r\n"]
[216.654, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[216.67627, "o", "        # matches base class except for whitespace padding\r\n"]
[216.698541, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[216.720811, "o", "\r\n"]
[216.743081, "o", "    def _format_native_types(\r\n"]
[216.765351, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[216.787622, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[216.809892, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[216.832162, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[216.854432, "o", "\r\n"]
[216.876703, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[216.898973, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[216.921243, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[216.943514, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[216.965784, "o", "\r\n"]
[216.988054, "o", "    # --------------------------------------------------------------------\r\n"]
[217.010324, "o", "    # Set Operations\r\n"]
[217.032595, "o", "\r\n"]
[217.054865, "o", "    def _intersection(self, other, sort):\r\n"]
[217.077135, "o", "        \"\"\"\r\n"]
[217.099405, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[217.121676, "o", "        \"\"\"\r\n"]
[217.143946, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[217.166216, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[217.188486, "o", "            taken = self._intersection_unique(other)\r\n"]
[217.210757, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[217.233027, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[217.255297, "o", "            # multiple NaNs\r\n"]
[217.277568, "o", "            taken = other._intersection_unique(self)\r\n"]
[217.299838, "o", "        else:\r\n"]
[217.322108, "o", "            # duplicates\r\n"]
[217.344378, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[217.366649, "o", "\r\n"]
[217.388919, "o", "        if sort is None:\r\n"]
[217.411189, "o", "            taken = taken.sort_values()\r\n"]
[217.433459, "o", "\r\n"]
[217.45573, "o", "        return taken\r\n"]
[217.478, "o", "\r\n"]
[217.50027, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[217.522541, "o", "        \"\"\"\r\n"]
[217.544811, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[217.567081, "o", "        no matter left or right.\r\n"]
[217.589351, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[217.611622, "o", "        Parameters\r\n"]
[217.633892, "o", "        ----------\r\n"]
[217.656162, "o", "        other : IntervalIndex\r\n"]
[217.678432, "o", "        Returns\r\n"]
[217.700703, "o", "        -------\r\n"]
[217.722973, "o", "        IntervalIndex\r\n"]
[217.745243, "o", "        \"\"\"\r\n"]
[217.767514, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[217.789784, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[217.812054, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[217.834324, "o", "\r\n"]
[217.856595, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[217.878865, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[217.901135, "o", "        indexer = unique(indexer)\r\n"]
[217.923405, "o", "\r\n"]
[217.945676, "o", "        return self.take(indexer)\r\n"]
[217.967946, "o", "\r\n"]
[217.990216, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[218.012486, "o", "        \"\"\"\r\n"]
[218.034757, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[218.057027, "o", "        on either sides.\r\n"]
[218.079297, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[218.101568, "o", "\r\n"]
[218.123838, "o", "        Parameters\r\n"]
[218.146108, "o", "        ----------\r\n"]
[218.168378, "o", "        other : IntervalIndex\r\n"]
[218.190649, "o", "\r\n"]
[218.212919, "o", "        Returns\r\n"]
[218.235189, "o", "        -------\r\n"]
[218.257459, "o", "        IntervalIndex\r\n"]
[218.27973, "o", "        \"\"\"\r\n"]
[218.302, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[218.32427, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[218.346541, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[218.368811, "o", "\r\n"]
[218.391081, "o", "        if self.hasnans and other.hasnans:\r\n"]
[218.413351, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[218.435622, "o", "            mask[first_nan_loc] = True\r\n"]
[218.457892, "o", "\r\n"]
[218.480162, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[218.502432, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[218.524703, "o", "            if tup in other_tups:\r\n"]
[218.546973, "o", "                mask[i] = True\r\n"]
[218.569243, "o", "\r\n"]
[218.591514, "o", "        return self[mask]\r\n"]
[218.613784, "o", "\r\n"]
[218.636054, "o", "    # --------------------------------------------------------------------\r\n"]
[218.658324, "o", "\r\n"]
[218.680595, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[218.702865, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[218.725135, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[218.747405, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[218.769676, "o", "        raise NotImplementedError(\r\n"]
[218.791946, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[218.814216, "o", "            \"IndexEngine objects\"\r\n"]
[218.836486, "o", "        )\r\n"]
[218.858757, "o", "\r\n"]
[218.881027, "o", "    def _from_join_target(self, result):\r\n"]
[218.903297, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[218.925568, "o", "\r\n"]
[218.947838, "o", "    # TODO: arithmetic operations\r\n"]
[218.970108, "o", "\r\n"]
[218.992378, "o", "\r\n"]
[219.014649, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[219.036919, "o", "    \"\"\"\r\n"]
[219.059189, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[219.081459, "o", "    \"\"\"\r\n"]
[219.10373, "o", "    return any(\r\n"]
[219.126, "o", "        [\r\n"]
[219.14827, "o", "            is_number(endpoint),\r\n"]
[219.170541, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[219.192811, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[219.215081, "o", "            endpoint is None,\r\n"]
[219.237351, "o", "        ]\r\n"]
[219.259622, "o", "    )\r\n"]
[219.281892, "o", "\r\n"]
[219.304162, "o", "\r\n"]
[219.326432, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[219.348703, "o", "    \"\"\"\r\n"]
[219.370973, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[219.393243, "o", "    \"\"\"\r\n"]
[219.415514, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[219.437784, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[219.460054, "o", "    return (\r\n"]
[219.482324, "o", "        (is_number(a) and is_number(b))\r\n"]
[219.504595, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[219.526865, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[219.549135, "o", "        or com.any_none(a, b)\r\n"]
[219.571405, "o", "    )\r\n"]
[219.593676, "o", "\r\n"]
[219.615946, "o", "\r\n"]
[219.638216, "o", "def interval_range(\r\n"]
[219.660486, "o", "    start=None,\r\n"]
[219.682757, "o", "    end=None,\r\n"]
[219.705027, "o", "    periods=None,\r\n"]
[219.727297, "o", "    freq=None,\r\n"]
[219.749568, "o", "    name: Hashable = None,\r\n"]
[219.771838, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[219.794108, "o", ") -> IntervalIndex:\r\n"]
[219.816378, "o", "    \"\"\"\r\n"]
[219.838649, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[219.860919, "o", "\r\n"]
[219.883189, "o", "    Parameters\r\n"]
[219.905459, "o", "    ----------\r\n"]
[219.92773, "o", "    start : numeric or datetime-like, default None\r\n"]
[220.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[220.002, "i", "python - << 'PY'\r"]
[220.004, "o", "python - << 'PY'\r\n"]
[220.05495, "o", "\u001b[?2004l\r\n"]
[220.103901, "o", "\u001b[?2004h> import numpy as np\r\n"]
[220.152851, "o", "\u001b[?2004l\r\n"]
[220.201802, "o", "\u001b[?2004h> from pandas.core.indexes.interval import IntervalIndex\r\n"]
[220.250752, "o", "\u001b[?2004l\r\n"]
[220.299703, "o", "\u001b[?2004h> import cProfile, pstats, io\r\n"]
[220.348653, "o", "\u001b[?2004l\r\n"]
[220.397604, "o", "\u001b[?2004h> \r\n"]
[220.446554, "o", "\u001b[?2004l\r\n"]
[220.495505, "o", "\u001b[?2004h> def setup_both_dup(N):\r\n"]
[220.544455, "o", "\u001b[?2004l\r\n"]
[220.593406, "o", "\u001b[?2004h>     left = np.append(np.arange(N), np.array(0))\r\n"]
[220.642356, "o", "\u001b[?2004l\r\n"]
[220.691307, "o", "\u001b[?2004h>     right = np.append(np.arange(1, N + 1), np.array(1))\r\n"]
[220.740257, "o", "\u001b[?2004l\r\n"]
[220.789208, "o", "\u001b[?2004h>     intv = IntervalIndex.from_arrays(left, right)\r\n"]
[220.838158, "o", "\u001b[?2004l\r\n"]
[220.887109, "o", "\u001b[?2004h>     intv._engine\r\n"]
[220.936059, "o", "\u001b[?2004l\r\n"]
[220.98501, "o", "\u001b[?2004h>     intv2 = IntervalIndex.from_arrays(left + 1, right + 1)\r\n"]
[221.03396, "o", "\u001b[?2004l\r\n"]
[221.082911, "o", "\u001b[?2004h>     intv2._engine\r\n"]
[221.131861, "o", "\u001b[?2004l\r\n"]
[221.180812, "o", "\u001b[?2004h>     return intv, intv2\r\n"]
[221.229762, "o", "\u001b[?2004l\r\n"]
[221.278713, "o", "\u001b[?2004h> \r\n"]
[221.327663, "o", "\u001b[?2004l\r\n"]
[221.376614, "o", "\u001b[?2004h> N = 100_000\r\n"]
[221.425564, "o", "\u001b[?2004l\r\n"]
[221.474515, "o", "\u001b[?2004h> intv, intv2 = setup_both_dup(N)\r\n"]
[221.523465, "o", "\u001b[?2004l\r\n"]
[221.572416, "o", "\u001b[?2004h> pr = cProfile.Profile()\r\n"]
[221.621366, "o", "\u001b[?2004l\r\n"]
[221.670317, "o", "\u001b[?2004h> pr.enable()\r\n"]
[221.719267, "o", "\u001b[?2004l\r\n"]
[221.768218, "o", "\u001b[?2004h> res = intv.intersection(intv2)\r\n"]
[221.817168, "o", "\u001b[?2004l\r\n"]
[221.866119, "o", "\u001b[?2004h> pr.disable()\r\n"]
[221.915069, "o", "\u001b[?2004l\r\n"]
[221.96402, "o", "\u001b[?2004h> s = io.StringIO()\r\n"]
[222.01297, "o", "\u001b[?2004l\r\n"]
[222.061921, "o", "\u001b[?2004h> ps = pstats.Stats(pr, stream=s).sort_stats('cumtime')\r\n"]
[222.110871, "o", "\u001b[?2004l\r\n"]
[222.159822, "o", "\u001b[?2004h> ps.print_stats(40)\r\n"]
[222.208772, "o", "\u001b[?2004l\r\n"]
[222.257723, "o", "\u001b[?2004h> print(s.getvalue())\r\n"]
[222.306673, "o", "\u001b[?2004l\r\n"]
[222.355624, "o", "\u001b[?2004h> print('result_len:', len(res))\r\n"]
[222.404574, "o", "\u001b[?2004l\r\n"]
[222.453525, "o", "\u001b[?2004h> PY\r\n"]
[222.502475, "o", "\u001b[?2004l\r\n"]
[222.551426, "o", "         1105 function calls (1089 primitive calls) in 0.119 seconds\r\n"]
[222.600376, "o", "\r\n"]
[222.649327, "o", "   Ordered by: cumulative time\r\n"]
[222.698277, "o", "   List reduced from 154 to 40 due to restriction <40>\r\n"]
[222.747228, "o", "\r\n"]
[222.796178, "o", "   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n"]
[222.845129, "o", "        1    0.000    0.000    0.119    0.119 /workspace/repo/pandas/core/indexes/base.py:3251(intersection)\r\n"]
[222.894079, "o", "        1    0.013    0.013    0.118    0.118 /workspace/repo/pandas/core/indexes/interval.py:850(_intersection)\r\n"]
[222.94303, "o", "        1    0.101    0.101    0.103    0.103 /workspace/repo/pandas/core/indexes/interval.py:892(_intersection_non_unique)\r\n"]
[222.99198, "o", "        2    0.002    0.001    0.002    0.001 /workspace/repo/pandas/core/indexes/base.py:2174(is_unique)\r\n"]
[223.040931, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/indexes/base.py:5100(__getitem__)\r\n"]
[223.089881, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:715(__getitem__)\r\n"]
[223.138832, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:665(_shallow_copy)\r\n"]
[223.187782, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:635(_validate)\r\n"]
[223.236733, "o", "      2/1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:5253(equals)\r\n"]
[223.285683, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:997(equals)\r\n"]
[223.334634, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:297(_ensure_simple_new_inputs)\r\n"]
[223.383584, "o", "        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:449(__new__)\r\n"]
[223.432535, "o", "  312/306    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n"]
[223.481485, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:456(array_equivalent)\r\n"]
[223.530436, "o", "        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(array_equal)\r\n"]
[223.579386, "o", "        2    0.000    0.000    0.000    0.000 {built-in method numpy.core._multiarray_umath.implement_array_function}\r\n"]
[223.628337, "o", "        1    0.000    0.000    0.000    0.000 /opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/numeric.py:2407(array_equal)\r\n"]
[223.677287, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:1281(left)\r\n"]
[223.726238, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:7010(ensure_index)\r\n"]
[223.775188, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/dtypes.py:1083(__new__)\r\n"]
[223.824139, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:955(astype)\r\n"]
[223.873089, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:2670(hasnans)\r\n"]
[223.92204, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:1143(copy)\r\n"]
[223.97099, "o", "       55    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/generic.py:42(_instancecheck)\r\n"]
[224.019941, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:106(isna)\r\n"]
[224.068891, "o", "        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/construction.py:500(sanitize_array)\r\n"]
[224.117842, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:794(_engine)\r\n"]
[224.166792, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:189(_isna)\r\n"]
[224.215743, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:353(notna)\r\n"]
[224.264693, "o", "        4    0.000    0.000    0.000    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n"]
[224.313644, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:6025(_should_compare)\r\n"]
[224.362594, "o", "      7/5    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/common.py:547(is_dtype_equal)\r\n"]
[224.411545, "o", "        7    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:619(_simple_new)\r\n"]
[224.460495, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/ops/common.py:87(get_op_result_name)\r\n"]
[224.509446, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:266(_isna_array)\r\n"]
[224.558396, "o", "        3    0.000    0.000    0.000    0.000 {method 'all' of 'numpy.ndarray' objects}\r\n"]
[224.607347, "o", "       17    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/common.py:1487(_is_dtype_type)\r\n"]
[224.656297, "o", "        3    0.000    0.000    0.000    0.000 /opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/_methods.py:61(_all)\r\n"]
[224.705248, "o", "        2    0.000    0.000    0.000    0.000 /opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/_dtype.py:34(__str__)\r\n"]
[224.754198, "o", "        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/common.py:1237(is_bool_dtype)\r\n"]
[224.803149, "o", "\r\n"]
[224.852099, "o", "\r\n"]
[224.90105, "o", "\r\n"]
[225.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[225.002, "i", "grep -n \"_intersection\" pandas/core/indexes/interval.py\r"]
[225.004, "o", "grep -n \"_intersection\" pandas/core/indexes/interval.py\r\n"]
[225.5004, "o", "\u001b[?2004l\r\n"]
[225.9948, "o", "\u001b[32m\u001b[K850\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(self, other, sort):\r\n"]
[226.4892, "o", "\u001b[32m\u001b[K856\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(other)\r\n"]
[226.9836, "o", "\u001b[32m\u001b[K860\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = other.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self)\r\n"]
[227.478, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(other)\r\n"]
[227.9724, "o", "\u001b[32m\u001b[K870\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[228.4668, "o", "\u001b[32m\u001b[K882\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is much more performant than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[228.9612, "o", "\u001b[32m\u001b[K892\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[229.4556, "o", "\u001b[32m\u001b[K906\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is about 3.25x faster than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[230.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[230.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[230.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[230.033165, "o", "\u001b[?2004l\r\n"]
[230.06033, "o", "\r\n"]
[230.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[230.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[230.141824, "o", "\r\n"]
[230.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[230.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[230.223319, "o", "            return False\r\n"]
[230.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[230.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[230.304813, "o", "\r\n"]
[230.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[230.359143, "o", "\r\n"]
[230.386308, "o", "    @cache_readonly\r\n"]
[230.413473, "o", "    def left(self) -> Index:\r\n"]
[230.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[230.467802, "o", "\r\n"]
[230.494967, "o", "    @cache_readonly\r\n"]
[230.522132, "o", "    def right(self) -> Index:\r\n"]
[230.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[230.576462, "o", "\r\n"]
[230.603626, "o", "    @cache_readonly\r\n"]
[230.630791, "o", "    def mid(self) -> Index:\r\n"]
[230.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[230.685121, "o", "\r\n"]
[230.712286, "o", "    @property\r\n"]
[230.739451, "o", "    def length(self) -> Index:\r\n"]
[230.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[230.79378, "o", "\r\n"]
[230.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[230.84811, "o", "    # Rendering Methods\r\n"]
[230.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[230.90244, "o", "\r\n"]
[230.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[230.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[230.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[231.011099, "o", "\r\n"]
[231.038264, "o", "    def _format_native_types(\r\n"]
[231.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[231.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[231.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[231.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[231.174088, "o", "\r\n"]
[231.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[231.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[231.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[231.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[231.309912, "o", "\r\n"]
[231.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[231.364242, "o", "    # Set Operations\r\n"]
[231.391407, "o", "\r\n"]
[231.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[231.445736, "o", "        \"\"\"\r\n"]
[231.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[231.500066, "o", "        \"\"\"\r\n"]
[231.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[231.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[231.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[231.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[231.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[231.663055, "o", "            # multiple NaNs\r\n"]
[231.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[231.717385, "o", "        else:\r\n"]
[231.744549, "o", "            # duplicates\r\n"]
[231.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[231.798879, "o", "\r\n"]
[231.826044, "o", "        if sort is None:\r\n"]
[231.853209, "o", "            taken = taken.sort_values()\r\n"]
[231.880374, "o", "\r\n"]
[231.907538, "o", "        return taken\r\n"]
[231.934703, "o", "\r\n"]
[231.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[231.989033, "o", "        \"\"\"\r\n"]
[232.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[232.043363, "o", "        no matter left or right.\r\n"]
[232.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[232.097692, "o", "        Parameters\r\n"]
[232.124857, "o", "        ----------\r\n"]
[232.152022, "o", "        other : IntervalIndex\r\n"]
[232.179187, "o", "        Returns\r\n"]
[232.206352, "o", "        -------\r\n"]
[232.233516, "o", "        IntervalIndex\r\n"]
[232.260681, "o", "        \"\"\"\r\n"]
[232.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[232.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[232.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[232.369341, "o", "\r\n"]
[232.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[232.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[232.450835, "o", "        indexer = unique(indexer)\r\n"]
[232.478, "o", "\r\n"]
[232.505165, "o", "        return self.take(indexer)\r\n"]
[232.53233, "o", "\r\n"]
[232.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[232.586659, "o", "        \"\"\"\r\n"]
[232.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[232.640989, "o", "        on either sides.\r\n"]
[232.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[232.695319, "o", "\r\n"]
[232.722484, "o", "        Parameters\r\n"]
[232.749648, "o", "        ----------\r\n"]
[232.776813, "o", "        other : IntervalIndex\r\n"]
[232.803978, "o", "\r\n"]
[232.831143, "o", "        Returns\r\n"]
[232.858308, "o", "        -------\r\n"]
[232.885473, "o", "        IntervalIndex\r\n"]
[232.912637, "o", "        \"\"\"\r\n"]
[232.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[232.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[232.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[233.021297, "o", "\r\n"]
[233.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[233.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[233.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[233.129956, "o", "\r\n"]
[233.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[233.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[233.211451, "o", "            if tup in other_tups:\r\n"]
[233.238615, "o", "                mask[i] = True\r\n"]
[233.26578, "o", "\r\n"]
[233.292945, "o", "        return self[mask]\r\n"]
[233.32011, "o", "\r\n"]
[233.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[233.37444, "o", "\r\n"]
[233.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[233.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[233.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[233.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[233.510264, "o", "        raise NotImplementedError(\r\n"]
[233.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[233.564593, "o", "            \"IndexEngine objects\"\r\n"]
[233.591758, "o", "        )\r\n"]
[233.618923, "o", "\r\n"]
[233.646088, "o", "    def _from_join_target(self, result):\r\n"]
[233.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[233.700418, "o", "\r\n"]
[233.727582, "o", "    # TODO: arithmetic operations\r\n"]
[233.754747, "o", "\r\n"]
[233.781912, "o", "\r\n"]
[233.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[233.836242, "o", "    \"\"\"\r\n"]
[233.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[233.890571, "o", "    \"\"\"\r\n"]
[233.917736, "o", "    return any(\r\n"]
[233.944901, "o", "        [\r\n"]
[233.972066, "o", "            is_number(endpoint),\r\n"]
[233.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[234.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[234.05356, "o", "            endpoint is None,\r\n"]
[234.080725, "o", "        ]\r\n"]
[234.10789, "o", "    )\r\n"]
[234.135055, "o", "\r\n"]
[234.16222, "o", "\r\n"]
[234.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[234.216549, "o", "    \"\"\"\r\n"]
[234.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[234.270879, "o", "    \"\"\"\r\n"]
[234.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[234.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[234.352374, "o", "    return (\r\n"]
[234.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[234.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[234.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[234.461033, "o", "        or com.any_none(a, b)\r\n"]
[234.488198, "o", "    )\r\n"]
[234.515363, "o", "\r\n"]
[234.542527, "o", "\r\n"]
[234.569692, "o", "def interval_range(\r\n"]
[234.596857, "o", "    start=None,\r\n"]
[234.624022, "o", "    end=None,\r\n"]
[234.651187, "o", "    periods=None,\r\n"]
[234.678352, "o", "    freq=None,\r\n"]
[234.705516, "o", "    name: Hashable = None,\r\n"]
[234.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[234.759846, "o", ") -> IntervalIndex:\r\n"]
[234.787011, "o", "    \"\"\"\r\n"]
[234.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[234.841341, "o", "\r\n"]
[234.868505, "o", "    Parameters\r\n"]
[234.89567, "o", "    ----------\r\n"]
[234.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[235.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[235.002, "i", "python - << 'PY'\r"]
[235.004, "o", "python - << 'PY'\r\n"]
[235.065566, "o", "\u001b[?2004l\r\n"]
[235.125133, "o", "\u001b[?2004h> import numpy as np\r\n"]
[235.184699, "o", "\u001b[?2004l\r\n"]
[235.244265, "o", "\u001b[?2004h> from pandas.core.indexes.interval import IntervalIndex\r\n"]
[235.303831, "o", "\u001b[?2004l\r\n"]
[235.363398, "o", "\u001b[?2004h> import cProfile, pstats, io\r\n"]
[235.422964, "o", "\u001b[?2004l\r\n"]
[235.48253, "o", "\u001b[?2004h> \r\n"]
[235.542096, "o", "\u001b[?2004l\r\n"]
[235.601663, "o", "\u001b[?2004h> def setup_both_dup(N):\r\n"]
[235.661229, "o", "\u001b[?2004l\r\n"]
[235.720795, "o", "\u001b[?2004h>     left = np.append(np.arange(N), np.array(0))\r\n"]
[235.780361, "o", "\u001b[?2004l\r\n"]
[235.839928, "o", "\u001b[?2004h>     right = np.append(np.arange(1, N + 1), np.array(1))\r\n"]
[235.899494, "o", "\u001b[?2004l\r\n"]
[235.95906, "o", "\u001b[?2004h>     intv = IntervalIndex.from_arrays(left, right)\r\n"]
[236.018627, "o", "\u001b[?2004l\r\n"]
[236.078193, "o", "\u001b[?2004h>     intv._engine\r\n"]
[236.137759, "o", "\u001b[?2004l\r\n"]
[236.197325, "o", "\u001b[?2004h>     intv2 = IntervalIndex.from_arrays(left + 1, right + 1)\r\n"]
[236.256892, "o", "\u001b[?2004l\r\n"]
[236.316458, "o", "\u001b[?2004h>     intv2._engine\r\n"]
[236.376024, "o", "\u001b[?2004l\r\n"]
[236.43559, "o", "\u001b[?2004h>     return intv, intv2\r\n"]
[236.495157, "o", "\u001b[?2004l\r\n"]
[236.554723, "o", "\u001b[?2004h> \r\n"]
[236.614289, "o", "\u001b[?2004l\r\n"]
[236.673855, "o", "\u001b[?2004h> N = 100_000\r\n"]
[236.733422, "o", "\u001b[?2004l\r\n"]
[236.792988, "o", "\u001b[?2004h> intv, intv2 = setup_both_dup(N)\r\n"]
[236.852554, "o", "\u001b[?2004l\r\n"]
[236.91212, "o", "\u001b[?2004h> pr = cProfile.Profile()\r\n"]
[236.971687, "o", "\u001b[?2004l\r\n"]
[237.031253, "o", "\u001b[?2004h> pr.enable()\r\n"]
[237.090819, "o", "\u001b[?2004l\r\n"]
[237.150386, "o", "\u001b[?2004h> _ = intv.intersection(intv2)\r\n"]
[237.209952, "o", "\u001b[?2004l\r\n"]
[237.269518, "o", "\u001b[?2004h> pr.disable()\r\n"]
[237.329084, "o", "\u001b[?2004l\r\n"]
[237.388651, "o", "\u001b[?2004h> ps = pstats.Stats(pr).sort_stats('cumtime')\r\n"]
[237.448217, "o", "\u001b[?2004l\r\n"]
[237.507783, "o", "\u001b[?2004h> ps.print_stats(30)\r\n"]
[237.567349, "o", "\u001b[?2004l\r\n"]
[237.626916, "o", "\u001b[?2004h> PY\r\n"]
[237.686482, "o", "\u001b[?2004l\r\n"]
[237.746048, "o", "         1105 function calls (1089 primitive calls) in 0.106 seconds\r\n"]
[237.805614, "o", "\r\n"]
[237.865181, "o", "   Ordered by: cumulative time\r\n"]
[237.924747, "o", "   List reduced from 154 to 30 due to restriction <30>\r\n"]
[237.984313, "o", "\r\n"]
[238.04388, "o", "   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n"]
[238.103446, "o", "        1    0.000    0.000    0.106    0.106 /workspace/repo/pandas/core/indexes/base.py:3251(intersection)\r\n"]
[238.163012, "o", "        1    0.009    0.009    0.106    0.106 /workspace/repo/pandas/core/indexes/interval.py:850(_intersection)\r\n"]
[238.222578, "o", "        1    0.093    0.093    0.095    0.095 /workspace/repo/pandas/core/indexes/interval.py:892(_intersection_non_unique)\r\n"]
[238.282145, "o", "        2    0.002    0.001    0.002    0.001 /workspace/repo/pandas/core/indexes/base.py:2174(is_unique)\r\n"]
[238.341711, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/indexes/base.py:5100(__getitem__)\r\n"]
[238.401277, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:715(__getitem__)\r\n"]
[238.460843, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:665(_shallow_copy)\r\n"]
[238.52041, "o", "        1    0.000    0.000    0.001    0.001 /workspace/repo/pandas/core/arrays/interval.py:635(_validate)\r\n"]
[238.579976, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:297(_ensure_simple_new_inputs)\r\n"]
[238.639542, "o", "      2/1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:5253(equals)\r\n"]
[238.699108, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:997(equals)\r\n"]
[238.758675, "o", "        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:449(__new__)\r\n"]
[238.818241, "o", "  312/306    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}\r\n"]
[238.877807, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:456(array_equivalent)\r\n"]
[238.937373, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/arrays/interval.py:1281(left)\r\n"]
[238.99694, "o", "        1    0.000    0.000    0.000    0.000 <__array_function__ internals>:177(array_equal)\r\n"]
[239.056506, "o", "        2    0.000    0.000    0.000    0.000 {built-in method numpy.core._multiarray_umath.implement_array_function}\r\n"]
[239.116072, "o", "        1    0.000    0.000    0.000    0.000 /opt/conda/envs/asv_3.8/lib/python3.8/site-packages/numpy/core/numeric.py:2407(array_equal)\r\n"]
[239.175639, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/dtypes.py:1083(__new__)\r\n"]
[239.235205, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:7010(ensure_index)\r\n"]
[239.294771, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:955(astype)\r\n"]
[239.354337, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:1143(copy)\r\n"]
[239.413904, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:106(isna)\r\n"]
[239.47347, "o", "        1    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:2670(hasnans)\r\n"]
[239.533036, "o", "       55    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/generic.py:42(_instancecheck)\r\n"]
[239.592602, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:353(notna)\r\n"]
[239.652169, "o", "        3    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/dtypes/missing.py:189(_isna)\r\n"]
[239.711735, "o", "        4    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/construction.py:500(sanitize_array)\r\n"]
[239.771301, "o", "        4    0.000    0.000    0.000    0.000 {method 'reduce' of 'numpy.ufunc' objects}\r\n"]
[239.830867, "o", "        2    0.000    0.000    0.000    0.000 /workspace/repo/pandas/core/indexes/base.py:794(_engine)\r\n"]
[239.890434, "o", "\r\n"]
[240.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[240.002, "i", "sed -n '820,960p' pandas/core/indexes/interval.py\r"]
[240.004, "o", "sed -n '820,960p' pandas/core/indexes/interval.py\r\n"]
[240.040817, "o", "\u001b[?2004l\r\n"]
[240.075634, "o", "    @cache_readonly\r\n"]
[240.110451, "o", "    def mid(self) -> Index:\r\n"]
[240.145268, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[240.180085, "o", "\r\n"]
[240.214901, "o", "    @property\r\n"]
[240.249718, "o", "    def length(self) -> Index:\r\n"]
[240.284535, "o", "        return Index(self._data.length, copy=False)\r\n"]
[240.319352, "o", "\r\n"]
[240.354169, "o", "    # --------------------------------------------------------------------\r\n"]
[240.388986, "o", "    # Rendering Methods\r\n"]
[240.423803, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[240.45862, "o", "\r\n"]
[240.493437, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[240.528254, "o", "        # matches base class except for whitespace padding\r\n"]
[240.56307, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[240.597887, "o", "\r\n"]
[240.632704, "o", "    def _format_native_types(\r\n"]
[240.667521, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[240.702338, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[240.737155, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[240.771972, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[240.806789, "o", "\r\n"]
[240.841606, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[240.876423, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[240.911239, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[240.946056, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[240.980873, "o", "\r\n"]
[241.01569, "o", "    # --------------------------------------------------------------------\r\n"]
[241.050507, "o", "    # Set Operations\r\n"]
[241.085324, "o", "\r\n"]
[241.120141, "o", "    def _intersection(self, other, sort):\r\n"]
[241.154958, "o", "        \"\"\"\r\n"]
[241.189775, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[241.224592, "o", "        \"\"\"\r\n"]
[241.259408, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[241.294225, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[241.329042, "o", "            taken = self._intersection_unique(other)\r\n"]
[241.363859, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[241.398676, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[241.433493, "o", "            # multiple NaNs\r\n"]
[241.46831, "o", "            taken = other._intersection_unique(self)\r\n"]
[241.503127, "o", "        else:\r\n"]
[241.537944, "o", "            # duplicates\r\n"]
[241.572761, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[241.607577, "o", "\r\n"]
[241.642394, "o", "        if sort is None:\r\n"]
[241.677211, "o", "            taken = taken.sort_values()\r\n"]
[241.712028, "o", "\r\n"]
[241.746845, "o", "        return taken\r\n"]
[241.781662, "o", "\r\n"]
[241.816479, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[241.851296, "o", "        \"\"\"\r\n"]
[241.886113, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[241.92093, "o", "        no matter left or right.\r\n"]
[241.955746, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[241.990563, "o", "        Parameters\r\n"]
[242.02538, "o", "        ----------\r\n"]
[242.060197, "o", "        other : IntervalIndex\r\n"]
[242.095014, "o", "        Returns\r\n"]
[242.129831, "o", "        -------\r\n"]
[242.164648, "o", "        IntervalIndex\r\n"]
[242.199465, "o", "        \"\"\"\r\n"]
[242.234282, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[242.269099, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[242.303915, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[242.338732, "o", "\r\n"]
[242.373549, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[242.408366, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[242.443183, "o", "        indexer = unique(indexer)\r\n"]
[242.478, "o", "\r\n"]
[242.512817, "o", "        return self.take(indexer)\r\n"]
[242.547634, "o", "\r\n"]
[242.582451, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[242.617268, "o", "        \"\"\"\r\n"]
[242.652085, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[242.686901, "o", "        on either sides.\r\n"]
[242.721718, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[242.756535, "o", "\r\n"]
[242.791352, "o", "        Parameters\r\n"]
[242.826169, "o", "        ----------\r\n"]
[242.860986, "o", "        other : IntervalIndex\r\n"]
[242.895803, "o", "\r\n"]
[242.93062, "o", "        Returns\r\n"]
[242.965437, "o", "        -------\r\n"]
[243.000254, "o", "        IntervalIndex\r\n"]
[243.03507, "o", "        \"\"\"\r\n"]
[243.069887, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[243.104704, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[243.139521, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[243.174338, "o", "\r\n"]
[243.209155, "o", "        if self.hasnans and other.hasnans:\r\n"]
[243.243972, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[243.278789, "o", "            mask[first_nan_loc] = True\r\n"]
[243.313606, "o", "\r\n"]
[243.348423, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[243.383239, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[243.418056, "o", "            if tup in other_tups:\r\n"]
[243.452873, "o", "                mask[i] = True\r\n"]
[243.48769, "o", "\r\n"]
[243.522507, "o", "        return self[mask]\r\n"]
[243.557324, "o", "\r\n"]
[243.592141, "o", "    # --------------------------------------------------------------------\r\n"]
[243.626958, "o", "\r\n"]
[243.661775, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[243.696592, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[243.731408, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[243.766225, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[243.801042, "o", "        raise NotImplementedError(\r\n"]
[243.835859, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[243.870676, "o", "            \"IndexEngine objects\"\r\n"]
[243.905493, "o", "        )\r\n"]
[243.94031, "o", "\r\n"]
[243.975127, "o", "    def _from_join_target(self, result):\r\n"]
[244.009944, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[244.044761, "o", "\r\n"]
[244.079577, "o", "    # TODO: arithmetic operations\r\n"]
[244.114394, "o", "\r\n"]
[244.149211, "o", "\r\n"]
[244.184028, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[244.218845, "o", "    \"\"\"\r\n"]
[244.253662, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[244.288479, "o", "    \"\"\"\r\n"]
[244.323296, "o", "    return any(\r\n"]
[244.358113, "o", "        [\r\n"]
[244.39293, "o", "            is_number(endpoint),\r\n"]
[244.427746, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[244.462563, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[244.49738, "o", "            endpoint is None,\r\n"]
[244.532197, "o", "        ]\r\n"]
[244.567014, "o", "    )\r\n"]
[244.601831, "o", "\r\n"]
[244.636648, "o", "\r\n"]
[244.671465, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[244.706282, "o", "    \"\"\"\r\n"]
[244.741099, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[244.775915, "o", "    \"\"\"\r\n"]
[244.810732, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[244.845549, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[244.880366, "o", "    return (\r\n"]
[244.915183, "o", "        (is_number(a) and is_number(b))\r\n"]
[245.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[245.002, "i", "sed -n '960,1120p' pandas/core/indexes/interval.py\r"]
[245.004, "o", "sed -n '960,1120p' pandas/core/indexes/interval.py\r\n"]
[245.036519, "o", "\u001b[?2004l\r\n"]
[245.067037, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[245.097556, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[245.128074, "o", "        or com.any_none(a, b)\r\n"]
[245.158593, "o", "    )\r\n"]
[245.189111, "o", "\r\n"]
[245.21963, "o", "\r\n"]
[245.250148, "o", "def interval_range(\r\n"]
[245.280667, "o", "    start=None,\r\n"]
[245.311185, "o", "    end=None,\r\n"]
[245.341704, "o", "    periods=None,\r\n"]
[245.372222, "o", "    freq=None,\r\n"]
[245.402741, "o", "    name: Hashable = None,\r\n"]
[245.433259, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[245.463778, "o", ") -> IntervalIndex:\r\n"]
[245.494296, "o", "    \"\"\"\r\n"]
[245.524815, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[245.555333, "o", "\r\n"]
[245.585852, "o", "    Parameters\r\n"]
[245.61637, "o", "    ----------\r\n"]
[245.646889, "o", "    start : numeric or datetime-like, default None\r\n"]
[245.677407, "o", "        Left bound for generating intervals.\r\n"]
[245.707926, "o", "    end : numeric or datetime-like, default None\r\n"]
[245.738444, "o", "        Right bound for generating intervals.\r\n"]
[245.768963, "o", "    periods : int, default None\r\n"]
[245.799481, "o", "        Number of periods to generate.\r\n"]
[245.83, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[245.860519, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[245.891037, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[245.921556, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[245.952074, "o", "    name : str, default None\r\n"]
[245.982593, "o", "        Name of the resulting IntervalIndex.\r\n"]
[246.013111, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[246.04363, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[246.074148, "o", "        or neither.\r\n"]
[246.104667, "o", "\r\n"]
[246.135185, "o", "    Returns\r\n"]
[246.165704, "o", "    -------\r\n"]
[246.196222, "o", "    IntervalIndex\r\n"]
[246.226741, "o", "\r\n"]
[246.257259, "o", "    See Also\r\n"]
[246.287778, "o", "    --------\r\n"]
[246.318296, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[246.348815, "o", "\r\n"]
[246.379333, "o", "    Notes\r\n"]
[246.409852, "o", "    -----\r\n"]
[246.44037, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[246.470889, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[246.501407, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[246.531926, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[246.562444, "o", "\r\n"]
[246.592963, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[246.623481, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[246.654, "o", "\r\n"]
[246.684519, "o", "    Examples\r\n"]
[246.715037, "o", "    --------\r\n"]
[246.745556, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[246.776074, "o", "\r\n"]
[246.806593, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[246.837111, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[246.86763, "o", "                  dtype='interval[int64, right]')\r\n"]
[246.898148, "o", "\r\n"]
[246.928667, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[246.959185, "o", "\r\n"]
[246.989704, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[247.020222, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[247.050741, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[247.081259, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[247.111778, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[247.142296, "o", "\r\n"]
[247.172815, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[247.203333, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[247.233852, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[247.26437, "o", "\r\n"]
[247.294889, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[247.325407, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[247.355926, "o", "                  dtype='interval[float64, right]')\r\n"]
[247.386444, "o", "\r\n"]
[247.416963, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[247.447481, "o", "    convertible to a DateOffset.\r\n"]
[247.478, "o", "\r\n"]
[247.508519, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[247.539037, "o", "    ...                   periods=3, freq='MS')\r\n"]
[247.569556, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[247.600074, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[247.630593, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[247.661111, "o", "\r\n"]
[247.69163, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[247.722148, "o", "    automatically (linearly spaced).\r\n"]
[247.752667, "o", "\r\n"]
[247.783185, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[247.813704, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[247.844222, "o", "              dtype='interval[float64, right]')\r\n"]
[247.874741, "o", "\r\n"]
[247.905259, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[247.935778, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[247.966296, "o", "\r\n"]
[247.996815, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[248.027333, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[248.057852, "o", "                  dtype='interval[int64, both]')\r\n"]
[248.08837, "o", "    \"\"\"\r\n"]
[248.118889, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[248.149407, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[248.179926, "o", "    endpoint = start if start is not None else end\r\n"]
[248.210444, "o", "\r\n"]
[248.240963, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[248.271481, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[248.302, "o", "\r\n"]
[248.332519, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[248.363037, "o", "        raise ValueError(\r\n"]
[248.393556, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[248.424074, "o", "            \"freq, exactly three must be specified\"\r\n"]
[248.454593, "o", "        )\r\n"]
[248.485111, "o", "\r\n"]
[248.51563, "o", "    if not _is_valid_endpoint(start):\r\n"]
[248.546148, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[248.576667, "o", "    if not _is_valid_endpoint(end):\r\n"]
[248.607185, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[248.637704, "o", "\r\n"]
[248.668222, "o", "    if is_float(periods):\r\n"]
[248.698741, "o", "        periods = int(periods)\r\n"]
[248.729259, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[248.759778, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[248.790296, "o", "\r\n"]
[248.820815, "o", "    if freq is not None and not is_number(freq):\r\n"]
[248.851333, "o", "        try:\r\n"]
[248.881852, "o", "            freq = to_offset(freq)\r\n"]
[248.91237, "o", "        except ValueError as err:\r\n"]
[248.942889, "o", "            raise ValueError(\r\n"]
[248.973407, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[249.003926, "o", "            ) from err\r\n"]
[249.034444, "o", "\r\n"]
[249.064963, "o", "    # verify type compatibility\r\n"]
[249.095481, "o", "    if not all(\r\n"]
[249.126, "o", "        [\r\n"]
[249.156519, "o", "            _is_type_compatible(start, end),\r\n"]
[249.187037, "o", "            _is_type_compatible(start, freq),\r\n"]
[249.217556, "o", "            _is_type_compatible(end, freq),\r\n"]
[249.248074, "o", "        ]\r\n"]
[249.278593, "o", "    ):\r\n"]
[249.309111, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[249.33963, "o", "\r\n"]
[249.370148, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[249.400667, "o", "    if periods is not None:\r\n"]
[249.431185, "o", "        periods += 1\r\n"]
[249.461704, "o", "\r\n"]
[249.492222, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[249.522741, "o", "\r\n"]
[249.553259, "o", "    if is_number(endpoint):\r\n"]
[249.583778, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[249.614296, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[249.644815, "o", "            end -= (end - start) % freq\r\n"]
[249.675333, "o", "\r\n"]
[249.705852, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[249.73637, "o", "        if periods is None:\r\n"]
[249.766889, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[249.797407, "o", "        elif start is None:\r\n"]
[249.827926, "o", "            start = end - (periods - 1) * freq\r\n"]
[249.858444, "o", "        elif end is None:\r\n"]
[249.888963, "o", "            end = start + (periods - 1) * freq\r\n"]
[249.919481, "o", "\r\n"]
[250.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[250.002, "i", "sed -n '1120,1280p' pandas/core/indexes/interval.py\r"]
[250.004, "o", "sed -n '1120,1280p' pandas/core/indexes/interval.py\r\n"]
[250.2532, "o", "\u001b[?2004l\r\n"]
[250.5004, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[250.7476, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[250.9948, "o", "            # np.linspace always produces float output\r\n"]
[251.242, "o", "\r\n"]
[251.4892, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[251.7364, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[251.9836, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[252.2308, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[252.478, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[252.7252, "o", "                np.dtype(\"int64\"),\r\n"]
[252.9724, "o", "            )\r\n"]
[253.2196, "o", "    else:\r\n"]
[253.4668, "o", "        # delegate to the appropriate range function\r\n"]
[253.714, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[253.9612, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[254.2084, "o", "        else:\r\n"]
[254.4556, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[254.7028, "o", "\r\n"]
[255.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[255.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py\r"]
[255.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py\r\n"]
[256.654, "o", "\u001b[?2004l\r\n"]
[258.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[260.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[260.002, "i", "sed -n '820,980p' pandas/core/indexes/interval.py\r"]
[260.004, "o", "sed -n '820,980p' pandas/core/indexes/interval.py\r\n"]
[260.036519, "o", "\u001b[?2004l\r\n"]
[260.067037, "o", "    @cache_readonly\r\n"]
[260.097556, "o", "    def mid(self) -> Index:\r\n"]
[260.128074, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[260.158593, "o", "\r\n"]
[260.189111, "o", "    @property\r\n"]
[260.21963, "o", "    def length(self) -> Index:\r\n"]
[260.250148, "o", "        return Index(self._data.length, copy=False)\r\n"]
[260.280667, "o", "\r\n"]
[260.311185, "o", "    # --------------------------------------------------------------------\r\n"]
[260.341704, "o", "    # Rendering Methods\r\n"]
[260.372222, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[260.402741, "o", "\r\n"]
[260.433259, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[260.463778, "o", "        # matches base class except for whitespace padding\r\n"]
[260.494296, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[260.524815, "o", "\r\n"]
[260.555333, "o", "    def _format_native_types(\r\n"]
[260.585852, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[260.61637, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[260.646889, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[260.677407, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[260.707926, "o", "\r\n"]
[260.738444, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[260.768963, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[260.799481, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[260.83, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[260.860519, "o", "\r\n"]
[260.891037, "o", "    # --------------------------------------------------------------------\r\n"]
[260.921556, "o", "    # Set Operations\r\n"]
[260.952074, "o", "\r\n"]
[260.982593, "o", "    def _intersection(self, other, sort):\r\n"]
[261.013111, "o", "        \"\"\"\r\n"]
[261.04363, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[261.074148, "o", "        \"\"\"\r\n"]
[261.104667, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[261.135185, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[261.165704, "o", "            taken = self._intersection_unique(other)\r\n"]
[261.196222, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[261.226741, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[261.257259, "o", "            # multiple NaNs\r\n"]
[261.287778, "o", "            taken = other._intersection_unique(self)\r\n"]
[261.318296, "o", "        else:\r\n"]
[261.348815, "o", "            # duplicates\r\n"]
[261.379333, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[261.409852, "o", "\r\n"]
[261.44037, "o", "        if sort is None:\r\n"]
[261.470889, "o", "            taken = taken.sort_values()\r\n"]
[261.501407, "o", "\r\n"]
[261.531926, "o", "        return taken\r\n"]
[261.562444, "o", "\r\n"]
[261.592963, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[261.623481, "o", "        \"\"\"\r\n"]
[261.654, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[261.684519, "o", "        no matter left or right.\r\n"]
[261.715037, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[261.745556, "o", "        Parameters\r\n"]
[261.776074, "o", "        ----------\r\n"]
[261.806593, "o", "        other : IntervalIndex\r\n"]
[261.837111, "o", "        Returns\r\n"]
[261.86763, "o", "        -------\r\n"]
[261.898148, "o", "        IntervalIndex\r\n"]
[261.928667, "o", "        \"\"\"\r\n"]
[261.959185, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[261.989704, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[262.020222, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[262.050741, "o", "\r\n"]
[262.081259, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[262.111778, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[262.142296, "o", "        indexer = unique(indexer)\r\n"]
[262.172815, "o", "\r\n"]
[262.203333, "o", "        return self.take(indexer)\r\n"]
[262.233852, "o", "\r\n"]
[262.26437, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[262.294889, "o", "        \"\"\"\r\n"]
[262.325407, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[262.355926, "o", "        on either sides.\r\n"]
[262.386444, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[262.416963, "o", "\r\n"]
[262.447481, "o", "        Parameters\r\n"]
[262.478, "o", "        ----------\r\n"]
[262.508519, "o", "        other : IntervalIndex\r\n"]
[262.539037, "o", "\r\n"]
[262.569556, "o", "        Returns\r\n"]
[262.600074, "o", "        -------\r\n"]
[262.630593, "o", "        IntervalIndex\r\n"]
[262.661111, "o", "        \"\"\"\r\n"]
[262.69163, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[262.722148, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[262.752667, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[262.783185, "o", "\r\n"]
[262.813704, "o", "        if self.hasnans and other.hasnans:\r\n"]
[262.844222, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[262.874741, "o", "            mask[first_nan_loc] = True\r\n"]
[262.905259, "o", "\r\n"]
[262.935778, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[262.966296, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[262.996815, "o", "            if tup in other_tups:\r\n"]
[263.027333, "o", "                mask[i] = True\r\n"]
[263.057852, "o", "\r\n"]
[263.08837, "o", "        return self[mask]\r\n"]
[263.118889, "o", "\r\n"]
[263.149407, "o", "    # --------------------------------------------------------------------\r\n"]
[263.179926, "o", "\r\n"]
[263.210444, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[263.240963, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[263.271481, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[263.302, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[263.332519, "o", "        raise NotImplementedError(\r\n"]
[263.363037, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[263.393556, "o", "            \"IndexEngine objects\"\r\n"]
[263.424074, "o", "        )\r\n"]
[263.454593, "o", "\r\n"]
[263.485111, "o", "    def _from_join_target(self, result):\r\n"]
[263.51563, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[263.546148, "o", "\r\n"]
[263.576667, "o", "    # TODO: arithmetic operations\r\n"]
[263.607185, "o", "\r\n"]
[263.637704, "o", "\r\n"]
[263.668222, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[263.698741, "o", "    \"\"\"\r\n"]
[263.729259, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[263.759778, "o", "    \"\"\"\r\n"]
[263.790296, "o", "    return any(\r\n"]
[263.820815, "o", "        [\r\n"]
[263.851333, "o", "            is_number(endpoint),\r\n"]
[263.881852, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[263.91237, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[263.942889, "o", "            endpoint is None,\r\n"]
[263.973407, "o", "        ]\r\n"]
[264.003926, "o", "    )\r\n"]
[264.034444, "o", "\r\n"]
[264.064963, "o", "\r\n"]
[264.095481, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[264.126, "o", "    \"\"\"\r\n"]
[264.156519, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[264.187037, "o", "    \"\"\"\r\n"]
[264.217556, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[264.248074, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[264.278593, "o", "    return (\r\n"]
[264.309111, "o", "        (is_number(a) and is_number(b))\r\n"]
[264.33963, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[264.370148, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[264.400667, "o", "        or com.any_none(a, b)\r\n"]
[264.431185, "o", "    )\r\n"]
[264.461704, "o", "\r\n"]
[264.492222, "o", "\r\n"]
[264.522741, "o", "def interval_range(\r\n"]
[264.553259, "o", "    start=None,\r\n"]
[264.583778, "o", "    end=None,\r\n"]
[264.614296, "o", "    periods=None,\r\n"]
[264.644815, "o", "    freq=None,\r\n"]
[264.675333, "o", "    name: Hashable = None,\r\n"]
[264.705852, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[264.73637, "o", ") -> IntervalIndex:\r\n"]
[264.766889, "o", "    \"\"\"\r\n"]
[264.797407, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[264.827926, "o", "\r\n"]
[264.858444, "o", "    Parameters\r\n"]
[264.888963, "o", "    ----------\r\n"]
[264.919481, "o", "    start : numeric or datetime-like, default None\r\n"]
[265.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[265.002, "i", "python - << 'PY'\r"]
[265.004, "o", "python - << 'PY'\r\n"]
[265.10488, "o", "\u001b[?2004l\r\n"]
[265.20376, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[265.30264, "o", "\u001b[?2004l\r\n"]
[265.40152, "o", "\u001b[?2004h> p = Path('pandas/core/indexes/interval.py')\r\n"]
[265.5004, "o", "\u001b[?2004l\r\n"]
[265.59928, "o", "\u001b[?2004h> text = p.read_text()\r\n"]
[265.69816, "o", "\u001b[?2004l\r\n"]
[265.79704, "o", "\u001b[?2004h> print('File length:', len(text), 'bytes')\r\n"]
[265.89592, "o", "\u001b[?2004l\r\n"]
[265.9948, "o", "\u001b[?2004h> start = text.find('_intersection_non_unique')\r\n"]
[266.09368, "o", "\u001b[?2004l\r\n"]
[266.19256, "o", "\u001b[?2004h> print('start index:', start)\r\n"]
[266.29144, "o", "\u001b[?2004l\r\n"]
[266.39032, "o", "\u001b[?2004h> print(text[max(0,start-300):start+800])\r\n"]
[266.4892, "o", "\u001b[?2004l\r\n"]
[266.58808, "o", "\u001b[?2004h> PY\r\n"]
[266.68696, "o", "\u001b[?2004l\r\n"]
[266.78584, "o", "File length: 38333 bytes\r\n"]
[266.88472, "o", "start index: 28489\r\n"]
[266.9836, "o", "   elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[267.08248, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[267.18136, "o", "            # multiple NaNs\r\n"]
[267.28024, "o", "            taken = other._intersection_unique(self)\r\n"]
[267.37912, "o", "        else:\r\n"]
[267.478, "o", "            # duplicates\r\n"]
[267.57688, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[267.67576, "o", "\r\n"]
[267.77464, "o", "        if sort is None:\r\n"]
[267.87352, "o", "            taken = taken.sort_values()\r\n"]
[267.9724, "o", "\r\n"]
[268.07128, "o", "        return taken\r\n"]
[268.17016, "o", "\r\n"]
[268.26904, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[268.36792, "o", "        \"\"\"\r\n"]
[268.4668, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[268.56568, "o", "        no matter left or right.\r\n"]
[268.66456, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[268.76344, "o", "        Parameters\r\n"]
[268.86232, "o", "        ----------\r\n"]
[268.9612, "o", "        other : IntervalIndex\r\n"]
[269.06008, "o", "        Returns\r\n"]
[269.15896, "o", "        -------\r\n"]
[269.25784, "o", "        IntervalIndex\r\n"]
[269.35672, "o", "        \"\"\"\r\n"]
[269.4556, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[269.55448, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[269.65336, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[269.75224, "o", "\r\n"]
[269.85112, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[270.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[270.002, "i", "python - << 'PY'\r"]
[270.004, "o", "python - << 'PY'\r\n"]
[270.053538, "o", "\u001b[?2004l\r\n"]
[270.101077, "o", "\u001b[?2004h> import io,sys\r\n"]
[270.148615, "o", "\u001b[?2004l\r\n"]
[270.196154, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[270.243692, "o", "\u001b[?2004l\r\n"]
[270.291231, "o", "\u001b[?2004h> p = Path('pandas/core/indexes/interval.py')\r\n"]
[270.338769, "o", "\u001b[?2004l\r\n"]
[270.386308, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[270.433846, "o", "\u001b[?2004l\r\n"]
[270.481385, "o", "\u001b[?2004h> anchor = s.find('def _intersection_non_unique')\r\n"]
[270.528923, "o", "\u001b[?2004l\r\n"]
[270.576462, "o", "\u001b[?2004h> if anchor==-1:\r\n"]
[270.624, "o", "\u001b[?2004l\r\n"]
[270.671538, "o", "\u001b[?2004h>     print('anchor not found')\r\n"]
[270.719077, "o", "\u001b[?2004l\r\n"]
[270.766615, "o", "\u001b[?2004h>     sys.exit(0)\r\n"]
[270.814154, "o", "\u001b[?2004l\r\n"]
[270.861692, "o", "\u001b[?2004h> # naive patch: insert fastpath after def line\r\n"]
[270.909231, "o", "\u001b[?2004l\r\n"]
[270.956769, "o", "\u001b[?2004h> lines = s.splitlines()\r\n"]
[271.004308, "o", "\u001b[?2004l\r\n"]
[271.051846, "o", "\u001b[?2004h> for i,l in enumerate(lines):\r\n"]
[271.099385, "o", "\u001b[?2004l\r\n"]
[271.146923, "o", "\u001b[?2004h>     if l.strip().startswith('def _intersection_non_unique'):\r\n"]
[271.194462, "o", "\u001b[?2004l\r\n"]
[271.242, "o", "\u001b[?2004h>         def_line=i\r\n"]
[271.289538, "o", "\u001b[?2004l\r\n"]
[271.337077, "o", "\u001b[?2004h>         break\r\n"]
[271.384615, "o", "\u001b[?2004l\r\n"]
[271.432154, "o", "\u001b[?2004h> # Find function indent and insert after signature\r\n"]
[271.479692, "o", "\u001b[?2004l\r\n"]
[271.527231, "o", "\u001b[?2004h> indent = lines[def_line][:len(lines[def_line]) - len(lines[def_line].lstrip())]\r\n"]
[271.574769, "o", "\u001b[?2004l\r\n"]
[271.622308, "o", "\u001b[?2004h> insert_at = def_line+1\r\n"]
[271.669846, "o", "\u001b[?2004l\r\n"]
[271.717385, "o", "\u001b[?2004h> fastpath = f\"{indent}    # Fastpath: vectorized intersection for same-dtype, non-object intervals\\n\" \\\r\n"]
[271.764923, "o", "\u001b[?2004l\r\n"]
[271.812462, "o", "\u001b[?2004h> + f\"{indent}    try:\\n\" \\\r\n"]
[271.86, "o", "\u001b[?2004l\r\n"]
[271.907538, "o", "\u001b[?2004h> + f\"{indent}        other = other  # ensure name exists\\n\" \\\r\n"]
[271.955077, "o", "\u001b[?2004l\r\n"]
[272.002615, "o", "\u001b[?2004h> + f\"{indent}        if (self.dtype == other.dtype and self.closed == other.closed):\\n\" \\\r\n"]
[272.050154, "o", "\u001b[?2004l\r\n"]
[272.097692, "o", "\u001b[?2004h> + f\"{indent}            left1 = self.left.values\\n\" \\\r\n"]
[272.145231, "o", "\u001b[?2004l\r\n"]
[272.192769, "o", "\u001b[?2004h> + f\"{indent}            right1 = self.right.values\\n\" \\\r\n"]
[272.240308, "o", "\u001b[?2004l\r\n"]
[272.287846, "o", "\u001b[?2004h> + f\"{indent}            left2 = other.left.values\\n\" \\\r\n"]
[272.335385, "o", "\u001b[?2004l\r\n"]
[272.382923, "o", "\u001b[?2004h> + f\"{indent}            right2 = other.right.values\\n\" \\\r\n"]
[272.430462, "o", "\u001b[?2004l\r\n"]
[272.478, "o", "\u001b[?2004h> + f\"{indent}            if (left1.dtype != object and right1.dtype != object and\\n\" \\\r\n"]
[272.525538, "o", "\u001b[?2004l\r\n"]
[272.573077, "o", "\u001b[?2004h> + f\"{indent}                left2.dtype == left1.dtype and right2.dtype == right1.dtype):\\n\" \\\r\n"]
[272.620615, "o", "\u001b[?2004l\r\n"]
[272.668154, "o", "\u001b[?2004h> + f\"{indent}                import numpy as np\\n\" \\\r\n"]
[272.715692, "o", "\u001b[?2004l\r\n"]
[272.763231, "o", "\u001b[?2004h> + f\"{indent}                dt = np.dtype([('l', left1.dtype), ('r', right1.dtype)])\\n\" \\\r\n"]
[272.810769, "o", "\u001b[?2004l\r\n"]
[272.858308, "o", "\u001b[?2004h> + f\"{indent}                a1 = np.empty(left1.shape[0], dtype=dt)\\n\" \\\r\n"]
[272.905846, "o", "\u001b[?2004l\r\n"]
[272.953385, "o", "\u001b[?2004h> + f\"{indent}                a2 = np.empty(left2.shape[0], dtype=dt)\\n\" \\\r\n"]
[273.000923, "o", "\u001b[?2004l\r\n"]
[273.048462, "o", "\u001b[?2004h> + f\"{indent}                a1['l'] = left1\\n\" \\\r\n"]
[273.096, "o", "\u001b[?2004l\r\n"]
[273.143538, "o", "\u001b[?2004h> + f\"{indent}                a1['r'] = right1\\n\" \\\r\n"]
[273.191077, "o", "\u001b[?2004l\r\n"]
[273.238615, "o", "\u001b[?2004h> + f\"{indent}                a2['l'] = left2\\n\" \\\r\n"]
[273.286154, "o", "\u001b[?2004l\r\n"]
[273.333692, "o", "\u001b[?2004h> + f\"{indent}                a2['r'] = right2\\n\" \\\r\n"]
[273.381231, "o", "\u001b[?2004l\r\n"]
[273.428769, "o", "\u001b[?2004h> + f\"{indent}                common = np.intersect1d(a1, a2, assume_unique=False)\\n\" \\\r\n"]
[273.476308, "o", "\u001b[?2004l\r\n"]
[273.523846, "o", "\u001b[?2004h> + f\"{indent}                # common is sorted and unique. Reconstruct IntervalIndex.\\n\" \\\r\n"]
[273.571385, "o", "\u001b[?2004l\r\n"]
[273.618923, "o", "\u001b[?2004h> + f\"{indent}                if common.size == 0:\\n\" \\\r\n"]
[273.666462, "o", "\u001b[?2004l\r\n"]
[273.714, "o", "\u001b[?2004h> + f\"{indent}                    return self[:0]\\n\" \\\r\n"]
[273.761538, "o", "\u001b[?2004l\r\n"]
[273.809077, "o", "\u001b[?2004h> + f\"{indent}                out_left = common['l']\\n\" \\\r\n"]
[273.856615, "o", "\u001b[?2004l\r\n"]
[273.904154, "o", "\u001b[?2004h> + f\"{indent}                out_right = common['r']\\n\" \\\r\n"]
[273.951692, "o", "\u001b[?2004l\r\n"]
[273.999231, "o", "\u001b[?2004h> + f\"{indent}                from pandas.core.indexes.interval import IntervalIndex as _II\\n\" \\\r\n"]
[274.046769, "o", "\u001b[?2004l\r\n"]
[274.094308, "o", "\u001b[?2004h> + f\"{indent}                return _II.from_arrays(out_left, out_right, closed=self.closed)\\n\" \\\r\n"]
[274.141846, "o", "\u001b[?2004l\r\n"]
[274.189385, "o", "\u001b[?2004h> + f\"{indent}    except Exception:\\n\" \\\r\n"]
[274.236923, "o", "\u001b[?2004l\r\n"]
[274.284462, "o", "\u001b[?2004h> + f\"{indent}        # fall back to existing implementation\\n\" \\\r\n"]
[274.332, "o", "\u001b[?2004l\r\n"]
[274.379538, "o", "\u001b[?2004h> + f\"{indent}        pass\\n\"\r\n"]
[274.427077, "o", "\u001b[?2004l\r\n"]
[274.474615, "o", "\u001b[?2004h> lines.insert(insert_at, fastpath)\r\n"]
[274.522154, "o", "\u001b[?2004l\r\n"]
[274.569692, "o", "\u001b[?2004h> new = \"\\n\".join(lines)\r\n"]
[274.617231, "o", "\u001b[?2004l\r\n"]
[274.664769, "o", "\u001b[?2004h> p.write_text(new)\r\n"]
[274.712308, "o", "\u001b[?2004l\r\n"]
[274.759846, "o", "\u001b[?2004h> print('Patched interval.py with fastpath')\r\n"]
[274.807385, "o", "\u001b[?2004l\r\n"]
[274.854923, "o", "\u001b[?2004h> PY\r\n"]
[274.902462, "o", "\u001b[?2004l\r\n"]
[275.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[275.002, "i", "python -m pyflakes pandas/core/indexes/interval.py 2>/dev/null || true\r"]
[275.004, "o", "python -m pyflakes pandas/core/indexes/interval.py 2>/dev/null || true\r\n"]
[275.006, "o", "\u001b[?2004l\r\n"]
[280.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[280.002, "i", "pytest -q -k \"IntervalIndex and intersection\" 2>/dev/null || true\r"]
[280.004, "o", "pytest -q -k \"IntervalIndex and intersection\" 2>/dev/null || true\r\n"]
[280.017942, "o", "\u001b[?2004l\r\n"]
[280.029884, "o", "cd asv_bench\r\n"]
[280.041826, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\"\r\n"]
[280.053768, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection\" \r\n"]
[280.06571, "o", "\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[31mF\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\r\n"]
[280.077652, "o", "=========================================================================== FAILURES ===========================================================================\r\n"]
[280.089594, "o", "\u001b[31m\u001b[1m________________________________________________________ TestIntervalIndex.test_intersection[left-None] ________________________________________________________\u001b[0m\r\n"]
[280.101536, "o", "\r\n"]
[280.113478, "o", "self = <pandas.tests.indexes.interval.test_setops.TestIntervalIndex object at 0x7fa7299ffa00>, closed = 'left', sort = None\r\n"]
[280.12542, "o", "\r\n"]
[280.137362, "o", "    def test_intersection(self, closed, sort):\r\n"]
[280.149304, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[280.161246, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[280.173188, "o", "    \r\n"]
[280.18513, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[280.197072, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[280.209014, "o", "        if sort is None:\r\n"]
[280.220957, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[280.232899, "o", "        assert tm.equalContents(result, expected)\r\n"]
[280.244841, "o", "    \r\n"]
[280.256783, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[280.268725, "o", "        if sort is None:\r\n"]
[280.280667, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[280.292609, "o", "        assert tm.equalContents(result, expected)\r\n"]
[280.304551, "o", "    \r\n"]
[280.316493, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[280.328435, "o", "    \r\n"]
[280.340377, "o", "        # GH 26225: nested intervals\r\n"]
[280.352319, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[280.364261, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[280.376203, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[280.388145, "o", "        result = index.intersection(other)\r\n"]
[280.400087, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[280.412029, "o", "    \r\n"]
[280.423971, "o", "        # GH 26225\r\n"]
[280.435913, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[280.447855, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[280.459797, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[280.471739, "o", "        result = index.intersection(other)\r\n"]
[280.483681, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[280.495623, "o", "    \r\n"]
[280.507565, "o", "        # GH 26225: duplicate nan element\r\n"]
[280.519507, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[280.531449, "o", "        other = IntervalIndex([np.nan])\r\n"]
[280.543391, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[280.555333, "o", "        result = index.intersection(other)\r\n"]
[280.567275, "o", ">       tm.assert_index_equal(result, expected)\r\n"]
[280.579217, "o", "\u001b[1m\u001b[31mE       AssertionError: Index are different\u001b[0m\r\n"]
[280.591159, "o", "\u001b[1m\u001b[31mE       \u001b[0m\r\n"]
[280.603101, "o", "\u001b[1m\u001b[31mE       Index length are different\u001b[0m\r\n"]
[280.615043, "o", "\u001b[1m\u001b[31mE       [left]:  0, IntervalIndex([], dtype='interval[float64, right]')\u001b[0m\r\n"]
[280.626986, "o", "\u001b[1m\u001b[31mE       [right]: 1, IntervalIndex([nan], dtype='interval[float64, right]')\u001b[0m\r\n"]
[280.638928, "o", "\r\n"]
[280.65087, "o", "\u001b[1m\u001b[31mpandas/tests/indexes/interval/test_setops.py\u001b[0m:98: AssertionError\r\n"]
[280.662812, "o", "\u001b[31m\u001b[1m_______________________________________________________ TestIntervalIndex.test_intersection[left-False] ________________________________________________________\u001b[0m\r\n"]
[280.674754, "o", "\r\n"]
[280.686696, "o", "self = <pandas.tests.indexes.interval.test_setops.TestIntervalIndex object at 0x7fa7299ff970>, closed = 'left', sort = False\r\n"]
[280.698638, "o", "\r\n"]
[280.71058, "o", "    def test_intersection(self, closed, sort):\r\n"]
[280.722522, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[280.734464, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[280.746406, "o", "    \r\n"]
[280.758348, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[280.77029, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[280.782232, "o", "        if sort is None:\r\n"]
[280.794174, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[280.806116, "o", "        assert tm.equalContents(result, expected)\r\n"]
[280.818058, "o", "    \r\n"]
[280.83, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[280.841942, "o", "        if sort is None:\r\n"]
[280.853884, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[280.865826, "o", "        assert tm.equalContents(result, expected)\r\n"]
[280.877768, "o", "    \r\n"]
[280.88971, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[280.901652, "o", "    \r\n"]
[280.913594, "o", "        # GH 26225: nested intervals\r\n"]
[280.925536, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[280.937478, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[280.94942, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[280.961362, "o", "        result = index.intersection(other)\r\n"]
[280.973304, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[280.985246, "o", "    \r\n"]
[280.997188, "o", "        # GH 26225\r\n"]
[281.00913, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[281.021072, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[281.033014, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[281.044957, "o", "        result = index.intersection(other)\r\n"]
[281.056899, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[281.068841, "o", "    \r\n"]
[281.080783, "o", "        # GH 26225: duplicate nan element\r\n"]
[281.092725, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[281.104667, "o", "        other = IntervalIndex([np.nan])\r\n"]
[281.116609, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[281.128551, "o", "        result = index.intersection(other)\r\n"]
[281.140493, "o", ">       tm.assert_index_equal(result, expected)\r\n"]
[281.152435, "o", "\u001b[1m\u001b[31mE       AssertionError: Index are different\u001b[0m\r\n"]
[281.164377, "o", "\u001b[1m\u001b[31mE       \u001b[0m\r\n"]
[281.176319, "o", "\u001b[1m\u001b[31mE       Index length are different\u001b[0m\r\n"]
[281.188261, "o", "\u001b[1m\u001b[31mE       [left]:  0, IntervalIndex([], dtype='interval[float64, right]')\u001b[0m\r\n"]
[281.200203, "o", "\u001b[1m\u001b[31mE       [right]: 1, IntervalIndex([nan], dtype='interval[float64, right]')\u001b[0m\r\n"]
[281.212145, "o", "\r\n"]
[281.224087, "o", "\u001b[1m\u001b[31mpandas/tests/indexes/interval/test_setops.py\u001b[0m:98: AssertionError\r\n"]
[281.236029, "o", "\u001b[31m\u001b[1m_______________________________________________________ TestIntervalIndex.test_intersection[right-None] ________________________________________________________\u001b[0m\r\n"]
[281.247971, "o", "\r\n"]
[281.259913, "o", "self = <pandas.tests.indexes.interval.test_setops.TestIntervalIndex object at 0x7fa7299ffa60>, closed = 'right', sort = None\r\n"]
[281.271855, "o", "\r\n"]
[281.283797, "o", "    def test_intersection(self, closed, sort):\r\n"]
[281.295739, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[281.307681, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[281.319623, "o", "    \r\n"]
[281.331565, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[281.343507, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[281.355449, "o", "        if sort is None:\r\n"]
[281.367391, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[281.379333, "o", "        assert tm.equalContents(result, expected)\r\n"]
[281.391275, "o", "    \r\n"]
[281.403217, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[281.415159, "o", "        if sort is None:\r\n"]
[281.427101, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[281.439043, "o", "        assert tm.equalContents(result, expected)\r\n"]
[281.450986, "o", "    \r\n"]
[281.462928, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[281.47487, "o", "    \r\n"]
[281.486812, "o", "        # GH 26225: nested intervals\r\n"]
[281.498754, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[281.510696, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[281.522638, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[281.53458, "o", "        result = index.intersection(other)\r\n"]
[281.546522, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[281.558464, "o", "    \r\n"]
[281.570406, "o", "        # GH 26225\r\n"]
[281.582348, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[281.59429, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[281.606232, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[281.618174, "o", "        result = index.intersection(other)\r\n"]
[281.630116, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[281.642058, "o", "    \r\n"]
[281.654, "o", "        # GH 26225: duplicate nan element\r\n"]
[281.665942, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[281.677884, "o", "        other = IntervalIndex([np.nan])\r\n"]
[281.689826, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[281.701768, "o", "        result = index.intersection(other)\r\n"]
[281.71371, "o", ">       tm.assert_index_equal(result, expected)\r\n"]
[281.725652, "o", "\u001b[1m\u001b[31mE       AssertionError: Index are different\u001b[0m\r\n"]
[281.737594, "o", "\u001b[1m\u001b[31mE       \u001b[0m\r\n"]
[281.749536, "o", "\u001b[1m\u001b[31mE       Index length are different\u001b[0m\r\n"]
[281.761478, "o", "\u001b[1m\u001b[31mE       [left]:  0, IntervalIndex([], dtype='interval[float64, right]')\u001b[0m\r\n"]
[281.77342, "o", "\u001b[1m\u001b[31mE       [right]: 1, IntervalIndex([nan], dtype='interval[float64, right]')\u001b[0m\r\n"]
[281.785362, "o", "\r\n"]
[281.797304, "o", "\u001b[1m\u001b[31mpandas/tests/indexes/interval/test_setops.py\u001b[0m:98: AssertionError\r\n"]
[281.809246, "o", "\u001b[31m\u001b[1m_______________________________________________________ TestIntervalIndex.test_intersection[right-False] _______________________________________________________\u001b[0m\r\n"]
[281.821188, "o", "\r\n"]
[281.83313, "o", "self = <pandas.tests.indexes.interval.test_setops.TestIntervalIndex object at 0x7fa7299ff910>, closed = 'right', sort = False\r\n"]
[281.845072, "o", "\r\n"]
[281.857014, "o", "    def test_intersection(self, closed, sort):\r\n"]
[281.868957, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[281.880899, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[281.892841, "o", "    \r\n"]
[281.904783, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[281.916725, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[281.928667, "o", "        if sort is None:\r\n"]
[281.940609, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[281.952551, "o", "        assert tm.equalContents(result, expected)\r\n"]
[281.964493, "o", "    \r\n"]
[281.976435, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[281.988377, "o", "        if sort is None:\r\n"]
[282.000319, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[282.012261, "o", "        assert tm.equalContents(result, expected)\r\n"]
[282.024203, "o", "    \r\n"]
[282.036145, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[282.048087, "o", "    \r\n"]
[282.060029, "o", "        # GH 26225: nested intervals\r\n"]
[282.071971, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[282.083913, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[282.095855, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[282.107797, "o", "        result = index.intersection(other)\r\n"]
[282.119739, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[282.131681, "o", "    \r\n"]
[282.143623, "o", "        # GH 26225\r\n"]
[282.155565, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[282.167507, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[282.179449, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[282.191391, "o", "        result = index.intersection(other)\r\n"]
[282.203333, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[282.215275, "o", "    \r\n"]
[282.227217, "o", "        # GH 26225: duplicate nan element\r\n"]
[282.239159, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[282.251101, "o", "        other = IntervalIndex([np.nan])\r\n"]
[282.263043, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[282.274986, "o", "        result = index.intersection(other)\r\n"]
[282.286928, "o", ">       tm.assert_index_equal(result, expected)\r\n"]
[282.29887, "o", "\u001b[1m\u001b[31mE       AssertionError: Index are different\u001b[0m\r\n"]
[282.310812, "o", "\u001b[1m\u001b[31mE       \u001b[0m\r\n"]
[282.322754, "o", "\u001b[1m\u001b[31mE       Index length are different\u001b[0m\r\n"]
[282.334696, "o", "\u001b[1m\u001b[31mE       [left]:  0, IntervalIndex([], dtype='interval[float64, right]')\u001b[0m\r\n"]
[282.346638, "o", "\u001b[1m\u001b[31mE       [right]: 1, IntervalIndex([nan], dtype='interval[float64, right]')\u001b[0m\r\n"]
[282.35858, "o", "\r\n"]
[282.370522, "o", "\u001b[1m\u001b[31mpandas/tests/indexes/interval/test_setops.py\u001b[0m:98: AssertionError\r\n"]
[282.382464, "o", "\u001b[31m\u001b[1m________________________________________________________ TestIntervalIndex.test_intersection[both-None] ________________________________________________________\u001b[0m\r\n"]
[282.394406, "o", "\r\n"]
[282.406348, "o", "self = <pandas.tests.indexes.interval.test_setops.TestIntervalIndex object at 0x7fa7299ffee0>, closed = 'both', sort = None\r\n"]
[282.41829, "o", "\r\n"]
[282.430232, "o", "    def test_intersection(self, closed, sort):\r\n"]
[282.442174, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[282.454116, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[282.466058, "o", "    \r\n"]
[282.478, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[282.489942, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[282.501884, "o", "        if sort is None:\r\n"]
[282.513826, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[282.525768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[282.53771, "o", "    \r\n"]
[282.549652, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[282.561594, "o", "        if sort is None:\r\n"]
[282.573536, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[282.585478, "o", "        assert tm.equalContents(result, expected)\r\n"]
[282.59742, "o", "    \r\n"]
[282.609362, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[282.621304, "o", "    \r\n"]
[282.633246, "o", "        # GH 26225: nested intervals\r\n"]
[282.645188, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[282.65713, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[282.669072, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[282.681014, "o", "        result = index.intersection(other)\r\n"]
[282.692957, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[282.704899, "o", "    \r\n"]
[282.716841, "o", "        # GH 26225\r\n"]
[282.728783, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[282.740725, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[282.752667, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[282.764609, "o", "        result = index.intersection(other)\r\n"]
[282.776551, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[282.788493, "o", "    \r\n"]
[282.800435, "o", "        # GH 26225: duplicate nan element\r\n"]
[282.812377, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[282.824319, "o", "        other = IntervalIndex([np.nan])\r\n"]
[282.836261, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[282.848203, "o", "        result = index.intersection(other)\r\n"]
[282.860145, "o", ">       tm.assert_index_equal(result, expected)\r\n"]
[282.872087, "o", "\u001b[1m\u001b[31mE       AssertionError: Index are different\u001b[0m\r\n"]
[282.884029, "o", "\u001b[1m\u001b[31mE       \u001b[0m\r\n"]
[282.895971, "o", "\u001b[1m\u001b[31mE       Index length are different\u001b[0m\r\n"]
[282.907913, "o", "\u001b[1m\u001b[31mE       [left]:  0, IntervalIndex([], dtype='interval[float64, right]')\u001b[0m\r\n"]
[282.919855, "o", "\u001b[1m\u001b[31mE       [right]: 1, IntervalIndex([nan], dtype='interval[float64, right]')\u001b[0m\r\n"]
[282.931797, "o", "\r\n"]
[282.943739, "o", "\u001b[1m\u001b[31mpandas/tests/indexes/interval/test_setops.py\u001b[0m:98: AssertionError\r\n"]
[282.955681, "o", "\u001b[31m\u001b[1m_______________________________________________________ TestIntervalIndex.test_intersection[both-False] ________________________________________________________\u001b[0m\r\n"]
[282.967623, "o", "\r\n"]
[282.979565, "o", "self = <pandas.tests.indexes.interval.test_setops.TestIntervalIndex object at 0x7fa7299ff700>, closed = 'both', sort = False\r\n"]
[282.991507, "o", "\r\n"]
[283.003449, "o", "    def test_intersection(self, closed, sort):\r\n"]
[283.015391, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[283.027333, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[283.039275, "o", "    \r\n"]
[283.051217, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[283.063159, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[283.075101, "o", "        if sort is None:\r\n"]
[283.087043, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[283.098986, "o", "        assert tm.equalContents(result, expected)\r\n"]
[283.110928, "o", "    \r\n"]
[283.12287, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[283.134812, "o", "        if sort is None:\r\n"]
[283.146754, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[283.158696, "o", "        assert tm.equalContents(result, expected)\r\n"]
[283.170638, "o", "    \r\n"]
[283.18258, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[283.194522, "o", "    \r\n"]
[283.206464, "o", "        # GH 26225: nested intervals\r\n"]
[283.218406, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[283.230348, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[283.24229, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[283.254232, "o", "        result = index.intersection(other)\r\n"]
[283.266174, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[283.278116, "o", "    \r\n"]
[283.290058, "o", "        # GH 26225\r\n"]
[283.302, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[283.313942, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[283.325884, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[283.337826, "o", "        result = index.intersection(other)\r\n"]
[283.349768, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[283.36171, "o", "    \r\n"]
[283.373652, "o", "        # GH 26225: duplicate nan element\r\n"]
[283.385594, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[283.397536, "o", "        other = IntervalIndex([np.nan])\r\n"]
[283.409478, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[283.42142, "o", "        result = index.intersection(other)\r\n"]
[283.433362, "o", ">       tm.assert_index_equal(result, expected)\r\n"]
[283.445304, "o", "\u001b[1m\u001b[31mE       AssertionError: Index are different\u001b[0m\r\n"]
[283.457246, "o", "\u001b[1m\u001b[31mE       \u001b[0m\r\n"]
[283.469188, "o", "\u001b[1m\u001b[31mE       Index length are different\u001b[0m\r\n"]
[283.48113, "o", "\u001b[1m\u001b[31mE       [left]:  0, IntervalIndex([], dtype='interval[float64, right]')\u001b[0m\r\n"]
[283.493072, "o", "\u001b[1m\u001b[31mE       [right]: 1, IntervalIndex([nan], dtype='interval[float64, right]')\u001b[0m\r\n"]
[283.505014, "o", "\r\n"]
[283.516957, "o", "\u001b[1m\u001b[31mpandas/tests/indexes/interval/test_setops.py\u001b[0m:98: AssertionError\r\n"]
[283.528899, "o", "\u001b[31m\u001b[1m______________________________________________________ TestIntervalIndex.test_intersection[neither-None] _______________________________________________________\u001b[0m\r\n"]
[283.540841, "o", "\r\n"]
[283.552783, "o", "self = <pandas.tests.indexes.interval.test_setops.TestIntervalIndex object at 0x7fa729a18070>, closed = 'neither', sort = None\r\n"]
[283.564725, "o", "\r\n"]
[283.576667, "o", "    def test_intersection(self, closed, sort):\r\n"]
[283.588609, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[283.600551, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[283.612493, "o", "    \r\n"]
[283.624435, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[283.636377, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[283.648319, "o", "        if sort is None:\r\n"]
[283.660261, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[283.672203, "o", "        assert tm.equalContents(result, expected)\r\n"]
[283.684145, "o", "    \r\n"]
[283.696087, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[283.708029, "o", "        if sort is None:\r\n"]
[283.719971, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[283.731913, "o", "        assert tm.equalContents(result, expected)\r\n"]
[283.743855, "o", "    \r\n"]
[283.755797, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[283.767739, "o", "    \r\n"]
[283.779681, "o", "        # GH 26225: nested intervals\r\n"]
[283.791623, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[283.803565, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[283.815507, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[283.827449, "o", "        result = index.intersection(other)\r\n"]
[283.839391, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[283.851333, "o", "    \r\n"]
[283.863275, "o", "        # GH 26225\r\n"]
[283.875217, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[283.887159, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[283.899101, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[283.911043, "o", "        result = index.intersection(other)\r\n"]
[283.922986, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[283.934928, "o", "    \r\n"]
[283.94687, "o", "        # GH 26225: duplicate nan element\r\n"]
[283.958812, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[283.970754, "o", "        other = IntervalIndex([np.nan])\r\n"]
[283.982696, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[283.994638, "o", "        result = index.intersection(other)\r\n"]
[284.00658, "o", ">       tm.assert_index_equal(result, expected)\r\n"]
[284.018522, "o", "\u001b[1m\u001b[31mE       AssertionError: Index are different\u001b[0m\r\n"]
[284.030464, "o", "\u001b[1m\u001b[31mE       \u001b[0m\r\n"]
[284.042406, "o", "\u001b[1m\u001b[31mE       Index length are different\u001b[0m\r\n"]
[284.054348, "o", "\u001b[1m\u001b[31mE       [left]:  0, IntervalIndex([], dtype='interval[float64, right]')\u001b[0m\r\n"]
[284.06629, "o", "\u001b[1m\u001b[31mE       [right]: 1, IntervalIndex([nan], dtype='interval[float64, right]')\u001b[0m\r\n"]
[284.078232, "o", "\r\n"]
[284.090174, "o", "\u001b[1m\u001b[31mpandas/tests/indexes/interval/test_setops.py\u001b[0m:98: AssertionError\r\n"]
[284.102116, "o", "\u001b[31m\u001b[1m______________________________________________________ TestIntervalIndex.test_intersection[neither-False] ______________________________________________________\u001b[0m\r\n"]
[284.114058, "o", "\r\n"]
[284.126, "o", "self = <pandas.tests.indexes.interval.test_setops.TestIntervalIndex object at 0x7fa729a18130>, closed = 'neither', sort = False\r\n"]
[284.137942, "o", "\r\n"]
[284.149884, "o", "    def test_intersection(self, closed, sort):\r\n"]
[284.161826, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[284.173768, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[284.18571, "o", "    \r\n"]
[284.197652, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[284.209594, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[284.221536, "o", "        if sort is None:\r\n"]
[284.233478, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[284.24542, "o", "        assert tm.equalContents(result, expected)\r\n"]
[284.257362, "o", "    \r\n"]
[284.269304, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[284.281246, "o", "        if sort is None:\r\n"]
[284.293188, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[284.30513, "o", "        assert tm.equalContents(result, expected)\r\n"]
[284.317072, "o", "    \r\n"]
[284.329014, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[284.340957, "o", "    \r\n"]
[284.352899, "o", "        # GH 26225: nested intervals\r\n"]
[284.364841, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[284.376783, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[284.388725, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[284.400667, "o", "        result = index.intersection(other)\r\n"]
[284.412609, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[284.424551, "o", "    \r\n"]
[284.436493, "o", "        # GH 26225\r\n"]
[284.448435, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[284.460377, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[284.472319, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[284.484261, "o", "        result = index.intersection(other)\r\n"]
[284.496203, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[284.508145, "o", "    \r\n"]
[284.520087, "o", "        # GH 26225: duplicate nan element\r\n"]
[284.532029, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[284.543971, "o", "        other = IntervalIndex([np.nan])\r\n"]
[284.555913, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[284.567855, "o", "        result = index.intersection(other)\r\n"]
[284.579797, "o", ">       tm.assert_index_equal(result, expected)\r\n"]
[284.591739, "o", "\u001b[1m\u001b[31mE       AssertionError: Index are different\u001b[0m\r\n"]
[284.603681, "o", "\u001b[1m\u001b[31mE       \u001b[0m\r\n"]
[284.615623, "o", "\u001b[1m\u001b[31mE       Index length are different\u001b[0m\r\n"]
[284.627565, "o", "\u001b[1m\u001b[31mE       [left]:  0, IntervalIndex([], dtype='interval[float64, right]')\u001b[0m\r\n"]
[284.639507, "o", "\u001b[1m\u001b[31mE       [right]: 1, IntervalIndex([nan], dtype='interval[float64, right]')\u001b[0m\r\n"]
[284.651449, "o", "\r\n"]
[284.663391, "o", "\u001b[1m\u001b[31mpandas/tests/indexes/interval/test_setops.py\u001b[0m:98: AssertionError\r\n"]
[284.675333, "o", "\u001b[33m======================================================================= warnings summary =======================================================================\u001b[0m\r\n"]
[284.687275, "o", "pandas/core/construction.py:335\r\n"]
[284.699217, "o", "  /workspace/repo/pandas/core/construction.py:335: UserWarning: pyarrow requires pandas 1.0.0 or above, pandas 0+untagged.31506.g5f584bd.dirty is installed. Therefore, pandas-specific integration is not used.\r\n"]
[284.711159, "o", "    return cls._from_sequence(data, dtype=dtype, copy=copy)\r\n"]
[284.723101, "o", "\r\n"]
[284.735043, "o", "-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\r\n"]
[284.746986, "o", "------------------------------------------------------ generated xml file: /workspace/repo/test-data.xml -------------------------------------------------------\r\n"]
[284.758928, "o", "===================================================================== slowest 30 durations =====================================================================\r\n"]
[284.77087, "o", "0.01s call     pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection[right-None]\r\n"]
[284.782812, "o", "0.01s call     pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection[left-None]\r\n"]
[284.794754, "o", "0.01s call     pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection[both-None]\r\n"]
[284.806696, "o", "0.01s call     pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection[neither-None]\r\n"]
[284.818638, "o", "\r\n"]
[284.83058, "o", "(26 durations < 0.005s hidden.  Use -vv to show these durations.)\r\n"]
[284.842522, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n"]
[284.854464, "o", "\u001b[31mFAILED\u001b[0m pandas/tests/indexes/interval/test_setops.py::\u001b[1mTestIntervalIndex::test_intersection[left-None]\u001b[0m - AssertionError: Index are different\r\n"]
[284.866406, "o", "\u001b[31mFAILED\u001b[0m pandas/tests/indexes/interval/test_setops.py::\u001b[1mTestIntervalIndex::test_intersection[left-False]\u001b[0m - AssertionError: Index are different\r\n"]
[284.878348, "o", "\u001b[31mFAILED\u001b[0m pandas/tests/indexes/interval/test_setops.py::\u001b[1mTestIntervalIndex::test_intersection[right-None]\u001b[0m - AssertionError: Index are different\r\n"]
[284.89029, "o", "\u001b[31mFAILED\u001b[0m pandas/tests/indexes/interval/test_setops.py::\u001b[1mTestIntervalIndex::test_intersection[right-False]\u001b[0m - AssertionError: Index are different\r\n"]
[284.902232, "o", "\u001b[31mFAILED\u001b[0m pandas/tests/indexes/interval/test_setops.py::\u001b[1mTestIntervalIndex::test_intersection[both-None]\u001b[0m - AssertionError: Index are different\r\n"]
[284.914174, "o", "\u001b[31mFAILED\u001b[0m pandas/tests/indexes/interval/test_setops.py::\u001b[1mTestIntervalIndex::test_intersection[both-False]\u001b[0m - AssertionError: Index are different\r\n"]
[284.926116, "o", "\u001b[31mFAILED\u001b[0m pandas/tests/indexes/interval/test_setops.py::\u001b[1mTestIntervalIndex::test_intersection[neither-None]\u001b[0m - AssertionError: Index are different\r\n"]
[284.938058, "o", "\u001b[31mFAILED\u001b[0m pandas/tests/indexes/interval/test_setops.py::\u001b[1mTestIntervalIndex::test_intersection[neither-False]\u001b[0m - AssertionError: Index are different\r\n"]
[285.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[285.002, "i", "cd asv_bench\r"]
[285.004, "o", "cd asv_bench\r\n"]
[285.006, "o", "\u001b[?2004l\r\n"]
[290.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[290.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[290.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[295.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[295.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[295.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[295.418, "o", "\u001b[?2004l\r\n"]
[295.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[296.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[296.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[297.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[297.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[297.89, "o", "              param1            \r\n"]
[298.302, "o", "             -------- ----------\r\n"]
[298.714, "o", "               1000    3.83\u00b10ms \r\n"]
[299.126, "o", "              100000   655\u00b10ms  \r\n"]
[299.538, "o", "             ======== ==========\r\n"]
[300.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[300.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection\" \r"]
[300.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection\" \r\n"]
[300.182571, "o", "\u001b[?2004l\r\n"]
[300.359143, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[300.535714, "o", "\u00b7 \u001b[0;32mRunning 3 total benchmarks (1 commits * 1 environments * 3 benchmarks)\u001b[0m\r\n"]
[300.712286, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[300.888857, "o", "[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection\u001b[0m                                                                                              ok\r\n"]
[301.065429, "o", "[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[301.242, "o", "              param1            \r\n"]
[301.418571, "o", "             -------- ----------\r\n"]
[301.595143, "o", "               1000    995\u00b10\u03bcs  \r\n"]
[301.771714, "o", "              100000   8.13\u00b10ms \r\n"]
[301.948286, "o", "             ======== ==========\r\n"]
[302.124857, "o", "\r\n"]
[302.301429, "o", "[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[302.478, "o", "[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[302.654571, "o", "              param1            \r\n"]
[302.831143, "o", "             -------- ----------\r\n"]
[303.007714, "o", "               1000    3.81\u00b10ms \r\n"]
[303.184286, "o", "              100000   655\u00b10ms  \r\n"]
[303.360857, "o", "             ======== ==========\r\n"]
[303.537429, "o", "\r\n"]
[303.714, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_one_duplicate\u001b[0m                                                                                ok\r\n"]
[303.890571, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[304.067143, "o", "              param1            \r\n"]
[304.243714, "o", "             -------- ----------\r\n"]
[304.420286, "o", "               1000    829\u00b10\u03bcs  \r\n"]
[304.596857, "o", "              100000   8.95\u00b10ms \r\n"]
[304.773429, "o", "             ======== ==========\r\n"]
[305.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[305.002, "i", "git checkout -- pandas/core/indexes/interval.py\r"]
[305.004, "o", "git checkout -- pandas/core/indexes/interval.py\r\n"]
[307.478, "o", "\u001b[?2004l\r\n"]
[310.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[310.002, "i", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/n\r"]
[310.004, "o", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/n\r\n"]
[312.478, "o", "null || true\r\n"]
[315.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[315.002, "i", "cd asv_bench\r"]
[315.004, "o", "cd asv_bench\r\n"]
[317.478, "o", "\u001b[?2004l\r\n"]
[320.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[320.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[320.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[325.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[325.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[325.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[325.418, "o", "\u001b[?2004l\r\n"]
[325.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[326.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[326.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[327.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[327.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[327.89, "o", "              param1            \r\n"]
[328.302, "o", "             -------- ----------\r\n"]
[328.714, "o", "               1000    3.88\u00b10ms \r\n"]
[329.126, "o", "              100000   682\u00b10ms  \r\n"]
[329.538, "o", "             ======== ==========\r\n"]
[330.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[330.002, "i", "cd ..\r"]
[330.004, "o", "cd ..\r\n"]
[330.006, "o", "\u001b[?2004l\r\n"]
[335.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[335.002, "i", "grep -n \"def _intersection_non_unique\" pandas/core/indexes/interval.py\r"]
[335.004, "o", "grep -n \"def _intersection_non_unique\" pandas/core/indexes/interval.py\r\n"]
[337.478, "o", "\u001b[?2004l\r\n"]
[340.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[340.002, "i", "sed -n '820,980p' pandas/core/indexes/interval.py\r"]
[340.004, "o", "sed -n '820,980p' pandas/core/indexes/interval.py\r\n"]
[340.036519, "o", "\u001b[?2004l\r\n"]
[340.067037, "o", "    @cache_readonly\r\n"]
[340.097556, "o", "    def mid(self) -> Index:\r\n"]
[340.128074, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[340.158593, "o", "\r\n"]
[340.189111, "o", "    @property\r\n"]
[340.21963, "o", "    def length(self) -> Index:\r\n"]
[340.250148, "o", "        return Index(self._data.length, copy=False)\r\n"]
[340.280667, "o", "\r\n"]
[340.311185, "o", "    # --------------------------------------------------------------------\r\n"]
[340.341704, "o", "    # Rendering Methods\r\n"]
[340.372222, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[340.402741, "o", "\r\n"]
[340.433259, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[340.463778, "o", "        # matches base class except for whitespace padding\r\n"]
[340.494296, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[340.524815, "o", "\r\n"]
[340.555333, "o", "    def _format_native_types(\r\n"]
[340.585852, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[340.61637, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[340.646889, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[340.677407, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[340.707926, "o", "\r\n"]
[340.738444, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[340.768963, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[340.799481, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[340.83, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[340.860519, "o", "\r\n"]
[340.891037, "o", "    # --------------------------------------------------------------------\r\n"]
[340.921556, "o", "    # Set Operations\r\n"]
[340.952074, "o", "\r\n"]
[340.982593, "o", "    def _intersection(self, other, sort):\r\n"]
[341.013111, "o", "        \"\"\"\r\n"]
[341.04363, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[341.074148, "o", "        \"\"\"\r\n"]
[341.104667, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[341.135185, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[341.165704, "o", "            taken = self._intersection_unique(other)\r\n"]
[341.196222, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[341.226741, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[341.257259, "o", "            # multiple NaNs\r\n"]
[341.287778, "o", "            taken = other._intersection_unique(self)\r\n"]
[341.318296, "o", "        else:\r\n"]
[341.348815, "o", "            # duplicates\r\n"]
[341.379333, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[341.409852, "o", "\r\n"]
[341.44037, "o", "        if sort is None:\r\n"]
[341.470889, "o", "            taken = taken.sort_values()\r\n"]
[341.501407, "o", "\r\n"]
[341.531926, "o", "        return taken\r\n"]
[341.562444, "o", "\r\n"]
[341.592963, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[341.623481, "o", "        \"\"\"\r\n"]
[341.654, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[341.684519, "o", "        no matter left or right.\r\n"]
[341.715037, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[341.745556, "o", "        Parameters\r\n"]
[341.776074, "o", "        ----------\r\n"]
[341.806593, "o", "        other : IntervalIndex\r\n"]
[341.837111, "o", "        Returns\r\n"]
[341.86763, "o", "        -------\r\n"]
[341.898148, "o", "        IntervalIndex\r\n"]
[341.928667, "o", "        \"\"\"\r\n"]
[341.959185, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[341.989704, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[342.020222, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[342.050741, "o", "\r\n"]
[342.081259, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[342.111778, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[342.142296, "o", "        indexer = unique(indexer)\r\n"]
[342.172815, "o", "\r\n"]
[342.203333, "o", "        return self.take(indexer)\r\n"]
[342.233852, "o", "\r\n"]
[342.26437, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[342.294889, "o", "        # Fastpath: vectorized intersection for same-dtype, non-object intervals\r\n"]
[342.325407, "o", "        try:\r\n"]
[342.355926, "o", "            other = other  # ensure name exists\r\n"]
[342.386444, "o", "            if (self.dtype == other.dtype and self.closed == other.closed):\r\n"]
[342.416963, "o", "                left1 = self.left.values\r\n"]
[342.447481, "o", "                right1 = self.right.values\r\n"]
[342.478, "o", "                left2 = other.left.values\r\n"]
[342.508519, "o", "                right2 = other.right.values\r\n"]
[342.539037, "o", "                if (left1.dtype != object and right1.dtype != object and\r\n"]
[342.569556, "o", "                    left2.dtype == left1.dtype and right2.dtype == right1.dtype):\r\n"]
[342.600074, "o", "                    import numpy as np\r\n"]
[342.630593, "o", "                    dt = np.dtype([('l', left1.dtype), ('r', right1.dtype)])\r\n"]
[342.661111, "o", "                    a1 = np.empty(left1.shape[0], dtype=dt)\r\n"]
[342.69163, "o", "                    a2 = np.empty(left2.shape[0], dtype=dt)\r\n"]
[342.722148, "o", "                    a1['l'] = left1\r\n"]
[342.752667, "o", "                    a1['r'] = right1\r\n"]
[342.783185, "o", "                    a2['l'] = left2\r\n"]
[342.813704, "o", "                    a2['r'] = right2\r\n"]
[342.844222, "o", "                    common = np.intersect1d(a1, a2, assume_unique=False)\r\n"]
[342.874741, "o", "                    # common is sorted and unique. Reconstruct IntervalIndex.\r\n"]
[342.905259, "o", "                    if common.size == 0:\r\n"]
[342.935778, "o", "                        return self[:0]\r\n"]
[342.966296, "o", "                    out_left = common['l']\r\n"]
[342.996815, "o", "                    out_right = common['r']\r\n"]
[343.027333, "o", "                    from pandas.core.indexes.interval import IntervalIndex as _II\r\n"]
[343.057852, "o", "                    return _II.from_arrays(out_left, out_right, closed=self.closed)\r\n"]
[343.08837, "o", "        except Exception:\r\n"]
[343.118889, "o", "            # fall back to existing implementation\r\n"]
[343.149407, "o", "            pass\r\n"]
[343.179926, "o", "\r\n"]
[343.210444, "o", "        \"\"\"\r\n"]
[343.240963, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[343.271481, "o", "        on either sides.\r\n"]
[343.302, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[343.332519, "o", "\r\n"]
[343.363037, "o", "        Parameters\r\n"]
[343.393556, "o", "        ----------\r\n"]
[343.424074, "o", "        other : IntervalIndex\r\n"]
[343.454593, "o", "\r\n"]
[343.485111, "o", "        Returns\r\n"]
[343.51563, "o", "        -------\r\n"]
[343.546148, "o", "        IntervalIndex\r\n"]
[343.576667, "o", "        \"\"\"\r\n"]
[343.607185, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[343.637704, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[343.668222, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[343.698741, "o", "\r\n"]
[343.729259, "o", "        if self.hasnans and other.hasnans:\r\n"]
[343.759778, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[343.790296, "o", "            mask[first_nan_loc] = True\r\n"]
[343.820815, "o", "\r\n"]
[343.851333, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[343.881852, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[343.91237, "o", "            if tup in other_tups:\r\n"]
[343.942889, "o", "                mask[i] = True\r\n"]
[343.973407, "o", "\r\n"]
[344.003926, "o", "        return self[mask]\r\n"]
[344.034444, "o", "\r\n"]
[344.064963, "o", "    # --------------------------------------------------------------------\r\n"]
[344.095481, "o", "\r\n"]
[344.126, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[344.156519, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[344.187037, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[344.217556, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[344.248074, "o", "        raise NotImplementedError(\r\n"]
[344.278593, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[344.309111, "o", "            \"IndexEngine objects\"\r\n"]
[344.33963, "o", "        )\r\n"]
[344.370148, "o", "\r\n"]
[344.400667, "o", "    def _from_join_target(self, result):\r\n"]
[344.431185, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[344.461704, "o", "\r\n"]
[344.492222, "o", "    # TODO: arithmetic operations\r\n"]
[344.522741, "o", "\r\n"]
[344.553259, "o", "\r\n"]
[344.583778, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[344.614296, "o", "    \"\"\"\r\n"]
[344.644815, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[344.675333, "o", "    \"\"\"\r\n"]
[344.705852, "o", "    return any(\r\n"]
[344.73637, "o", "        [\r\n"]
[344.766889, "o", "            is_number(endpoint),\r\n"]
[344.797407, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[344.827926, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[344.858444, "o", "            endpoint is None,\r\n"]
[344.888963, "o", "        ]\r\n"]
[344.919481, "o", "    )\r\n"]
[345.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[345.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[345.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[345.033165, "o", "\u001b[?2004l\r\n"]
[345.06033, "o", "\r\n"]
[345.087495, "o", "\r\n"]
[345.114659, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[345.141824, "o", "    \"\"\"\r\n"]
[345.168989, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[345.196154, "o", "    \"\"\"\r\n"]
[345.223319, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[345.250484, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[345.277648, "o", "    return (\r\n"]
[345.304813, "o", "        (is_number(a) and is_number(b))\r\n"]
[345.331978, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[345.359143, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[345.386308, "o", "        or com.any_none(a, b)\r\n"]
[345.413473, "o", "    )\r\n"]
[345.440637, "o", "\r\n"]
[345.467802, "o", "\r\n"]
[345.494967, "o", "def interval_range(\r\n"]
[345.522132, "o", "    start=None,\r\n"]
[345.549297, "o", "    end=None,\r\n"]
[345.576462, "o", "    periods=None,\r\n"]
[345.603626, "o", "    freq=None,\r\n"]
[345.630791, "o", "    name: Hashable = None,\r\n"]
[345.657956, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[345.685121, "o", ") -> IntervalIndex:\r\n"]
[345.712286, "o", "    \"\"\"\r\n"]
[345.739451, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[345.766615, "o", "\r\n"]
[345.79378, "o", "    Parameters\r\n"]
[345.820945, "o", "    ----------\r\n"]
[345.84811, "o", "    start : numeric or datetime-like, default None\r\n"]
[345.875275, "o", "        Left bound for generating intervals.\r\n"]
[345.90244, "o", "    end : numeric or datetime-like, default None\r\n"]
[345.929604, "o", "        Right bound for generating intervals.\r\n"]
[345.956769, "o", "    periods : int, default None\r\n"]
[345.983934, "o", "        Number of periods to generate.\r\n"]
[346.011099, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[346.038264, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[346.065429, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[346.092593, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[346.119758, "o", "    name : str, default None\r\n"]
[346.146923, "o", "        Name of the resulting IntervalIndex.\r\n"]
[346.174088, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[346.201253, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[346.228418, "o", "        or neither.\r\n"]
[346.255582, "o", "\r\n"]
[346.282747, "o", "    Returns\r\n"]
[346.309912, "o", "    -------\r\n"]
[346.337077, "o", "    IntervalIndex\r\n"]
[346.364242, "o", "\r\n"]
[346.391407, "o", "    See Also\r\n"]
[346.418571, "o", "    --------\r\n"]
[346.445736, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[346.472901, "o", "\r\n"]
[346.500066, "o", "    Notes\r\n"]
[346.527231, "o", "    -----\r\n"]
[346.554396, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[346.58156, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[346.608725, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[346.63589, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[346.663055, "o", "\r\n"]
[346.69022, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[346.717385, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[346.744549, "o", "\r\n"]
[346.771714, "o", "    Examples\r\n"]
[346.798879, "o", "    --------\r\n"]
[346.826044, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[346.853209, "o", "\r\n"]
[346.880374, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[346.907538, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[346.934703, "o", "                  dtype='interval[int64, right]')\r\n"]
[346.961868, "o", "\r\n"]
[346.989033, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[347.016198, "o", "\r\n"]
[347.043363, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[347.070527, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[347.097692, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[347.124857, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[347.152022, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[347.179187, "o", "\r\n"]
[347.206352, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[347.233516, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[347.260681, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[347.287846, "o", "\r\n"]
[347.315011, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[347.342176, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[347.369341, "o", "                  dtype='interval[float64, right]')\r\n"]
[347.396505, "o", "\r\n"]
[347.42367, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[347.450835, "o", "    convertible to a DateOffset.\r\n"]
[347.478, "o", "\r\n"]
[347.505165, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[347.53233, "o", "    ...                   periods=3, freq='MS')\r\n"]
[347.559495, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[347.586659, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[347.613824, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[347.640989, "o", "\r\n"]
[347.668154, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[347.695319, "o", "    automatically (linearly spaced).\r\n"]
[347.722484, "o", "\r\n"]
[347.749648, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[347.776813, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[347.803978, "o", "              dtype='interval[float64, right]')\r\n"]
[347.831143, "o", "\r\n"]
[347.858308, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[347.885473, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[347.912637, "o", "\r\n"]
[347.939802, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[347.966967, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[347.994132, "o", "                  dtype='interval[int64, both]')\r\n"]
[348.021297, "o", "    \"\"\"\r\n"]
[348.048462, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[348.075626, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[348.102791, "o", "    endpoint = start if start is not None else end\r\n"]
[348.129956, "o", "\r\n"]
[348.157121, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[348.184286, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[348.211451, "o", "\r\n"]
[348.238615, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[348.26578, "o", "        raise ValueError(\r\n"]
[348.292945, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[348.32011, "o", "            \"freq, exactly three must be specified\"\r\n"]
[348.347275, "o", "        )\r\n"]
[348.37444, "o", "\r\n"]
[348.401604, "o", "    if not _is_valid_endpoint(start):\r\n"]
[348.428769, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[348.455934, "o", "    if not _is_valid_endpoint(end):\r\n"]
[348.483099, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[348.510264, "o", "\r\n"]
[348.537429, "o", "    if is_float(periods):\r\n"]
[348.564593, "o", "        periods = int(periods)\r\n"]
[348.591758, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[348.618923, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[348.646088, "o", "\r\n"]
[348.673253, "o", "    if freq is not None and not is_number(freq):\r\n"]
[348.700418, "o", "        try:\r\n"]
[348.727582, "o", "            freq = to_offset(freq)\r\n"]
[348.754747, "o", "        except ValueError as err:\r\n"]
[348.781912, "o", "            raise ValueError(\r\n"]
[348.809077, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[348.836242, "o", "            ) from err\r\n"]
[348.863407, "o", "\r\n"]
[348.890571, "o", "    # verify type compatibility\r\n"]
[348.917736, "o", "    if not all(\r\n"]
[348.944901, "o", "        [\r\n"]
[348.972066, "o", "            _is_type_compatible(start, end),\r\n"]
[348.999231, "o", "            _is_type_compatible(start, freq),\r\n"]
[349.026396, "o", "            _is_type_compatible(end, freq),\r\n"]
[349.05356, "o", "        ]\r\n"]
[349.080725, "o", "    ):\r\n"]
[349.10789, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[349.135055, "o", "\r\n"]
[349.16222, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[349.189385, "o", "    if periods is not None:\r\n"]
[349.216549, "o", "        periods += 1\r\n"]
[349.243714, "o", "\r\n"]
[349.270879, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[349.298044, "o", "\r\n"]
[349.325209, "o", "    if is_number(endpoint):\r\n"]
[349.352374, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[349.379538, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[349.406703, "o", "            end -= (end - start) % freq\r\n"]
[349.433868, "o", "\r\n"]
[349.461033, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[349.488198, "o", "        if periods is None:\r\n"]
[349.515363, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[349.542527, "o", "        elif start is None:\r\n"]
[349.569692, "o", "            start = end - (periods - 1) * freq\r\n"]
[349.596857, "o", "        elif end is None:\r\n"]
[349.624022, "o", "            end = start + (periods - 1) * freq\r\n"]
[349.651187, "o", "\r\n"]
[349.678352, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[349.705516, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[349.732681, "o", "            # np.linspace always produces float output\r\n"]
[349.759846, "o", "\r\n"]
[349.787011, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[349.814176, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[349.841341, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[349.868505, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[349.89567, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[349.922835, "o", "                np.dtype(\"int64\"),\r\n"]
[350.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[350.002, "i", "grep -n \"Fastpath: vectorized intersection\" pandas/core/indexes/interval.py || true\r"]
[350.004, "o", "grep -n \"Fastpath: vectorized intersection\" pandas/core/indexes/interval.py || true\r\n"]
[352.478, "o", "\u001b[?2004l\r\n"]
[355.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[355.002, "i", "git checkout -- pandas/core/indexes/interval.py\r"]
[355.004, "o", "git checkout -- pandas/core/indexes/interval.py\r\n"]
[355.006, "o", "\u001b[?2004l\r\n"]
[360.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[360.002, "i", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r"]
[360.004, "o", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r\n"]
[360.315, "o", "ue\r\n"]
[360.624, "o", "\u001b[?2004l\r\n"]
[360.933, "o", "cd asv_bench\r\n"]
[361.242, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\"\r\n"]
[361.551, "o", "cd ..\r\n"]
[361.86, "o", "grep -n \"def _intersection_non_unique\" pandas/core/indexes/interval.py\r\n"]
[362.169, "o", "sed -n '820,980p' pandas/core/indexes/interval.py\r\n"]
[362.478, "o", "\r\n"]
[362.787, "o", "\u001b[33m======================================================================= warnings summary =======================================================================\u001b[0m\r\n"]
[363.096, "o", "pandas/core/construction.py:335\r\n"]
[363.405, "o", "  /workspace/repo/pandas/core/construction.py:335: UserWarning: pyarrow requires pandas 1.0.0 or above, pandas 0+untagged.31506.g5f584bd is installed. Therefore, pandas-specific integration is not used.\r\n"]
[363.714, "o", "    return cls._from_sequence(data, dtype=dtype, copy=copy)\r\n"]
[364.023, "o", "\r\n"]
[364.332, "o", "-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\r\n"]
[364.641, "o", "------------------------------------------------------ generated xml file: /workspace/repo/test-data.xml -------------------------------------------------------\r\n"]
[365.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[365.002, "i", "cd asv_bench\r"]
[365.004, "o", "cd asv_bench\r\n"]
[365.006, "o", "\u001b[?2004l\r\n"]
[370.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[370.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[370.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[375.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[375.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[375.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[375.418, "o", "\u001b[?2004l\r\n"]
[375.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[376.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[376.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[377.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[377.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[377.89, "o", "              param1            \r\n"]
[378.302, "o", "             -------- ----------\r\n"]
[378.714, "o", "               1000    1.45\u00b10ms \r\n"]
[379.126, "o", "              100000   104\u00b10ms  \r\n"]
[379.538, "o", "             ======== ==========\r\n"]
[380.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[380.002, "i", "cd ..\r"]
[380.004, "o", "cd ..\r\n"]
[380.006, "o", "\u001b[?2004l\r\n"]
[385.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[385.002, "i", "grep -n \"def _intersection_non_unique\" pandas/core/indexes/interval.py\r"]
[385.004, "o", "grep -n \"def _intersection_non_unique\" pandas/core/indexes/interval.py\r\n"]
[387.478, "o", "\u001b[?2004l\r\n"]
[390.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[390.002, "i", "sed -n '820,980p' pandas/core/indexes/interval.py\r"]
[390.004, "o", "sed -n '820,980p' pandas/core/indexes/interval.py\r\n"]
[390.036519, "o", "\u001b[?2004l\r\n"]
[390.067037, "o", "    @cache_readonly\r\n"]
[390.097556, "o", "    def mid(self) -> Index:\r\n"]
[390.128074, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[390.158593, "o", "\r\n"]
[390.189111, "o", "    @property\r\n"]
[390.21963, "o", "    def length(self) -> Index:\r\n"]
[390.250148, "o", "        return Index(self._data.length, copy=False)\r\n"]
[390.280667, "o", "\r\n"]
[390.311185, "o", "    # --------------------------------------------------------------------\r\n"]
[390.341704, "o", "    # Rendering Methods\r\n"]
[390.372222, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[390.402741, "o", "\r\n"]
[390.433259, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[390.463778, "o", "        # matches base class except for whitespace padding\r\n"]
[390.494296, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[390.524815, "o", "\r\n"]
[390.555333, "o", "    def _format_native_types(\r\n"]
[390.585852, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[390.61637, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[390.646889, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[390.677407, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[390.707926, "o", "\r\n"]
[390.738444, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[390.768963, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[390.799481, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[390.83, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[390.860519, "o", "\r\n"]
[390.891037, "o", "    # --------------------------------------------------------------------\r\n"]
[390.921556, "o", "    # Set Operations\r\n"]
[390.952074, "o", "\r\n"]
[390.982593, "o", "    def _intersection(self, other, sort):\r\n"]
[391.013111, "o", "        \"\"\"\r\n"]
[391.04363, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[391.074148, "o", "        \"\"\"\r\n"]
[391.104667, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[391.135185, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[391.165704, "o", "            taken = self._intersection_unique(other)\r\n"]
[391.196222, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[391.226741, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[391.257259, "o", "            # multiple NaNs\r\n"]
[391.287778, "o", "            taken = other._intersection_unique(self)\r\n"]
[391.318296, "o", "        else:\r\n"]
[391.348815, "o", "            # duplicates\r\n"]
[391.379333, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[391.409852, "o", "\r\n"]
[391.44037, "o", "        if sort is None:\r\n"]
[391.470889, "o", "            taken = taken.sort_values()\r\n"]
[391.501407, "o", "\r\n"]
[391.531926, "o", "        return taken\r\n"]
[391.562444, "o", "\r\n"]
[391.592963, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[391.623481, "o", "        \"\"\"\r\n"]
[391.654, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[391.684519, "o", "        no matter left or right.\r\n"]
[391.715037, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[391.745556, "o", "        Parameters\r\n"]
[391.776074, "o", "        ----------\r\n"]
[391.806593, "o", "        other : IntervalIndex\r\n"]
[391.837111, "o", "        Returns\r\n"]
[391.86763, "o", "        -------\r\n"]
[391.898148, "o", "        IntervalIndex\r\n"]
[391.928667, "o", "        \"\"\"\r\n"]
[391.959185, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[391.989704, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[392.020222, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[392.050741, "o", "\r\n"]
[392.081259, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[392.111778, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[392.142296, "o", "        indexer = unique(indexer)\r\n"]
[392.172815, "o", "\r\n"]
[392.203333, "o", "        return self.take(indexer)\r\n"]
[392.233852, "o", "\r\n"]
[392.26437, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[392.294889, "o", "        \"\"\"\r\n"]
[392.325407, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[392.355926, "o", "        on either sides.\r\n"]
[392.386444, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[392.416963, "o", "\r\n"]
[392.447481, "o", "        Parameters\r\n"]
[392.478, "o", "        ----------\r\n"]
[392.508519, "o", "        other : IntervalIndex\r\n"]
[392.539037, "o", "\r\n"]
[392.569556, "o", "        Returns\r\n"]
[392.600074, "o", "        -------\r\n"]
[392.630593, "o", "        IntervalIndex\r\n"]
[392.661111, "o", "        \"\"\"\r\n"]
[392.69163, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[392.722148, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[392.752667, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[392.783185, "o", "\r\n"]
[392.813704, "o", "        if self.hasnans and other.hasnans:\r\n"]
[392.844222, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[392.874741, "o", "            mask[first_nan_loc] = True\r\n"]
[392.905259, "o", "\r\n"]
[392.935778, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[392.966296, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[392.996815, "o", "            if tup in other_tups:\r\n"]
[393.027333, "o", "                mask[i] = True\r\n"]
[393.057852, "o", "\r\n"]
[393.08837, "o", "        return self[mask]\r\n"]
[393.118889, "o", "\r\n"]
[393.149407, "o", "    # --------------------------------------------------------------------\r\n"]
[393.179926, "o", "\r\n"]
[393.210444, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[393.240963, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[393.271481, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[393.302, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[393.332519, "o", "        raise NotImplementedError(\r\n"]
[393.363037, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[393.393556, "o", "            \"IndexEngine objects\"\r\n"]
[393.424074, "o", "        )\r\n"]
[393.454593, "o", "\r\n"]
[393.485111, "o", "    def _from_join_target(self, result):\r\n"]
[393.51563, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[393.546148, "o", "\r\n"]
[393.576667, "o", "    # TODO: arithmetic operations\r\n"]
[393.607185, "o", "\r\n"]
[393.637704, "o", "\r\n"]
[393.668222, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[393.698741, "o", "    \"\"\"\r\n"]
[393.729259, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[393.759778, "o", "    \"\"\"\r\n"]
[393.790296, "o", "    return any(\r\n"]
[393.820815, "o", "        [\r\n"]
[393.851333, "o", "            is_number(endpoint),\r\n"]
[393.881852, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[393.91237, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[393.942889, "o", "            endpoint is None,\r\n"]
[393.973407, "o", "        ]\r\n"]
[394.003926, "o", "    )\r\n"]
[394.034444, "o", "\r\n"]
[394.064963, "o", "\r\n"]
[394.095481, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[394.126, "o", "    \"\"\"\r\n"]
[394.156519, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[394.187037, "o", "    \"\"\"\r\n"]
[394.217556, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[394.248074, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[394.278593, "o", "    return (\r\n"]
[394.309111, "o", "        (is_number(a) and is_number(b))\r\n"]
[394.33963, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[394.370148, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[394.400667, "o", "        or com.any_none(a, b)\r\n"]
[394.431185, "o", "    )\r\n"]
[394.461704, "o", "\r\n"]
[394.492222, "o", "\r\n"]
[394.522741, "o", "def interval_range(\r\n"]
[394.553259, "o", "    start=None,\r\n"]
[394.583778, "o", "    end=None,\r\n"]
[394.614296, "o", "    periods=None,\r\n"]
[394.644815, "o", "    freq=None,\r\n"]
[394.675333, "o", "    name: Hashable = None,\r\n"]
[394.705852, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[394.73637, "o", ") -> IntervalIndex:\r\n"]
[394.766889, "o", "    \"\"\"\r\n"]
[394.797407, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[394.827926, "o", "\r\n"]
[394.858444, "o", "    Parameters\r\n"]
[394.888963, "o", "    ----------\r\n"]
[394.919481, "o", "    start : numeric or datetime-like, default None\r\n"]
[395.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[395.002, "i", "grep -n \"Fastpath: vectorized intersection\" pandas/core/indexes/interval.py || true\r"]
[395.004, "o", "grep -n \"Fastpath: vectorized intersection\" pandas/core/indexes/interval.py || true\r\n"]
[395.006, "o", "\u001b[?2004l\r\n"]
[400.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[400.002, "i", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r"]
[400.004, "o", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r\n"]
[400.280667, "o", "ue\r\n"]
[400.555333, "o", "\u001b[?2004l\r\n"]
[400.83, "o", "cd asv_bench\r\n"]
[401.104667, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\"\r\n"]
[401.379333, "o", "cd ..\r\n"]
[401.654, "o", "grep -n \"def _intersection_non_unique\" pandas/core/indexes/interval.py\r\n"]
[401.928667, "o", "sed -n '820,980p' pandas/core/indexes/interval.py\r\n"]
[402.203333, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[402.478, "o", "sed -n '1,220p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[402.752667, "o", "\r\n"]
[403.027333, "o", "\u001b[33m======================================================================= warnings summary =======================================================================\u001b[0m\r\n"]
[403.302, "o", "pandas/core/construction.py:335\r\n"]
[403.576667, "o", "  /workspace/repo/pandas/core/construction.py:335: UserWarning: pyarrow requires pandas 1.0.0 or above, pandas 0+untagged.31506.g5f584bd is installed. Therefore, pandas-specific integration is not used.\r\n"]
[403.851333, "o", "    return cls._from_sequence(data, dtype=dtype, copy=copy)\r\n"]
[404.126, "o", "\r\n"]
[404.400667, "o", "-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\r\n"]
[404.675333, "o", "------------------------------------------------------ generated xml file: /workspace/repo/test-data.xml -------------------------------------------------------\r\n"]
[405.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[405.002, "i", "cd asv_bench\r"]
[405.004, "o", "cd asv_bench\r\n"]
[405.006, "o", "\u001b[?2004l\r\n"]
[410.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[410.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[410.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[415.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[415.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[415.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[415.418, "o", "\u001b[?2004l\r\n"]
[415.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[416.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[416.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[417.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[417.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[417.89, "o", "              param1            \r\n"]
[418.302, "o", "             -------- ----------\r\n"]
[418.714, "o", "               1000    1.21\u00b10ms \r\n"]
[419.126, "o", "              100000   93.2\u00b10ms \r\n"]
[419.538, "o", "             ======== ==========\r\n"]
[420.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[420.002, "i", "cd ..\r"]
[420.004, "o", "cd ..\r\n"]
[420.006, "o", "\u001b[?2004l\r\n"]
[425.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[425.002, "i", "grep -n \"def _intersection_non_unique\" pandas/core/indexes/interval.py\r"]
[425.004, "o", "grep -n \"def _intersection_non_unique\" pandas/core/indexes/interval.py\r\n"]
[427.478, "o", "\u001b[?2004l\r\n"]
[430.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[430.002, "i", "sed -n '820,980p' pandas/core/indexes/interval.py\r"]
[430.004, "o", "sed -n '820,980p' pandas/core/indexes/interval.py\r\n"]
[430.036519, "o", "\u001b[?2004l\r\n"]
[430.067037, "o", "    @cache_readonly\r\n"]
[430.097556, "o", "    def mid(self) -> Index:\r\n"]
[430.128074, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[430.158593, "o", "\r\n"]
[430.189111, "o", "    @property\r\n"]
[430.21963, "o", "    def length(self) -> Index:\r\n"]
[430.250148, "o", "        return Index(self._data.length, copy=False)\r\n"]
[430.280667, "o", "\r\n"]
[430.311185, "o", "    # --------------------------------------------------------------------\r\n"]
[430.341704, "o", "    # Rendering Methods\r\n"]
[430.372222, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[430.402741, "o", "\r\n"]
[430.433259, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[430.463778, "o", "        # matches base class except for whitespace padding\r\n"]
[430.494296, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[430.524815, "o", "\r\n"]
[430.555333, "o", "    def _format_native_types(\r\n"]
[430.585852, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[430.61637, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[430.646889, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[430.677407, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[430.707926, "o", "\r\n"]
[430.738444, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[430.768963, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[430.799481, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[430.83, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[430.860519, "o", "\r\n"]
[430.891037, "o", "    # --------------------------------------------------------------------\r\n"]
[430.921556, "o", "    # Set Operations\r\n"]
[430.952074, "o", "\r\n"]
[430.982593, "o", "    def _intersection(self, other, sort):\r\n"]
[431.013111, "o", "        \"\"\"\r\n"]
[431.04363, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[431.074148, "o", "        \"\"\"\r\n"]
[431.104667, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[431.135185, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[431.165704, "o", "            taken = self._intersection_unique(other)\r\n"]
[431.196222, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[431.226741, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[431.257259, "o", "            # multiple NaNs\r\n"]
[431.287778, "o", "            taken = other._intersection_unique(self)\r\n"]
[431.318296, "o", "        else:\r\n"]
[431.348815, "o", "            # duplicates\r\n"]
[431.379333, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[431.409852, "o", "\r\n"]
[431.44037, "o", "        if sort is None:\r\n"]
[431.470889, "o", "            taken = taken.sort_values()\r\n"]
[431.501407, "o", "\r\n"]
[431.531926, "o", "        return taken\r\n"]
[431.562444, "o", "\r\n"]
[431.592963, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[431.623481, "o", "        \"\"\"\r\n"]
[431.654, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[431.684519, "o", "        no matter left or right.\r\n"]
[431.715037, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[431.745556, "o", "        Parameters\r\n"]
[431.776074, "o", "        ----------\r\n"]
[431.806593, "o", "        other : IntervalIndex\r\n"]
[431.837111, "o", "        Returns\r\n"]
[431.86763, "o", "        -------\r\n"]
[431.898148, "o", "        IntervalIndex\r\n"]
[431.928667, "o", "        \"\"\"\r\n"]
[431.959185, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[431.989704, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[432.020222, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[432.050741, "o", "\r\n"]
[432.081259, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[432.111778, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[432.142296, "o", "        indexer = unique(indexer)\r\n"]
[432.172815, "o", "\r\n"]
[432.203333, "o", "        return self.take(indexer)\r\n"]
[432.233852, "o", "\r\n"]
[432.26437, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[432.294889, "o", "        \"\"\"\r\n"]
[432.325407, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[432.355926, "o", "        on either sides.\r\n"]
[432.386444, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[432.416963, "o", "\r\n"]
[432.447481, "o", "        Parameters\r\n"]
[432.478, "o", "        ----------\r\n"]
[432.508519, "o", "        other : IntervalIndex\r\n"]
[432.539037, "o", "\r\n"]
[432.569556, "o", "        Returns\r\n"]
[432.600074, "o", "        -------\r\n"]
[432.630593, "o", "        IntervalIndex\r\n"]
[432.661111, "o", "        \"\"\"\r\n"]
[432.69163, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[432.722148, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[432.752667, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[432.783185, "o", "\r\n"]
[432.813704, "o", "        if self.hasnans and other.hasnans:\r\n"]
[432.844222, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[432.874741, "o", "            mask[first_nan_loc] = True\r\n"]
[432.905259, "o", "\r\n"]
[432.935778, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[432.966296, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[432.996815, "o", "            if tup in other_tups:\r\n"]
[433.027333, "o", "                mask[i] = True\r\n"]
[433.057852, "o", "\r\n"]
[433.08837, "o", "        return self[mask]\r\n"]
[433.118889, "o", "\r\n"]
[433.149407, "o", "    # --------------------------------------------------------------------\r\n"]
[433.179926, "o", "\r\n"]
[433.210444, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[433.240963, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[433.271481, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[433.302, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[433.332519, "o", "        raise NotImplementedError(\r\n"]
[433.363037, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[433.393556, "o", "            \"IndexEngine objects\"\r\n"]
[433.424074, "o", "        )\r\n"]
[433.454593, "o", "\r\n"]
[433.485111, "o", "    def _from_join_target(self, result):\r\n"]
[433.51563, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[433.546148, "o", "\r\n"]
[433.576667, "o", "    # TODO: arithmetic operations\r\n"]
[433.607185, "o", "\r\n"]
[433.637704, "o", "\r\n"]
[433.668222, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[433.698741, "o", "    \"\"\"\r\n"]
[433.729259, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[433.759778, "o", "    \"\"\"\r\n"]
[433.790296, "o", "    return any(\r\n"]
[433.820815, "o", "        [\r\n"]
[433.851333, "o", "            is_number(endpoint),\r\n"]
[433.881852, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[433.91237, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[433.942889, "o", "            endpoint is None,\r\n"]
[433.973407, "o", "        ]\r\n"]
[434.003926, "o", "    )\r\n"]
[434.034444, "o", "\r\n"]
[434.064963, "o", "\r\n"]
[434.095481, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[434.126, "o", "    \"\"\"\r\n"]
[434.156519, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[434.187037, "o", "    \"\"\"\r\n"]
[434.217556, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[434.248074, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[434.278593, "o", "    return (\r\n"]
[434.309111, "o", "        (is_number(a) and is_number(b))\r\n"]
[434.33963, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[434.370148, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[434.400667, "o", "        or com.any_none(a, b)\r\n"]
[434.431185, "o", "    )\r\n"]
[434.461704, "o", "\r\n"]
[434.492222, "o", "\r\n"]
[434.522741, "o", "def interval_range(\r\n"]
[434.553259, "o", "    start=None,\r\n"]
[434.583778, "o", "    end=None,\r\n"]
[434.614296, "o", "    periods=None,\r\n"]
[434.644815, "o", "    freq=None,\r\n"]
[434.675333, "o", "    name: Hashable = None,\r\n"]
[434.705852, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[434.73637, "o", ") -> IntervalIndex:\r\n"]
[434.766889, "o", "    \"\"\"\r\n"]
[434.797407, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[434.827926, "o", "\r\n"]
[434.858444, "o", "    Parameters\r\n"]
[434.888963, "o", "    ----------\r\n"]
[434.919481, "o", "    start : numeric or datetime-like, default None\r\n"]
[435.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[435.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[435.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[435.0369, "o", "\u001b[?2004l\r\n"]
[435.0678, "o", "        Left bound for generating intervals.\r\n"]
[435.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[435.1296, "o", "        Right bound for generating intervals.\r\n"]
[435.1605, "o", "    periods : int, default None\r\n"]
[435.1914, "o", "        Number of periods to generate.\r\n"]
[435.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[435.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[435.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[435.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[435.3459, "o", "    name : str, default None\r\n"]
[435.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[435.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[435.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[435.4695, "o", "        or neither.\r\n"]
[435.5004, "o", "\r\n"]
[435.5313, "o", "    Returns\r\n"]
[435.5622, "o", "    -------\r\n"]
[435.5931, "o", "    IntervalIndex\r\n"]
[435.624, "o", "\r\n"]
[435.6549, "o", "    See Also\r\n"]
[435.6858, "o", "    --------\r\n"]
[435.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[435.7476, "o", "\r\n"]
[435.7785, "o", "    Notes\r\n"]
[435.8094, "o", "    -----\r\n"]
[435.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[435.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[435.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[435.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[435.9639, "o", "\r\n"]
[435.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[436.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[436.0566, "o", "\r\n"]
[436.0875, "o", "    Examples\r\n"]
[436.1184, "o", "    --------\r\n"]
[436.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[436.1802, "o", "\r\n"]
[436.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[436.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[436.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[436.3038, "o", "\r\n"]
[436.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[436.3656, "o", "\r\n"]
[436.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[436.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[436.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[436.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[436.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[436.551, "o", "\r\n"]
[436.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[436.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[436.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[436.6746, "o", "\r\n"]
[436.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[436.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[436.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[436.7982, "o", "\r\n"]
[436.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[436.86, "o", "    convertible to a DateOffset.\r\n"]
[436.8909, "o", "\r\n"]
[436.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[436.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[436.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[437.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[437.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[437.0763, "o", "\r\n"]
[437.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[437.1381, "o", "    automatically (linearly spaced).\r\n"]
[437.169, "o", "\r\n"]
[437.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[437.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[437.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[437.2926, "o", "\r\n"]
[437.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[437.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[437.3853, "o", "\r\n"]
[437.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[437.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[437.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[437.5089, "o", "    \"\"\"\r\n"]
[437.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[437.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[437.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[437.6325, "o", "\r\n"]
[437.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[437.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[437.7252, "o", "\r\n"]
[437.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[437.787, "o", "        raise ValueError(\r\n"]
[437.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[437.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[437.8797, "o", "        )\r\n"]
[437.9106, "o", "\r\n"]
[437.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[437.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[438.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[438.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[438.0651, "o", "\r\n"]
[438.096, "o", "    if is_float(periods):\r\n"]
[438.1269, "o", "        periods = int(periods)\r\n"]
[438.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[438.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[438.2196, "o", "\r\n"]
[438.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[438.2814, "o", "        try:\r\n"]
[438.3123, "o", "            freq = to_offset(freq)\r\n"]
[438.3432, "o", "        except ValueError as err:\r\n"]
[438.3741, "o", "            raise ValueError(\r\n"]
[438.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[438.4359, "o", "            ) from err\r\n"]
[438.4668, "o", "\r\n"]
[438.4977, "o", "    # verify type compatibility\r\n"]
[438.5286, "o", "    if not all(\r\n"]
[438.5595, "o", "        [\r\n"]
[438.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[438.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[438.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[438.6831, "o", "        ]\r\n"]
[438.714, "o", "    ):\r\n"]
[438.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[438.7758, "o", "\r\n"]
[438.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[438.8376, "o", "    if periods is not None:\r\n"]
[438.8685, "o", "        periods += 1\r\n"]
[438.8994, "o", "\r\n"]
[438.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[438.9612, "o", "\r\n"]
[438.9921, "o", "    if is_number(endpoint):\r\n"]
[439.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[439.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[439.0848, "o", "            end -= (end - start) % freq\r\n"]
[439.1157, "o", "\r\n"]
[439.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[439.1775, "o", "        if periods is None:\r\n"]
[439.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[439.2393, "o", "        elif start is None:\r\n"]
[439.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[439.3011, "o", "        elif end is None:\r\n"]
[439.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[439.3629, "o", "\r\n"]
[439.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[439.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[439.4556, "o", "            # np.linspace always produces float output\r\n"]
[439.4865, "o", "\r\n"]
[439.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[439.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[439.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[439.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[439.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[439.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[439.7028, "o", "            )\r\n"]
[439.7337, "o", "    else:\r\n"]
[439.7646, "o", "        # delegate to the appropriate range function\r\n"]
[439.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[439.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[439.8573, "o", "        else:\r\n"]
[439.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[439.9191, "o", "\r\n"]
[440.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[440.002, "i", "sed -n '1,220p' pandas/tests/indexes/interval/test_setops.py\r"]
[440.004, "o", "sed -n '1,220p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[440.030355, "o", "\u001b[?2004l\r\n"]
[440.054709, "o", "import numpy as np\r\n"]
[440.079064, "o", "import pytest\r\n"]
[440.103419, "o", "\r\n"]
[440.127773, "o", "from pandas import (\r\n"]
[440.152128, "o", "    Index,\r\n"]
[440.176483, "o", "    IntervalIndex,\r\n"]
[440.200837, "o", "    Timestamp,\r\n"]
[440.225192, "o", "    interval_range,\r\n"]
[440.249547, "o", ")\r\n"]
[440.273901, "o", "import pandas._testing as tm\r\n"]
[440.298256, "o", "\r\n"]
[440.322611, "o", "\r\n"]
[440.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[440.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[440.395675, "o", "\r\n"]
[440.42003, "o", "\r\n"]
[440.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[440.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[440.493094, "o", "\r\n"]
[440.517448, "o", "\r\n"]
[440.541803, "o", "class TestIntervalIndex:\r\n"]
[440.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[440.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[440.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[440.639222, "o", "\r\n"]
[440.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[440.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[440.712286, "o", "        if sort is None:\r\n"]
[440.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[440.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[440.78535, "o", "\r\n"]
[440.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[440.834059, "o", "        if sort is None:\r\n"]
[440.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[440.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[440.907123, "o", "\r\n"]
[440.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[440.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[440.980187, "o", "\r\n"]
[441.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[441.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[441.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[441.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[441.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[441.126315, "o", "\r\n"]
[441.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[441.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[441.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[441.223734, "o", "        expected = other\r\n"]
[441.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[441.272443, "o", "\r\n"]
[441.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[441.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[441.345507, "o", "\r\n"]
[441.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[441.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[441.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[441.442926, "o", "\r\n"]
[441.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[441.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[441.51599, "o", "\r\n"]
[441.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[441.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[441.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[441.613409, "o", "\r\n"]
[441.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[441.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[441.686473, "o", "        if sort is None:\r\n"]
[441.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[441.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[441.759537, "o", "\r\n"]
[441.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[441.808246, "o", "        if sort is None:\r\n"]
[441.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[441.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[441.88131, "o", "\r\n"]
[441.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[441.93002, "o", "\r\n"]
[441.954374, "o", "        # GH 26225: nested intervals\r\n"]
[441.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[442.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[442.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[442.051793, "o", "        result = index.intersection(other)\r\n"]
[442.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[442.100502, "o", "\r\n"]
[442.124857, "o", "        # GH 26225\r\n"]
[442.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[442.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[442.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[442.222276, "o", "        result = index.intersection(other)\r\n"]
[442.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[442.270985, "o", "\r\n"]
[442.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[442.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[442.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[442.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[442.392759, "o", "        result = index.intersection(other)\r\n"]
[442.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[442.441468, "o", "\r\n"]
[442.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[442.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[442.514532, "o", "\r\n"]
[442.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[442.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[442.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[442.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[442.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[442.66066, "o", "\r\n"]
[442.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[442.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[442.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[442.758079, "o", "        expected = other[:0]\r\n"]
[442.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[442.806788, "o", "\r\n"]
[442.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[442.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[442.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[442.904207, "o", "\r\n"]
[442.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[442.952916, "o", "        # GH#38743\r\n"]
[442.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[443.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[443.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[443.050335, "o", "        result = index.intersection(other)\r\n"]
[443.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[443.099044, "o", "\r\n"]
[443.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[443.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[443.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[443.196463, "o", "        expected = index[1:]\r\n"]
[443.220818, "o", "        if sort is None:\r\n"]
[443.245172, "o", "            expected = expected.sort_values()\r\n"]
[443.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[443.293882, "o", "\r\n"]
[443.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[443.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[443.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[443.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[443.415655, "o", "\r\n"]
[443.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[443.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[443.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[443.513074, "o", "        )\r\n"]
[443.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[443.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[443.586138, "o", "\r\n"]
[443.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[443.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[443.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[443.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[443.707911, "o", "        if sort is None:\r\n"]
[443.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[443.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[443.780975, "o", "\r\n"]
[443.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[443.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[443.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[443.878394, "o", "        if sort is None:\r\n"]
[443.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[443.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[443.951458, "o", "\r\n"]
[443.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[444.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[444.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[444.048877, "o", "        )\r\n"]
[444.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[444.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[444.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[444.146296, "o", "\r\n"]
[444.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[444.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[444.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[444.243714, "o", "    )\r\n"]
[444.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[444.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[444.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[444.341133, "o", "\r\n"]
[444.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[444.389842, "o", "        # non-IntervalIndex\r\n"]
[444.414197, "o", "        if op_name == \"difference\":\r\n"]
[444.438552, "o", "            expected = index\r\n"]
[444.462906, "o", "        else:\r\n"]
[444.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[444.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[444.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[444.560325, "o", "\r\n"]
[444.58468, "o", "        # mixed closed -> cast to object\r\n"]
[444.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[444.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[444.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[444.682099, "o", "            if op_name == \"difference\":\r\n"]
[444.706453, "o", "                expected = index\r\n"]
[444.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[444.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[444.779517, "o", "\r\n"]
[444.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[444.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[444.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[444.876936, "o", "        if op_name == \"difference\":\r\n"]
[444.901291, "o", "            expected = index\r\n"]
[444.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[445.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[445.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[445.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[447.478, "o", "\u001b[?2004l\r\n"]
[450.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[450.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[450.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[451.654, "o", "\u001b[?2004l\r\n"]
[453.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[455.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[455.002, "i", "sed -n '820,980p' pandas/core/indexes/interval.py\r"]
[455.004, "o", "sed -n '820,980p' pandas/core/indexes/interval.py\r\n"]
[455.036519, "o", "\u001b[?2004l\r\n"]
[455.067037, "o", "    @cache_readonly\r\n"]
[455.097556, "o", "    def mid(self) -> Index:\r\n"]
[455.128074, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[455.158593, "o", "\r\n"]
[455.189111, "o", "    @property\r\n"]
[455.21963, "o", "    def length(self) -> Index:\r\n"]
[455.250148, "o", "        return Index(self._data.length, copy=False)\r\n"]
[455.280667, "o", "\r\n"]
[455.311185, "o", "    # --------------------------------------------------------------------\r\n"]
[455.341704, "o", "    # Rendering Methods\r\n"]
[455.372222, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[455.402741, "o", "\r\n"]
[455.433259, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[455.463778, "o", "        # matches base class except for whitespace padding\r\n"]
[455.494296, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[455.524815, "o", "\r\n"]
[455.555333, "o", "    def _format_native_types(\r\n"]
[455.585852, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[455.61637, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[455.646889, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[455.677407, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[455.707926, "o", "\r\n"]
[455.738444, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[455.768963, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[455.799481, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[455.83, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[455.860519, "o", "\r\n"]
[455.891037, "o", "    # --------------------------------------------------------------------\r\n"]
[455.921556, "o", "    # Set Operations\r\n"]
[455.952074, "o", "\r\n"]
[455.982593, "o", "    def _intersection(self, other, sort):\r\n"]
[456.013111, "o", "        \"\"\"\r\n"]
[456.04363, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[456.074148, "o", "        \"\"\"\r\n"]
[456.104667, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[456.135185, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[456.165704, "o", "            taken = self._intersection_unique(other)\r\n"]
[456.196222, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[456.226741, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[456.257259, "o", "            # multiple NaNs\r\n"]
[456.287778, "o", "            taken = other._intersection_unique(self)\r\n"]
[456.318296, "o", "        else:\r\n"]
[456.348815, "o", "            # duplicates\r\n"]
[456.379333, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[456.409852, "o", "\r\n"]
[456.44037, "o", "        if sort is None:\r\n"]
[456.470889, "o", "            taken = taken.sort_values()\r\n"]
[456.501407, "o", "\r\n"]
[456.531926, "o", "        return taken\r\n"]
[456.562444, "o", "\r\n"]
[456.592963, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[456.623481, "o", "        \"\"\"\r\n"]
[456.654, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[456.684519, "o", "        no matter left or right.\r\n"]
[456.715037, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[456.745556, "o", "        Parameters\r\n"]
[456.776074, "o", "        ----------\r\n"]
[456.806593, "o", "        other : IntervalIndex\r\n"]
[456.837111, "o", "        Returns\r\n"]
[456.86763, "o", "        -------\r\n"]
[456.898148, "o", "        IntervalIndex\r\n"]
[456.928667, "o", "        \"\"\"\r\n"]
[456.959185, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[456.989704, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[457.020222, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[457.050741, "o", "\r\n"]
[457.081259, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[457.111778, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[457.142296, "o", "        indexer = unique(indexer)\r\n"]
[457.172815, "o", "\r\n"]
[457.203333, "o", "        return self.take(indexer)\r\n"]
[457.233852, "o", "\r\n"]
[457.26437, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[457.294889, "o", "        \"\"\"\r\n"]
[457.325407, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[457.355926, "o", "        on either sides.\r\n"]
[457.386444, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[457.416963, "o", "\r\n"]
[457.447481, "o", "        Parameters\r\n"]
[457.478, "o", "        ----------\r\n"]
[457.508519, "o", "        other : IntervalIndex\r\n"]
[457.539037, "o", "\r\n"]
[457.569556, "o", "        Returns\r\n"]
[457.600074, "o", "        -------\r\n"]
[457.630593, "o", "        IntervalIndex\r\n"]
[457.661111, "o", "        \"\"\"\r\n"]
[457.69163, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[457.722148, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[457.752667, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[457.783185, "o", "\r\n"]
[457.813704, "o", "        if self.hasnans and other.hasnans:\r\n"]
[457.844222, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[457.874741, "o", "            mask[first_nan_loc] = True\r\n"]
[457.905259, "o", "\r\n"]
[457.935778, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[457.966296, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[457.996815, "o", "            if tup in other_tups:\r\n"]
[458.027333, "o", "                mask[i] = True\r\n"]
[458.057852, "o", "\r\n"]
[458.08837, "o", "        return self[mask]\r\n"]
[458.118889, "o", "\r\n"]
[458.149407, "o", "    # --------------------------------------------------------------------\r\n"]
[458.179926, "o", "\r\n"]
[458.210444, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[458.240963, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[458.271481, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[458.302, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[458.332519, "o", "        raise NotImplementedError(\r\n"]
[458.363037, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[458.393556, "o", "            \"IndexEngine objects\"\r\n"]
[458.424074, "o", "        )\r\n"]
[458.454593, "o", "\r\n"]
[458.485111, "o", "    def _from_join_target(self, result):\r\n"]
[458.51563, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[458.546148, "o", "\r\n"]
[458.576667, "o", "    # TODO: arithmetic operations\r\n"]
[458.607185, "o", "\r\n"]
[458.637704, "o", "\r\n"]
[458.668222, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[458.698741, "o", "    \"\"\"\r\n"]
[458.729259, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[458.759778, "o", "    \"\"\"\r\n"]
[458.790296, "o", "    return any(\r\n"]
[458.820815, "o", "        [\r\n"]
[458.851333, "o", "            is_number(endpoint),\r\n"]
[458.881852, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[458.91237, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[458.942889, "o", "            endpoint is None,\r\n"]
[458.973407, "o", "        ]\r\n"]
[459.003926, "o", "    )\r\n"]
[459.034444, "o", "\r\n"]
[459.064963, "o", "\r\n"]
[459.095481, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[459.126, "o", "    \"\"\"\r\n"]
[459.156519, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[459.187037, "o", "    \"\"\"\r\n"]
[459.217556, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[459.248074, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[459.278593, "o", "    return (\r\n"]
[459.309111, "o", "        (is_number(a) and is_number(b))\r\n"]
[459.33963, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[459.370148, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[459.400667, "o", "        or com.any_none(a, b)\r\n"]
[459.431185, "o", "    )\r\n"]
[459.461704, "o", "\r\n"]
[459.492222, "o", "\r\n"]
[459.522741, "o", "def interval_range(\r\n"]
[459.553259, "o", "    start=None,\r\n"]
[459.583778, "o", "    end=None,\r\n"]
[459.614296, "o", "    periods=None,\r\n"]
[459.644815, "o", "    freq=None,\r\n"]
[459.675333, "o", "    name: Hashable = None,\r\n"]
[459.705852, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[459.73637, "o", ") -> IntervalIndex:\r\n"]
[459.766889, "o", "    \"\"\"\r\n"]
[459.797407, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[459.827926, "o", "\r\n"]
[459.858444, "o", "    Parameters\r\n"]
[459.888963, "o", "    ----------\r\n"]
[459.919481, "o", "    start : numeric or datetime-like, default None\r\n"]
[460.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[460.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[460.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[460.0369, "o", "\u001b[?2004l\r\n"]
[460.0678, "o", "        Left bound for generating intervals.\r\n"]
[460.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[460.1296, "o", "        Right bound for generating intervals.\r\n"]
[460.1605, "o", "    periods : int, default None\r\n"]
[460.1914, "o", "        Number of periods to generate.\r\n"]
[460.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[460.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[460.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[460.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[460.3459, "o", "    name : str, default None\r\n"]
[460.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[460.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[460.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[460.4695, "o", "        or neither.\r\n"]
[460.5004, "o", "\r\n"]
[460.5313, "o", "    Returns\r\n"]
[460.5622, "o", "    -------\r\n"]
[460.5931, "o", "    IntervalIndex\r\n"]
[460.624, "o", "\r\n"]
[460.6549, "o", "    See Also\r\n"]
[460.6858, "o", "    --------\r\n"]
[460.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[460.7476, "o", "\r\n"]
[460.7785, "o", "    Notes\r\n"]
[460.8094, "o", "    -----\r\n"]
[460.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[460.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[460.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[460.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[460.9639, "o", "\r\n"]
[460.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[461.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[461.0566, "o", "\r\n"]
[461.0875, "o", "    Examples\r\n"]
[461.1184, "o", "    --------\r\n"]
[461.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[461.1802, "o", "\r\n"]
[461.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[461.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[461.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[461.3038, "o", "\r\n"]
[461.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[461.3656, "o", "\r\n"]
[461.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[461.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[461.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[461.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[461.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[461.551, "o", "\r\n"]
[461.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[461.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[461.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[461.6746, "o", "\r\n"]
[461.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[461.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[461.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[461.7982, "o", "\r\n"]
[461.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[461.86, "o", "    convertible to a DateOffset.\r\n"]
[461.8909, "o", "\r\n"]
[461.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[461.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[461.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[462.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[462.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[462.0763, "o", "\r\n"]
[462.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[462.1381, "o", "    automatically (linearly spaced).\r\n"]
[462.169, "o", "\r\n"]
[462.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[462.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[462.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[462.2926, "o", "\r\n"]
[462.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[462.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[462.3853, "o", "\r\n"]
[462.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[462.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[462.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[462.5089, "o", "    \"\"\"\r\n"]
[462.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[462.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[462.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[462.6325, "o", "\r\n"]
[462.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[462.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[462.7252, "o", "\r\n"]
[462.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[462.787, "o", "        raise ValueError(\r\n"]
[462.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[462.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[462.8797, "o", "        )\r\n"]
[462.9106, "o", "\r\n"]
[462.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[462.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[463.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[463.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[463.0651, "o", "\r\n"]
[463.096, "o", "    if is_float(periods):\r\n"]
[463.1269, "o", "        periods = int(periods)\r\n"]
[463.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[463.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[463.2196, "o", "\r\n"]
[463.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[463.2814, "o", "        try:\r\n"]
[463.3123, "o", "            freq = to_offset(freq)\r\n"]
[463.3432, "o", "        except ValueError as err:\r\n"]
[463.3741, "o", "            raise ValueError(\r\n"]
[463.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[463.4359, "o", "            ) from err\r\n"]
[463.4668, "o", "\r\n"]
[463.4977, "o", "    # verify type compatibility\r\n"]
[463.5286, "o", "    if not all(\r\n"]
[463.5595, "o", "        [\r\n"]
[463.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[463.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[463.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[463.6831, "o", "        ]\r\n"]
[463.714, "o", "    ):\r\n"]
[463.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[463.7758, "o", "\r\n"]
[463.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[463.8376, "o", "    if periods is not None:\r\n"]
[463.8685, "o", "        periods += 1\r\n"]
[463.8994, "o", "\r\n"]
[463.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[463.9612, "o", "\r\n"]
[463.9921, "o", "    if is_number(endpoint):\r\n"]
[464.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[464.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[464.0848, "o", "            end -= (end - start) % freq\r\n"]
[464.1157, "o", "\r\n"]
[464.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[464.1775, "o", "        if periods is None:\r\n"]
[464.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[464.2393, "o", "        elif start is None:\r\n"]
[464.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[464.3011, "o", "        elif end is None:\r\n"]
[464.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[464.3629, "o", "\r\n"]
[464.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[464.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[464.4556, "o", "            # np.linspace always produces float output\r\n"]
[464.4865, "o", "\r\n"]
[464.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[464.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[464.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[464.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[464.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[464.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[464.7028, "o", "            )\r\n"]
[464.7337, "o", "    else:\r\n"]
[464.7646, "o", "        # delegate to the appropriate range function\r\n"]
[464.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[464.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[464.8573, "o", "        else:\r\n"]
[464.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[464.9191, "o", "\r\n"]
[465.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[465.002, "i", "sed -n '1,280p' pandas/tests/indexes/interval/test_setops.py\r"]
[465.004, "o", "sed -n '1,280p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[465.030355, "o", "\u001b[?2004l\r\n"]
[465.054709, "o", "import numpy as np\r\n"]
[465.079064, "o", "import pytest\r\n"]
[465.103419, "o", "\r\n"]
[465.127773, "o", "from pandas import (\r\n"]
[465.152128, "o", "    Index,\r\n"]
[465.176483, "o", "    IntervalIndex,\r\n"]
[465.200837, "o", "    Timestamp,\r\n"]
[465.225192, "o", "    interval_range,\r\n"]
[465.249547, "o", ")\r\n"]
[465.273901, "o", "import pandas._testing as tm\r\n"]
[465.298256, "o", "\r\n"]
[465.322611, "o", "\r\n"]
[465.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[465.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[465.395675, "o", "\r\n"]
[465.42003, "o", "\r\n"]
[465.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[465.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[465.493094, "o", "\r\n"]
[465.517448, "o", "\r\n"]
[465.541803, "o", "class TestIntervalIndex:\r\n"]
[465.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[465.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[465.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[465.639222, "o", "\r\n"]
[465.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[465.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[465.712286, "o", "        if sort is None:\r\n"]
[465.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[465.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[465.78535, "o", "\r\n"]
[465.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[465.834059, "o", "        if sort is None:\r\n"]
[465.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[465.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[465.907123, "o", "\r\n"]
[465.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[465.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[465.980187, "o", "\r\n"]
[466.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[466.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[466.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[466.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[466.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[466.126315, "o", "\r\n"]
[466.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[466.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[466.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[466.223734, "o", "        expected = other\r\n"]
[466.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[466.272443, "o", "\r\n"]
[466.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[466.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[466.345507, "o", "\r\n"]
[466.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[466.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[466.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[466.442926, "o", "\r\n"]
[466.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[466.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[466.51599, "o", "\r\n"]
[466.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[466.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[466.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[466.613409, "o", "\r\n"]
[466.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[466.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[466.686473, "o", "        if sort is None:\r\n"]
[466.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[466.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[466.759537, "o", "\r\n"]
[466.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[466.808246, "o", "        if sort is None:\r\n"]
[466.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[466.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[466.88131, "o", "\r\n"]
[466.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[466.93002, "o", "\r\n"]
[466.954374, "o", "        # GH 26225: nested intervals\r\n"]
[466.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[467.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[467.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[467.051793, "o", "        result = index.intersection(other)\r\n"]
[467.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[467.100502, "o", "\r\n"]
[467.124857, "o", "        # GH 26225\r\n"]
[467.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[467.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[467.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[467.222276, "o", "        result = index.intersection(other)\r\n"]
[467.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[467.270985, "o", "\r\n"]
[467.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[467.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[467.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[467.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[467.392759, "o", "        result = index.intersection(other)\r\n"]
[467.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[467.441468, "o", "\r\n"]
[467.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[467.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[467.514532, "o", "\r\n"]
[467.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[467.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[467.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[467.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[467.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[467.66066, "o", "\r\n"]
[467.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[467.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[467.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[467.758079, "o", "        expected = other[:0]\r\n"]
[467.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[467.806788, "o", "\r\n"]
[467.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[467.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[467.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[467.904207, "o", "\r\n"]
[467.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[467.952916, "o", "        # GH#38743\r\n"]
[467.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[468.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[468.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[468.050335, "o", "        result = index.intersection(other)\r\n"]
[468.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[468.099044, "o", "\r\n"]
[468.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[468.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[468.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[468.196463, "o", "        expected = index[1:]\r\n"]
[468.220818, "o", "        if sort is None:\r\n"]
[468.245172, "o", "            expected = expected.sort_values()\r\n"]
[468.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[468.293882, "o", "\r\n"]
[468.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[468.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[468.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[468.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[468.415655, "o", "\r\n"]
[468.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[468.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[468.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[468.513074, "o", "        )\r\n"]
[468.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[468.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[468.586138, "o", "\r\n"]
[468.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[468.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[468.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[468.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[468.707911, "o", "        if sort is None:\r\n"]
[468.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[468.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[468.780975, "o", "\r\n"]
[468.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[468.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[468.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[468.878394, "o", "        if sort is None:\r\n"]
[468.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[468.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[468.951458, "o", "\r\n"]
[468.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[469.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[469.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[469.048877, "o", "        )\r\n"]
[469.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[469.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[469.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[469.146296, "o", "\r\n"]
[469.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[469.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[469.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[469.243714, "o", "    )\r\n"]
[469.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[469.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[469.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[469.341133, "o", "\r\n"]
[469.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[469.389842, "o", "        # non-IntervalIndex\r\n"]
[469.414197, "o", "        if op_name == \"difference\":\r\n"]
[469.438552, "o", "            expected = index\r\n"]
[469.462906, "o", "        else:\r\n"]
[469.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[469.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[469.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[469.560325, "o", "\r\n"]
[469.58468, "o", "        # mixed closed -> cast to object\r\n"]
[469.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[469.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[469.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[469.682099, "o", "            if op_name == \"difference\":\r\n"]
[469.706453, "o", "                expected = index\r\n"]
[469.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[469.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[469.779517, "o", "\r\n"]
[469.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[469.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[469.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[469.876936, "o", "        if op_name == \"difference\":\r\n"]
[469.901291, "o", "            expected = index\r\n"]
[469.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[470.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[470.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\"\r"]
[470.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\"\r\n"]
[472.478, "o", "\u001b[?2004l\r\n"]
[475.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[475.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[475.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[477.478, "o", "\u001b[?2004l\r\n"]
[480.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[480.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[480.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[481.654, "o", "\u001b[?2004l\r\n"]
[483.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[485.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[485.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[485.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[485.033165, "o", "\u001b[?2004l\r\n"]
[485.06033, "o", "\r\n"]
[485.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[485.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[485.141824, "o", "\r\n"]
[485.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[485.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[485.223319, "o", "            return False\r\n"]
[485.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[485.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[485.304813, "o", "\r\n"]
[485.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[485.359143, "o", "\r\n"]
[485.386308, "o", "    @cache_readonly\r\n"]
[485.413473, "o", "    def left(self) -> Index:\r\n"]
[485.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[485.467802, "o", "\r\n"]
[485.494967, "o", "    @cache_readonly\r\n"]
[485.522132, "o", "    def right(self) -> Index:\r\n"]
[485.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[485.576462, "o", "\r\n"]
[485.603626, "o", "    @cache_readonly\r\n"]
[485.630791, "o", "    def mid(self) -> Index:\r\n"]
[485.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[485.685121, "o", "\r\n"]
[485.712286, "o", "    @property\r\n"]
[485.739451, "o", "    def length(self) -> Index:\r\n"]
[485.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[485.79378, "o", "\r\n"]
[485.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[485.84811, "o", "    # Rendering Methods\r\n"]
[485.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[485.90244, "o", "\r\n"]
[485.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[485.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[485.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[486.011099, "o", "\r\n"]
[486.038264, "o", "    def _format_native_types(\r\n"]
[486.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[486.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[486.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[486.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[486.174088, "o", "\r\n"]
[486.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[486.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[486.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[486.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[486.309912, "o", "\r\n"]
[486.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[486.364242, "o", "    # Set Operations\r\n"]
[486.391407, "o", "\r\n"]
[486.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[486.445736, "o", "        \"\"\"\r\n"]
[486.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[486.500066, "o", "        \"\"\"\r\n"]
[486.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[486.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[486.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[486.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[486.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[486.663055, "o", "            # multiple NaNs\r\n"]
[486.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[486.717385, "o", "        else:\r\n"]
[486.744549, "o", "            # duplicates\r\n"]
[486.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[486.798879, "o", "\r\n"]
[486.826044, "o", "        if sort is None:\r\n"]
[486.853209, "o", "            taken = taken.sort_values()\r\n"]
[486.880374, "o", "\r\n"]
[486.907538, "o", "        return taken\r\n"]
[486.934703, "o", "\r\n"]
[486.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[486.989033, "o", "        \"\"\"\r\n"]
[487.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[487.043363, "o", "        no matter left or right.\r\n"]
[487.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[487.097692, "o", "        Parameters\r\n"]
[487.124857, "o", "        ----------\r\n"]
[487.152022, "o", "        other : IntervalIndex\r\n"]
[487.179187, "o", "        Returns\r\n"]
[487.206352, "o", "        -------\r\n"]
[487.233516, "o", "        IntervalIndex\r\n"]
[487.260681, "o", "        \"\"\"\r\n"]
[487.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[487.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[487.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[487.369341, "o", "\r\n"]
[487.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[487.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[487.450835, "o", "        indexer = unique(indexer)\r\n"]
[487.478, "o", "\r\n"]
[487.505165, "o", "        return self.take(indexer)\r\n"]
[487.53233, "o", "\r\n"]
[487.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[487.586659, "o", "        \"\"\"\r\n"]
[487.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[487.640989, "o", "        on either sides.\r\n"]
[487.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[487.695319, "o", "\r\n"]
[487.722484, "o", "        Parameters\r\n"]
[487.749648, "o", "        ----------\r\n"]
[487.776813, "o", "        other : IntervalIndex\r\n"]
[487.803978, "o", "\r\n"]
[487.831143, "o", "        Returns\r\n"]
[487.858308, "o", "        -------\r\n"]
[487.885473, "o", "        IntervalIndex\r\n"]
[487.912637, "o", "        \"\"\"\r\n"]
[487.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[487.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[487.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[488.021297, "o", "\r\n"]
[488.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[488.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[488.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[488.129956, "o", "\r\n"]
[488.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[488.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[488.211451, "o", "            if tup in other_tups:\r\n"]
[488.238615, "o", "                mask[i] = True\r\n"]
[488.26578, "o", "\r\n"]
[488.292945, "o", "        return self[mask]\r\n"]
[488.32011, "o", "\r\n"]
[488.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[488.37444, "o", "\r\n"]
[488.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[488.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[488.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[488.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[488.510264, "o", "        raise NotImplementedError(\r\n"]
[488.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[488.564593, "o", "            \"IndexEngine objects\"\r\n"]
[488.591758, "o", "        )\r\n"]
[488.618923, "o", "\r\n"]
[488.646088, "o", "    def _from_join_target(self, result):\r\n"]
[488.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[488.700418, "o", "\r\n"]
[488.727582, "o", "    # TODO: arithmetic operations\r\n"]
[488.754747, "o", "\r\n"]
[488.781912, "o", "\r\n"]
[488.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[488.836242, "o", "    \"\"\"\r\n"]
[488.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[488.890571, "o", "    \"\"\"\r\n"]
[488.917736, "o", "    return any(\r\n"]
[488.944901, "o", "        [\r\n"]
[488.972066, "o", "            is_number(endpoint),\r\n"]
[488.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[489.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[489.05356, "o", "            endpoint is None,\r\n"]
[489.080725, "o", "        ]\r\n"]
[489.10789, "o", "    )\r\n"]
[489.135055, "o", "\r\n"]
[489.16222, "o", "\r\n"]
[489.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[489.216549, "o", "    \"\"\"\r\n"]
[489.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[489.270879, "o", "    \"\"\"\r\n"]
[489.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[489.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[489.352374, "o", "    return (\r\n"]
[489.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[489.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[489.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[489.461033, "o", "        or com.any_none(a, b)\r\n"]
[489.488198, "o", "    )\r\n"]
[489.515363, "o", "\r\n"]
[489.542527, "o", "\r\n"]
[489.569692, "o", "def interval_range(\r\n"]
[489.596857, "o", "    start=None,\r\n"]
[489.624022, "o", "    end=None,\r\n"]
[489.651187, "o", "    periods=None,\r\n"]
[489.678352, "o", "    freq=None,\r\n"]
[489.705516, "o", "    name: Hashable = None,\r\n"]
[489.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[489.759846, "o", ") -> IntervalIndex:\r\n"]
[489.787011, "o", "    \"\"\"\r\n"]
[489.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[489.841341, "o", "\r\n"]
[489.868505, "o", "    Parameters\r\n"]
[489.89567, "o", "    ----------\r\n"]
[489.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[490.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[490.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[490.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[490.0369, "o", "\u001b[?2004l\r\n"]
[490.0678, "o", "        Left bound for generating intervals.\r\n"]
[490.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[490.1296, "o", "        Right bound for generating intervals.\r\n"]
[490.1605, "o", "    periods : int, default None\r\n"]
[490.1914, "o", "        Number of periods to generate.\r\n"]
[490.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[490.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[490.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[490.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[490.3459, "o", "    name : str, default None\r\n"]
[490.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[490.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[490.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[490.4695, "o", "        or neither.\r\n"]
[490.5004, "o", "\r\n"]
[490.5313, "o", "    Returns\r\n"]
[490.5622, "o", "    -------\r\n"]
[490.5931, "o", "    IntervalIndex\r\n"]
[490.624, "o", "\r\n"]
[490.6549, "o", "    See Also\r\n"]
[490.6858, "o", "    --------\r\n"]
[490.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[490.7476, "o", "\r\n"]
[490.7785, "o", "    Notes\r\n"]
[490.8094, "o", "    -----\r\n"]
[490.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[490.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[490.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[490.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[490.9639, "o", "\r\n"]
[490.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[491.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[491.0566, "o", "\r\n"]
[491.0875, "o", "    Examples\r\n"]
[491.1184, "o", "    --------\r\n"]
[491.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[491.1802, "o", "\r\n"]
[491.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[491.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[491.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[491.3038, "o", "\r\n"]
[491.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[491.3656, "o", "\r\n"]
[491.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[491.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[491.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[491.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[491.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[491.551, "o", "\r\n"]
[491.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[491.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[491.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[491.6746, "o", "\r\n"]
[491.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[491.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[491.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[491.7982, "o", "\r\n"]
[491.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[491.86, "o", "    convertible to a DateOffset.\r\n"]
[491.8909, "o", "\r\n"]
[491.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[491.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[491.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[492.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[492.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[492.0763, "o", "\r\n"]
[492.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[492.1381, "o", "    automatically (linearly spaced).\r\n"]
[492.169, "o", "\r\n"]
[492.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[492.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[492.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[492.2926, "o", "\r\n"]
[492.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[492.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[492.3853, "o", "\r\n"]
[492.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[492.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[492.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[492.5089, "o", "    \"\"\"\r\n"]
[492.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[492.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[492.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[492.6325, "o", "\r\n"]
[492.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[492.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[492.7252, "o", "\r\n"]
[492.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[492.787, "o", "        raise ValueError(\r\n"]
[492.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[492.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[492.8797, "o", "        )\r\n"]
[492.9106, "o", "\r\n"]
[492.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[492.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[493.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[493.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[493.0651, "o", "\r\n"]
[493.096, "o", "    if is_float(periods):\r\n"]
[493.1269, "o", "        periods = int(periods)\r\n"]
[493.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[493.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[493.2196, "o", "\r\n"]
[493.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[493.2814, "o", "        try:\r\n"]
[493.3123, "o", "            freq = to_offset(freq)\r\n"]
[493.3432, "o", "        except ValueError as err:\r\n"]
[493.3741, "o", "            raise ValueError(\r\n"]
[493.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[493.4359, "o", "            ) from err\r\n"]
[493.4668, "o", "\r\n"]
[493.4977, "o", "    # verify type compatibility\r\n"]
[493.5286, "o", "    if not all(\r\n"]
[493.5595, "o", "        [\r\n"]
[493.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[493.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[493.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[493.6831, "o", "        ]\r\n"]
[493.714, "o", "    ):\r\n"]
[493.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[493.7758, "o", "\r\n"]
[493.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[493.8376, "o", "    if periods is not None:\r\n"]
[493.8685, "o", "        periods += 1\r\n"]
[493.8994, "o", "\r\n"]
[493.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[493.9612, "o", "\r\n"]
[493.9921, "o", "    if is_number(endpoint):\r\n"]
[494.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[494.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[494.0848, "o", "            end -= (end - start) % freq\r\n"]
[494.1157, "o", "\r\n"]
[494.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[494.1775, "o", "        if periods is None:\r\n"]
[494.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[494.2393, "o", "        elif start is None:\r\n"]
[494.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[494.3011, "o", "        elif end is None:\r\n"]
[494.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[494.3629, "o", "\r\n"]
[494.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[494.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[494.4556, "o", "            # np.linspace always produces float output\r\n"]
[494.4865, "o", "\r\n"]
[494.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[494.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[494.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[494.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[494.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[494.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[494.7028, "o", "            )\r\n"]
[494.7337, "o", "    else:\r\n"]
[494.7646, "o", "        # delegate to the appropriate range function\r\n"]
[494.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[494.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[494.8573, "o", "        else:\r\n"]
[494.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[494.9191, "o", "\r\n"]
[495.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[495.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[495.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[495.030355, "o", "\u001b[?2004l\r\n"]
[495.054709, "o", "import numpy as np\r\n"]
[495.079064, "o", "import pytest\r\n"]
[495.103419, "o", "\r\n"]
[495.127773, "o", "from pandas import (\r\n"]
[495.152128, "o", "    Index,\r\n"]
[495.176483, "o", "    IntervalIndex,\r\n"]
[495.200837, "o", "    Timestamp,\r\n"]
[495.225192, "o", "    interval_range,\r\n"]
[495.249547, "o", ")\r\n"]
[495.273901, "o", "import pandas._testing as tm\r\n"]
[495.298256, "o", "\r\n"]
[495.322611, "o", "\r\n"]
[495.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[495.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[495.395675, "o", "\r\n"]
[495.42003, "o", "\r\n"]
[495.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[495.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[495.493094, "o", "\r\n"]
[495.517448, "o", "\r\n"]
[495.541803, "o", "class TestIntervalIndex:\r\n"]
[495.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[495.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[495.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[495.639222, "o", "\r\n"]
[495.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[495.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[495.712286, "o", "        if sort is None:\r\n"]
[495.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[495.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[495.78535, "o", "\r\n"]
[495.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[495.834059, "o", "        if sort is None:\r\n"]
[495.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[495.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[495.907123, "o", "\r\n"]
[495.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[495.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[495.980187, "o", "\r\n"]
[496.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[496.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[496.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[496.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[496.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[496.126315, "o", "\r\n"]
[496.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[496.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[496.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[496.223734, "o", "        expected = other\r\n"]
[496.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[496.272443, "o", "\r\n"]
[496.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[496.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[496.345507, "o", "\r\n"]
[496.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[496.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[496.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[496.442926, "o", "\r\n"]
[496.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[496.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[496.51599, "o", "\r\n"]
[496.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[496.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[496.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[496.613409, "o", "\r\n"]
[496.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[496.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[496.686473, "o", "        if sort is None:\r\n"]
[496.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[496.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[496.759537, "o", "\r\n"]
[496.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[496.808246, "o", "        if sort is None:\r\n"]
[496.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[496.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[496.88131, "o", "\r\n"]
[496.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[496.93002, "o", "\r\n"]
[496.954374, "o", "        # GH 26225: nested intervals\r\n"]
[496.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[497.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[497.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[497.051793, "o", "        result = index.intersection(other)\r\n"]
[497.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[497.100502, "o", "\r\n"]
[497.124857, "o", "        # GH 26225\r\n"]
[497.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[497.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[497.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[497.222276, "o", "        result = index.intersection(other)\r\n"]
[497.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[497.270985, "o", "\r\n"]
[497.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[497.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[497.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[497.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[497.392759, "o", "        result = index.intersection(other)\r\n"]
[497.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[497.441468, "o", "\r\n"]
[497.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[497.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[497.514532, "o", "\r\n"]
[497.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[497.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[497.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[497.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[497.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[497.66066, "o", "\r\n"]
[497.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[497.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[497.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[497.758079, "o", "        expected = other[:0]\r\n"]
[497.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[497.806788, "o", "\r\n"]
[497.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[497.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[497.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[497.904207, "o", "\r\n"]
[497.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[497.952916, "o", "        # GH#38743\r\n"]
[497.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[498.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[498.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[498.050335, "o", "        result = index.intersection(other)\r\n"]
[498.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[498.099044, "o", "\r\n"]
[498.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[498.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[498.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[498.196463, "o", "        expected = index[1:]\r\n"]
[498.220818, "o", "        if sort is None:\r\n"]
[498.245172, "o", "            expected = expected.sort_values()\r\n"]
[498.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[498.293882, "o", "\r\n"]
[498.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[498.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[498.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[498.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[498.415655, "o", "\r\n"]
[498.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[498.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[498.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[498.513074, "o", "        )\r\n"]
[498.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[498.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[498.586138, "o", "\r\n"]
[498.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[498.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[498.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[498.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[498.707911, "o", "        if sort is None:\r\n"]
[498.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[498.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[498.780975, "o", "\r\n"]
[498.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[498.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[498.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[498.878394, "o", "        if sort is None:\r\n"]
[498.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[498.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[498.951458, "o", "\r\n"]
[498.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[499.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[499.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[499.048877, "o", "        )\r\n"]
[499.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[499.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[499.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[499.146296, "o", "\r\n"]
[499.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[499.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[499.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[499.243714, "o", "    )\r\n"]
[499.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[499.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[499.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[499.341133, "o", "\r\n"]
[499.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[499.389842, "o", "        # non-IntervalIndex\r\n"]
[499.414197, "o", "        if op_name == \"difference\":\r\n"]
[499.438552, "o", "            expected = index\r\n"]
[499.462906, "o", "        else:\r\n"]
[499.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[499.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[499.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[499.560325, "o", "\r\n"]
[499.58468, "o", "        # mixed closed -> cast to object\r\n"]
[499.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[499.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[499.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[499.682099, "o", "            if op_name == \"difference\":\r\n"]
[499.706453, "o", "                expected = index\r\n"]
[499.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[499.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[499.779517, "o", "\r\n"]
[499.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[499.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[499.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[499.876936, "o", "        if op_name == \"difference\":\r\n"]
[499.901291, "o", "            expected = index\r\n"]
[499.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[500.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[500.002, "i", "cd asv_bench\r"]
[500.004, "o", "cd asv_bench\r\n"]
[500.006, "o", "\u001b[?2004l\r\n"]
[505.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[505.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[505.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[510.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[510.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[510.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[510.418, "o", "\u001b[?2004l\r\n"]
[510.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[511.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[511.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[512.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[512.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[512.89, "o", "              param1            \r\n"]
[513.302, "o", "             -------- ----------\r\n"]
[513.714, "o", "               1000    1.18\u00b10ms \r\n"]
[514.126, "o", "              100000   77.5\u00b10ms \r\n"]
[514.538, "o", "             ======== ==========\r\n"]
[515.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[515.002, "i", "cd ..\r"]
[515.004, "o", "cd ..\r\n"]
[515.006, "o", "\u001b[?2004l\r\n"]
[520.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[520.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[520.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[522.478, "o", "\u001b[?2004l\r\n"]
[525.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[525.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[525.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[526.654, "o", "\u001b[?2004l\r\n"]
[528.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[530.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[530.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[530.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[530.033165, "o", "\u001b[?2004l\r\n"]
[530.06033, "o", "\r\n"]
[530.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[530.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[530.141824, "o", "\r\n"]
[530.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[530.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[530.223319, "o", "            return False\r\n"]
[530.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[530.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[530.304813, "o", "\r\n"]
[530.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[530.359143, "o", "\r\n"]
[530.386308, "o", "    @cache_readonly\r\n"]
[530.413473, "o", "    def left(self) -> Index:\r\n"]
[530.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[530.467802, "o", "\r\n"]
[530.494967, "o", "    @cache_readonly\r\n"]
[530.522132, "o", "    def right(self) -> Index:\r\n"]
[530.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[530.576462, "o", "\r\n"]
[530.603626, "o", "    @cache_readonly\r\n"]
[530.630791, "o", "    def mid(self) -> Index:\r\n"]
[530.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[530.685121, "o", "\r\n"]
[530.712286, "o", "    @property\r\n"]
[530.739451, "o", "    def length(self) -> Index:\r\n"]
[530.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[530.79378, "o", "\r\n"]
[530.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[530.84811, "o", "    # Rendering Methods\r\n"]
[530.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[530.90244, "o", "\r\n"]
[530.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[530.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[530.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[531.011099, "o", "\r\n"]
[531.038264, "o", "    def _format_native_types(\r\n"]
[531.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[531.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[531.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[531.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[531.174088, "o", "\r\n"]
[531.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[531.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[531.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[531.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[531.309912, "o", "\r\n"]
[531.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[531.364242, "o", "    # Set Operations\r\n"]
[531.391407, "o", "\r\n"]
[531.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[531.445736, "o", "        \"\"\"\r\n"]
[531.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[531.500066, "o", "        \"\"\"\r\n"]
[531.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[531.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[531.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[531.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[531.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[531.663055, "o", "            # multiple NaNs\r\n"]
[531.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[531.717385, "o", "        else:\r\n"]
[531.744549, "o", "            # duplicates\r\n"]
[531.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[531.798879, "o", "\r\n"]
[531.826044, "o", "        if sort is None:\r\n"]
[531.853209, "o", "            taken = taken.sort_values()\r\n"]
[531.880374, "o", "\r\n"]
[531.907538, "o", "        return taken\r\n"]
[531.934703, "o", "\r\n"]
[531.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[531.989033, "o", "        \"\"\"\r\n"]
[532.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[532.043363, "o", "        no matter left or right.\r\n"]
[532.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[532.097692, "o", "        Parameters\r\n"]
[532.124857, "o", "        ----------\r\n"]
[532.152022, "o", "        other : IntervalIndex\r\n"]
[532.179187, "o", "        Returns\r\n"]
[532.206352, "o", "        -------\r\n"]
[532.233516, "o", "        IntervalIndex\r\n"]
[532.260681, "o", "        \"\"\"\r\n"]
[532.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[532.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[532.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[532.369341, "o", "\r\n"]
[532.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[532.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[532.450835, "o", "        indexer = unique(indexer)\r\n"]
[532.478, "o", "\r\n"]
[532.505165, "o", "        return self.take(indexer)\r\n"]
[532.53233, "o", "\r\n"]
[532.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[532.586659, "o", "        \"\"\"\r\n"]
[532.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[532.640989, "o", "        on either sides.\r\n"]
[532.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[532.695319, "o", "\r\n"]
[532.722484, "o", "        Parameters\r\n"]
[532.749648, "o", "        ----------\r\n"]
[532.776813, "o", "        other : IntervalIndex\r\n"]
[532.803978, "o", "\r\n"]
[532.831143, "o", "        Returns\r\n"]
[532.858308, "o", "        -------\r\n"]
[532.885473, "o", "        IntervalIndex\r\n"]
[532.912637, "o", "        \"\"\"\r\n"]
[532.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[532.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[532.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[533.021297, "o", "\r\n"]
[533.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[533.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[533.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[533.129956, "o", "\r\n"]
[533.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[533.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[533.211451, "o", "            if tup in other_tups:\r\n"]
[533.238615, "o", "                mask[i] = True\r\n"]
[533.26578, "o", "\r\n"]
[533.292945, "o", "        return self[mask]\r\n"]
[533.32011, "o", "\r\n"]
[533.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[533.37444, "o", "\r\n"]
[533.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[533.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[533.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[533.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[533.510264, "o", "        raise NotImplementedError(\r\n"]
[533.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[533.564593, "o", "            \"IndexEngine objects\"\r\n"]
[533.591758, "o", "        )\r\n"]
[533.618923, "o", "\r\n"]
[533.646088, "o", "    def _from_join_target(self, result):\r\n"]
[533.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[533.700418, "o", "\r\n"]
[533.727582, "o", "    # TODO: arithmetic operations\r\n"]
[533.754747, "o", "\r\n"]
[533.781912, "o", "\r\n"]
[533.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[533.836242, "o", "    \"\"\"\r\n"]
[533.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[533.890571, "o", "    \"\"\"\r\n"]
[533.917736, "o", "    return any(\r\n"]
[533.944901, "o", "        [\r\n"]
[533.972066, "o", "            is_number(endpoint),\r\n"]
[533.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[534.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[534.05356, "o", "            endpoint is None,\r\n"]
[534.080725, "o", "        ]\r\n"]
[534.10789, "o", "    )\r\n"]
[534.135055, "o", "\r\n"]
[534.16222, "o", "\r\n"]
[534.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[534.216549, "o", "    \"\"\"\r\n"]
[534.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[534.270879, "o", "    \"\"\"\r\n"]
[534.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[534.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[534.352374, "o", "    return (\r\n"]
[534.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[534.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[534.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[534.461033, "o", "        or com.any_none(a, b)\r\n"]
[534.488198, "o", "    )\r\n"]
[534.515363, "o", "\r\n"]
[534.542527, "o", "\r\n"]
[534.569692, "o", "def interval_range(\r\n"]
[534.596857, "o", "    start=None,\r\n"]
[534.624022, "o", "    end=None,\r\n"]
[534.651187, "o", "    periods=None,\r\n"]
[534.678352, "o", "    freq=None,\r\n"]
[534.705516, "o", "    name: Hashable = None,\r\n"]
[534.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[534.759846, "o", ") -> IntervalIndex:\r\n"]
[534.787011, "o", "    \"\"\"\r\n"]
[534.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[534.841341, "o", "\r\n"]
[534.868505, "o", "    Parameters\r\n"]
[534.89567, "o", "    ----------\r\n"]
[534.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[535.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[535.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[535.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[535.0369, "o", "\u001b[?2004l\r\n"]
[535.0678, "o", "        Left bound for generating intervals.\r\n"]
[535.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[535.1296, "o", "        Right bound for generating intervals.\r\n"]
[535.1605, "o", "    periods : int, default None\r\n"]
[535.1914, "o", "        Number of periods to generate.\r\n"]
[535.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[535.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[535.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[535.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[535.3459, "o", "    name : str, default None\r\n"]
[535.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[535.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[535.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[535.4695, "o", "        or neither.\r\n"]
[535.5004, "o", "\r\n"]
[535.5313, "o", "    Returns\r\n"]
[535.5622, "o", "    -------\r\n"]
[535.5931, "o", "    IntervalIndex\r\n"]
[535.624, "o", "\r\n"]
[535.6549, "o", "    See Also\r\n"]
[535.6858, "o", "    --------\r\n"]
[535.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[535.7476, "o", "\r\n"]
[535.7785, "o", "    Notes\r\n"]
[535.8094, "o", "    -----\r\n"]
[535.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[535.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[535.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[535.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[535.9639, "o", "\r\n"]
[535.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[536.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[536.0566, "o", "\r\n"]
[536.0875, "o", "    Examples\r\n"]
[536.1184, "o", "    --------\r\n"]
[536.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[536.1802, "o", "\r\n"]
[536.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[536.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[536.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[536.3038, "o", "\r\n"]
[536.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[536.3656, "o", "\r\n"]
[536.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[536.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[536.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[536.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[536.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[536.551, "o", "\r\n"]
[536.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[536.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[536.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[536.6746, "o", "\r\n"]
[536.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[536.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[536.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[536.7982, "o", "\r\n"]
[536.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[536.86, "o", "    convertible to a DateOffset.\r\n"]
[536.8909, "o", "\r\n"]
[536.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[536.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[536.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[537.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[537.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[537.0763, "o", "\r\n"]
[537.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[537.1381, "o", "    automatically (linearly spaced).\r\n"]
[537.169, "o", "\r\n"]
[537.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[537.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[537.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[537.2926, "o", "\r\n"]
[537.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[537.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[537.3853, "o", "\r\n"]
[537.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[537.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[537.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[537.5089, "o", "    \"\"\"\r\n"]
[537.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[537.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[537.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[537.6325, "o", "\r\n"]
[537.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[537.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[537.7252, "o", "\r\n"]
[537.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[537.787, "o", "        raise ValueError(\r\n"]
[537.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[537.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[537.8797, "o", "        )\r\n"]
[537.9106, "o", "\r\n"]
[537.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[537.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[538.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[538.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[538.0651, "o", "\r\n"]
[538.096, "o", "    if is_float(periods):\r\n"]
[538.1269, "o", "        periods = int(periods)\r\n"]
[538.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[538.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[538.2196, "o", "\r\n"]
[538.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[538.2814, "o", "        try:\r\n"]
[538.3123, "o", "            freq = to_offset(freq)\r\n"]
[538.3432, "o", "        except ValueError as err:\r\n"]
[538.3741, "o", "            raise ValueError(\r\n"]
[538.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[538.4359, "o", "            ) from err\r\n"]
[538.4668, "o", "\r\n"]
[538.4977, "o", "    # verify type compatibility\r\n"]
[538.5286, "o", "    if not all(\r\n"]
[538.5595, "o", "        [\r\n"]
[538.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[538.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[538.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[538.6831, "o", "        ]\r\n"]
[538.714, "o", "    ):\r\n"]
[538.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[538.7758, "o", "\r\n"]
[538.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[538.8376, "o", "    if periods is not None:\r\n"]
[538.8685, "o", "        periods += 1\r\n"]
[538.8994, "o", "\r\n"]
[538.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[538.9612, "o", "\r\n"]
[538.9921, "o", "    if is_number(endpoint):\r\n"]
[539.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[539.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[539.0848, "o", "            end -= (end - start) % freq\r\n"]
[539.1157, "o", "\r\n"]
[539.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[539.1775, "o", "        if periods is None:\r\n"]
[539.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[539.2393, "o", "        elif start is None:\r\n"]
[539.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[539.3011, "o", "        elif end is None:\r\n"]
[539.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[539.3629, "o", "\r\n"]
[539.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[539.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[539.4556, "o", "            # np.linspace always produces float output\r\n"]
[539.4865, "o", "\r\n"]
[539.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[539.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[539.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[539.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[539.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[539.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[539.7028, "o", "            )\r\n"]
[539.7337, "o", "    else:\r\n"]
[539.7646, "o", "        # delegate to the appropriate range function\r\n"]
[539.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[539.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[539.8573, "o", "        else:\r\n"]
[539.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[539.9191, "o", "\r\n"]
[540.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[540.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[540.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[540.030355, "o", "\u001b[?2004l\r\n"]
[540.054709, "o", "import numpy as np\r\n"]
[540.079064, "o", "import pytest\r\n"]
[540.103419, "o", "\r\n"]
[540.127773, "o", "from pandas import (\r\n"]
[540.152128, "o", "    Index,\r\n"]
[540.176483, "o", "    IntervalIndex,\r\n"]
[540.200837, "o", "    Timestamp,\r\n"]
[540.225192, "o", "    interval_range,\r\n"]
[540.249547, "o", ")\r\n"]
[540.273901, "o", "import pandas._testing as tm\r\n"]
[540.298256, "o", "\r\n"]
[540.322611, "o", "\r\n"]
[540.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[540.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[540.395675, "o", "\r\n"]
[540.42003, "o", "\r\n"]
[540.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[540.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[540.493094, "o", "\r\n"]
[540.517448, "o", "\r\n"]
[540.541803, "o", "class TestIntervalIndex:\r\n"]
[540.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[540.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[540.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[540.639222, "o", "\r\n"]
[540.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[540.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[540.712286, "o", "        if sort is None:\r\n"]
[540.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[540.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[540.78535, "o", "\r\n"]
[540.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[540.834059, "o", "        if sort is None:\r\n"]
[540.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[540.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[540.907123, "o", "\r\n"]
[540.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[540.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[540.980187, "o", "\r\n"]
[541.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[541.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[541.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[541.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[541.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[541.126315, "o", "\r\n"]
[541.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[541.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[541.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[541.223734, "o", "        expected = other\r\n"]
[541.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[541.272443, "o", "\r\n"]
[541.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[541.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[541.345507, "o", "\r\n"]
[541.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[541.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[541.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[541.442926, "o", "\r\n"]
[541.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[541.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[541.51599, "o", "\r\n"]
[541.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[541.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[541.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[541.613409, "o", "\r\n"]
[541.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[541.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[541.686473, "o", "        if sort is None:\r\n"]
[541.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[541.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[541.759537, "o", "\r\n"]
[541.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[541.808246, "o", "        if sort is None:\r\n"]
[541.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[541.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[541.88131, "o", "\r\n"]
[541.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[541.93002, "o", "\r\n"]
[541.954374, "o", "        # GH 26225: nested intervals\r\n"]
[541.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[542.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[542.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[542.051793, "o", "        result = index.intersection(other)\r\n"]
[542.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[542.100502, "o", "\r\n"]
[542.124857, "o", "        # GH 26225\r\n"]
[542.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[542.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[542.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[542.222276, "o", "        result = index.intersection(other)\r\n"]
[542.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[542.270985, "o", "\r\n"]
[542.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[542.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[542.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[542.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[542.392759, "o", "        result = index.intersection(other)\r\n"]
[542.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[542.441468, "o", "\r\n"]
[542.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[542.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[542.514532, "o", "\r\n"]
[542.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[542.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[542.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[542.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[542.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[542.66066, "o", "\r\n"]
[542.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[542.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[542.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[542.758079, "o", "        expected = other[:0]\r\n"]
[542.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[542.806788, "o", "\r\n"]
[542.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[542.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[542.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[542.904207, "o", "\r\n"]
[542.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[542.952916, "o", "        # GH#38743\r\n"]
[542.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[543.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[543.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[543.050335, "o", "        result = index.intersection(other)\r\n"]
[543.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[543.099044, "o", "\r\n"]
[543.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[543.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[543.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[543.196463, "o", "        expected = index[1:]\r\n"]
[543.220818, "o", "        if sort is None:\r\n"]
[543.245172, "o", "            expected = expected.sort_values()\r\n"]
[543.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[543.293882, "o", "\r\n"]
[543.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[543.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[543.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[543.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[543.415655, "o", "\r\n"]
[543.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[543.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[543.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[543.513074, "o", "        )\r\n"]
[543.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[543.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[543.586138, "o", "\r\n"]
[543.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[543.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[543.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[543.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[543.707911, "o", "        if sort is None:\r\n"]
[543.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[543.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[543.780975, "o", "\r\n"]
[543.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[543.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[543.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[543.878394, "o", "        if sort is None:\r\n"]
[543.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[543.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[543.951458, "o", "\r\n"]
[543.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[544.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[544.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[544.048877, "o", "        )\r\n"]
[544.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[544.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[544.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[544.146296, "o", "\r\n"]
[544.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[544.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[544.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[544.243714, "o", "    )\r\n"]
[544.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[544.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[544.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[544.341133, "o", "\r\n"]
[544.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[544.389842, "o", "        # non-IntervalIndex\r\n"]
[544.414197, "o", "        if op_name == \"difference\":\r\n"]
[544.438552, "o", "            expected = index\r\n"]
[544.462906, "o", "        else:\r\n"]
[544.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[544.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[544.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[544.560325, "o", "\r\n"]
[544.58468, "o", "        # mixed closed -> cast to object\r\n"]
[544.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[544.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[544.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[544.682099, "o", "            if op_name == \"difference\":\r\n"]
[544.706453, "o", "                expected = index\r\n"]
[544.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[544.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[544.779517, "o", "\r\n"]
[544.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[544.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[544.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[544.876936, "o", "        if op_name == \"difference\":\r\n"]
[544.901291, "o", "            expected = index\r\n"]
[544.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[545.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[545.002, "i", "cd asv_bench\r"]
[545.004, "o", "cd asv_bench\r\n"]
[545.006, "o", "\u001b[?2004l\r\n"]
[550.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[550.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[550.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[555.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[555.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[555.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[555.418, "o", "\u001b[?2004l\r\n"]
[555.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[556.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[556.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[557.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[557.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[557.89, "o", "              param1            \r\n"]
[558.302, "o", "             -------- ----------\r\n"]
[558.714, "o", "               1000    1.15\u00b10ms \r\n"]
[559.126, "o", "              100000   76.4\u00b10ms \r\n"]
[559.538, "o", "             ======== ==========\r\n"]
[560.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[560.002, "i", "cd ..\r"]
[560.004, "o", "cd ..\r\n"]
[560.006, "o", "\u001b[?2004l\r\n"]
[565.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[565.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[565.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[567.478, "o", "\u001b[?2004l\r\n"]
[570.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[570.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[570.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[571.654, "o", "\u001b[?2004l\r\n"]
[573.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[575.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[575.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[575.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[575.033165, "o", "\u001b[?2004l\r\n"]
[575.06033, "o", "\r\n"]
[575.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[575.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[575.141824, "o", "\r\n"]
[575.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[575.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[575.223319, "o", "            return False\r\n"]
[575.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[575.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[575.304813, "o", "\r\n"]
[575.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[575.359143, "o", "\r\n"]
[575.386308, "o", "    @cache_readonly\r\n"]
[575.413473, "o", "    def left(self) -> Index:\r\n"]
[575.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[575.467802, "o", "\r\n"]
[575.494967, "o", "    @cache_readonly\r\n"]
[575.522132, "o", "    def right(self) -> Index:\r\n"]
[575.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[575.576462, "o", "\r\n"]
[575.603626, "o", "    @cache_readonly\r\n"]
[575.630791, "o", "    def mid(self) -> Index:\r\n"]
[575.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[575.685121, "o", "\r\n"]
[575.712286, "o", "    @property\r\n"]
[575.739451, "o", "    def length(self) -> Index:\r\n"]
[575.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[575.79378, "o", "\r\n"]
[575.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[575.84811, "o", "    # Rendering Methods\r\n"]
[575.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[575.90244, "o", "\r\n"]
[575.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[575.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[575.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[576.011099, "o", "\r\n"]
[576.038264, "o", "    def _format_native_types(\r\n"]
[576.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[576.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[576.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[576.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[576.174088, "o", "\r\n"]
[576.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[576.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[576.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[576.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[576.309912, "o", "\r\n"]
[576.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[576.364242, "o", "    # Set Operations\r\n"]
[576.391407, "o", "\r\n"]
[576.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[576.445736, "o", "        \"\"\"\r\n"]
[576.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[576.500066, "o", "        \"\"\"\r\n"]
[576.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[576.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[576.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[576.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[576.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[576.663055, "o", "            # multiple NaNs\r\n"]
[576.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[576.717385, "o", "        else:\r\n"]
[576.744549, "o", "            # duplicates\r\n"]
[576.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[576.798879, "o", "\r\n"]
[576.826044, "o", "        if sort is None:\r\n"]
[576.853209, "o", "            taken = taken.sort_values()\r\n"]
[576.880374, "o", "\r\n"]
[576.907538, "o", "        return taken\r\n"]
[576.934703, "o", "\r\n"]
[576.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[576.989033, "o", "        \"\"\"\r\n"]
[577.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[577.043363, "o", "        no matter left or right.\r\n"]
[577.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[577.097692, "o", "        Parameters\r\n"]
[577.124857, "o", "        ----------\r\n"]
[577.152022, "o", "        other : IntervalIndex\r\n"]
[577.179187, "o", "        Returns\r\n"]
[577.206352, "o", "        -------\r\n"]
[577.233516, "o", "        IntervalIndex\r\n"]
[577.260681, "o", "        \"\"\"\r\n"]
[577.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[577.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[577.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[577.369341, "o", "\r\n"]
[577.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[577.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[577.450835, "o", "        indexer = unique(indexer)\r\n"]
[577.478, "o", "\r\n"]
[577.505165, "o", "        return self.take(indexer)\r\n"]
[577.53233, "o", "\r\n"]
[577.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[577.586659, "o", "        \"\"\"\r\n"]
[577.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[577.640989, "o", "        on either sides.\r\n"]
[577.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[577.695319, "o", "\r\n"]
[577.722484, "o", "        Parameters\r\n"]
[577.749648, "o", "        ----------\r\n"]
[577.776813, "o", "        other : IntervalIndex\r\n"]
[577.803978, "o", "\r\n"]
[577.831143, "o", "        Returns\r\n"]
[577.858308, "o", "        -------\r\n"]
[577.885473, "o", "        IntervalIndex\r\n"]
[577.912637, "o", "        \"\"\"\r\n"]
[577.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[577.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[577.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[578.021297, "o", "\r\n"]
[578.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[578.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[578.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[578.129956, "o", "\r\n"]
[578.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[578.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[578.211451, "o", "            if tup in other_tups:\r\n"]
[578.238615, "o", "                mask[i] = True\r\n"]
[578.26578, "o", "\r\n"]
[578.292945, "o", "        return self[mask]\r\n"]
[578.32011, "o", "\r\n"]
[578.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[578.37444, "o", "\r\n"]
[578.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[578.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[578.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[578.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[578.510264, "o", "        raise NotImplementedError(\r\n"]
[578.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[578.564593, "o", "            \"IndexEngine objects\"\r\n"]
[578.591758, "o", "        )\r\n"]
[578.618923, "o", "\r\n"]
[578.646088, "o", "    def _from_join_target(self, result):\r\n"]
[578.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[578.700418, "o", "\r\n"]
[578.727582, "o", "    # TODO: arithmetic operations\r\n"]
[578.754747, "o", "\r\n"]
[578.781912, "o", "\r\n"]
[578.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[578.836242, "o", "    \"\"\"\r\n"]
[578.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[578.890571, "o", "    \"\"\"\r\n"]
[578.917736, "o", "    return any(\r\n"]
[578.944901, "o", "        [\r\n"]
[578.972066, "o", "            is_number(endpoint),\r\n"]
[578.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[579.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[579.05356, "o", "            endpoint is None,\r\n"]
[579.080725, "o", "        ]\r\n"]
[579.10789, "o", "    )\r\n"]
[579.135055, "o", "\r\n"]
[579.16222, "o", "\r\n"]
[579.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[579.216549, "o", "    \"\"\"\r\n"]
[579.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[579.270879, "o", "    \"\"\"\r\n"]
[579.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[579.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[579.352374, "o", "    return (\r\n"]
[579.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[579.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[579.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[579.461033, "o", "        or com.any_none(a, b)\r\n"]
[579.488198, "o", "    )\r\n"]
[579.515363, "o", "\r\n"]
[579.542527, "o", "\r\n"]
[579.569692, "o", "def interval_range(\r\n"]
[579.596857, "o", "    start=None,\r\n"]
[579.624022, "o", "    end=None,\r\n"]
[579.651187, "o", "    periods=None,\r\n"]
[579.678352, "o", "    freq=None,\r\n"]
[579.705516, "o", "    name: Hashable = None,\r\n"]
[579.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[579.759846, "o", ") -> IntervalIndex:\r\n"]
[579.787011, "o", "    \"\"\"\r\n"]
[579.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[579.841341, "o", "\r\n"]
[579.868505, "o", "    Parameters\r\n"]
[579.89567, "o", "    ----------\r\n"]
[579.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[580.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[580.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[580.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[580.0369, "o", "\u001b[?2004l\r\n"]
[580.0678, "o", "        Left bound for generating intervals.\r\n"]
[580.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[580.1296, "o", "        Right bound for generating intervals.\r\n"]
[580.1605, "o", "    periods : int, default None\r\n"]
[580.1914, "o", "        Number of periods to generate.\r\n"]
[580.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[580.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[580.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[580.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[580.3459, "o", "    name : str, default None\r\n"]
[580.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[580.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[580.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[580.4695, "o", "        or neither.\r\n"]
[580.5004, "o", "\r\n"]
[580.5313, "o", "    Returns\r\n"]
[580.5622, "o", "    -------\r\n"]
[580.5931, "o", "    IntervalIndex\r\n"]
[580.624, "o", "\r\n"]
[580.6549, "o", "    See Also\r\n"]
[580.6858, "o", "    --------\r\n"]
[580.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[580.7476, "o", "\r\n"]
[580.7785, "o", "    Notes\r\n"]
[580.8094, "o", "    -----\r\n"]
[580.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[580.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[580.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[580.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[580.9639, "o", "\r\n"]
[580.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[581.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[581.0566, "o", "\r\n"]
[581.0875, "o", "    Examples\r\n"]
[581.1184, "o", "    --------\r\n"]
[581.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[581.1802, "o", "\r\n"]
[581.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[581.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[581.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[581.3038, "o", "\r\n"]
[581.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[581.3656, "o", "\r\n"]
[581.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[581.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[581.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[581.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[581.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[581.551, "o", "\r\n"]
[581.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[581.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[581.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[581.6746, "o", "\r\n"]
[581.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[581.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[581.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[581.7982, "o", "\r\n"]
[581.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[581.86, "o", "    convertible to a DateOffset.\r\n"]
[581.8909, "o", "\r\n"]
[581.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[581.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[581.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[582.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[582.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[582.0763, "o", "\r\n"]
[582.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[582.1381, "o", "    automatically (linearly spaced).\r\n"]
[582.169, "o", "\r\n"]
[582.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[582.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[582.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[582.2926, "o", "\r\n"]
[582.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[582.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[582.3853, "o", "\r\n"]
[582.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[582.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[582.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[582.5089, "o", "    \"\"\"\r\n"]
[582.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[582.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[582.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[582.6325, "o", "\r\n"]
[582.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[582.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[582.7252, "o", "\r\n"]
[582.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[582.787, "o", "        raise ValueError(\r\n"]
[582.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[582.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[582.8797, "o", "        )\r\n"]
[582.9106, "o", "\r\n"]
[582.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[582.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[583.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[583.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[583.0651, "o", "\r\n"]
[583.096, "o", "    if is_float(periods):\r\n"]
[583.1269, "o", "        periods = int(periods)\r\n"]
[583.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[583.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[583.2196, "o", "\r\n"]
[583.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[583.2814, "o", "        try:\r\n"]
[583.3123, "o", "            freq = to_offset(freq)\r\n"]
[583.3432, "o", "        except ValueError as err:\r\n"]
[583.3741, "o", "            raise ValueError(\r\n"]
[583.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[583.4359, "o", "            ) from err\r\n"]
[583.4668, "o", "\r\n"]
[583.4977, "o", "    # verify type compatibility\r\n"]
[583.5286, "o", "    if not all(\r\n"]
[583.5595, "o", "        [\r\n"]
[583.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[583.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[583.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[583.6831, "o", "        ]\r\n"]
[583.714, "o", "    ):\r\n"]
[583.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[583.7758, "o", "\r\n"]
[583.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[583.8376, "o", "    if periods is not None:\r\n"]
[583.8685, "o", "        periods += 1\r\n"]
[583.8994, "o", "\r\n"]
[583.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[583.9612, "o", "\r\n"]
[583.9921, "o", "    if is_number(endpoint):\r\n"]
[584.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[584.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[584.0848, "o", "            end -= (end - start) % freq\r\n"]
[584.1157, "o", "\r\n"]
[584.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[584.1775, "o", "        if periods is None:\r\n"]
[584.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[584.2393, "o", "        elif start is None:\r\n"]
[584.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[584.3011, "o", "        elif end is None:\r\n"]
[584.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[584.3629, "o", "\r\n"]
[584.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[584.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[584.4556, "o", "            # np.linspace always produces float output\r\n"]
[584.4865, "o", "\r\n"]
[584.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[584.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[584.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[584.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[584.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[584.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[584.7028, "o", "            )\r\n"]
[584.7337, "o", "    else:\r\n"]
[584.7646, "o", "        # delegate to the appropriate range function\r\n"]
[584.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[584.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[584.8573, "o", "        else:\r\n"]
[584.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[584.9191, "o", "\r\n"]
[585.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[585.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[585.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[585.030355, "o", "\u001b[?2004l\r\n"]
[585.054709, "o", "import numpy as np\r\n"]
[585.079064, "o", "import pytest\r\n"]
[585.103419, "o", "\r\n"]
[585.127773, "o", "from pandas import (\r\n"]
[585.152128, "o", "    Index,\r\n"]
[585.176483, "o", "    IntervalIndex,\r\n"]
[585.200837, "o", "    Timestamp,\r\n"]
[585.225192, "o", "    interval_range,\r\n"]
[585.249547, "o", ")\r\n"]
[585.273901, "o", "import pandas._testing as tm\r\n"]
[585.298256, "o", "\r\n"]
[585.322611, "o", "\r\n"]
[585.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[585.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[585.395675, "o", "\r\n"]
[585.42003, "o", "\r\n"]
[585.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[585.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[585.493094, "o", "\r\n"]
[585.517448, "o", "\r\n"]
[585.541803, "o", "class TestIntervalIndex:\r\n"]
[585.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[585.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[585.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[585.639222, "o", "\r\n"]
[585.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[585.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[585.712286, "o", "        if sort is None:\r\n"]
[585.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[585.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[585.78535, "o", "\r\n"]
[585.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[585.834059, "o", "        if sort is None:\r\n"]
[585.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[585.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[585.907123, "o", "\r\n"]
[585.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[585.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[585.980187, "o", "\r\n"]
[586.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[586.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[586.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[586.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[586.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[586.126315, "o", "\r\n"]
[586.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[586.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[586.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[586.223734, "o", "        expected = other\r\n"]
[586.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[586.272443, "o", "\r\n"]
[586.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[586.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[586.345507, "o", "\r\n"]
[586.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[586.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[586.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[586.442926, "o", "\r\n"]
[586.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[586.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[586.51599, "o", "\r\n"]
[586.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[586.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[586.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[586.613409, "o", "\r\n"]
[586.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[586.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[586.686473, "o", "        if sort is None:\r\n"]
[586.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[586.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[586.759537, "o", "\r\n"]
[586.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[586.808246, "o", "        if sort is None:\r\n"]
[586.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[586.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[586.88131, "o", "\r\n"]
[586.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[586.93002, "o", "\r\n"]
[586.954374, "o", "        # GH 26225: nested intervals\r\n"]
[586.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[587.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[587.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[587.051793, "o", "        result = index.intersection(other)\r\n"]
[587.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[587.100502, "o", "\r\n"]
[587.124857, "o", "        # GH 26225\r\n"]
[587.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[587.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[587.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[587.222276, "o", "        result = index.intersection(other)\r\n"]
[587.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[587.270985, "o", "\r\n"]
[587.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[587.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[587.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[587.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[587.392759, "o", "        result = index.intersection(other)\r\n"]
[587.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[587.441468, "o", "\r\n"]
[587.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[587.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[587.514532, "o", "\r\n"]
[587.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[587.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[587.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[587.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[587.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[587.66066, "o", "\r\n"]
[587.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[587.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[587.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[587.758079, "o", "        expected = other[:0]\r\n"]
[587.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[587.806788, "o", "\r\n"]
[587.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[587.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[587.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[587.904207, "o", "\r\n"]
[587.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[587.952916, "o", "        # GH#38743\r\n"]
[587.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[588.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[588.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[588.050335, "o", "        result = index.intersection(other)\r\n"]
[588.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[588.099044, "o", "\r\n"]
[588.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[588.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[588.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[588.196463, "o", "        expected = index[1:]\r\n"]
[588.220818, "o", "        if sort is None:\r\n"]
[588.245172, "o", "            expected = expected.sort_values()\r\n"]
[588.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[588.293882, "o", "\r\n"]
[588.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[588.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[588.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[588.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[588.415655, "o", "\r\n"]
[588.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[588.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[588.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[588.513074, "o", "        )\r\n"]
[588.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[588.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[588.586138, "o", "\r\n"]
[588.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[588.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[588.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[588.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[588.707911, "o", "        if sort is None:\r\n"]
[588.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[588.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[588.780975, "o", "\r\n"]
[588.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[588.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[588.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[588.878394, "o", "        if sort is None:\r\n"]
[588.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[588.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[588.951458, "o", "\r\n"]
[588.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[589.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[589.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[589.048877, "o", "        )\r\n"]
[589.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[589.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[589.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[589.146296, "o", "\r\n"]
[589.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[589.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[589.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[589.243714, "o", "    )\r\n"]
[589.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[589.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[589.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[589.341133, "o", "\r\n"]
[589.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[589.389842, "o", "        # non-IntervalIndex\r\n"]
[589.414197, "o", "        if op_name == \"difference\":\r\n"]
[589.438552, "o", "            expected = index\r\n"]
[589.462906, "o", "        else:\r\n"]
[589.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[589.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[589.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[589.560325, "o", "\r\n"]
[589.58468, "o", "        # mixed closed -> cast to object\r\n"]
[589.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[589.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[589.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[589.682099, "o", "            if op_name == \"difference\":\r\n"]
[589.706453, "o", "                expected = index\r\n"]
[589.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[589.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[589.779517, "o", "\r\n"]
[589.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[589.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[589.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[589.876936, "o", "        if op_name == \"difference\":\r\n"]
[589.901291, "o", "            expected = index\r\n"]
[589.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[590.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[590.002, "i", "cd asv_bench\r"]
[590.004, "o", "cd asv_bench\r\n"]
[590.006, "o", "\u001b[?2004l\r\n"]
[595.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[595.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[595.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[600.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[600.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[600.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[600.418, "o", "\u001b[?2004l\r\n"]
[600.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[601.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[601.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[602.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[602.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[602.89, "o", "              param1            \r\n"]
[603.302, "o", "             -------- ----------\r\n"]
[603.714, "o", "               1000    1.21\u00b10ms \r\n"]
[604.126, "o", "              100000   85.0\u00b10ms \r\n"]
[604.538, "o", "             ======== ==========\r\n"]
[605.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[605.002, "i", "cd ..\r"]
[605.004, "o", "cd ..\r\n"]
[605.006, "o", "\u001b[?2004l\r\n"]
[610.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[610.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[610.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[612.478, "o", "\u001b[?2004l\r\n"]
[615.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[615.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[615.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[616.654, "o", "\u001b[?2004l\r\n"]
[618.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[620.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[620.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[620.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[620.033165, "o", "\u001b[?2004l\r\n"]
[620.06033, "o", "\r\n"]
[620.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[620.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[620.141824, "o", "\r\n"]
[620.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[620.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[620.223319, "o", "            return False\r\n"]
[620.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[620.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[620.304813, "o", "\r\n"]
[620.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[620.359143, "o", "\r\n"]
[620.386308, "o", "    @cache_readonly\r\n"]
[620.413473, "o", "    def left(self) -> Index:\r\n"]
[620.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[620.467802, "o", "\r\n"]
[620.494967, "o", "    @cache_readonly\r\n"]
[620.522132, "o", "    def right(self) -> Index:\r\n"]
[620.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[620.576462, "o", "\r\n"]
[620.603626, "o", "    @cache_readonly\r\n"]
[620.630791, "o", "    def mid(self) -> Index:\r\n"]
[620.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[620.685121, "o", "\r\n"]
[620.712286, "o", "    @property\r\n"]
[620.739451, "o", "    def length(self) -> Index:\r\n"]
[620.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[620.79378, "o", "\r\n"]
[620.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[620.84811, "o", "    # Rendering Methods\r\n"]
[620.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[620.90244, "o", "\r\n"]
[620.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[620.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[620.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[621.011099, "o", "\r\n"]
[621.038264, "o", "    def _format_native_types(\r\n"]
[621.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[621.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[621.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[621.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[621.174088, "o", "\r\n"]
[621.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[621.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[621.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[621.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[621.309912, "o", "\r\n"]
[621.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[621.364242, "o", "    # Set Operations\r\n"]
[621.391407, "o", "\r\n"]
[621.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[621.445736, "o", "        \"\"\"\r\n"]
[621.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[621.500066, "o", "        \"\"\"\r\n"]
[621.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[621.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[621.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[621.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[621.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[621.663055, "o", "            # multiple NaNs\r\n"]
[621.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[621.717385, "o", "        else:\r\n"]
[621.744549, "o", "            # duplicates\r\n"]
[621.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[621.798879, "o", "\r\n"]
[621.826044, "o", "        if sort is None:\r\n"]
[621.853209, "o", "            taken = taken.sort_values()\r\n"]
[621.880374, "o", "\r\n"]
[621.907538, "o", "        return taken\r\n"]
[621.934703, "o", "\r\n"]
[621.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[621.989033, "o", "        \"\"\"\r\n"]
[622.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[622.043363, "o", "        no matter left or right.\r\n"]
[622.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[622.097692, "o", "        Parameters\r\n"]
[622.124857, "o", "        ----------\r\n"]
[622.152022, "o", "        other : IntervalIndex\r\n"]
[622.179187, "o", "        Returns\r\n"]
[622.206352, "o", "        -------\r\n"]
[622.233516, "o", "        IntervalIndex\r\n"]
[622.260681, "o", "        \"\"\"\r\n"]
[622.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[622.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[622.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[622.369341, "o", "\r\n"]
[622.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[622.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[622.450835, "o", "        indexer = unique(indexer)\r\n"]
[622.478, "o", "\r\n"]
[622.505165, "o", "        return self.take(indexer)\r\n"]
[622.53233, "o", "\r\n"]
[622.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[622.586659, "o", "        \"\"\"\r\n"]
[622.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[622.640989, "o", "        on either sides.\r\n"]
[622.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[622.695319, "o", "\r\n"]
[622.722484, "o", "        Parameters\r\n"]
[622.749648, "o", "        ----------\r\n"]
[622.776813, "o", "        other : IntervalIndex\r\n"]
[622.803978, "o", "\r\n"]
[622.831143, "o", "        Returns\r\n"]
[622.858308, "o", "        -------\r\n"]
[622.885473, "o", "        IntervalIndex\r\n"]
[622.912637, "o", "        \"\"\"\r\n"]
[622.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[622.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[622.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[623.021297, "o", "\r\n"]
[623.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[623.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[623.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[623.129956, "o", "\r\n"]
[623.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[623.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[623.211451, "o", "            if tup in other_tups:\r\n"]
[623.238615, "o", "                mask[i] = True\r\n"]
[623.26578, "o", "\r\n"]
[623.292945, "o", "        return self[mask]\r\n"]
[623.32011, "o", "\r\n"]
[623.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[623.37444, "o", "\r\n"]
[623.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[623.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[623.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[623.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[623.510264, "o", "        raise NotImplementedError(\r\n"]
[623.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[623.564593, "o", "            \"IndexEngine objects\"\r\n"]
[623.591758, "o", "        )\r\n"]
[623.618923, "o", "\r\n"]
[623.646088, "o", "    def _from_join_target(self, result):\r\n"]
[623.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[623.700418, "o", "\r\n"]
[623.727582, "o", "    # TODO: arithmetic operations\r\n"]
[623.754747, "o", "\r\n"]
[623.781912, "o", "\r\n"]
[623.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[623.836242, "o", "    \"\"\"\r\n"]
[623.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[623.890571, "o", "    \"\"\"\r\n"]
[623.917736, "o", "    return any(\r\n"]
[623.944901, "o", "        [\r\n"]
[623.972066, "o", "            is_number(endpoint),\r\n"]
[623.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[624.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[624.05356, "o", "            endpoint is None,\r\n"]
[624.080725, "o", "        ]\r\n"]
[624.10789, "o", "    )\r\n"]
[624.135055, "o", "\r\n"]
[624.16222, "o", "\r\n"]
[624.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[624.216549, "o", "    \"\"\"\r\n"]
[624.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[624.270879, "o", "    \"\"\"\r\n"]
[624.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[624.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[624.352374, "o", "    return (\r\n"]
[624.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[624.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[624.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[624.461033, "o", "        or com.any_none(a, b)\r\n"]
[624.488198, "o", "    )\r\n"]
[624.515363, "o", "\r\n"]
[624.542527, "o", "\r\n"]
[624.569692, "o", "def interval_range(\r\n"]
[624.596857, "o", "    start=None,\r\n"]
[624.624022, "o", "    end=None,\r\n"]
[624.651187, "o", "    periods=None,\r\n"]
[624.678352, "o", "    freq=None,\r\n"]
[624.705516, "o", "    name: Hashable = None,\r\n"]
[624.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[624.759846, "o", ") -> IntervalIndex:\r\n"]
[624.787011, "o", "    \"\"\"\r\n"]
[624.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[624.841341, "o", "\r\n"]
[624.868505, "o", "    Parameters\r\n"]
[624.89567, "o", "    ----------\r\n"]
[624.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[625.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[625.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[625.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[625.0369, "o", "\u001b[?2004l\r\n"]
[625.0678, "o", "        Left bound for generating intervals.\r\n"]
[625.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[625.1296, "o", "        Right bound for generating intervals.\r\n"]
[625.1605, "o", "    periods : int, default None\r\n"]
[625.1914, "o", "        Number of periods to generate.\r\n"]
[625.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[625.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[625.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[625.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[625.3459, "o", "    name : str, default None\r\n"]
[625.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[625.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[625.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[625.4695, "o", "        or neither.\r\n"]
[625.5004, "o", "\r\n"]
[625.5313, "o", "    Returns\r\n"]
[625.5622, "o", "    -------\r\n"]
[625.5931, "o", "    IntervalIndex\r\n"]
[625.624, "o", "\r\n"]
[625.6549, "o", "    See Also\r\n"]
[625.6858, "o", "    --------\r\n"]
[625.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[625.7476, "o", "\r\n"]
[625.7785, "o", "    Notes\r\n"]
[625.8094, "o", "    -----\r\n"]
[625.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[625.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[625.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[625.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[625.9639, "o", "\r\n"]
[625.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[626.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[626.0566, "o", "\r\n"]
[626.0875, "o", "    Examples\r\n"]
[626.1184, "o", "    --------\r\n"]
[626.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[626.1802, "o", "\r\n"]
[626.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[626.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[626.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[626.3038, "o", "\r\n"]
[626.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[626.3656, "o", "\r\n"]
[626.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[626.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[626.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[626.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[626.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[626.551, "o", "\r\n"]
[626.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[626.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[626.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[626.6746, "o", "\r\n"]
[626.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[626.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[626.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[626.7982, "o", "\r\n"]
[626.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[626.86, "o", "    convertible to a DateOffset.\r\n"]
[626.8909, "o", "\r\n"]
[626.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[626.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[626.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[627.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[627.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[627.0763, "o", "\r\n"]
[627.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[627.1381, "o", "    automatically (linearly spaced).\r\n"]
[627.169, "o", "\r\n"]
[627.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[627.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[627.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[627.2926, "o", "\r\n"]
[627.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[627.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[627.3853, "o", "\r\n"]
[627.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[627.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[627.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[627.5089, "o", "    \"\"\"\r\n"]
[627.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[627.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[627.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[627.6325, "o", "\r\n"]
[627.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[627.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[627.7252, "o", "\r\n"]
[627.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[627.787, "o", "        raise ValueError(\r\n"]
[627.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[627.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[627.8797, "o", "        )\r\n"]
[627.9106, "o", "\r\n"]
[627.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[627.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[628.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[628.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[628.0651, "o", "\r\n"]
[628.096, "o", "    if is_float(periods):\r\n"]
[628.1269, "o", "        periods = int(periods)\r\n"]
[628.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[628.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[628.2196, "o", "\r\n"]
[628.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[628.2814, "o", "        try:\r\n"]
[628.3123, "o", "            freq = to_offset(freq)\r\n"]
[628.3432, "o", "        except ValueError as err:\r\n"]
[628.3741, "o", "            raise ValueError(\r\n"]
[628.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[628.4359, "o", "            ) from err\r\n"]
[628.4668, "o", "\r\n"]
[628.4977, "o", "    # verify type compatibility\r\n"]
[628.5286, "o", "    if not all(\r\n"]
[628.5595, "o", "        [\r\n"]
[628.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[628.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[628.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[628.6831, "o", "        ]\r\n"]
[628.714, "o", "    ):\r\n"]
[628.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[628.7758, "o", "\r\n"]
[628.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[628.8376, "o", "    if periods is not None:\r\n"]
[628.8685, "o", "        periods += 1\r\n"]
[628.8994, "o", "\r\n"]
[628.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[628.9612, "o", "\r\n"]
[628.9921, "o", "    if is_number(endpoint):\r\n"]
[629.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[629.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[629.0848, "o", "            end -= (end - start) % freq\r\n"]
[629.1157, "o", "\r\n"]
[629.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[629.1775, "o", "        if periods is None:\r\n"]
[629.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[629.2393, "o", "        elif start is None:\r\n"]
[629.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[629.3011, "o", "        elif end is None:\r\n"]
[629.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[629.3629, "o", "\r\n"]
[629.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[629.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[629.4556, "o", "            # np.linspace always produces float output\r\n"]
[629.4865, "o", "\r\n"]
[629.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[629.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[629.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[629.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[629.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[629.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[629.7028, "o", "            )\r\n"]
[629.7337, "o", "    else:\r\n"]
[629.7646, "o", "        # delegate to the appropriate range function\r\n"]
[629.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[629.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[629.8573, "o", "        else:\r\n"]
[629.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[629.9191, "o", "\r\n"]
[630.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[630.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[630.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[630.030355, "o", "\u001b[?2004l\r\n"]
[630.054709, "o", "import numpy as np\r\n"]
[630.079064, "o", "import pytest\r\n"]
[630.103419, "o", "\r\n"]
[630.127773, "o", "from pandas import (\r\n"]
[630.152128, "o", "    Index,\r\n"]
[630.176483, "o", "    IntervalIndex,\r\n"]
[630.200837, "o", "    Timestamp,\r\n"]
[630.225192, "o", "    interval_range,\r\n"]
[630.249547, "o", ")\r\n"]
[630.273901, "o", "import pandas._testing as tm\r\n"]
[630.298256, "o", "\r\n"]
[630.322611, "o", "\r\n"]
[630.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[630.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[630.395675, "o", "\r\n"]
[630.42003, "o", "\r\n"]
[630.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[630.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[630.493094, "o", "\r\n"]
[630.517448, "o", "\r\n"]
[630.541803, "o", "class TestIntervalIndex:\r\n"]
[630.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[630.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[630.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[630.639222, "o", "\r\n"]
[630.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[630.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[630.712286, "o", "        if sort is None:\r\n"]
[630.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[630.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[630.78535, "o", "\r\n"]
[630.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[630.834059, "o", "        if sort is None:\r\n"]
[630.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[630.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[630.907123, "o", "\r\n"]
[630.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[630.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[630.980187, "o", "\r\n"]
[631.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[631.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[631.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[631.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[631.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[631.126315, "o", "\r\n"]
[631.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[631.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[631.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[631.223734, "o", "        expected = other\r\n"]
[631.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[631.272443, "o", "\r\n"]
[631.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[631.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[631.345507, "o", "\r\n"]
[631.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[631.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[631.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[631.442926, "o", "\r\n"]
[631.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[631.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[631.51599, "o", "\r\n"]
[631.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[631.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[631.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[631.613409, "o", "\r\n"]
[631.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[631.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[631.686473, "o", "        if sort is None:\r\n"]
[631.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[631.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[631.759537, "o", "\r\n"]
[631.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[631.808246, "o", "        if sort is None:\r\n"]
[631.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[631.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[631.88131, "o", "\r\n"]
[631.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[631.93002, "o", "\r\n"]
[631.954374, "o", "        # GH 26225: nested intervals\r\n"]
[631.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[632.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[632.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[632.051793, "o", "        result = index.intersection(other)\r\n"]
[632.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[632.100502, "o", "\r\n"]
[632.124857, "o", "        # GH 26225\r\n"]
[632.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[632.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[632.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[632.222276, "o", "        result = index.intersection(other)\r\n"]
[632.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[632.270985, "o", "\r\n"]
[632.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[632.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[632.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[632.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[632.392759, "o", "        result = index.intersection(other)\r\n"]
[632.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[632.441468, "o", "\r\n"]
[632.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[632.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[632.514532, "o", "\r\n"]
[632.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[632.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[632.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[632.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[632.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[632.66066, "o", "\r\n"]
[632.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[632.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[632.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[632.758079, "o", "        expected = other[:0]\r\n"]
[632.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[632.806788, "o", "\r\n"]
[632.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[632.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[632.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[632.904207, "o", "\r\n"]
[632.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[632.952916, "o", "        # GH#38743\r\n"]
[632.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[633.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[633.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[633.050335, "o", "        result = index.intersection(other)\r\n"]
[633.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[633.099044, "o", "\r\n"]
[633.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[633.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[633.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[633.196463, "o", "        expected = index[1:]\r\n"]
[633.220818, "o", "        if sort is None:\r\n"]
[633.245172, "o", "            expected = expected.sort_values()\r\n"]
[633.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[633.293882, "o", "\r\n"]
[633.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[633.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[633.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[633.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[633.415655, "o", "\r\n"]
[633.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[633.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[633.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[633.513074, "o", "        )\r\n"]
[633.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[633.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[633.586138, "o", "\r\n"]
[633.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[633.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[633.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[633.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[633.707911, "o", "        if sort is None:\r\n"]
[633.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[633.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[633.780975, "o", "\r\n"]
[633.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[633.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[633.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[633.878394, "o", "        if sort is None:\r\n"]
[633.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[633.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[633.951458, "o", "\r\n"]
[633.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[634.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[634.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[634.048877, "o", "        )\r\n"]
[634.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[634.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[634.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[634.146296, "o", "\r\n"]
[634.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[634.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[634.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[634.243714, "o", "    )\r\n"]
[634.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[634.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[634.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[634.341133, "o", "\r\n"]
[634.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[634.389842, "o", "        # non-IntervalIndex\r\n"]
[634.414197, "o", "        if op_name == \"difference\":\r\n"]
[634.438552, "o", "            expected = index\r\n"]
[634.462906, "o", "        else:\r\n"]
[634.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[634.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[634.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[634.560325, "o", "\r\n"]
[634.58468, "o", "        # mixed closed -> cast to object\r\n"]
[634.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[634.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[634.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[634.682099, "o", "            if op_name == \"difference\":\r\n"]
[634.706453, "o", "                expected = index\r\n"]
[634.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[634.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[634.779517, "o", "\r\n"]
[634.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[634.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[634.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[634.876936, "o", "        if op_name == \"difference\":\r\n"]
[634.901291, "o", "            expected = index\r\n"]
[634.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[635.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[635.002, "i", "cd asv_bench\r"]
[635.004, "o", "cd asv_bench\r\n"]
[635.006, "o", "\u001b[?2004l\r\n"]
[640.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[640.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[640.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[645.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[645.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[645.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[645.418, "o", "\u001b[?2004l\r\n"]
[645.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[646.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[646.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[647.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[647.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[647.89, "o", "              param1            \r\n"]
[648.302, "o", "             -------- ----------\r\n"]
[648.714, "o", "               1000    1.14\u00b10ms \r\n"]
[649.126, "o", "              100000   73.6\u00b10ms \r\n"]
[649.538, "o", "             ======== ==========\r\n"]
[650.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[650.002, "i", "cd ..\r"]
[650.004, "o", "cd ..\r\n"]
[650.006, "o", "\u001b[?2004l\r\n"]
[655.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[655.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[655.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[657.478, "o", "\u001b[?2004l\r\n"]
[660.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[660.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[660.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[661.654, "o", "\u001b[?2004l\r\n"]
[663.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[665.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[665.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[665.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[665.033165, "o", "\u001b[?2004l\r\n"]
[665.06033, "o", "\r\n"]
[665.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[665.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[665.141824, "o", "\r\n"]
[665.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[665.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[665.223319, "o", "            return False\r\n"]
[665.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[665.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[665.304813, "o", "\r\n"]
[665.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[665.359143, "o", "\r\n"]
[665.386308, "o", "    @cache_readonly\r\n"]
[665.413473, "o", "    def left(self) -> Index:\r\n"]
[665.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[665.467802, "o", "\r\n"]
[665.494967, "o", "    @cache_readonly\r\n"]
[665.522132, "o", "    def right(self) -> Index:\r\n"]
[665.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[665.576462, "o", "\r\n"]
[665.603626, "o", "    @cache_readonly\r\n"]
[665.630791, "o", "    def mid(self) -> Index:\r\n"]
[665.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[665.685121, "o", "\r\n"]
[665.712286, "o", "    @property\r\n"]
[665.739451, "o", "    def length(self) -> Index:\r\n"]
[665.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[665.79378, "o", "\r\n"]
[665.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[665.84811, "o", "    # Rendering Methods\r\n"]
[665.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[665.90244, "o", "\r\n"]
[665.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[665.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[665.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[666.011099, "o", "\r\n"]
[666.038264, "o", "    def _format_native_types(\r\n"]
[666.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[666.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[666.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[666.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[666.174088, "o", "\r\n"]
[666.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[666.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[666.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[666.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[666.309912, "o", "\r\n"]
[666.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[666.364242, "o", "    # Set Operations\r\n"]
[666.391407, "o", "\r\n"]
[666.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[666.445736, "o", "        \"\"\"\r\n"]
[666.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[666.500066, "o", "        \"\"\"\r\n"]
[666.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[666.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[666.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[666.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[666.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[666.663055, "o", "            # multiple NaNs\r\n"]
[666.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[666.717385, "o", "        else:\r\n"]
[666.744549, "o", "            # duplicates\r\n"]
[666.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[666.798879, "o", "\r\n"]
[666.826044, "o", "        if sort is None:\r\n"]
[666.853209, "o", "            taken = taken.sort_values()\r\n"]
[666.880374, "o", "\r\n"]
[666.907538, "o", "        return taken\r\n"]
[666.934703, "o", "\r\n"]
[666.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[666.989033, "o", "        \"\"\"\r\n"]
[667.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[667.043363, "o", "        no matter left or right.\r\n"]
[667.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[667.097692, "o", "        Parameters\r\n"]
[667.124857, "o", "        ----------\r\n"]
[667.152022, "o", "        other : IntervalIndex\r\n"]
[667.179187, "o", "        Returns\r\n"]
[667.206352, "o", "        -------\r\n"]
[667.233516, "o", "        IntervalIndex\r\n"]
[667.260681, "o", "        \"\"\"\r\n"]
[667.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[667.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[667.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[667.369341, "o", "\r\n"]
[667.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[667.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[667.450835, "o", "        indexer = unique(indexer)\r\n"]
[667.478, "o", "\r\n"]
[667.505165, "o", "        return self.take(indexer)\r\n"]
[667.53233, "o", "\r\n"]
[667.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[667.586659, "o", "        \"\"\"\r\n"]
[667.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[667.640989, "o", "        on either sides.\r\n"]
[667.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[667.695319, "o", "\r\n"]
[667.722484, "o", "        Parameters\r\n"]
[667.749648, "o", "        ----------\r\n"]
[667.776813, "o", "        other : IntervalIndex\r\n"]
[667.803978, "o", "\r\n"]
[667.831143, "o", "        Returns\r\n"]
[667.858308, "o", "        -------\r\n"]
[667.885473, "o", "        IntervalIndex\r\n"]
[667.912637, "o", "        \"\"\"\r\n"]
[667.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[667.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[667.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[668.021297, "o", "\r\n"]
[668.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[668.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[668.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[668.129956, "o", "\r\n"]
[668.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[668.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[668.211451, "o", "            if tup in other_tups:\r\n"]
[668.238615, "o", "                mask[i] = True\r\n"]
[668.26578, "o", "\r\n"]
[668.292945, "o", "        return self[mask]\r\n"]
[668.32011, "o", "\r\n"]
[668.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[668.37444, "o", "\r\n"]
[668.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[668.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[668.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[668.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[668.510264, "o", "        raise NotImplementedError(\r\n"]
[668.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[668.564593, "o", "            \"IndexEngine objects\"\r\n"]
[668.591758, "o", "        )\r\n"]
[668.618923, "o", "\r\n"]
[668.646088, "o", "    def _from_join_target(self, result):\r\n"]
[668.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[668.700418, "o", "\r\n"]
[668.727582, "o", "    # TODO: arithmetic operations\r\n"]
[668.754747, "o", "\r\n"]
[668.781912, "o", "\r\n"]
[668.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[668.836242, "o", "    \"\"\"\r\n"]
[668.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[668.890571, "o", "    \"\"\"\r\n"]
[668.917736, "o", "    return any(\r\n"]
[668.944901, "o", "        [\r\n"]
[668.972066, "o", "            is_number(endpoint),\r\n"]
[668.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[669.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[669.05356, "o", "            endpoint is None,\r\n"]
[669.080725, "o", "        ]\r\n"]
[669.10789, "o", "    )\r\n"]
[669.135055, "o", "\r\n"]
[669.16222, "o", "\r\n"]
[669.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[669.216549, "o", "    \"\"\"\r\n"]
[669.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[669.270879, "o", "    \"\"\"\r\n"]
[669.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[669.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[669.352374, "o", "    return (\r\n"]
[669.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[669.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[669.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[669.461033, "o", "        or com.any_none(a, b)\r\n"]
[669.488198, "o", "    )\r\n"]
[669.515363, "o", "\r\n"]
[669.542527, "o", "\r\n"]
[669.569692, "o", "def interval_range(\r\n"]
[669.596857, "o", "    start=None,\r\n"]
[669.624022, "o", "    end=None,\r\n"]
[669.651187, "o", "    periods=None,\r\n"]
[669.678352, "o", "    freq=None,\r\n"]
[669.705516, "o", "    name: Hashable = None,\r\n"]
[669.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[669.759846, "o", ") -> IntervalIndex:\r\n"]
[669.787011, "o", "    \"\"\"\r\n"]
[669.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[669.841341, "o", "\r\n"]
[669.868505, "o", "    Parameters\r\n"]
[669.89567, "o", "    ----------\r\n"]
[669.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[670.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[670.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[670.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[670.0369, "o", "\u001b[?2004l\r\n"]
[670.0678, "o", "        Left bound for generating intervals.\r\n"]
[670.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[670.1296, "o", "        Right bound for generating intervals.\r\n"]
[670.1605, "o", "    periods : int, default None\r\n"]
[670.1914, "o", "        Number of periods to generate.\r\n"]
[670.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[670.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[670.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[670.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[670.3459, "o", "    name : str, default None\r\n"]
[670.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[670.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[670.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[670.4695, "o", "        or neither.\r\n"]
[670.5004, "o", "\r\n"]
[670.5313, "o", "    Returns\r\n"]
[670.5622, "o", "    -------\r\n"]
[670.5931, "o", "    IntervalIndex\r\n"]
[670.624, "o", "\r\n"]
[670.6549, "o", "    See Also\r\n"]
[670.6858, "o", "    --------\r\n"]
[670.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[670.7476, "o", "\r\n"]
[670.7785, "o", "    Notes\r\n"]
[670.8094, "o", "    -----\r\n"]
[670.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[670.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[670.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[670.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[670.9639, "o", "\r\n"]
[670.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[671.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[671.0566, "o", "\r\n"]
[671.0875, "o", "    Examples\r\n"]
[671.1184, "o", "    --------\r\n"]
[671.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[671.1802, "o", "\r\n"]
[671.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[671.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[671.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[671.3038, "o", "\r\n"]
[671.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[671.3656, "o", "\r\n"]
[671.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[671.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[671.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[671.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[671.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[671.551, "o", "\r\n"]
[671.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[671.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[671.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[671.6746, "o", "\r\n"]
[671.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[671.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[671.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[671.7982, "o", "\r\n"]
[671.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[671.86, "o", "    convertible to a DateOffset.\r\n"]
[671.8909, "o", "\r\n"]
[671.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[671.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[671.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[672.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[672.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[672.0763, "o", "\r\n"]
[672.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[672.1381, "o", "    automatically (linearly spaced).\r\n"]
[672.169, "o", "\r\n"]
[672.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[672.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[672.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[672.2926, "o", "\r\n"]
[672.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[672.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[672.3853, "o", "\r\n"]
[672.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[672.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[672.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[672.5089, "o", "    \"\"\"\r\n"]
[672.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[672.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[672.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[672.6325, "o", "\r\n"]
[672.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[672.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[672.7252, "o", "\r\n"]
[672.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[672.787, "o", "        raise ValueError(\r\n"]
[672.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[672.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[672.8797, "o", "        )\r\n"]
[672.9106, "o", "\r\n"]
[672.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[672.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[673.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[673.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[673.0651, "o", "\r\n"]
[673.096, "o", "    if is_float(periods):\r\n"]
[673.1269, "o", "        periods = int(periods)\r\n"]
[673.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[673.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[673.2196, "o", "\r\n"]
[673.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[673.2814, "o", "        try:\r\n"]
[673.3123, "o", "            freq = to_offset(freq)\r\n"]
[673.3432, "o", "        except ValueError as err:\r\n"]
[673.3741, "o", "            raise ValueError(\r\n"]
[673.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[673.4359, "o", "            ) from err\r\n"]
[673.4668, "o", "\r\n"]
[673.4977, "o", "    # verify type compatibility\r\n"]
[673.5286, "o", "    if not all(\r\n"]
[673.5595, "o", "        [\r\n"]
[673.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[673.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[673.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[673.6831, "o", "        ]\r\n"]
[673.714, "o", "    ):\r\n"]
[673.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[673.7758, "o", "\r\n"]
[673.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[673.8376, "o", "    if periods is not None:\r\n"]
[673.8685, "o", "        periods += 1\r\n"]
[673.8994, "o", "\r\n"]
[673.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[673.9612, "o", "\r\n"]
[673.9921, "o", "    if is_number(endpoint):\r\n"]
[674.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[674.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[674.0848, "o", "            end -= (end - start) % freq\r\n"]
[674.1157, "o", "\r\n"]
[674.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[674.1775, "o", "        if periods is None:\r\n"]
[674.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[674.2393, "o", "        elif start is None:\r\n"]
[674.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[674.3011, "o", "        elif end is None:\r\n"]
[674.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[674.3629, "o", "\r\n"]
[674.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[674.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[674.4556, "o", "            # np.linspace always produces float output\r\n"]
[674.4865, "o", "\r\n"]
[674.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[674.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[674.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[674.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[674.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[674.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[674.7028, "o", "            )\r\n"]
[674.7337, "o", "    else:\r\n"]
[674.7646, "o", "        # delegate to the appropriate range function\r\n"]
[674.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[674.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[674.8573, "o", "        else:\r\n"]
[674.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[674.9191, "o", "\r\n"]
[675.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[675.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[675.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[675.030355, "o", "\u001b[?2004l\r\n"]
[675.054709, "o", "import numpy as np\r\n"]
[675.079064, "o", "import pytest\r\n"]
[675.103419, "o", "\r\n"]
[675.127773, "o", "from pandas import (\r\n"]
[675.152128, "o", "    Index,\r\n"]
[675.176483, "o", "    IntervalIndex,\r\n"]
[675.200837, "o", "    Timestamp,\r\n"]
[675.225192, "o", "    interval_range,\r\n"]
[675.249547, "o", ")\r\n"]
[675.273901, "o", "import pandas._testing as tm\r\n"]
[675.298256, "o", "\r\n"]
[675.322611, "o", "\r\n"]
[675.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[675.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[675.395675, "o", "\r\n"]
[675.42003, "o", "\r\n"]
[675.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[675.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[675.493094, "o", "\r\n"]
[675.517448, "o", "\r\n"]
[675.541803, "o", "class TestIntervalIndex:\r\n"]
[675.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[675.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[675.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[675.639222, "o", "\r\n"]
[675.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[675.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[675.712286, "o", "        if sort is None:\r\n"]
[675.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[675.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[675.78535, "o", "\r\n"]
[675.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[675.834059, "o", "        if sort is None:\r\n"]
[675.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[675.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[675.907123, "o", "\r\n"]
[675.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[675.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[675.980187, "o", "\r\n"]
[676.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[676.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[676.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[676.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[676.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[676.126315, "o", "\r\n"]
[676.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[676.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[676.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[676.223734, "o", "        expected = other\r\n"]
[676.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[676.272443, "o", "\r\n"]
[676.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[676.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[676.345507, "o", "\r\n"]
[676.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[676.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[676.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[676.442926, "o", "\r\n"]
[676.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[676.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[676.51599, "o", "\r\n"]
[676.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[676.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[676.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[676.613409, "o", "\r\n"]
[676.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[676.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[676.686473, "o", "        if sort is None:\r\n"]
[676.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[676.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[676.759537, "o", "\r\n"]
[676.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[676.808246, "o", "        if sort is None:\r\n"]
[676.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[676.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[676.88131, "o", "\r\n"]
[676.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[676.93002, "o", "\r\n"]
[676.954374, "o", "        # GH 26225: nested intervals\r\n"]
[676.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[677.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[677.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[677.051793, "o", "        result = index.intersection(other)\r\n"]
[677.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[677.100502, "o", "\r\n"]
[677.124857, "o", "        # GH 26225\r\n"]
[677.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[677.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[677.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[677.222276, "o", "        result = index.intersection(other)\r\n"]
[677.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[677.270985, "o", "\r\n"]
[677.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[677.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[677.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[677.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[677.392759, "o", "        result = index.intersection(other)\r\n"]
[677.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[677.441468, "o", "\r\n"]
[677.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[677.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[677.514532, "o", "\r\n"]
[677.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[677.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[677.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[677.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[677.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[677.66066, "o", "\r\n"]
[677.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[677.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[677.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[677.758079, "o", "        expected = other[:0]\r\n"]
[677.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[677.806788, "o", "\r\n"]
[677.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[677.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[677.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[677.904207, "o", "\r\n"]
[677.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[677.952916, "o", "        # GH#38743\r\n"]
[677.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[678.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[678.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[678.050335, "o", "        result = index.intersection(other)\r\n"]
[678.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[678.099044, "o", "\r\n"]
[678.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[678.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[678.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[678.196463, "o", "        expected = index[1:]\r\n"]
[678.220818, "o", "        if sort is None:\r\n"]
[678.245172, "o", "            expected = expected.sort_values()\r\n"]
[678.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[678.293882, "o", "\r\n"]
[678.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[678.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[678.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[678.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[678.415655, "o", "\r\n"]
[678.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[678.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[678.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[678.513074, "o", "        )\r\n"]
[678.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[678.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[678.586138, "o", "\r\n"]
[678.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[678.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[678.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[678.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[678.707911, "o", "        if sort is None:\r\n"]
[678.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[678.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[678.780975, "o", "\r\n"]
[678.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[678.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[678.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[678.878394, "o", "        if sort is None:\r\n"]
[678.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[678.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[678.951458, "o", "\r\n"]
[678.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[679.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[679.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[679.048877, "o", "        )\r\n"]
[679.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[679.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[679.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[679.146296, "o", "\r\n"]
[679.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[679.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[679.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[679.243714, "o", "    )\r\n"]
[679.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[679.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[679.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[679.341133, "o", "\r\n"]
[679.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[679.389842, "o", "        # non-IntervalIndex\r\n"]
[679.414197, "o", "        if op_name == \"difference\":\r\n"]
[679.438552, "o", "            expected = index\r\n"]
[679.462906, "o", "        else:\r\n"]
[679.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[679.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[679.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[679.560325, "o", "\r\n"]
[679.58468, "o", "        # mixed closed -> cast to object\r\n"]
[679.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[679.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[679.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[679.682099, "o", "            if op_name == \"difference\":\r\n"]
[679.706453, "o", "                expected = index\r\n"]
[679.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[679.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[679.779517, "o", "\r\n"]
[679.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[679.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[679.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[679.876936, "o", "        if op_name == \"difference\":\r\n"]
[679.901291, "o", "            expected = index\r\n"]
[679.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[680.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[680.002, "i", "cd asv_bench\r"]
[680.004, "o", "cd asv_bench\r\n"]
[680.006, "o", "\u001b[?2004l\r\n"]
[685.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[685.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[685.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[690.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[690.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[690.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[690.418, "o", "\u001b[?2004l\r\n"]
[690.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[691.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[691.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[692.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[692.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[692.89, "o", "              param1            \r\n"]
[693.302, "o", "             -------- ----------\r\n"]
[693.714, "o", "               1000    1.17\u00b10ms \r\n"]
[694.126, "o", "              100000   75.8\u00b10ms \r\n"]
[694.538, "o", "             ======== ==========\r\n"]
[695.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[695.002, "i", "cd ..\r"]
[695.004, "o", "cd ..\r\n"]
[695.006, "o", "\u001b[?2004l\r\n"]
[700.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[700.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[700.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[702.478, "o", "\u001b[?2004l\r\n"]
[705.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[705.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[705.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[706.654, "o", "\u001b[?2004l\r\n"]
[708.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[710.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[710.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[710.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[710.033165, "o", "\u001b[?2004l\r\n"]
[710.06033, "o", "\r\n"]
[710.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[710.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[710.141824, "o", "\r\n"]
[710.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[710.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[710.223319, "o", "            return False\r\n"]
[710.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[710.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[710.304813, "o", "\r\n"]
[710.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[710.359143, "o", "\r\n"]
[710.386308, "o", "    @cache_readonly\r\n"]
[710.413473, "o", "    def left(self) -> Index:\r\n"]
[710.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[710.467802, "o", "\r\n"]
[710.494967, "o", "    @cache_readonly\r\n"]
[710.522132, "o", "    def right(self) -> Index:\r\n"]
[710.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[710.576462, "o", "\r\n"]
[710.603626, "o", "    @cache_readonly\r\n"]
[710.630791, "o", "    def mid(self) -> Index:\r\n"]
[710.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[710.685121, "o", "\r\n"]
[710.712286, "o", "    @property\r\n"]
[710.739451, "o", "    def length(self) -> Index:\r\n"]
[710.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[710.79378, "o", "\r\n"]
[710.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[710.84811, "o", "    # Rendering Methods\r\n"]
[710.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[710.90244, "o", "\r\n"]
[710.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[710.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[710.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[711.011099, "o", "\r\n"]
[711.038264, "o", "    def _format_native_types(\r\n"]
[711.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[711.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[711.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[711.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[711.174088, "o", "\r\n"]
[711.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[711.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[711.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[711.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[711.309912, "o", "\r\n"]
[711.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[711.364242, "o", "    # Set Operations\r\n"]
[711.391407, "o", "\r\n"]
[711.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[711.445736, "o", "        \"\"\"\r\n"]
[711.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[711.500066, "o", "        \"\"\"\r\n"]
[711.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[711.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[711.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[711.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[711.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[711.663055, "o", "            # multiple NaNs\r\n"]
[711.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[711.717385, "o", "        else:\r\n"]
[711.744549, "o", "            # duplicates\r\n"]
[711.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[711.798879, "o", "\r\n"]
[711.826044, "o", "        if sort is None:\r\n"]
[711.853209, "o", "            taken = taken.sort_values()\r\n"]
[711.880374, "o", "\r\n"]
[711.907538, "o", "        return taken\r\n"]
[711.934703, "o", "\r\n"]
[711.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[711.989033, "o", "        \"\"\"\r\n"]
[712.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[712.043363, "o", "        no matter left or right.\r\n"]
[712.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[712.097692, "o", "        Parameters\r\n"]
[712.124857, "o", "        ----------\r\n"]
[712.152022, "o", "        other : IntervalIndex\r\n"]
[712.179187, "o", "        Returns\r\n"]
[712.206352, "o", "        -------\r\n"]
[712.233516, "o", "        IntervalIndex\r\n"]
[712.260681, "o", "        \"\"\"\r\n"]
[712.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[712.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[712.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[712.369341, "o", "\r\n"]
[712.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[712.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[712.450835, "o", "        indexer = unique(indexer)\r\n"]
[712.478, "o", "\r\n"]
[712.505165, "o", "        return self.take(indexer)\r\n"]
[712.53233, "o", "\r\n"]
[712.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[712.586659, "o", "        \"\"\"\r\n"]
[712.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[712.640989, "o", "        on either sides.\r\n"]
[712.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[712.695319, "o", "\r\n"]
[712.722484, "o", "        Parameters\r\n"]
[712.749648, "o", "        ----------\r\n"]
[712.776813, "o", "        other : IntervalIndex\r\n"]
[712.803978, "o", "\r\n"]
[712.831143, "o", "        Returns\r\n"]
[712.858308, "o", "        -------\r\n"]
[712.885473, "o", "        IntervalIndex\r\n"]
[712.912637, "o", "        \"\"\"\r\n"]
[712.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[712.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[712.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[713.021297, "o", "\r\n"]
[713.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[713.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[713.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[713.129956, "o", "\r\n"]
[713.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[713.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[713.211451, "o", "            if tup in other_tups:\r\n"]
[713.238615, "o", "                mask[i] = True\r\n"]
[713.26578, "o", "\r\n"]
[713.292945, "o", "        return self[mask]\r\n"]
[713.32011, "o", "\r\n"]
[713.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[713.37444, "o", "\r\n"]
[713.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[713.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[713.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[713.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[713.510264, "o", "        raise NotImplementedError(\r\n"]
[713.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[713.564593, "o", "            \"IndexEngine objects\"\r\n"]
[713.591758, "o", "        )\r\n"]
[713.618923, "o", "\r\n"]
[713.646088, "o", "    def _from_join_target(self, result):\r\n"]
[713.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[713.700418, "o", "\r\n"]
[713.727582, "o", "    # TODO: arithmetic operations\r\n"]
[713.754747, "o", "\r\n"]
[713.781912, "o", "\r\n"]
[713.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[713.836242, "o", "    \"\"\"\r\n"]
[713.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[713.890571, "o", "    \"\"\"\r\n"]
[713.917736, "o", "    return any(\r\n"]
[713.944901, "o", "        [\r\n"]
[713.972066, "o", "            is_number(endpoint),\r\n"]
[713.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[714.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[714.05356, "o", "            endpoint is None,\r\n"]
[714.080725, "o", "        ]\r\n"]
[714.10789, "o", "    )\r\n"]
[714.135055, "o", "\r\n"]
[714.16222, "o", "\r\n"]
[714.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[714.216549, "o", "    \"\"\"\r\n"]
[714.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[714.270879, "o", "    \"\"\"\r\n"]
[714.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[714.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[714.352374, "o", "    return (\r\n"]
[714.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[714.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[714.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[714.461033, "o", "        or com.any_none(a, b)\r\n"]
[714.488198, "o", "    )\r\n"]
[714.515363, "o", "\r\n"]
[714.542527, "o", "\r\n"]
[714.569692, "o", "def interval_range(\r\n"]
[714.596857, "o", "    start=None,\r\n"]
[714.624022, "o", "    end=None,\r\n"]
[714.651187, "o", "    periods=None,\r\n"]
[714.678352, "o", "    freq=None,\r\n"]
[714.705516, "o", "    name: Hashable = None,\r\n"]
[714.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[714.759846, "o", ") -> IntervalIndex:\r\n"]
[714.787011, "o", "    \"\"\"\r\n"]
[714.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[714.841341, "o", "\r\n"]
[714.868505, "o", "    Parameters\r\n"]
[714.89567, "o", "    ----------\r\n"]
[714.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[715.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[715.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[715.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[715.0369, "o", "\u001b[?2004l\r\n"]
[715.0678, "o", "        Left bound for generating intervals.\r\n"]
[715.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[715.1296, "o", "        Right bound for generating intervals.\r\n"]
[715.1605, "o", "    periods : int, default None\r\n"]
[715.1914, "o", "        Number of periods to generate.\r\n"]
[715.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[715.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[715.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[715.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[715.3459, "o", "    name : str, default None\r\n"]
[715.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[715.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[715.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[715.4695, "o", "        or neither.\r\n"]
[715.5004, "o", "\r\n"]
[715.5313, "o", "    Returns\r\n"]
[715.5622, "o", "    -------\r\n"]
[715.5931, "o", "    IntervalIndex\r\n"]
[715.624, "o", "\r\n"]
[715.6549, "o", "    See Also\r\n"]
[715.6858, "o", "    --------\r\n"]
[715.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[715.7476, "o", "\r\n"]
[715.7785, "o", "    Notes\r\n"]
[715.8094, "o", "    -----\r\n"]
[715.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[715.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[715.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[715.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[715.9639, "o", "\r\n"]
[715.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[716.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[716.0566, "o", "\r\n"]
[716.0875, "o", "    Examples\r\n"]
[716.1184, "o", "    --------\r\n"]
[716.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[716.1802, "o", "\r\n"]
[716.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[716.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[716.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[716.3038, "o", "\r\n"]
[716.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[716.3656, "o", "\r\n"]
[716.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[716.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[716.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[716.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[716.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[716.551, "o", "\r\n"]
[716.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[716.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[716.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[716.6746, "o", "\r\n"]
[716.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[716.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[716.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[716.7982, "o", "\r\n"]
[716.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[716.86, "o", "    convertible to a DateOffset.\r\n"]
[716.8909, "o", "\r\n"]
[716.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[716.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[716.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[717.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[717.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[717.0763, "o", "\r\n"]
[717.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[717.1381, "o", "    automatically (linearly spaced).\r\n"]
[717.169, "o", "\r\n"]
[717.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[717.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[717.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[717.2926, "o", "\r\n"]
[717.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[717.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[717.3853, "o", "\r\n"]
[717.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[717.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[717.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[717.5089, "o", "    \"\"\"\r\n"]
[717.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[717.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[717.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[717.6325, "o", "\r\n"]
[717.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[717.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[717.7252, "o", "\r\n"]
[717.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[717.787, "o", "        raise ValueError(\r\n"]
[717.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[717.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[717.8797, "o", "        )\r\n"]
[717.9106, "o", "\r\n"]
[717.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[717.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[718.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[718.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[718.0651, "o", "\r\n"]
[718.096, "o", "    if is_float(periods):\r\n"]
[718.1269, "o", "        periods = int(periods)\r\n"]
[718.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[718.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[718.2196, "o", "\r\n"]
[718.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[718.2814, "o", "        try:\r\n"]
[718.3123, "o", "            freq = to_offset(freq)\r\n"]
[718.3432, "o", "        except ValueError as err:\r\n"]
[718.3741, "o", "            raise ValueError(\r\n"]
[718.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[718.4359, "o", "            ) from err\r\n"]
[718.4668, "o", "\r\n"]
[718.4977, "o", "    # verify type compatibility\r\n"]
[718.5286, "o", "    if not all(\r\n"]
[718.5595, "o", "        [\r\n"]
[718.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[718.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[718.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[718.6831, "o", "        ]\r\n"]
[718.714, "o", "    ):\r\n"]
[718.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[718.7758, "o", "\r\n"]
[718.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[718.8376, "o", "    if periods is not None:\r\n"]
[718.8685, "o", "        periods += 1\r\n"]
[718.8994, "o", "\r\n"]
[718.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[718.9612, "o", "\r\n"]
[718.9921, "o", "    if is_number(endpoint):\r\n"]
[719.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[719.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[719.0848, "o", "            end -= (end - start) % freq\r\n"]
[719.1157, "o", "\r\n"]
[719.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[719.1775, "o", "        if periods is None:\r\n"]
[719.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[719.2393, "o", "        elif start is None:\r\n"]
[719.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[719.3011, "o", "        elif end is None:\r\n"]
[719.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[719.3629, "o", "\r\n"]
[719.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[719.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[719.4556, "o", "            # np.linspace always produces float output\r\n"]
[719.4865, "o", "\r\n"]
[719.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[719.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[719.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[719.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[719.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[719.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[719.7028, "o", "            )\r\n"]
[719.7337, "o", "    else:\r\n"]
[719.7646, "o", "        # delegate to the appropriate range function\r\n"]
[719.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[719.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[719.8573, "o", "        else:\r\n"]
[719.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[719.9191, "o", "\r\n"]
[720.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[720.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[720.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[720.030355, "o", "\u001b[?2004l\r\n"]
[720.054709, "o", "import numpy as np\r\n"]
[720.079064, "o", "import pytest\r\n"]
[720.103419, "o", "\r\n"]
[720.127773, "o", "from pandas import (\r\n"]
[720.152128, "o", "    Index,\r\n"]
[720.176483, "o", "    IntervalIndex,\r\n"]
[720.200837, "o", "    Timestamp,\r\n"]
[720.225192, "o", "    interval_range,\r\n"]
[720.249547, "o", ")\r\n"]
[720.273901, "o", "import pandas._testing as tm\r\n"]
[720.298256, "o", "\r\n"]
[720.322611, "o", "\r\n"]
[720.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[720.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[720.395675, "o", "\r\n"]
[720.42003, "o", "\r\n"]
[720.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[720.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[720.493094, "o", "\r\n"]
[720.517448, "o", "\r\n"]
[720.541803, "o", "class TestIntervalIndex:\r\n"]
[720.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[720.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[720.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[720.639222, "o", "\r\n"]
[720.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[720.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[720.712286, "o", "        if sort is None:\r\n"]
[720.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[720.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[720.78535, "o", "\r\n"]
[720.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[720.834059, "o", "        if sort is None:\r\n"]
[720.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[720.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[720.907123, "o", "\r\n"]
[720.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[720.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[720.980187, "o", "\r\n"]
[721.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[721.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[721.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[721.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[721.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[721.126315, "o", "\r\n"]
[721.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[721.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[721.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[721.223734, "o", "        expected = other\r\n"]
[721.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[721.272443, "o", "\r\n"]
[721.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[721.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[721.345507, "o", "\r\n"]
[721.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[721.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[721.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[721.442926, "o", "\r\n"]
[721.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[721.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[721.51599, "o", "\r\n"]
[721.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[721.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[721.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[721.613409, "o", "\r\n"]
[721.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[721.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[721.686473, "o", "        if sort is None:\r\n"]
[721.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[721.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[721.759537, "o", "\r\n"]
[721.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[721.808246, "o", "        if sort is None:\r\n"]
[721.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[721.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[721.88131, "o", "\r\n"]
[721.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[721.93002, "o", "\r\n"]
[721.954374, "o", "        # GH 26225: nested intervals\r\n"]
[721.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[722.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[722.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[722.051793, "o", "        result = index.intersection(other)\r\n"]
[722.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[722.100502, "o", "\r\n"]
[722.124857, "o", "        # GH 26225\r\n"]
[722.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[722.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[722.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[722.222276, "o", "        result = index.intersection(other)\r\n"]
[722.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[722.270985, "o", "\r\n"]
[722.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[722.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[722.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[722.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[722.392759, "o", "        result = index.intersection(other)\r\n"]
[722.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[722.441468, "o", "\r\n"]
[722.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[722.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[722.514532, "o", "\r\n"]
[722.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[722.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[722.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[722.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[722.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[722.66066, "o", "\r\n"]
[722.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[722.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[722.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[722.758079, "o", "        expected = other[:0]\r\n"]
[722.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[722.806788, "o", "\r\n"]
[722.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[722.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[722.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[722.904207, "o", "\r\n"]
[722.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[722.952916, "o", "        # GH#38743\r\n"]
[722.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[723.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[723.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[723.050335, "o", "        result = index.intersection(other)\r\n"]
[723.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[723.099044, "o", "\r\n"]
[723.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[723.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[723.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[723.196463, "o", "        expected = index[1:]\r\n"]
[723.220818, "o", "        if sort is None:\r\n"]
[723.245172, "o", "            expected = expected.sort_values()\r\n"]
[723.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[723.293882, "o", "\r\n"]
[723.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[723.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[723.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[723.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[723.415655, "o", "\r\n"]
[723.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[723.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[723.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[723.513074, "o", "        )\r\n"]
[723.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[723.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[723.586138, "o", "\r\n"]
[723.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[723.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[723.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[723.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[723.707911, "o", "        if sort is None:\r\n"]
[723.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[723.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[723.780975, "o", "\r\n"]
[723.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[723.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[723.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[723.878394, "o", "        if sort is None:\r\n"]
[723.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[723.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[723.951458, "o", "\r\n"]
[723.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[724.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[724.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[724.048877, "o", "        )\r\n"]
[724.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[724.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[724.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[724.146296, "o", "\r\n"]
[724.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[724.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[724.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[724.243714, "o", "    )\r\n"]
[724.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[724.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[724.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[724.341133, "o", "\r\n"]
[724.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[724.389842, "o", "        # non-IntervalIndex\r\n"]
[724.414197, "o", "        if op_name == \"difference\":\r\n"]
[724.438552, "o", "            expected = index\r\n"]
[724.462906, "o", "        else:\r\n"]
[724.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[724.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[724.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[724.560325, "o", "\r\n"]
[724.58468, "o", "        # mixed closed -> cast to object\r\n"]
[724.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[724.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[724.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[724.682099, "o", "            if op_name == \"difference\":\r\n"]
[724.706453, "o", "                expected = index\r\n"]
[724.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[724.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[724.779517, "o", "\r\n"]
[724.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[724.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[724.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[724.876936, "o", "        if op_name == \"difference\":\r\n"]
[724.901291, "o", "            expected = index\r\n"]
[724.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[725.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[725.002, "i", "cd asv_bench\r"]
[725.004, "o", "cd asv_bench\r\n"]
[725.006, "o", "\u001b[?2004l\r\n"]
[730.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[730.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[730.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[735.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[735.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[735.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[735.418, "o", "\u001b[?2004l\r\n"]
[735.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[736.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[736.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[737.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[737.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[737.89, "o", "              param1            \r\n"]
[738.302, "o", "             -------- ----------\r\n"]
[738.714, "o", "               1000    1.17\u00b10ms \r\n"]
[739.126, "o", "              100000   76.6\u00b10ms \r\n"]
[739.538, "o", "             ======== ==========\r\n"]
[740.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[740.002, "i", "cd ..\r"]
[740.004, "o", "cd ..\r\n"]
[740.006, "o", "\u001b[?2004l\r\n"]
[745.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[745.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[745.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[747.478, "o", "\u001b[?2004l\r\n"]
[750.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[750.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[750.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[751.654, "o", "\u001b[?2004l\r\n"]
[753.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[755.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[755.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[755.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[755.033165, "o", "\u001b[?2004l\r\n"]
[755.06033, "o", "\r\n"]
[755.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[755.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[755.141824, "o", "\r\n"]
[755.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[755.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[755.223319, "o", "            return False\r\n"]
[755.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[755.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[755.304813, "o", "\r\n"]
[755.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[755.359143, "o", "\r\n"]
[755.386308, "o", "    @cache_readonly\r\n"]
[755.413473, "o", "    def left(self) -> Index:\r\n"]
[755.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[755.467802, "o", "\r\n"]
[755.494967, "o", "    @cache_readonly\r\n"]
[755.522132, "o", "    def right(self) -> Index:\r\n"]
[755.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[755.576462, "o", "\r\n"]
[755.603626, "o", "    @cache_readonly\r\n"]
[755.630791, "o", "    def mid(self) -> Index:\r\n"]
[755.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[755.685121, "o", "\r\n"]
[755.712286, "o", "    @property\r\n"]
[755.739451, "o", "    def length(self) -> Index:\r\n"]
[755.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[755.79378, "o", "\r\n"]
[755.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[755.84811, "o", "    # Rendering Methods\r\n"]
[755.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[755.90244, "o", "\r\n"]
[755.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[755.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[755.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[756.011099, "o", "\r\n"]
[756.038264, "o", "    def _format_native_types(\r\n"]
[756.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[756.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[756.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[756.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[756.174088, "o", "\r\n"]
[756.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[756.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[756.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[756.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[756.309912, "o", "\r\n"]
[756.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[756.364242, "o", "    # Set Operations\r\n"]
[756.391407, "o", "\r\n"]
[756.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[756.445736, "o", "        \"\"\"\r\n"]
[756.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[756.500066, "o", "        \"\"\"\r\n"]
[756.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[756.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[756.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[756.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[756.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[756.663055, "o", "            # multiple NaNs\r\n"]
[756.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[756.717385, "o", "        else:\r\n"]
[756.744549, "o", "            # duplicates\r\n"]
[756.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[756.798879, "o", "\r\n"]
[756.826044, "o", "        if sort is None:\r\n"]
[756.853209, "o", "            taken = taken.sort_values()\r\n"]
[756.880374, "o", "\r\n"]
[756.907538, "o", "        return taken\r\n"]
[756.934703, "o", "\r\n"]
[756.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[756.989033, "o", "        \"\"\"\r\n"]
[757.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[757.043363, "o", "        no matter left or right.\r\n"]
[757.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[757.097692, "o", "        Parameters\r\n"]
[757.124857, "o", "        ----------\r\n"]
[757.152022, "o", "        other : IntervalIndex\r\n"]
[757.179187, "o", "        Returns\r\n"]
[757.206352, "o", "        -------\r\n"]
[757.233516, "o", "        IntervalIndex\r\n"]
[757.260681, "o", "        \"\"\"\r\n"]
[757.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[757.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[757.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[757.369341, "o", "\r\n"]
[757.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[757.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[757.450835, "o", "        indexer = unique(indexer)\r\n"]
[757.478, "o", "\r\n"]
[757.505165, "o", "        return self.take(indexer)\r\n"]
[757.53233, "o", "\r\n"]
[757.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[757.586659, "o", "        \"\"\"\r\n"]
[757.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[757.640989, "o", "        on either sides.\r\n"]
[757.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[757.695319, "o", "\r\n"]
[757.722484, "o", "        Parameters\r\n"]
[757.749648, "o", "        ----------\r\n"]
[757.776813, "o", "        other : IntervalIndex\r\n"]
[757.803978, "o", "\r\n"]
[757.831143, "o", "        Returns\r\n"]
[757.858308, "o", "        -------\r\n"]
[757.885473, "o", "        IntervalIndex\r\n"]
[757.912637, "o", "        \"\"\"\r\n"]
[757.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[757.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[757.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[758.021297, "o", "\r\n"]
[758.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[758.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[758.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[758.129956, "o", "\r\n"]
[758.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[758.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[758.211451, "o", "            if tup in other_tups:\r\n"]
[758.238615, "o", "                mask[i] = True\r\n"]
[758.26578, "o", "\r\n"]
[758.292945, "o", "        return self[mask]\r\n"]
[758.32011, "o", "\r\n"]
[758.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[758.37444, "o", "\r\n"]
[758.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[758.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[758.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[758.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[758.510264, "o", "        raise NotImplementedError(\r\n"]
[758.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[758.564593, "o", "            \"IndexEngine objects\"\r\n"]
[758.591758, "o", "        )\r\n"]
[758.618923, "o", "\r\n"]
[758.646088, "o", "    def _from_join_target(self, result):\r\n"]
[758.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[758.700418, "o", "\r\n"]
[758.727582, "o", "    # TODO: arithmetic operations\r\n"]
[758.754747, "o", "\r\n"]
[758.781912, "o", "\r\n"]
[758.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[758.836242, "o", "    \"\"\"\r\n"]
[758.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[758.890571, "o", "    \"\"\"\r\n"]
[758.917736, "o", "    return any(\r\n"]
[758.944901, "o", "        [\r\n"]
[758.972066, "o", "            is_number(endpoint),\r\n"]
[758.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[759.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[759.05356, "o", "            endpoint is None,\r\n"]
[759.080725, "o", "        ]\r\n"]
[759.10789, "o", "    )\r\n"]
[759.135055, "o", "\r\n"]
[759.16222, "o", "\r\n"]
[759.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[759.216549, "o", "    \"\"\"\r\n"]
[759.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[759.270879, "o", "    \"\"\"\r\n"]
[759.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[759.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[759.352374, "o", "    return (\r\n"]
[759.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[759.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[759.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[759.461033, "o", "        or com.any_none(a, b)\r\n"]
[759.488198, "o", "    )\r\n"]
[759.515363, "o", "\r\n"]
[759.542527, "o", "\r\n"]
[759.569692, "o", "def interval_range(\r\n"]
[759.596857, "o", "    start=None,\r\n"]
[759.624022, "o", "    end=None,\r\n"]
[759.651187, "o", "    periods=None,\r\n"]
[759.678352, "o", "    freq=None,\r\n"]
[759.705516, "o", "    name: Hashable = None,\r\n"]
[759.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[759.759846, "o", ") -> IntervalIndex:\r\n"]
[759.787011, "o", "    \"\"\"\r\n"]
[759.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[759.841341, "o", "\r\n"]
[759.868505, "o", "    Parameters\r\n"]
[759.89567, "o", "    ----------\r\n"]
[759.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[760.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[760.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[760.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[760.0369, "o", "\u001b[?2004l\r\n"]
[760.0678, "o", "        Left bound for generating intervals.\r\n"]
[760.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[760.1296, "o", "        Right bound for generating intervals.\r\n"]
[760.1605, "o", "    periods : int, default None\r\n"]
[760.1914, "o", "        Number of periods to generate.\r\n"]
[760.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[760.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[760.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[760.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[760.3459, "o", "    name : str, default None\r\n"]
[760.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[760.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[760.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[760.4695, "o", "        or neither.\r\n"]
[760.5004, "o", "\r\n"]
[760.5313, "o", "    Returns\r\n"]
[760.5622, "o", "    -------\r\n"]
[760.5931, "o", "    IntervalIndex\r\n"]
[760.624, "o", "\r\n"]
[760.6549, "o", "    See Also\r\n"]
[760.6858, "o", "    --------\r\n"]
[760.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[760.7476, "o", "\r\n"]
[760.7785, "o", "    Notes\r\n"]
[760.8094, "o", "    -----\r\n"]
[760.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[760.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[760.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[760.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[760.9639, "o", "\r\n"]
[760.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[761.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[761.0566, "o", "\r\n"]
[761.0875, "o", "    Examples\r\n"]
[761.1184, "o", "    --------\r\n"]
[761.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[761.1802, "o", "\r\n"]
[761.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[761.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[761.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[761.3038, "o", "\r\n"]
[761.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[761.3656, "o", "\r\n"]
[761.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[761.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[761.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[761.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[761.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[761.551, "o", "\r\n"]
[761.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[761.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[761.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[761.6746, "o", "\r\n"]
[761.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[761.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[761.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[761.7982, "o", "\r\n"]
[761.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[761.86, "o", "    convertible to a DateOffset.\r\n"]
[761.8909, "o", "\r\n"]
[761.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[761.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[761.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[762.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[762.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[762.0763, "o", "\r\n"]
[762.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[762.1381, "o", "    automatically (linearly spaced).\r\n"]
[762.169, "o", "\r\n"]
[762.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[762.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[762.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[762.2926, "o", "\r\n"]
[762.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[762.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[762.3853, "o", "\r\n"]
[762.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[762.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[762.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[762.5089, "o", "    \"\"\"\r\n"]
[762.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[762.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[762.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[762.6325, "o", "\r\n"]
[762.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[762.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[762.7252, "o", "\r\n"]
[762.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[762.787, "o", "        raise ValueError(\r\n"]
[762.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[762.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[762.8797, "o", "        )\r\n"]
[762.9106, "o", "\r\n"]
[762.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[762.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[763.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[763.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[763.0651, "o", "\r\n"]
[763.096, "o", "    if is_float(periods):\r\n"]
[763.1269, "o", "        periods = int(periods)\r\n"]
[763.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[763.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[763.2196, "o", "\r\n"]
[763.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[763.2814, "o", "        try:\r\n"]
[763.3123, "o", "            freq = to_offset(freq)\r\n"]
[763.3432, "o", "        except ValueError as err:\r\n"]
[763.3741, "o", "            raise ValueError(\r\n"]
[763.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[763.4359, "o", "            ) from err\r\n"]
[763.4668, "o", "\r\n"]
[763.4977, "o", "    # verify type compatibility\r\n"]
[763.5286, "o", "    if not all(\r\n"]
[763.5595, "o", "        [\r\n"]
[763.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[763.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[763.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[763.6831, "o", "        ]\r\n"]
[763.714, "o", "    ):\r\n"]
[763.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[763.7758, "o", "\r\n"]
[763.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[763.8376, "o", "    if periods is not None:\r\n"]
[763.8685, "o", "        periods += 1\r\n"]
[763.8994, "o", "\r\n"]
[763.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[763.9612, "o", "\r\n"]
[763.9921, "o", "    if is_number(endpoint):\r\n"]
[764.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[764.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[764.0848, "o", "            end -= (end - start) % freq\r\n"]
[764.1157, "o", "\r\n"]
[764.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[764.1775, "o", "        if periods is None:\r\n"]
[764.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[764.2393, "o", "        elif start is None:\r\n"]
[764.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[764.3011, "o", "        elif end is None:\r\n"]
[764.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[764.3629, "o", "\r\n"]
[764.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[764.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[764.4556, "o", "            # np.linspace always produces float output\r\n"]
[764.4865, "o", "\r\n"]
[764.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[764.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[764.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[764.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[764.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[764.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[764.7028, "o", "            )\r\n"]
[764.7337, "o", "    else:\r\n"]
[764.7646, "o", "        # delegate to the appropriate range function\r\n"]
[764.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[764.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[764.8573, "o", "        else:\r\n"]
[764.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[764.9191, "o", "\r\n"]
[765.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[765.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[765.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[765.030355, "o", "\u001b[?2004l\r\n"]
[765.054709, "o", "import numpy as np\r\n"]
[765.079064, "o", "import pytest\r\n"]
[765.103419, "o", "\r\n"]
[765.127773, "o", "from pandas import (\r\n"]
[765.152128, "o", "    Index,\r\n"]
[765.176483, "o", "    IntervalIndex,\r\n"]
[765.200837, "o", "    Timestamp,\r\n"]
[765.225192, "o", "    interval_range,\r\n"]
[765.249547, "o", ")\r\n"]
[765.273901, "o", "import pandas._testing as tm\r\n"]
[765.298256, "o", "\r\n"]
[765.322611, "o", "\r\n"]
[765.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[765.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[765.395675, "o", "\r\n"]
[765.42003, "o", "\r\n"]
[765.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[765.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[765.493094, "o", "\r\n"]
[765.517448, "o", "\r\n"]
[765.541803, "o", "class TestIntervalIndex:\r\n"]
[765.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[765.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[765.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[765.639222, "o", "\r\n"]
[765.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[765.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[765.712286, "o", "        if sort is None:\r\n"]
[765.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[765.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[765.78535, "o", "\r\n"]
[765.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[765.834059, "o", "        if sort is None:\r\n"]
[765.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[765.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[765.907123, "o", "\r\n"]
[765.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[765.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[765.980187, "o", "\r\n"]
[766.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[766.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[766.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[766.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[766.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[766.126315, "o", "\r\n"]
[766.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[766.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[766.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[766.223734, "o", "        expected = other\r\n"]
[766.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[766.272443, "o", "\r\n"]
[766.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[766.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[766.345507, "o", "\r\n"]
[766.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[766.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[766.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[766.442926, "o", "\r\n"]
[766.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[766.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[766.51599, "o", "\r\n"]
[766.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[766.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[766.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[766.613409, "o", "\r\n"]
[766.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[766.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[766.686473, "o", "        if sort is None:\r\n"]
[766.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[766.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[766.759537, "o", "\r\n"]
[766.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[766.808246, "o", "        if sort is None:\r\n"]
[766.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[766.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[766.88131, "o", "\r\n"]
[766.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[766.93002, "o", "\r\n"]
[766.954374, "o", "        # GH 26225: nested intervals\r\n"]
[766.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[767.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[767.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[767.051793, "o", "        result = index.intersection(other)\r\n"]
[767.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[767.100502, "o", "\r\n"]
[767.124857, "o", "        # GH 26225\r\n"]
[767.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[767.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[767.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[767.222276, "o", "        result = index.intersection(other)\r\n"]
[767.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[767.270985, "o", "\r\n"]
[767.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[767.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[767.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[767.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[767.392759, "o", "        result = index.intersection(other)\r\n"]
[767.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[767.441468, "o", "\r\n"]
[767.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[767.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[767.514532, "o", "\r\n"]
[767.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[767.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[767.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[767.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[767.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[767.66066, "o", "\r\n"]
[767.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[767.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[767.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[767.758079, "o", "        expected = other[:0]\r\n"]
[767.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[767.806788, "o", "\r\n"]
[767.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[767.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[767.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[767.904207, "o", "\r\n"]
[767.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[767.952916, "o", "        # GH#38743\r\n"]
[767.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[768.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[768.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[768.050335, "o", "        result = index.intersection(other)\r\n"]
[768.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[768.099044, "o", "\r\n"]
[768.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[768.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[768.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[768.196463, "o", "        expected = index[1:]\r\n"]
[768.220818, "o", "        if sort is None:\r\n"]
[768.245172, "o", "            expected = expected.sort_values()\r\n"]
[768.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[768.293882, "o", "\r\n"]
[768.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[768.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[768.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[768.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[768.415655, "o", "\r\n"]
[768.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[768.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[768.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[768.513074, "o", "        )\r\n"]
[768.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[768.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[768.586138, "o", "\r\n"]
[768.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[768.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[768.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[768.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[768.707911, "o", "        if sort is None:\r\n"]
[768.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[768.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[768.780975, "o", "\r\n"]
[768.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[768.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[768.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[768.878394, "o", "        if sort is None:\r\n"]
[768.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[768.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[768.951458, "o", "\r\n"]
[768.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[769.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[769.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[769.048877, "o", "        )\r\n"]
[769.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[769.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[769.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[769.146296, "o", "\r\n"]
[769.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[769.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[769.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[769.243714, "o", "    )\r\n"]
[769.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[769.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[769.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[769.341133, "o", "\r\n"]
[769.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[769.389842, "o", "        # non-IntervalIndex\r\n"]
[769.414197, "o", "        if op_name == \"difference\":\r\n"]
[769.438552, "o", "            expected = index\r\n"]
[769.462906, "o", "        else:\r\n"]
[769.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[769.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[769.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[769.560325, "o", "\r\n"]
[769.58468, "o", "        # mixed closed -> cast to object\r\n"]
[769.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[769.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[769.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[769.682099, "o", "            if op_name == \"difference\":\r\n"]
[769.706453, "o", "                expected = index\r\n"]
[769.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[769.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[769.779517, "o", "\r\n"]
[769.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[769.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[769.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[769.876936, "o", "        if op_name == \"difference\":\r\n"]
[769.901291, "o", "            expected = index\r\n"]
[769.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[770.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[770.002, "i", "cd asv_bench\r"]
[770.004, "o", "cd asv_bench\r\n"]
[770.006, "o", "\u001b[?2004l\r\n"]
[775.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[775.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[775.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[780.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[780.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[780.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[780.418, "o", "\u001b[?2004l\r\n"]
[780.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[781.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[781.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[782.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[782.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[782.89, "o", "              param1            \r\n"]
[783.302, "o", "             -------- ----------\r\n"]
[783.714, "o", "               1000    1.17\u00b10ms \r\n"]
[784.126, "o", "              100000   77.0\u00b10ms \r\n"]
[784.538, "o", "             ======== ==========\r\n"]
[785.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[785.002, "i", "cd ..\r"]
[785.004, "o", "cd ..\r\n"]
[785.006, "o", "\u001b[?2004l\r\n"]
[790.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[790.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[790.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[792.478, "o", "\u001b[?2004l\r\n"]
[795.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[795.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[795.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[796.654, "o", "\u001b[?2004l\r\n"]
[798.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[800.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[800.002, "i", "sed -n '820,980p' pandas/core/indexes/interval.py\r"]
[800.004, "o", "sed -n '820,980p' pandas/core/indexes/interval.py\r\n"]
[800.036519, "o", "\u001b[?2004l\r\n"]
[800.067037, "o", "    @cache_readonly\r\n"]
[800.097556, "o", "    def mid(self) -> Index:\r\n"]
[800.128074, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[800.158593, "o", "\r\n"]
[800.189111, "o", "    @property\r\n"]
[800.21963, "o", "    def length(self) -> Index:\r\n"]
[800.250148, "o", "        return Index(self._data.length, copy=False)\r\n"]
[800.280667, "o", "\r\n"]
[800.311185, "o", "    # --------------------------------------------------------------------\r\n"]
[800.341704, "o", "    # Rendering Methods\r\n"]
[800.372222, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[800.402741, "o", "\r\n"]
[800.433259, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[800.463778, "o", "        # matches base class except for whitespace padding\r\n"]
[800.494296, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[800.524815, "o", "\r\n"]
[800.555333, "o", "    def _format_native_types(\r\n"]
[800.585852, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[800.61637, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[800.646889, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[800.677407, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[800.707926, "o", "\r\n"]
[800.738444, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[800.768963, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[800.799481, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[800.83, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[800.860519, "o", "\r\n"]
[800.891037, "o", "    # --------------------------------------------------------------------\r\n"]
[800.921556, "o", "    # Set Operations\r\n"]
[800.952074, "o", "\r\n"]
[800.982593, "o", "    def _intersection(self, other, sort):\r\n"]
[801.013111, "o", "        \"\"\"\r\n"]
[801.04363, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[801.074148, "o", "        \"\"\"\r\n"]
[801.104667, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[801.135185, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[801.165704, "o", "            taken = self._intersection_unique(other)\r\n"]
[801.196222, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[801.226741, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[801.257259, "o", "            # multiple NaNs\r\n"]
[801.287778, "o", "            taken = other._intersection_unique(self)\r\n"]
[801.318296, "o", "        else:\r\n"]
[801.348815, "o", "            # duplicates\r\n"]
[801.379333, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[801.409852, "o", "\r\n"]
[801.44037, "o", "        if sort is None:\r\n"]
[801.470889, "o", "            taken = taken.sort_values()\r\n"]
[801.501407, "o", "\r\n"]
[801.531926, "o", "        return taken\r\n"]
[801.562444, "o", "\r\n"]
[801.592963, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[801.623481, "o", "        \"\"\"\r\n"]
[801.654, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[801.684519, "o", "        no matter left or right.\r\n"]
[801.715037, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[801.745556, "o", "        Parameters\r\n"]
[801.776074, "o", "        ----------\r\n"]
[801.806593, "o", "        other : IntervalIndex\r\n"]
[801.837111, "o", "        Returns\r\n"]
[801.86763, "o", "        -------\r\n"]
[801.898148, "o", "        IntervalIndex\r\n"]
[801.928667, "o", "        \"\"\"\r\n"]
[801.959185, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[801.989704, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[802.020222, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[802.050741, "o", "\r\n"]
[802.081259, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[802.111778, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[802.142296, "o", "        indexer = unique(indexer)\r\n"]
[802.172815, "o", "\r\n"]
[802.203333, "o", "        return self.take(indexer)\r\n"]
[802.233852, "o", "\r\n"]
[802.26437, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[802.294889, "o", "        \"\"\"\r\n"]
[802.325407, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[802.355926, "o", "        on either sides.\r\n"]
[802.386444, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[802.416963, "o", "\r\n"]
[802.447481, "o", "        Parameters\r\n"]
[802.478, "o", "        ----------\r\n"]
[802.508519, "o", "        other : IntervalIndex\r\n"]
[802.539037, "o", "\r\n"]
[802.569556, "o", "        Returns\r\n"]
[802.600074, "o", "        -------\r\n"]
[802.630593, "o", "        IntervalIndex\r\n"]
[802.661111, "o", "        \"\"\"\r\n"]
[802.69163, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[802.722148, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[802.752667, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[802.783185, "o", "\r\n"]
[802.813704, "o", "        if self.hasnans and other.hasnans:\r\n"]
[802.844222, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[802.874741, "o", "            mask[first_nan_loc] = True\r\n"]
[802.905259, "o", "\r\n"]
[802.935778, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[802.966296, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[802.996815, "o", "            if tup in other_tups:\r\n"]
[803.027333, "o", "                mask[i] = True\r\n"]
[803.057852, "o", "\r\n"]
[803.08837, "o", "        return self[mask]\r\n"]
[803.118889, "o", "\r\n"]
[803.149407, "o", "    # --------------------------------------------------------------------\r\n"]
[803.179926, "o", "\r\n"]
[803.210444, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[803.240963, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[803.271481, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[803.302, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[803.332519, "o", "        raise NotImplementedError(\r\n"]
[803.363037, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[803.393556, "o", "            \"IndexEngine objects\"\r\n"]
[803.424074, "o", "        )\r\n"]
[803.454593, "o", "\r\n"]
[803.485111, "o", "    def _from_join_target(self, result):\r\n"]
[803.51563, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[803.546148, "o", "\r\n"]
[803.576667, "o", "    # TODO: arithmetic operations\r\n"]
[803.607185, "o", "\r\n"]
[803.637704, "o", "\r\n"]
[803.668222, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[803.698741, "o", "    \"\"\"\r\n"]
[803.729259, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[803.759778, "o", "    \"\"\"\r\n"]
[803.790296, "o", "    return any(\r\n"]
[803.820815, "o", "        [\r\n"]
[803.851333, "o", "            is_number(endpoint),\r\n"]
[803.881852, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[803.91237, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[803.942889, "o", "            endpoint is None,\r\n"]
[803.973407, "o", "        ]\r\n"]
[804.003926, "o", "    )\r\n"]
[804.034444, "o", "\r\n"]
[804.064963, "o", "\r\n"]
[804.095481, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[804.126, "o", "    \"\"\"\r\n"]
[804.156519, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[804.187037, "o", "    \"\"\"\r\n"]
[804.217556, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[804.248074, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[804.278593, "o", "    return (\r\n"]
[804.309111, "o", "        (is_number(a) and is_number(b))\r\n"]
[804.33963, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[804.370148, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[804.400667, "o", "        or com.any_none(a, b)\r\n"]
[804.431185, "o", "    )\r\n"]
[804.461704, "o", "\r\n"]
[804.492222, "o", "\r\n"]
[804.522741, "o", "def interval_range(\r\n"]
[804.553259, "o", "    start=None,\r\n"]
[804.583778, "o", "    end=None,\r\n"]
[804.614296, "o", "    periods=None,\r\n"]
[804.644815, "o", "    freq=None,\r\n"]
[804.675333, "o", "    name: Hashable = None,\r\n"]
[804.705852, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[804.73637, "o", ") -> IntervalIndex:\r\n"]
[804.766889, "o", "    \"\"\"\r\n"]
[804.797407, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[804.827926, "o", "\r\n"]
[804.858444, "o", "    Parameters\r\n"]
[804.888963, "o", "    ----------\r\n"]
[804.919481, "o", "    start : numeric or datetime-like, default None\r\n"]
[805.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[805.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[805.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[805.0369, "o", "\u001b[?2004l\r\n"]
[805.0678, "o", "        Left bound for generating intervals.\r\n"]
[805.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[805.1296, "o", "        Right bound for generating intervals.\r\n"]
[805.1605, "o", "    periods : int, default None\r\n"]
[805.1914, "o", "        Number of periods to generate.\r\n"]
[805.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[805.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[805.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[805.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[805.3459, "o", "    name : str, default None\r\n"]
[805.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[805.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[805.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[805.4695, "o", "        or neither.\r\n"]
[805.5004, "o", "\r\n"]
[805.5313, "o", "    Returns\r\n"]
[805.5622, "o", "    -------\r\n"]
[805.5931, "o", "    IntervalIndex\r\n"]
[805.624, "o", "\r\n"]
[805.6549, "o", "    See Also\r\n"]
[805.6858, "o", "    --------\r\n"]
[805.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[805.7476, "o", "\r\n"]
[805.7785, "o", "    Notes\r\n"]
[805.8094, "o", "    -----\r\n"]
[805.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[805.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[805.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[805.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[805.9639, "o", "\r\n"]
[805.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[806.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[806.0566, "o", "\r\n"]
[806.0875, "o", "    Examples\r\n"]
[806.1184, "o", "    --------\r\n"]
[806.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[806.1802, "o", "\r\n"]
[806.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[806.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[806.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[806.3038, "o", "\r\n"]
[806.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[806.3656, "o", "\r\n"]
[806.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[806.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[806.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[806.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[806.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[806.551, "o", "\r\n"]
[806.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[806.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[806.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[806.6746, "o", "\r\n"]
[806.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[806.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[806.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[806.7982, "o", "\r\n"]
[806.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[806.86, "o", "    convertible to a DateOffset.\r\n"]
[806.8909, "o", "\r\n"]
[806.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[806.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[806.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[807.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[807.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[807.0763, "o", "\r\n"]
[807.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[807.1381, "o", "    automatically (linearly spaced).\r\n"]
[807.169, "o", "\r\n"]
[807.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[807.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[807.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[807.2926, "o", "\r\n"]
[807.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[807.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[807.3853, "o", "\r\n"]
[807.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[807.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[807.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[807.5089, "o", "    \"\"\"\r\n"]
[807.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[807.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[807.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[807.6325, "o", "\r\n"]
[807.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[807.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[807.7252, "o", "\r\n"]
[807.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[807.787, "o", "        raise ValueError(\r\n"]
[807.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[807.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[807.8797, "o", "        )\r\n"]
[807.9106, "o", "\r\n"]
[807.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[807.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[808.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[808.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[808.0651, "o", "\r\n"]
[808.096, "o", "    if is_float(periods):\r\n"]
[808.1269, "o", "        periods = int(periods)\r\n"]
[808.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[808.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[808.2196, "o", "\r\n"]
[808.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[808.2814, "o", "        try:\r\n"]
[808.3123, "o", "            freq = to_offset(freq)\r\n"]
[808.3432, "o", "        except ValueError as err:\r\n"]
[808.3741, "o", "            raise ValueError(\r\n"]
[808.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[808.4359, "o", "            ) from err\r\n"]
[808.4668, "o", "\r\n"]
[808.4977, "o", "    # verify type compatibility\r\n"]
[808.5286, "o", "    if not all(\r\n"]
[808.5595, "o", "        [\r\n"]
[808.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[808.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[808.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[808.6831, "o", "        ]\r\n"]
[808.714, "o", "    ):\r\n"]
[808.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[808.7758, "o", "\r\n"]
[808.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[808.8376, "o", "    if periods is not None:\r\n"]
[808.8685, "o", "        periods += 1\r\n"]
[808.8994, "o", "\r\n"]
[808.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[808.9612, "o", "\r\n"]
[808.9921, "o", "    if is_number(endpoint):\r\n"]
[809.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[809.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[809.0848, "o", "            end -= (end - start) % freq\r\n"]
[809.1157, "o", "\r\n"]
[809.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[809.1775, "o", "        if periods is None:\r\n"]
[809.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[809.2393, "o", "        elif start is None:\r\n"]
[809.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[809.3011, "o", "        elif end is None:\r\n"]
[809.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[809.3629, "o", "\r\n"]
[809.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[809.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[809.4556, "o", "            # np.linspace always produces float output\r\n"]
[809.4865, "o", "\r\n"]
[809.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[809.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[809.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[809.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[809.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[809.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[809.7028, "o", "            )\r\n"]
[809.7337, "o", "    else:\r\n"]
[809.7646, "o", "        # delegate to the appropriate range function\r\n"]
[809.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[809.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[809.8573, "o", "        else:\r\n"]
[809.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[809.9191, "o", "\r\n"]
[810.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[810.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[810.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[810.030355, "o", "\u001b[?2004l\r\n"]
[810.054709, "o", "import numpy as np\r\n"]
[810.079064, "o", "import pytest\r\n"]
[810.103419, "o", "\r\n"]
[810.127773, "o", "from pandas import (\r\n"]
[810.152128, "o", "    Index,\r\n"]
[810.176483, "o", "    IntervalIndex,\r\n"]
[810.200837, "o", "    Timestamp,\r\n"]
[810.225192, "o", "    interval_range,\r\n"]
[810.249547, "o", ")\r\n"]
[810.273901, "o", "import pandas._testing as tm\r\n"]
[810.298256, "o", "\r\n"]
[810.322611, "o", "\r\n"]
[810.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[810.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[810.395675, "o", "\r\n"]
[810.42003, "o", "\r\n"]
[810.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[810.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[810.493094, "o", "\r\n"]
[810.517448, "o", "\r\n"]
[810.541803, "o", "class TestIntervalIndex:\r\n"]
[810.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[810.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[810.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[810.639222, "o", "\r\n"]
[810.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[810.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[810.712286, "o", "        if sort is None:\r\n"]
[810.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[810.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[810.78535, "o", "\r\n"]
[810.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[810.834059, "o", "        if sort is None:\r\n"]
[810.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[810.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[810.907123, "o", "\r\n"]
[810.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[810.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[810.980187, "o", "\r\n"]
[811.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[811.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[811.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[811.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[811.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[811.126315, "o", "\r\n"]
[811.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[811.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[811.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[811.223734, "o", "        expected = other\r\n"]
[811.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[811.272443, "o", "\r\n"]
[811.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[811.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[811.345507, "o", "\r\n"]
[811.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[811.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[811.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[811.442926, "o", "\r\n"]
[811.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[811.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[811.51599, "o", "\r\n"]
[811.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[811.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[811.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[811.613409, "o", "\r\n"]
[811.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[811.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[811.686473, "o", "        if sort is None:\r\n"]
[811.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[811.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[811.759537, "o", "\r\n"]
[811.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[811.808246, "o", "        if sort is None:\r\n"]
[811.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[811.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[811.88131, "o", "\r\n"]
[811.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[811.93002, "o", "\r\n"]
[811.954374, "o", "        # GH 26225: nested intervals\r\n"]
[811.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[812.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[812.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[812.051793, "o", "        result = index.intersection(other)\r\n"]
[812.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[812.100502, "o", "\r\n"]
[812.124857, "o", "        # GH 26225\r\n"]
[812.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[812.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[812.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[812.222276, "o", "        result = index.intersection(other)\r\n"]
[812.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[812.270985, "o", "\r\n"]
[812.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[812.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[812.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[812.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[812.392759, "o", "        result = index.intersection(other)\r\n"]
[812.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[812.441468, "o", "\r\n"]
[812.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[812.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[812.514532, "o", "\r\n"]
[812.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[812.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[812.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[812.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[812.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[812.66066, "o", "\r\n"]
[812.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[812.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[812.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[812.758079, "o", "        expected = other[:0]\r\n"]
[812.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[812.806788, "o", "\r\n"]
[812.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[812.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[812.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[812.904207, "o", "\r\n"]
[812.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[812.952916, "o", "        # GH#38743\r\n"]
[812.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[813.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[813.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[813.050335, "o", "        result = index.intersection(other)\r\n"]
[813.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[813.099044, "o", "\r\n"]
[813.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[813.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[813.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[813.196463, "o", "        expected = index[1:]\r\n"]
[813.220818, "o", "        if sort is None:\r\n"]
[813.245172, "o", "            expected = expected.sort_values()\r\n"]
[813.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[813.293882, "o", "\r\n"]
[813.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[813.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[813.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[813.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[813.415655, "o", "\r\n"]
[813.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[813.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[813.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[813.513074, "o", "        )\r\n"]
[813.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[813.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[813.586138, "o", "\r\n"]
[813.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[813.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[813.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[813.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[813.707911, "o", "        if sort is None:\r\n"]
[813.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[813.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[813.780975, "o", "\r\n"]
[813.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[813.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[813.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[813.878394, "o", "        if sort is None:\r\n"]
[813.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[813.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[813.951458, "o", "\r\n"]
[813.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[814.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[814.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[814.048877, "o", "        )\r\n"]
[814.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[814.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[814.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[814.146296, "o", "\r\n"]
[814.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[814.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[814.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[814.243714, "o", "    )\r\n"]
[814.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[814.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[814.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[814.341133, "o", "\r\n"]
[814.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[814.389842, "o", "        # non-IntervalIndex\r\n"]
[814.414197, "o", "        if op_name == \"difference\":\r\n"]
[814.438552, "o", "            expected = index\r\n"]
[814.462906, "o", "        else:\r\n"]
[814.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[814.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[814.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[814.560325, "o", "\r\n"]
[814.58468, "o", "        # mixed closed -> cast to object\r\n"]
[814.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[814.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[814.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[814.682099, "o", "            if op_name == \"difference\":\r\n"]
[814.706453, "o", "                expected = index\r\n"]
[814.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[814.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[814.779517, "o", "\r\n"]
[814.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[814.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[814.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[814.876936, "o", "        if op_name == \"difference\":\r\n"]
[814.901291, "o", "            expected = index\r\n"]
[814.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[815.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[815.002, "i", "cd asv_bench\r"]
[815.004, "o", "cd asv_bench\r\n"]
[815.006, "o", "\u001b[?2004l\r\n"]
[820.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[820.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[820.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[825.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[825.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[825.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[825.418, "o", "\u001b[?2004l\r\n"]
[825.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[826.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[826.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[827.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[827.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[827.89, "o", "              param1            \r\n"]
[828.302, "o", "             -------- ----------\r\n"]
[828.714, "o", "               1000    1.19\u00b10ms \r\n"]
[829.126, "o", "              100000   74.9\u00b10ms \r\n"]
[829.538, "o", "             ======== ==========\r\n"]
[830.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[830.002, "i", "cd ..\r"]
[830.004, "o", "cd ..\r\n"]
[830.006, "o", "\u001b[?2004l\r\n"]
[835.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[835.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[835.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[837.478, "o", "\u001b[?2004l\r\n"]
[840.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[840.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[840.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[841.654, "o", "\u001b[?2004l\r\n"]
[843.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[845.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[845.002, "i", "sed -n '800,980p' pandas/core/indexes/interval.py\r"]
[845.004, "o", "sed -n '800,980p' pandas/core/indexes/interval.py\r\n"]
[845.033165, "o", "\u001b[?2004l\r\n"]
[845.06033, "o", "\r\n"]
[845.087495, "o", "    def _maybe_cast_slice_bound(self, label, side: str):\r\n"]
[845.114659, "o", "        return getattr(self, side)._maybe_cast_slice_bound(label, side)\r\n"]
[845.141824, "o", "\r\n"]
[845.168989, "o", "    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\r\n"]
[845.196154, "o", "        if not isinstance(dtype, IntervalDtype):\r\n"]
[845.223319, "o", "            return False\r\n"]
[845.250484, "o", "        common_subtype = find_common_type([self.dtype, dtype])\r\n"]
[845.277648, "o", "        return not is_object_dtype(common_subtype)\r\n"]
[845.304813, "o", "\r\n"]
[845.331978, "o", "    # --------------------------------------------------------------------\r\n"]
[845.359143, "o", "\r\n"]
[845.386308, "o", "    @cache_readonly\r\n"]
[845.413473, "o", "    def left(self) -> Index:\r\n"]
[845.440637, "o", "        return Index(self._data.left, copy=False)\r\n"]
[845.467802, "o", "\r\n"]
[845.494967, "o", "    @cache_readonly\r\n"]
[845.522132, "o", "    def right(self) -> Index:\r\n"]
[845.549297, "o", "        return Index(self._data.right, copy=False)\r\n"]
[845.576462, "o", "\r\n"]
[845.603626, "o", "    @cache_readonly\r\n"]
[845.630791, "o", "    def mid(self) -> Index:\r\n"]
[845.657956, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[845.685121, "o", "\r\n"]
[845.712286, "o", "    @property\r\n"]
[845.739451, "o", "    def length(self) -> Index:\r\n"]
[845.766615, "o", "        return Index(self._data.length, copy=False)\r\n"]
[845.79378, "o", "\r\n"]
[845.820945, "o", "    # --------------------------------------------------------------------\r\n"]
[845.84811, "o", "    # Rendering Methods\r\n"]
[845.875275, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[845.90244, "o", "\r\n"]
[845.929604, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[845.956769, "o", "        # matches base class except for whitespace padding\r\n"]
[845.983934, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[846.011099, "o", "\r\n"]
[846.038264, "o", "    def _format_native_types(\r\n"]
[846.065429, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[846.092593, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[846.119758, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[846.146923, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[846.174088, "o", "\r\n"]
[846.201253, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[846.228418, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[846.255582, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[846.282747, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[846.309912, "o", "\r\n"]
[846.337077, "o", "    # --------------------------------------------------------------------\r\n"]
[846.364242, "o", "    # Set Operations\r\n"]
[846.391407, "o", "\r\n"]
[846.418571, "o", "    def _intersection(self, other, sort):\r\n"]
[846.445736, "o", "        \"\"\"\r\n"]
[846.472901, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[846.500066, "o", "        \"\"\"\r\n"]
[846.527231, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[846.554396, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[846.58156, "o", "            taken = self._intersection_unique(other)\r\n"]
[846.608725, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[846.63589, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[846.663055, "o", "            # multiple NaNs\r\n"]
[846.69022, "o", "            taken = other._intersection_unique(self)\r\n"]
[846.717385, "o", "        else:\r\n"]
[846.744549, "o", "            # duplicates\r\n"]
[846.771714, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[846.798879, "o", "\r\n"]
[846.826044, "o", "        if sort is None:\r\n"]
[846.853209, "o", "            taken = taken.sort_values()\r\n"]
[846.880374, "o", "\r\n"]
[846.907538, "o", "        return taken\r\n"]
[846.934703, "o", "\r\n"]
[846.961868, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[846.989033, "o", "        \"\"\"\r\n"]
[847.016198, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[847.043363, "o", "        no matter left or right.\r\n"]
[847.070527, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[847.097692, "o", "        Parameters\r\n"]
[847.124857, "o", "        ----------\r\n"]
[847.152022, "o", "        other : IntervalIndex\r\n"]
[847.179187, "o", "        Returns\r\n"]
[847.206352, "o", "        -------\r\n"]
[847.233516, "o", "        IntervalIndex\r\n"]
[847.260681, "o", "        \"\"\"\r\n"]
[847.287846, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[847.315011, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[847.342176, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[847.369341, "o", "\r\n"]
[847.396505, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[847.42367, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[847.450835, "o", "        indexer = unique(indexer)\r\n"]
[847.478, "o", "\r\n"]
[847.505165, "o", "        return self.take(indexer)\r\n"]
[847.53233, "o", "\r\n"]
[847.559495, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[847.586659, "o", "        \"\"\"\r\n"]
[847.613824, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[847.640989, "o", "        on either sides.\r\n"]
[847.668154, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[847.695319, "o", "\r\n"]
[847.722484, "o", "        Parameters\r\n"]
[847.749648, "o", "        ----------\r\n"]
[847.776813, "o", "        other : IntervalIndex\r\n"]
[847.803978, "o", "\r\n"]
[847.831143, "o", "        Returns\r\n"]
[847.858308, "o", "        -------\r\n"]
[847.885473, "o", "        IntervalIndex\r\n"]
[847.912637, "o", "        \"\"\"\r\n"]
[847.939802, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[847.966967, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[847.994132, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[848.021297, "o", "\r\n"]
[848.048462, "o", "        if self.hasnans and other.hasnans:\r\n"]
[848.075626, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[848.102791, "o", "            mask[first_nan_loc] = True\r\n"]
[848.129956, "o", "\r\n"]
[848.157121, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[848.184286, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[848.211451, "o", "            if tup in other_tups:\r\n"]
[848.238615, "o", "                mask[i] = True\r\n"]
[848.26578, "o", "\r\n"]
[848.292945, "o", "        return self[mask]\r\n"]
[848.32011, "o", "\r\n"]
[848.347275, "o", "    # --------------------------------------------------------------------\r\n"]
[848.37444, "o", "\r\n"]
[848.401604, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[848.428769, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[848.455934, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[848.483099, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[848.510264, "o", "        raise NotImplementedError(\r\n"]
[848.537429, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[848.564593, "o", "            \"IndexEngine objects\"\r\n"]
[848.591758, "o", "        )\r\n"]
[848.618923, "o", "\r\n"]
[848.646088, "o", "    def _from_join_target(self, result):\r\n"]
[848.673253, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[848.700418, "o", "\r\n"]
[848.727582, "o", "    # TODO: arithmetic operations\r\n"]
[848.754747, "o", "\r\n"]
[848.781912, "o", "\r\n"]
[848.809077, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[848.836242, "o", "    \"\"\"\r\n"]
[848.863407, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[848.890571, "o", "    \"\"\"\r\n"]
[848.917736, "o", "    return any(\r\n"]
[848.944901, "o", "        [\r\n"]
[848.972066, "o", "            is_number(endpoint),\r\n"]
[848.999231, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[849.026396, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[849.05356, "o", "            endpoint is None,\r\n"]
[849.080725, "o", "        ]\r\n"]
[849.10789, "o", "    )\r\n"]
[849.135055, "o", "\r\n"]
[849.16222, "o", "\r\n"]
[849.189385, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[849.216549, "o", "    \"\"\"\r\n"]
[849.243714, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[849.270879, "o", "    \"\"\"\r\n"]
[849.298044, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[849.325209, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[849.352374, "o", "    return (\r\n"]
[849.379538, "o", "        (is_number(a) and is_number(b))\r\n"]
[849.406703, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[849.433868, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[849.461033, "o", "        or com.any_none(a, b)\r\n"]
[849.488198, "o", "    )\r\n"]
[849.515363, "o", "\r\n"]
[849.542527, "o", "\r\n"]
[849.569692, "o", "def interval_range(\r\n"]
[849.596857, "o", "    start=None,\r\n"]
[849.624022, "o", "    end=None,\r\n"]
[849.651187, "o", "    periods=None,\r\n"]
[849.678352, "o", "    freq=None,\r\n"]
[849.705516, "o", "    name: Hashable = None,\r\n"]
[849.732681, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[849.759846, "o", ") -> IntervalIndex:\r\n"]
[849.787011, "o", "    \"\"\"\r\n"]
[849.814176, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[849.841341, "o", "\r\n"]
[849.868505, "o", "    Parameters\r\n"]
[849.89567, "o", "    ----------\r\n"]
[849.922835, "o", "    start : numeric or datetime-like, default None\r\n"]
[850.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[850.002, "i", "sed -n '980,1160p' pandas/core/indexes/interval.py\r"]
[850.004, "o", "sed -n '980,1160p' pandas/core/indexes/interval.py\r\n"]
[850.0369, "o", "\u001b[?2004l\r\n"]
[850.0678, "o", "        Left bound for generating intervals.\r\n"]
[850.0987, "o", "    end : numeric or datetime-like, default None\r\n"]
[850.1296, "o", "        Right bound for generating intervals.\r\n"]
[850.1605, "o", "    periods : int, default None\r\n"]
[850.1914, "o", "        Number of periods to generate.\r\n"]
[850.2223, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[850.2532, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[850.2841, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[850.315, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[850.3459, "o", "    name : str, default None\r\n"]
[850.3768, "o", "        Name of the resulting IntervalIndex.\r\n"]
[850.4077, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[850.4386, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[850.4695, "o", "        or neither.\r\n"]
[850.5004, "o", "\r\n"]
[850.5313, "o", "    Returns\r\n"]
[850.5622, "o", "    -------\r\n"]
[850.5931, "o", "    IntervalIndex\r\n"]
[850.624, "o", "\r\n"]
[850.6549, "o", "    See Also\r\n"]
[850.6858, "o", "    --------\r\n"]
[850.7167, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[850.7476, "o", "\r\n"]
[850.7785, "o", "    Notes\r\n"]
[850.8094, "o", "    -----\r\n"]
[850.8403, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[850.8712, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[850.9021, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[850.933, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[850.9639, "o", "\r\n"]
[850.9948, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[851.0257, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[851.0566, "o", "\r\n"]
[851.0875, "o", "    Examples\r\n"]
[851.1184, "o", "    --------\r\n"]
[851.1493, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[851.1802, "o", "\r\n"]
[851.2111, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[851.242, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[851.2729, "o", "                  dtype='interval[int64, right]')\r\n"]
[851.3038, "o", "\r\n"]
[851.3347, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[851.3656, "o", "\r\n"]
[851.3965, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[851.4274, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[851.4583, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[851.4892, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[851.5201, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[851.551, "o", "\r\n"]
[851.5819, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[851.6128, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[851.6437, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[851.6746, "o", "\r\n"]
[851.7055, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[851.7364, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[851.7673, "o", "                  dtype='interval[float64, right]')\r\n"]
[851.7982, "o", "\r\n"]
[851.8291, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[851.86, "o", "    convertible to a DateOffset.\r\n"]
[851.8909, "o", "\r\n"]
[851.9218, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[851.9527, "o", "    ...                   periods=3, freq='MS')\r\n"]
[851.9836, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[852.0145, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[852.0454, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[852.0763, "o", "\r\n"]
[852.1072, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[852.1381, "o", "    automatically (linearly spaced).\r\n"]
[852.169, "o", "\r\n"]
[852.1999, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[852.2308, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[852.2617, "o", "              dtype='interval[float64, right]')\r\n"]
[852.2926, "o", "\r\n"]
[852.3235, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[852.3544, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[852.3853, "o", "\r\n"]
[852.4162, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[852.4471, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[852.478, "o", "                  dtype='interval[int64, both]')\r\n"]
[852.5089, "o", "    \"\"\"\r\n"]
[852.5398, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[852.5707, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[852.6016, "o", "    endpoint = start if start is not None else end\r\n"]
[852.6325, "o", "\r\n"]
[852.6634, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[852.6943, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[852.7252, "o", "\r\n"]
[852.7561, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[852.787, "o", "        raise ValueError(\r\n"]
[852.8179, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[852.8488, "o", "            \"freq, exactly three must be specified\"\r\n"]
[852.8797, "o", "        )\r\n"]
[852.9106, "o", "\r\n"]
[852.9415, "o", "    if not _is_valid_endpoint(start):\r\n"]
[852.9724, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[853.0033, "o", "    if not _is_valid_endpoint(end):\r\n"]
[853.0342, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[853.0651, "o", "\r\n"]
[853.096, "o", "    if is_float(periods):\r\n"]
[853.1269, "o", "        periods = int(periods)\r\n"]
[853.1578, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[853.1887, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[853.2196, "o", "\r\n"]
[853.2505, "o", "    if freq is not None and not is_number(freq):\r\n"]
[853.2814, "o", "        try:\r\n"]
[853.3123, "o", "            freq = to_offset(freq)\r\n"]
[853.3432, "o", "        except ValueError as err:\r\n"]
[853.3741, "o", "            raise ValueError(\r\n"]
[853.405, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[853.4359, "o", "            ) from err\r\n"]
[853.4668, "o", "\r\n"]
[853.4977, "o", "    # verify type compatibility\r\n"]
[853.5286, "o", "    if not all(\r\n"]
[853.5595, "o", "        [\r\n"]
[853.5904, "o", "            _is_type_compatible(start, end),\r\n"]
[853.6213, "o", "            _is_type_compatible(start, freq),\r\n"]
[853.6522, "o", "            _is_type_compatible(end, freq),\r\n"]
[853.6831, "o", "        ]\r\n"]
[853.714, "o", "    ):\r\n"]
[853.7449, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[853.7758, "o", "\r\n"]
[853.8067, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[853.8376, "o", "    if periods is not None:\r\n"]
[853.8685, "o", "        periods += 1\r\n"]
[853.8994, "o", "\r\n"]
[853.9303, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[853.9612, "o", "\r\n"]
[853.9921, "o", "    if is_number(endpoint):\r\n"]
[854.023, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[854.0539, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[854.0848, "o", "            end -= (end - start) % freq\r\n"]
[854.1157, "o", "\r\n"]
[854.1466, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[854.1775, "o", "        if periods is None:\r\n"]
[854.2084, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[854.2393, "o", "        elif start is None:\r\n"]
[854.2702, "o", "            start = end - (periods - 1) * freq\r\n"]
[854.3011, "o", "        elif end is None:\r\n"]
[854.332, "o", "            end = start + (periods - 1) * freq\r\n"]
[854.3629, "o", "\r\n"]
[854.3938, "o", "        breaks = np.linspace(start, end, periods)\r\n"]
[854.4247, "o", "        if all(is_integer(x) for x in com.not_none(start, end, freq)):\r\n"]
[854.4556, "o", "            # np.linspace always produces float output\r\n"]
[854.4865, "o", "\r\n"]
[854.5174, "o", "            # error: Argument 1 to \"maybe_downcast_numeric\" has incompatible type\r\n"]
[854.5483, "o", "            # \"Union[ndarray[Any, Any], TimedeltaIndex, DatetimeIndex]\";\r\n"]
[854.5792, "o", "            # expected \"ndarray[Any, Any]\"  [\r\n"]
[854.6101, "o", "            breaks = maybe_downcast_numeric(\r\n"]
[854.641, "o", "                breaks,  # type: ignore[arg-type]\r\n"]
[854.6719, "o", "                np.dtype(\"int64\"),\r\n"]
[854.7028, "o", "            )\r\n"]
[854.7337, "o", "    else:\r\n"]
[854.7646, "o", "        # delegate to the appropriate range function\r\n"]
[854.7955, "o", "        if isinstance(endpoint, Timestamp):\r\n"]
[854.8264, "o", "            breaks = date_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[854.8573, "o", "        else:\r\n"]
[854.8882, "o", "            breaks = timedelta_range(start=start, end=end, periods=periods, freq=freq)\r\n"]
[854.9191, "o", "\r\n"]
[855.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[855.002, "i", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r"]
[855.004, "o", "sed -n '1,300p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[855.030355, "o", "\u001b[?2004l\r\n"]
[855.054709, "o", "import numpy as np\r\n"]
[855.079064, "o", "import pytest\r\n"]
[855.103419, "o", "\r\n"]
[855.127773, "o", "from pandas import (\r\n"]
[855.152128, "o", "    Index,\r\n"]
[855.176483, "o", "    IntervalIndex,\r\n"]
[855.200837, "o", "    Timestamp,\r\n"]
[855.225192, "o", "    interval_range,\r\n"]
[855.249547, "o", ")\r\n"]
[855.273901, "o", "import pandas._testing as tm\r\n"]
[855.298256, "o", "\r\n"]
[855.322611, "o", "\r\n"]
[855.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[855.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[855.395675, "o", "\r\n"]
[855.42003, "o", "\r\n"]
[855.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[855.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[855.493094, "o", "\r\n"]
[855.517448, "o", "\r\n"]
[855.541803, "o", "class TestIntervalIndex:\r\n"]
[855.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[855.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[855.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[855.639222, "o", "\r\n"]
[855.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[855.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[855.712286, "o", "        if sort is None:\r\n"]
[855.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[855.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[855.78535, "o", "\r\n"]
[855.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[855.834059, "o", "        if sort is None:\r\n"]
[855.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[855.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[855.907123, "o", "\r\n"]
[855.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[855.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[855.980187, "o", "\r\n"]
[856.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[856.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[856.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[856.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[856.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[856.126315, "o", "\r\n"]
[856.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[856.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[856.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[856.223734, "o", "        expected = other\r\n"]
[856.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[856.272443, "o", "\r\n"]
[856.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[856.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[856.345507, "o", "\r\n"]
[856.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[856.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[856.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[856.442926, "o", "\r\n"]
[856.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[856.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[856.51599, "o", "\r\n"]
[856.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[856.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[856.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[856.613409, "o", "\r\n"]
[856.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[856.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[856.686473, "o", "        if sort is None:\r\n"]
[856.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[856.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[856.759537, "o", "\r\n"]
[856.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[856.808246, "o", "        if sort is None:\r\n"]
[856.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[856.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[856.88131, "o", "\r\n"]
[856.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[856.93002, "o", "\r\n"]
[856.954374, "o", "        # GH 26225: nested intervals\r\n"]
[856.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[857.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[857.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[857.051793, "o", "        result = index.intersection(other)\r\n"]
[857.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[857.100502, "o", "\r\n"]
[857.124857, "o", "        # GH 26225\r\n"]
[857.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[857.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[857.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[857.222276, "o", "        result = index.intersection(other)\r\n"]
[857.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[857.270985, "o", "\r\n"]
[857.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[857.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[857.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[857.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[857.392759, "o", "        result = index.intersection(other)\r\n"]
[857.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[857.441468, "o", "\r\n"]
[857.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[857.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[857.514532, "o", "\r\n"]
[857.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[857.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[857.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[857.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[857.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[857.66066, "o", "\r\n"]
[857.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[857.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[857.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[857.758079, "o", "        expected = other[:0]\r\n"]
[857.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[857.806788, "o", "\r\n"]
[857.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[857.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[857.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[857.904207, "o", "\r\n"]
[857.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[857.952916, "o", "        # GH#38743\r\n"]
[857.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[858.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[858.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[858.050335, "o", "        result = index.intersection(other)\r\n"]
[858.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[858.099044, "o", "\r\n"]
[858.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[858.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[858.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[858.196463, "o", "        expected = index[1:]\r\n"]
[858.220818, "o", "        if sort is None:\r\n"]
[858.245172, "o", "            expected = expected.sort_values()\r\n"]
[858.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[858.293882, "o", "\r\n"]
[858.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[858.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[858.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[858.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[858.415655, "o", "\r\n"]
[858.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[858.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[858.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[858.513074, "o", "        )\r\n"]
[858.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[858.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[858.586138, "o", "\r\n"]
[858.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[858.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[858.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[858.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[858.707911, "o", "        if sort is None:\r\n"]
[858.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[858.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[858.780975, "o", "\r\n"]
[858.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[858.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[858.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[858.878394, "o", "        if sort is None:\r\n"]
[858.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[858.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[858.951458, "o", "\r\n"]
[858.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[859.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[859.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[859.048877, "o", "        )\r\n"]
[859.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[859.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[859.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[859.146296, "o", "\r\n"]
[859.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[859.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[859.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[859.243714, "o", "    )\r\n"]
[859.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[859.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[859.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[859.341133, "o", "\r\n"]
[859.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[859.389842, "o", "        # non-IntervalIndex\r\n"]
[859.414197, "o", "        if op_name == \"difference\":\r\n"]
[859.438552, "o", "            expected = index\r\n"]
[859.462906, "o", "        else:\r\n"]
[859.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[859.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[859.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[859.560325, "o", "\r\n"]
[859.58468, "o", "        # mixed closed -> cast to object\r\n"]
[859.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[859.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[859.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[859.682099, "o", "            if op_name == \"difference\":\r\n"]
[859.706453, "o", "                expected = index\r\n"]
[859.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[859.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[859.779517, "o", "\r\n"]
[859.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[859.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[859.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[859.876936, "o", "        if op_name == \"difference\":\r\n"]
[859.901291, "o", "            expected = index\r\n"]
[859.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[860.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[860.002, "i", "cd asv_bench\r"]
[860.004, "o", "cd asv_bench\r\n"]
[860.006, "o", "\u001b[?2004l\r\n"]
[865.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[865.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[865.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[870.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[870.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[870.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[870.418, "o", "\u001b[?2004l\r\n"]
[870.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[871.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[871.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[872.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[872.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[872.89, "o", "              param1            \r\n"]
[873.302, "o", "             -------- ----------\r\n"]
[873.714, "o", "               1000    1.13\u00b10ms \r\n"]
[874.126, "o", "              100000   74.3\u00b10ms \r\n"]
[874.538, "o", "             ======== ==========\r\n"]
[875.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[875.002, "i", "cd ..\r"]
[875.004, "o", "cd ..\r\n"]
[875.006, "o", "\u001b[?2004l\r\n"]
[880.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[880.002, "i", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r"]
[880.004, "o", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r\n"]
[880.5004, "o", "\u001b[?2004l\r\n"]
[880.9948, "o", "\u001b[32m\u001b[K850\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(self, other, sort):\r\n"]
[881.4892, "o", "\u001b[32m\u001b[K856\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(other)\r\n"]
[881.9836, "o", "\u001b[32m\u001b[K860\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = other.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self)\r\n"]
[882.478, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(other)\r\n"]
[882.9724, "o", "\u001b[32m\u001b[K870\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[883.4668, "o", "\u001b[32m\u001b[K882\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is much more performant than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[883.9612, "o", "\u001b[32m\u001b[K892\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[884.4556, "o", "\u001b[32m\u001b[K906\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is about 3.25x faster than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[885.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[885.002, "i", "sed -n '840,940p' pandas/core/indexes/interval.py\r"]
[885.004, "o", "sed -n '840,940p' pandas/core/indexes/interval.py\r\n"]
[885.054471, "o", "\u001b[?2004l\r\n"]
[885.102941, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[885.151412, "o", "\r\n"]
[885.199882, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[885.248353, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[885.296824, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[885.345294, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[885.393765, "o", "\r\n"]
[885.442235, "o", "    # --------------------------------------------------------------------\r\n"]
[885.490706, "o", "    # Set Operations\r\n"]
[885.539176, "o", "\r\n"]
[885.587647, "o", "    def _intersection(self, other, sort):\r\n"]
[885.636118, "o", "        \"\"\"\r\n"]
[885.684588, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[885.733059, "o", "        \"\"\"\r\n"]
[885.781529, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[885.83, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[885.878471, "o", "            taken = self._intersection_unique(other)\r\n"]
[885.926941, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[885.975412, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[886.023882, "o", "            # multiple NaNs\r\n"]
[886.072353, "o", "            taken = other._intersection_unique(self)\r\n"]
[886.120824, "o", "        else:\r\n"]
[886.169294, "o", "            # duplicates\r\n"]
[886.217765, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[886.266235, "o", "\r\n"]
[886.314706, "o", "        if sort is None:\r\n"]
[886.363176, "o", "            taken = taken.sort_values()\r\n"]
[886.411647, "o", "\r\n"]
[886.460118, "o", "        return taken\r\n"]
[886.508588, "o", "\r\n"]
[886.557059, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[886.605529, "o", "        \"\"\"\r\n"]
[886.654, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[886.702471, "o", "        no matter left or right.\r\n"]
[886.750941, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[886.799412, "o", "        Parameters\r\n"]
[886.847882, "o", "        ----------\r\n"]
[886.896353, "o", "        other : IntervalIndex\r\n"]
[886.944824, "o", "        Returns\r\n"]
[886.993294, "o", "        -------\r\n"]
[887.041765, "o", "        IntervalIndex\r\n"]
[887.090235, "o", "        \"\"\"\r\n"]
[887.138706, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[887.187176, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[887.235647, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[887.284118, "o", "\r\n"]
[887.332588, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[887.381059, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[887.429529, "o", "        indexer = unique(indexer)\r\n"]
[887.478, "o", "\r\n"]
[887.526471, "o", "        return self.take(indexer)\r\n"]
[887.574941, "o", "\r\n"]
[887.623412, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[887.671882, "o", "        \"\"\"\r\n"]
[887.720353, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[887.768824, "o", "        on either sides.\r\n"]
[887.817294, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[887.865765, "o", "\r\n"]
[887.914235, "o", "        Parameters\r\n"]
[887.962706, "o", "        ----------\r\n"]
[888.011176, "o", "        other : IntervalIndex\r\n"]
[888.059647, "o", "\r\n"]
[888.108118, "o", "        Returns\r\n"]
[888.156588, "o", "        -------\r\n"]
[888.205059, "o", "        IntervalIndex\r\n"]
[888.253529, "o", "        \"\"\"\r\n"]
[888.302, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[888.350471, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[888.398941, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[888.447412, "o", "\r\n"]
[888.495882, "o", "        if self.hasnans and other.hasnans:\r\n"]
[888.544353, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[888.592824, "o", "            mask[first_nan_loc] = True\r\n"]
[888.641294, "o", "\r\n"]
[888.689765, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[888.738235, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[888.786706, "o", "            if tup in other_tups:\r\n"]
[888.835176, "o", "                mask[i] = True\r\n"]
[888.883647, "o", "\r\n"]
[888.932118, "o", "        return self[mask]\r\n"]
[888.980588, "o", "\r\n"]
[889.029059, "o", "    # --------------------------------------------------------------------\r\n"]
[889.077529, "o", "\r\n"]
[889.126, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[889.174471, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[889.222941, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[889.271412, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[889.319882, "o", "        raise NotImplementedError(\r\n"]
[889.368353, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[889.416824, "o", "            \"IndexEngine objects\"\r\n"]
[889.465294, "o", "        )\r\n"]
[889.513765, "o", "\r\n"]
[889.562235, "o", "    def _from_join_target(self, result):\r\n"]
[889.610706, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[889.659176, "o", "\r\n"]
[889.707647, "o", "    # TODO: arithmetic operations\r\n"]
[889.756118, "o", "\r\n"]
[889.804588, "o", "\r\n"]
[889.853059, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[889.901529, "o", "    \"\"\"\r\n"]
[890.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[890.002, "i", "sed -n '940,1040p' pandas/core/indexes/interval.py\r"]
[890.004, "o", "sed -n '940,1040p' pandas/core/indexes/interval.py\r\n"]
[890.054471, "o", "\u001b[?2004l\r\n"]
[890.102941, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[890.151412, "o", "    \"\"\"\r\n"]
[890.199882, "o", "    return any(\r\n"]
[890.248353, "o", "        [\r\n"]
[890.296824, "o", "            is_number(endpoint),\r\n"]
[890.345294, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[890.393765, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[890.442235, "o", "            endpoint is None,\r\n"]
[890.490706, "o", "        ]\r\n"]
[890.539176, "o", "    )\r\n"]
[890.587647, "o", "\r\n"]
[890.636118, "o", "\r\n"]
[890.684588, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[890.733059, "o", "    \"\"\"\r\n"]
[890.781529, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[890.83, "o", "    \"\"\"\r\n"]
[890.878471, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[890.926941, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[890.975412, "o", "    return (\r\n"]
[891.023882, "o", "        (is_number(a) and is_number(b))\r\n"]
[891.072353, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[891.120824, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[891.169294, "o", "        or com.any_none(a, b)\r\n"]
[891.217765, "o", "    )\r\n"]
[891.266235, "o", "\r\n"]
[891.314706, "o", "\r\n"]
[891.363176, "o", "def interval_range(\r\n"]
[891.411647, "o", "    start=None,\r\n"]
[891.460118, "o", "    end=None,\r\n"]
[891.508588, "o", "    periods=None,\r\n"]
[891.557059, "o", "    freq=None,\r\n"]
[891.605529, "o", "    name: Hashable = None,\r\n"]
[891.654, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[891.702471, "o", ") -> IntervalIndex:\r\n"]
[891.750941, "o", "    \"\"\"\r\n"]
[891.799412, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[891.847882, "o", "\r\n"]
[891.896353, "o", "    Parameters\r\n"]
[891.944824, "o", "    ----------\r\n"]
[891.993294, "o", "    start : numeric or datetime-like, default None\r\n"]
[892.041765, "o", "        Left bound for generating intervals.\r\n"]
[892.090235, "o", "    end : numeric or datetime-like, default None\r\n"]
[892.138706, "o", "        Right bound for generating intervals.\r\n"]
[892.187176, "o", "    periods : int, default None\r\n"]
[892.235647, "o", "        Number of periods to generate.\r\n"]
[892.284118, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[892.332588, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[892.381059, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[892.429529, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[892.478, "o", "    name : str, default None\r\n"]
[892.526471, "o", "        Name of the resulting IntervalIndex.\r\n"]
[892.574941, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[892.623412, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[892.671882, "o", "        or neither.\r\n"]
[892.720353, "o", "\r\n"]
[892.768824, "o", "    Returns\r\n"]
[892.817294, "o", "    -------\r\n"]
[892.865765, "o", "    IntervalIndex\r\n"]
[892.914235, "o", "\r\n"]
[892.962706, "o", "    See Also\r\n"]
[893.011176, "o", "    --------\r\n"]
[893.059647, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[893.108118, "o", "\r\n"]
[893.156588, "o", "    Notes\r\n"]
[893.205059, "o", "    -----\r\n"]
[893.253529, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[893.302, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[893.350471, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[893.398941, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[893.447412, "o", "\r\n"]
[893.495882, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[893.544353, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[893.592824, "o", "\r\n"]
[893.641294, "o", "    Examples\r\n"]
[893.689765, "o", "    --------\r\n"]
[893.738235, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[893.786706, "o", "\r\n"]
[893.835176, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[893.883647, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[893.932118, "o", "                  dtype='interval[int64, right]')\r\n"]
[893.980588, "o", "\r\n"]
[894.029059, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[894.077529, "o", "\r\n"]
[894.126, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[894.174471, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[894.222941, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[894.271412, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[894.319882, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[894.368353, "o", "\r\n"]
[894.416824, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[894.465294, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[894.513765, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[894.562235, "o", "\r\n"]
[894.610706, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[894.659176, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[894.707647, "o", "                  dtype='interval[float64, right]')\r\n"]
[894.756118, "o", "\r\n"]
[894.804588, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[894.853059, "o", "    convertible to a DateOffset.\r\n"]
[894.901529, "o", "\r\n"]
[895.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[895.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[895.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[895.030355, "o", "\u001b[?2004l\r\n"]
[895.054709, "o", "import numpy as np\r\n"]
[895.079064, "o", "import pytest\r\n"]
[895.103419, "o", "\r\n"]
[895.127773, "o", "from pandas import (\r\n"]
[895.152128, "o", "    Index,\r\n"]
[895.176483, "o", "    IntervalIndex,\r\n"]
[895.200837, "o", "    Timestamp,\r\n"]
[895.225192, "o", "    interval_range,\r\n"]
[895.249547, "o", ")\r\n"]
[895.273901, "o", "import pandas._testing as tm\r\n"]
[895.298256, "o", "\r\n"]
[895.322611, "o", "\r\n"]
[895.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[895.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[895.395675, "o", "\r\n"]
[895.42003, "o", "\r\n"]
[895.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[895.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[895.493094, "o", "\r\n"]
[895.517448, "o", "\r\n"]
[895.541803, "o", "class TestIntervalIndex:\r\n"]
[895.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[895.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[895.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[895.639222, "o", "\r\n"]
[895.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[895.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[895.712286, "o", "        if sort is None:\r\n"]
[895.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[895.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[895.78535, "o", "\r\n"]
[895.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[895.834059, "o", "        if sort is None:\r\n"]
[895.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[895.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[895.907123, "o", "\r\n"]
[895.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[895.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[895.980187, "o", "\r\n"]
[896.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[896.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[896.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[896.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[896.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[896.126315, "o", "\r\n"]
[896.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[896.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[896.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[896.223734, "o", "        expected = other\r\n"]
[896.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[896.272443, "o", "\r\n"]
[896.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[896.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[896.345507, "o", "\r\n"]
[896.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[896.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[896.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[896.442926, "o", "\r\n"]
[896.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[896.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[896.51599, "o", "\r\n"]
[896.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[896.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[896.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[896.613409, "o", "\r\n"]
[896.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[896.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[896.686473, "o", "        if sort is None:\r\n"]
[896.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[896.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[896.759537, "o", "\r\n"]
[896.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[896.808246, "o", "        if sort is None:\r\n"]
[896.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[896.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[896.88131, "o", "\r\n"]
[896.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[896.93002, "o", "\r\n"]
[896.954374, "o", "        # GH 26225: nested intervals\r\n"]
[896.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[897.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[897.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[897.051793, "o", "        result = index.intersection(other)\r\n"]
[897.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[897.100502, "o", "\r\n"]
[897.124857, "o", "        # GH 26225\r\n"]
[897.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[897.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[897.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[897.222276, "o", "        result = index.intersection(other)\r\n"]
[897.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[897.270985, "o", "\r\n"]
[897.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[897.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[897.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[897.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[897.392759, "o", "        result = index.intersection(other)\r\n"]
[897.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[897.441468, "o", "\r\n"]
[897.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[897.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[897.514532, "o", "\r\n"]
[897.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[897.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[897.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[897.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[897.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[897.66066, "o", "\r\n"]
[897.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[897.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[897.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[897.758079, "o", "        expected = other[:0]\r\n"]
[897.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[897.806788, "o", "\r\n"]
[897.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[897.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[897.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[897.904207, "o", "\r\n"]
[897.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[897.952916, "o", "        # GH#38743\r\n"]
[897.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[898.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[898.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[898.050335, "o", "        result = index.intersection(other)\r\n"]
[898.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[898.099044, "o", "\r\n"]
[898.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[898.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[898.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[898.196463, "o", "        expected = index[1:]\r\n"]
[898.220818, "o", "        if sort is None:\r\n"]
[898.245172, "o", "            expected = expected.sort_values()\r\n"]
[898.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[898.293882, "o", "\r\n"]
[898.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[898.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[898.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[898.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[898.415655, "o", "\r\n"]
[898.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[898.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[898.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[898.513074, "o", "        )\r\n"]
[898.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[898.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[898.586138, "o", "\r\n"]
[898.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[898.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[898.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[898.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[898.707911, "o", "        if sort is None:\r\n"]
[898.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[898.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[898.780975, "o", "\r\n"]
[898.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[898.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[898.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[898.878394, "o", "        if sort is None:\r\n"]
[898.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[898.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[898.951458, "o", "\r\n"]
[898.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[899.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[899.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[899.048877, "o", "        )\r\n"]
[899.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[899.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[899.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[899.146296, "o", "\r\n"]
[899.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[899.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[899.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[899.243714, "o", "    )\r\n"]
[899.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[899.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[899.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[899.341133, "o", "\r\n"]
[899.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[899.389842, "o", "        # non-IntervalIndex\r\n"]
[899.414197, "o", "        if op_name == \"difference\":\r\n"]
[899.438552, "o", "            expected = index\r\n"]
[899.462906, "o", "        else:\r\n"]
[899.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[899.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[899.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[899.560325, "o", "\r\n"]
[899.58468, "o", "        # mixed closed -> cast to object\r\n"]
[899.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[899.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[899.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[899.682099, "o", "            if op_name == \"difference\":\r\n"]
[899.706453, "o", "                expected = index\r\n"]
[899.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[899.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[899.779517, "o", "\r\n"]
[899.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[899.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[899.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[899.876936, "o", "        if op_name == \"difference\":\r\n"]
[899.901291, "o", "            expected = index\r\n"]
[899.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[900.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[900.002, "i", "cd asv_bench\r"]
[900.004, "o", "cd asv_bench\r\n"]
[900.006, "o", "\u001b[?2004l\r\n"]
[905.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[905.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[905.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[910.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[910.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[910.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[910.418, "o", "\u001b[?2004l\r\n"]
[910.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[911.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[911.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[912.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[912.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[912.89, "o", "              param1            \r\n"]
[913.302, "o", "             -------- ----------\r\n"]
[913.714, "o", "               1000    1.15\u00b10ms \r\n"]
[914.126, "o", "              100000   78.3\u00b10ms \r\n"]
[914.538, "o", "             ======== ==========\r\n"]
[915.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[915.002, "i", "cd ..\r"]
[915.004, "o", "cd ..\r\n"]
[915.006, "o", "\u001b[?2004l\r\n"]
[920.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[920.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[920.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[922.478, "o", "\u001b[?2004l\r\n"]
[925.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[925.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[925.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[926.654, "o", "\u001b[?2004l\r\n"]
[928.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[930.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[930.002, "i", "sed -n '840,960p' pandas/core/indexes/interval.py\r"]
[930.004, "o", "sed -n '840,960p' pandas/core/indexes/interval.py\r\n"]
[930.046525, "o", "\u001b[?2004l\r\n"]
[930.087049, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[930.127574, "o", "\r\n"]
[930.168098, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[930.208623, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[930.249148, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[930.289672, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[930.330197, "o", "\r\n"]
[930.370721, "o", "    # --------------------------------------------------------------------\r\n"]
[930.411246, "o", "    # Set Operations\r\n"]
[930.45177, "o", "\r\n"]
[930.492295, "o", "    def _intersection(self, other, sort):\r\n"]
[930.53282, "o", "        \"\"\"\r\n"]
[930.573344, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[930.613869, "o", "        \"\"\"\r\n"]
[930.654393, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[930.694918, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[930.735443, "o", "            taken = self._intersection_unique(other)\r\n"]
[930.775967, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[930.816492, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[930.857016, "o", "            # multiple NaNs\r\n"]
[930.897541, "o", "            taken = other._intersection_unique(self)\r\n"]
[930.938066, "o", "        else:\r\n"]
[930.97859, "o", "            # duplicates\r\n"]
[931.019115, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[931.059639, "o", "\r\n"]
[931.100164, "o", "        if sort is None:\r\n"]
[931.140689, "o", "            taken = taken.sort_values()\r\n"]
[931.181213, "o", "\r\n"]
[931.221738, "o", "        return taken\r\n"]
[931.262262, "o", "\r\n"]
[931.302787, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[931.343311, "o", "        \"\"\"\r\n"]
[931.383836, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[931.424361, "o", "        no matter left or right.\r\n"]
[931.464885, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[931.50541, "o", "        Parameters\r\n"]
[931.545934, "o", "        ----------\r\n"]
[931.586459, "o", "        other : IntervalIndex\r\n"]
[931.626984, "o", "        Returns\r\n"]
[931.667508, "o", "        -------\r\n"]
[931.708033, "o", "        IntervalIndex\r\n"]
[931.748557, "o", "        \"\"\"\r\n"]
[931.789082, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[931.829607, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[931.870131, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[931.910656, "o", "\r\n"]
[931.95118, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[931.991705, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[932.03223, "o", "        indexer = unique(indexer)\r\n"]
[932.072754, "o", "\r\n"]
[932.113279, "o", "        return self.take(indexer)\r\n"]
[932.153803, "o", "\r\n"]
[932.194328, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[932.234852, "o", "        \"\"\"\r\n"]
[932.275377, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[932.315902, "o", "        on either sides.\r\n"]
[932.356426, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[932.396951, "o", "\r\n"]
[932.437475, "o", "        Parameters\r\n"]
[932.478, "o", "        ----------\r\n"]
[932.518525, "o", "        other : IntervalIndex\r\n"]
[932.559049, "o", "\r\n"]
[932.599574, "o", "        Returns\r\n"]
[932.640098, "o", "        -------\r\n"]
[932.680623, "o", "        IntervalIndex\r\n"]
[932.721148, "o", "        \"\"\"\r\n"]
[932.761672, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[932.802197, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[932.842721, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[932.883246, "o", "\r\n"]
[932.92377, "o", "        if self.hasnans and other.hasnans:\r\n"]
[932.964295, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[933.00482, "o", "            mask[first_nan_loc] = True\r\n"]
[933.045344, "o", "\r\n"]
[933.085869, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[933.126393, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[933.166918, "o", "            if tup in other_tups:\r\n"]
[933.207443, "o", "                mask[i] = True\r\n"]
[933.247967, "o", "\r\n"]
[933.288492, "o", "        return self[mask]\r\n"]
[933.329016, "o", "\r\n"]
[933.369541, "o", "    # --------------------------------------------------------------------\r\n"]
[933.410066, "o", "\r\n"]
[933.45059, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[933.491115, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[933.531639, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[933.572164, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[933.612689, "o", "        raise NotImplementedError(\r\n"]
[933.653213, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[933.693738, "o", "            \"IndexEngine objects\"\r\n"]
[933.734262, "o", "        )\r\n"]
[933.774787, "o", "\r\n"]
[933.815311, "o", "    def _from_join_target(self, result):\r\n"]
[933.855836, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[933.896361, "o", "\r\n"]
[933.936885, "o", "    # TODO: arithmetic operations\r\n"]
[933.97741, "o", "\r\n"]
[934.017934, "o", "\r\n"]
[934.058459, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[934.098984, "o", "    \"\"\"\r\n"]
[934.139508, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[934.180033, "o", "    \"\"\"\r\n"]
[934.220557, "o", "    return any(\r\n"]
[934.261082, "o", "        [\r\n"]
[934.301607, "o", "            is_number(endpoint),\r\n"]
[934.342131, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[934.382656, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[934.42318, "o", "            endpoint is None,\r\n"]
[934.463705, "o", "        ]\r\n"]
[934.50423, "o", "    )\r\n"]
[934.544754, "o", "\r\n"]
[934.585279, "o", "\r\n"]
[934.625803, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[934.666328, "o", "    \"\"\"\r\n"]
[934.706852, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[934.747377, "o", "    \"\"\"\r\n"]
[934.787902, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[934.828426, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[934.868951, "o", "    return (\r\n"]
[934.909475, "o", "        (is_number(a) and is_number(b))\r\n"]
[935.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[935.002, "i", "sed -n '960,1100p' pandas/core/indexes/interval.py\r"]
[935.004, "o", "sed -n '960,1100p' pandas/core/indexes/interval.py\r\n"]
[935.040817, "o", "\u001b[?2004l\r\n"]
[935.075634, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[935.110451, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[935.145268, "o", "        or com.any_none(a, b)\r\n"]
[935.180085, "o", "    )\r\n"]
[935.214901, "o", "\r\n"]
[935.249718, "o", "\r\n"]
[935.284535, "o", "def interval_range(\r\n"]
[935.319352, "o", "    start=None,\r\n"]
[935.354169, "o", "    end=None,\r\n"]
[935.388986, "o", "    periods=None,\r\n"]
[935.423803, "o", "    freq=None,\r\n"]
[935.45862, "o", "    name: Hashable = None,\r\n"]
[935.493437, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[935.528254, "o", ") -> IntervalIndex:\r\n"]
[935.56307, "o", "    \"\"\"\r\n"]
[935.597887, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[935.632704, "o", "\r\n"]
[935.667521, "o", "    Parameters\r\n"]
[935.702338, "o", "    ----------\r\n"]
[935.737155, "o", "    start : numeric or datetime-like, default None\r\n"]
[935.771972, "o", "        Left bound for generating intervals.\r\n"]
[935.806789, "o", "    end : numeric or datetime-like, default None\r\n"]
[935.841606, "o", "        Right bound for generating intervals.\r\n"]
[935.876423, "o", "    periods : int, default None\r\n"]
[935.911239, "o", "        Number of periods to generate.\r\n"]
[935.946056, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[935.980873, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[936.01569, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[936.050507, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[936.085324, "o", "    name : str, default None\r\n"]
[936.120141, "o", "        Name of the resulting IntervalIndex.\r\n"]
[936.154958, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[936.189775, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[936.224592, "o", "        or neither.\r\n"]
[936.259408, "o", "\r\n"]
[936.294225, "o", "    Returns\r\n"]
[936.329042, "o", "    -------\r\n"]
[936.363859, "o", "    IntervalIndex\r\n"]
[936.398676, "o", "\r\n"]
[936.433493, "o", "    See Also\r\n"]
[936.46831, "o", "    --------\r\n"]
[936.503127, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[936.537944, "o", "\r\n"]
[936.572761, "o", "    Notes\r\n"]
[936.607577, "o", "    -----\r\n"]
[936.642394, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[936.677211, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[936.712028, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[936.746845, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[936.781662, "o", "\r\n"]
[936.816479, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[936.851296, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[936.886113, "o", "\r\n"]
[936.92093, "o", "    Examples\r\n"]
[936.955746, "o", "    --------\r\n"]
[936.990563, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[937.02538, "o", "\r\n"]
[937.060197, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[937.095014, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[937.129831, "o", "                  dtype='interval[int64, right]')\r\n"]
[937.164648, "o", "\r\n"]
[937.199465, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[937.234282, "o", "\r\n"]
[937.269099, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[937.303915, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[937.338732, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[937.373549, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[937.408366, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[937.443183, "o", "\r\n"]
[937.478, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[937.512817, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[937.547634, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[937.582451, "o", "\r\n"]
[937.617268, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[937.652085, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[937.686901, "o", "                  dtype='interval[float64, right]')\r\n"]
[937.721718, "o", "\r\n"]
[937.756535, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[937.791352, "o", "    convertible to a DateOffset.\r\n"]
[937.826169, "o", "\r\n"]
[937.860986, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[937.895803, "o", "    ...                   periods=3, freq='MS')\r\n"]
[937.93062, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[937.965437, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[938.000254, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[938.03507, "o", "\r\n"]
[938.069887, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[938.104704, "o", "    automatically (linearly spaced).\r\n"]
[938.139521, "o", "\r\n"]
[938.174338, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[938.209155, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[938.243972, "o", "              dtype='interval[float64, right]')\r\n"]
[938.278789, "o", "\r\n"]
[938.313606, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[938.348423, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[938.383239, "o", "\r\n"]
[938.418056, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[938.452873, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[938.48769, "o", "                  dtype='interval[int64, both]')\r\n"]
[938.522507, "o", "    \"\"\"\r\n"]
[938.557324, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[938.592141, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[938.626958, "o", "    endpoint = start if start is not None else end\r\n"]
[938.661775, "o", "\r\n"]
[938.696592, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[938.731408, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[938.766225, "o", "\r\n"]
[938.801042, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[938.835859, "o", "        raise ValueError(\r\n"]
[938.870676, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[938.905493, "o", "            \"freq, exactly three must be specified\"\r\n"]
[938.94031, "o", "        )\r\n"]
[938.975127, "o", "\r\n"]
[939.009944, "o", "    if not _is_valid_endpoint(start):\r\n"]
[939.044761, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[939.079577, "o", "    if not _is_valid_endpoint(end):\r\n"]
[939.114394, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[939.149211, "o", "\r\n"]
[939.184028, "o", "    if is_float(periods):\r\n"]
[939.218845, "o", "        periods = int(periods)\r\n"]
[939.253662, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[939.288479, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[939.323296, "o", "\r\n"]
[939.358113, "o", "    if freq is not None and not is_number(freq):\r\n"]
[939.39293, "o", "        try:\r\n"]
[939.427746, "o", "            freq = to_offset(freq)\r\n"]
[939.462563, "o", "        except ValueError as err:\r\n"]
[939.49738, "o", "            raise ValueError(\r\n"]
[939.532197, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[939.567014, "o", "            ) from err\r\n"]
[939.601831, "o", "\r\n"]
[939.636648, "o", "    # verify type compatibility\r\n"]
[939.671465, "o", "    if not all(\r\n"]
[939.706282, "o", "        [\r\n"]
[939.741099, "o", "            _is_type_compatible(start, end),\r\n"]
[939.775915, "o", "            _is_type_compatible(start, freq),\r\n"]
[939.810732, "o", "            _is_type_compatible(end, freq),\r\n"]
[939.845549, "o", "        ]\r\n"]
[939.880366, "o", "    ):\r\n"]
[939.915183, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[940.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[940.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[940.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[940.030355, "o", "\u001b[?2004l\r\n"]
[940.054709, "o", "import numpy as np\r\n"]
[940.079064, "o", "import pytest\r\n"]
[940.103419, "o", "\r\n"]
[940.127773, "o", "from pandas import (\r\n"]
[940.152128, "o", "    Index,\r\n"]
[940.176483, "o", "    IntervalIndex,\r\n"]
[940.200837, "o", "    Timestamp,\r\n"]
[940.225192, "o", "    interval_range,\r\n"]
[940.249547, "o", ")\r\n"]
[940.273901, "o", "import pandas._testing as tm\r\n"]
[940.298256, "o", "\r\n"]
[940.322611, "o", "\r\n"]
[940.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[940.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[940.395675, "o", "\r\n"]
[940.42003, "o", "\r\n"]
[940.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[940.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[940.493094, "o", "\r\n"]
[940.517448, "o", "\r\n"]
[940.541803, "o", "class TestIntervalIndex:\r\n"]
[940.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[940.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[940.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[940.639222, "o", "\r\n"]
[940.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[940.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[940.712286, "o", "        if sort is None:\r\n"]
[940.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[940.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[940.78535, "o", "\r\n"]
[940.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[940.834059, "o", "        if sort is None:\r\n"]
[940.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[940.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[940.907123, "o", "\r\n"]
[940.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[940.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[940.980187, "o", "\r\n"]
[941.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[941.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[941.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[941.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[941.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[941.126315, "o", "\r\n"]
[941.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[941.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[941.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[941.223734, "o", "        expected = other\r\n"]
[941.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[941.272443, "o", "\r\n"]
[941.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[941.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[941.345507, "o", "\r\n"]
[941.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[941.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[941.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[941.442926, "o", "\r\n"]
[941.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[941.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[941.51599, "o", "\r\n"]
[941.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[941.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[941.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[941.613409, "o", "\r\n"]
[941.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[941.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[941.686473, "o", "        if sort is None:\r\n"]
[941.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[941.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[941.759537, "o", "\r\n"]
[941.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[941.808246, "o", "        if sort is None:\r\n"]
[941.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[941.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[941.88131, "o", "\r\n"]
[941.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[941.93002, "o", "\r\n"]
[941.954374, "o", "        # GH 26225: nested intervals\r\n"]
[941.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[942.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[942.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[942.051793, "o", "        result = index.intersection(other)\r\n"]
[942.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[942.100502, "o", "\r\n"]
[942.124857, "o", "        # GH 26225\r\n"]
[942.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[942.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[942.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[942.222276, "o", "        result = index.intersection(other)\r\n"]
[942.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[942.270985, "o", "\r\n"]
[942.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[942.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[942.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[942.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[942.392759, "o", "        result = index.intersection(other)\r\n"]
[942.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[942.441468, "o", "\r\n"]
[942.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[942.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[942.514532, "o", "\r\n"]
[942.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[942.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[942.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[942.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[942.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[942.66066, "o", "\r\n"]
[942.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[942.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[942.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[942.758079, "o", "        expected = other[:0]\r\n"]
[942.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[942.806788, "o", "\r\n"]
[942.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[942.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[942.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[942.904207, "o", "\r\n"]
[942.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[942.952916, "o", "        # GH#38743\r\n"]
[942.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[943.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[943.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[943.050335, "o", "        result = index.intersection(other)\r\n"]
[943.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[943.099044, "o", "\r\n"]
[943.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[943.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[943.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[943.196463, "o", "        expected = index[1:]\r\n"]
[943.220818, "o", "        if sort is None:\r\n"]
[943.245172, "o", "            expected = expected.sort_values()\r\n"]
[943.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[943.293882, "o", "\r\n"]
[943.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[943.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[943.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[943.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[943.415655, "o", "\r\n"]
[943.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[943.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[943.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[943.513074, "o", "        )\r\n"]
[943.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[943.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[943.586138, "o", "\r\n"]
[943.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[943.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[943.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[943.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[943.707911, "o", "        if sort is None:\r\n"]
[943.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[943.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[943.780975, "o", "\r\n"]
[943.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[943.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[943.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[943.878394, "o", "        if sort is None:\r\n"]
[943.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[943.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[943.951458, "o", "\r\n"]
[943.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[944.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[944.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[944.048877, "o", "        )\r\n"]
[944.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[944.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[944.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[944.146296, "o", "\r\n"]
[944.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[944.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[944.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[944.243714, "o", "    )\r\n"]
[944.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[944.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[944.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[944.341133, "o", "\r\n"]
[944.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[944.389842, "o", "        # non-IntervalIndex\r\n"]
[944.414197, "o", "        if op_name == \"difference\":\r\n"]
[944.438552, "o", "            expected = index\r\n"]
[944.462906, "o", "        else:\r\n"]
[944.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[944.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[944.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[944.560325, "o", "\r\n"]
[944.58468, "o", "        # mixed closed -> cast to object\r\n"]
[944.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[944.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[944.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[944.682099, "o", "            if op_name == \"difference\":\r\n"]
[944.706453, "o", "                expected = index\r\n"]
[944.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[944.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[944.779517, "o", "\r\n"]
[944.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[944.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[944.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[944.876936, "o", "        if op_name == \"difference\":\r\n"]
[944.901291, "o", "            expected = index\r\n"]
[944.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[945.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[945.002, "i", "cd asv_bench\r"]
[945.004, "o", "cd asv_bench\r\n"]
[945.006, "o", "\u001b[?2004l\r\n"]
[950.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[950.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[950.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[955.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[955.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[955.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[955.418, "o", "\u001b[?2004l\r\n"]
[955.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[956.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[956.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[957.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[957.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[957.89, "o", "              param1            \r\n"]
[958.302, "o", "             -------- ----------\r\n"]
[958.714, "o", "               1000    1.15\u00b10ms \r\n"]
[959.126, "o", "              100000   75.9\u00b10ms \r\n"]
[959.538, "o", "             ======== ==========\r\n"]
[960.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[960.002, "i", "cd ..\r"]
[960.004, "o", "cd ..\r\n"]
[960.006, "o", "\u001b[?2004l\r\n"]
[965.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[965.002, "i", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r"]
[965.004, "o", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r\n"]
[965.5004, "o", "\u001b[?2004l\r\n"]
[965.9948, "o", "\u001b[32m\u001b[K850\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(self, other, sort):\r\n"]
[966.4892, "o", "\u001b[32m\u001b[K856\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(other)\r\n"]
[966.9836, "o", "\u001b[32m\u001b[K860\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = other.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self)\r\n"]
[967.478, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(other)\r\n"]
[967.9724, "o", "\u001b[32m\u001b[K870\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[968.4668, "o", "\u001b[32m\u001b[K882\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is much more performant than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[968.9612, "o", "\u001b[32m\u001b[K892\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[969.4556, "o", "\u001b[32m\u001b[K906\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is about 3.25x faster than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[970.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[970.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[970.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[970.040817, "o", "\u001b[?2004l\r\n"]
[970.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[970.110451, "o", "\r\n"]
[970.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[970.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[970.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[970.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[970.284535, "o", "\r\n"]
[970.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[970.354169, "o", "    # Set Operations\r\n"]
[970.388986, "o", "\r\n"]
[970.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[970.45862, "o", "        \"\"\"\r\n"]
[970.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[970.528254, "o", "        \"\"\"\r\n"]
[970.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[970.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[970.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[970.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[970.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[970.737155, "o", "            # multiple NaNs\r\n"]
[970.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[970.806789, "o", "        else:\r\n"]
[970.841606, "o", "            # duplicates\r\n"]
[970.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[970.911239, "o", "\r\n"]
[970.946056, "o", "        if sort is None:\r\n"]
[970.980873, "o", "            taken = taken.sort_values()\r\n"]
[971.01569, "o", "\r\n"]
[971.050507, "o", "        return taken\r\n"]
[971.085324, "o", "\r\n"]
[971.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[971.154958, "o", "        \"\"\"\r\n"]
[971.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[971.224592, "o", "        no matter left or right.\r\n"]
[971.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[971.294225, "o", "        Parameters\r\n"]
[971.329042, "o", "        ----------\r\n"]
[971.363859, "o", "        other : IntervalIndex\r\n"]
[971.398676, "o", "        Returns\r\n"]
[971.433493, "o", "        -------\r\n"]
[971.46831, "o", "        IntervalIndex\r\n"]
[971.503127, "o", "        \"\"\"\r\n"]
[971.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[971.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[971.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[971.642394, "o", "\r\n"]
[971.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[971.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[971.746845, "o", "        indexer = unique(indexer)\r\n"]
[971.781662, "o", "\r\n"]
[971.816479, "o", "        return self.take(indexer)\r\n"]
[971.851296, "o", "\r\n"]
[971.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[971.92093, "o", "        \"\"\"\r\n"]
[971.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[971.990563, "o", "        on either sides.\r\n"]
[972.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[972.060197, "o", "\r\n"]
[972.095014, "o", "        Parameters\r\n"]
[972.129831, "o", "        ----------\r\n"]
[972.164648, "o", "        other : IntervalIndex\r\n"]
[972.199465, "o", "\r\n"]
[972.234282, "o", "        Returns\r\n"]
[972.269099, "o", "        -------\r\n"]
[972.303915, "o", "        IntervalIndex\r\n"]
[972.338732, "o", "        \"\"\"\r\n"]
[972.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[972.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[972.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[972.478, "o", "\r\n"]
[972.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[972.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[972.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[972.617268, "o", "\r\n"]
[972.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[972.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[972.721718, "o", "            if tup in other_tups:\r\n"]
[972.756535, "o", "                mask[i] = True\r\n"]
[972.791352, "o", "\r\n"]
[972.826169, "o", "        return self[mask]\r\n"]
[972.860986, "o", "\r\n"]
[972.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[972.93062, "o", "\r\n"]
[972.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[973.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[973.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[973.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[973.104704, "o", "        raise NotImplementedError(\r\n"]
[973.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[973.174338, "o", "            \"IndexEngine objects\"\r\n"]
[973.209155, "o", "        )\r\n"]
[973.243972, "o", "\r\n"]
[973.278789, "o", "    def _from_join_target(self, result):\r\n"]
[973.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[973.348423, "o", "\r\n"]
[973.383239, "o", "    # TODO: arithmetic operations\r\n"]
[973.418056, "o", "\r\n"]
[973.452873, "o", "\r\n"]
[973.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[973.522507, "o", "    \"\"\"\r\n"]
[973.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[973.592141, "o", "    \"\"\"\r\n"]
[973.626958, "o", "    return any(\r\n"]
[973.661775, "o", "        [\r\n"]
[973.696592, "o", "            is_number(endpoint),\r\n"]
[973.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[973.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[973.801042, "o", "            endpoint is None,\r\n"]
[973.835859, "o", "        ]\r\n"]
[973.870676, "o", "    )\r\n"]
[973.905493, "o", "\r\n"]
[973.94031, "o", "\r\n"]
[973.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[974.009944, "o", "    \"\"\"\r\n"]
[974.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[974.079577, "o", "    \"\"\"\r\n"]
[974.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[974.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[974.184028, "o", "    return (\r\n"]
[974.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[974.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[974.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[974.323296, "o", "        or com.any_none(a, b)\r\n"]
[974.358113, "o", "    )\r\n"]
[974.39293, "o", "\r\n"]
[974.427746, "o", "\r\n"]
[974.462563, "o", "def interval_range(\r\n"]
[974.49738, "o", "    start=None,\r\n"]
[974.532197, "o", "    end=None,\r\n"]
[974.567014, "o", "    periods=None,\r\n"]
[974.601831, "o", "    freq=None,\r\n"]
[974.636648, "o", "    name: Hashable = None,\r\n"]
[974.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[974.706282, "o", ") -> IntervalIndex:\r\n"]
[974.741099, "o", "    \"\"\"\r\n"]
[974.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[974.810732, "o", "\r\n"]
[974.845549, "o", "    Parameters\r\n"]
[974.880366, "o", "    ----------\r\n"]
[974.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[975.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[975.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[975.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[975.040817, "o", "\u001b[?2004l\r\n"]
[975.075634, "o", "        Left bound for generating intervals.\r\n"]
[975.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[975.145268, "o", "        Right bound for generating intervals.\r\n"]
[975.180085, "o", "    periods : int, default None\r\n"]
[975.214901, "o", "        Number of periods to generate.\r\n"]
[975.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[975.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[975.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[975.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[975.388986, "o", "    name : str, default None\r\n"]
[975.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[975.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[975.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[975.528254, "o", "        or neither.\r\n"]
[975.56307, "o", "\r\n"]
[975.597887, "o", "    Returns\r\n"]
[975.632704, "o", "    -------\r\n"]
[975.667521, "o", "    IntervalIndex\r\n"]
[975.702338, "o", "\r\n"]
[975.737155, "o", "    See Also\r\n"]
[975.771972, "o", "    --------\r\n"]
[975.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[975.841606, "o", "\r\n"]
[975.876423, "o", "    Notes\r\n"]
[975.911239, "o", "    -----\r\n"]
[975.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[975.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[976.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[976.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[976.085324, "o", "\r\n"]
[976.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[976.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[976.189775, "o", "\r\n"]
[976.224592, "o", "    Examples\r\n"]
[976.259408, "o", "    --------\r\n"]
[976.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[976.329042, "o", "\r\n"]
[976.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[976.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[976.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[976.46831, "o", "\r\n"]
[976.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[976.537944, "o", "\r\n"]
[976.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[976.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[976.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[976.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[976.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[976.746845, "o", "\r\n"]
[976.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[976.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[976.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[976.886113, "o", "\r\n"]
[976.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[976.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[976.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[977.02538, "o", "\r\n"]
[977.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[977.095014, "o", "    convertible to a DateOffset.\r\n"]
[977.129831, "o", "\r\n"]
[977.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[977.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[977.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[977.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[977.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[977.338732, "o", "\r\n"]
[977.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[977.408366, "o", "    automatically (linearly spaced).\r\n"]
[977.443183, "o", "\r\n"]
[977.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[977.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[977.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[977.582451, "o", "\r\n"]
[977.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[977.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[977.686901, "o", "\r\n"]
[977.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[977.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[977.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[977.826169, "o", "    \"\"\"\r\n"]
[977.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[977.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[977.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[977.965437, "o", "\r\n"]
[978.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[978.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[978.069887, "o", "\r\n"]
[978.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[978.139521, "o", "        raise ValueError(\r\n"]
[978.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[978.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[978.243972, "o", "        )\r\n"]
[978.278789, "o", "\r\n"]
[978.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[978.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[978.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[978.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[978.452873, "o", "\r\n"]
[978.48769, "o", "    if is_float(periods):\r\n"]
[978.522507, "o", "        periods = int(periods)\r\n"]
[978.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[978.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[978.626958, "o", "\r\n"]
[978.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[978.696592, "o", "        try:\r\n"]
[978.731408, "o", "            freq = to_offset(freq)\r\n"]
[978.766225, "o", "        except ValueError as err:\r\n"]
[978.801042, "o", "            raise ValueError(\r\n"]
[978.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[978.870676, "o", "            ) from err\r\n"]
[978.905493, "o", "\r\n"]
[978.94031, "o", "    # verify type compatibility\r\n"]
[978.975127, "o", "    if not all(\r\n"]
[979.009944, "o", "        [\r\n"]
[979.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[979.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[979.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[979.149211, "o", "        ]\r\n"]
[979.184028, "o", "    ):\r\n"]
[979.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[979.253662, "o", "\r\n"]
[979.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[979.323296, "o", "    if periods is not None:\r\n"]
[979.358113, "o", "        periods += 1\r\n"]
[979.39293, "o", "\r\n"]
[979.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[979.462563, "o", "\r\n"]
[979.49738, "o", "    if is_number(endpoint):\r\n"]
[979.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[979.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[979.601831, "o", "            end -= (end - start) % freq\r\n"]
[979.636648, "o", "\r\n"]
[979.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[979.706282, "o", "        if periods is None:\r\n"]
[979.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[979.775915, "o", "        elif start is None:\r\n"]
[979.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[979.845549, "o", "        elif end is None:\r\n"]
[979.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[979.915183, "o", "\r\n"]
[980.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[980.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[980.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[980.030355, "o", "\u001b[?2004l\r\n"]
[980.054709, "o", "import numpy as np\r\n"]
[980.079064, "o", "import pytest\r\n"]
[980.103419, "o", "\r\n"]
[980.127773, "o", "from pandas import (\r\n"]
[980.152128, "o", "    Index,\r\n"]
[980.176483, "o", "    IntervalIndex,\r\n"]
[980.200837, "o", "    Timestamp,\r\n"]
[980.225192, "o", "    interval_range,\r\n"]
[980.249547, "o", ")\r\n"]
[980.273901, "o", "import pandas._testing as tm\r\n"]
[980.298256, "o", "\r\n"]
[980.322611, "o", "\r\n"]
[980.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[980.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[980.395675, "o", "\r\n"]
[980.42003, "o", "\r\n"]
[980.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[980.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[980.493094, "o", "\r\n"]
[980.517448, "o", "\r\n"]
[980.541803, "o", "class TestIntervalIndex:\r\n"]
[980.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[980.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[980.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[980.639222, "o", "\r\n"]
[980.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[980.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[980.712286, "o", "        if sort is None:\r\n"]
[980.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[980.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[980.78535, "o", "\r\n"]
[980.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[980.834059, "o", "        if sort is None:\r\n"]
[980.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[980.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[980.907123, "o", "\r\n"]
[980.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[980.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[980.980187, "o", "\r\n"]
[981.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[981.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[981.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[981.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[981.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[981.126315, "o", "\r\n"]
[981.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[981.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[981.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[981.223734, "o", "        expected = other\r\n"]
[981.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[981.272443, "o", "\r\n"]
[981.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[981.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[981.345507, "o", "\r\n"]
[981.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[981.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[981.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[981.442926, "o", "\r\n"]
[981.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[981.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[981.51599, "o", "\r\n"]
[981.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[981.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[981.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[981.613409, "o", "\r\n"]
[981.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[981.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[981.686473, "o", "        if sort is None:\r\n"]
[981.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[981.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[981.759537, "o", "\r\n"]
[981.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[981.808246, "o", "        if sort is None:\r\n"]
[981.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[981.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[981.88131, "o", "\r\n"]
[981.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[981.93002, "o", "\r\n"]
[981.954374, "o", "        # GH 26225: nested intervals\r\n"]
[981.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[982.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[982.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[982.051793, "o", "        result = index.intersection(other)\r\n"]
[982.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[982.100502, "o", "\r\n"]
[982.124857, "o", "        # GH 26225\r\n"]
[982.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[982.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[982.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[982.222276, "o", "        result = index.intersection(other)\r\n"]
[982.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[982.270985, "o", "\r\n"]
[982.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[982.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[982.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[982.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[982.392759, "o", "        result = index.intersection(other)\r\n"]
[982.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[982.441468, "o", "\r\n"]
[982.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[982.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[982.514532, "o", "\r\n"]
[982.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[982.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[982.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[982.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[982.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[982.66066, "o", "\r\n"]
[982.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[982.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[982.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[982.758079, "o", "        expected = other[:0]\r\n"]
[982.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[982.806788, "o", "\r\n"]
[982.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[982.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[982.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[982.904207, "o", "\r\n"]
[982.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[982.952916, "o", "        # GH#38743\r\n"]
[982.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[983.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[983.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[983.050335, "o", "        result = index.intersection(other)\r\n"]
[983.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[983.099044, "o", "\r\n"]
[983.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[983.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[983.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[983.196463, "o", "        expected = index[1:]\r\n"]
[983.220818, "o", "        if sort is None:\r\n"]
[983.245172, "o", "            expected = expected.sort_values()\r\n"]
[983.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[983.293882, "o", "\r\n"]
[983.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[983.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[983.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[983.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[983.415655, "o", "\r\n"]
[983.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[983.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[983.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[983.513074, "o", "        )\r\n"]
[983.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[983.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[983.586138, "o", "\r\n"]
[983.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[983.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[983.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[983.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[983.707911, "o", "        if sort is None:\r\n"]
[983.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[983.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[983.780975, "o", "\r\n"]
[983.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[983.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[983.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[983.878394, "o", "        if sort is None:\r\n"]
[983.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[983.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[983.951458, "o", "\r\n"]
[983.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[984.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[984.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[984.048877, "o", "        )\r\n"]
[984.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[984.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[984.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[984.146296, "o", "\r\n"]
[984.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[984.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[984.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[984.243714, "o", "    )\r\n"]
[984.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[984.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[984.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[984.341133, "o", "\r\n"]
[984.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[984.389842, "o", "        # non-IntervalIndex\r\n"]
[984.414197, "o", "        if op_name == \"difference\":\r\n"]
[984.438552, "o", "            expected = index\r\n"]
[984.462906, "o", "        else:\r\n"]
[984.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[984.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[984.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[984.560325, "o", "\r\n"]
[984.58468, "o", "        # mixed closed -> cast to object\r\n"]
[984.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[984.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[984.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[984.682099, "o", "            if op_name == \"difference\":\r\n"]
[984.706453, "o", "                expected = index\r\n"]
[984.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[984.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[984.779517, "o", "\r\n"]
[984.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[984.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[984.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[984.876936, "o", "        if op_name == \"difference\":\r\n"]
[984.901291, "o", "            expected = index\r\n"]
[984.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[985.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[985.002, "i", "cd asv_bench\r"]
[985.004, "o", "cd asv_bench\r\n"]
[985.006, "o", "\u001b[?2004l\r\n"]
[990.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[990.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[990.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[995.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[995.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[995.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[995.418, "o", "\u001b[?2004l\r\n"]
[995.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[996.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[996.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[997.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[997.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[997.89, "o", "              param1            \r\n"]
[998.302, "o", "             -------- ----------\r\n"]
[998.714, "o", "               1000    1.19\u00b10ms \r\n"]
[999.126, "o", "              100000   76.1\u00b10ms \r\n"]
[999.538, "o", "             ======== ==========\r\n"]
[1000.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1000.002, "i", "cd ..\r"]
[1000.004, "o", "cd ..\r\n"]
[1000.006, "o", "\u001b[?2004l\r\n"]
[1005.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1005.002, "i", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r"]
[1005.004, "o", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r\n"]
[1005.5004, "o", "\u001b[?2004l\r\n"]
[1005.9948, "o", "\u001b[32m\u001b[K850\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(self, other, sort):\r\n"]
[1006.4892, "o", "\u001b[32m\u001b[K856\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(other)\r\n"]
[1006.9836, "o", "\u001b[32m\u001b[K860\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = other.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self)\r\n"]
[1007.478, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(other)\r\n"]
[1007.9724, "o", "\u001b[32m\u001b[K870\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1008.4668, "o", "\u001b[32m\u001b[K882\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is much more performant than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[1008.9612, "o", "\u001b[32m\u001b[K892\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1009.4556, "o", "\u001b[32m\u001b[K906\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is about 3.25x faster than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[1010.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1010.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1010.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1010.040817, "o", "\u001b[?2004l\r\n"]
[1010.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1010.110451, "o", "\r\n"]
[1010.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1010.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1010.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1010.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1010.284535, "o", "\r\n"]
[1010.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1010.354169, "o", "    # Set Operations\r\n"]
[1010.388986, "o", "\r\n"]
[1010.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1010.45862, "o", "        \"\"\"\r\n"]
[1010.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1010.528254, "o", "        \"\"\"\r\n"]
[1010.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1010.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1010.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1010.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1010.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1010.737155, "o", "            # multiple NaNs\r\n"]
[1010.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1010.806789, "o", "        else:\r\n"]
[1010.841606, "o", "            # duplicates\r\n"]
[1010.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1010.911239, "o", "\r\n"]
[1010.946056, "o", "        if sort is None:\r\n"]
[1010.980873, "o", "            taken = taken.sort_values()\r\n"]
[1011.01569, "o", "\r\n"]
[1011.050507, "o", "        return taken\r\n"]
[1011.085324, "o", "\r\n"]
[1011.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1011.154958, "o", "        \"\"\"\r\n"]
[1011.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1011.224592, "o", "        no matter left or right.\r\n"]
[1011.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1011.294225, "o", "        Parameters\r\n"]
[1011.329042, "o", "        ----------\r\n"]
[1011.363859, "o", "        other : IntervalIndex\r\n"]
[1011.398676, "o", "        Returns\r\n"]
[1011.433493, "o", "        -------\r\n"]
[1011.46831, "o", "        IntervalIndex\r\n"]
[1011.503127, "o", "        \"\"\"\r\n"]
[1011.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1011.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1011.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1011.642394, "o", "\r\n"]
[1011.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1011.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1011.746845, "o", "        indexer = unique(indexer)\r\n"]
[1011.781662, "o", "\r\n"]
[1011.816479, "o", "        return self.take(indexer)\r\n"]
[1011.851296, "o", "\r\n"]
[1011.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1011.92093, "o", "        \"\"\"\r\n"]
[1011.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1011.990563, "o", "        on either sides.\r\n"]
[1012.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1012.060197, "o", "\r\n"]
[1012.095014, "o", "        Parameters\r\n"]
[1012.129831, "o", "        ----------\r\n"]
[1012.164648, "o", "        other : IntervalIndex\r\n"]
[1012.199465, "o", "\r\n"]
[1012.234282, "o", "        Returns\r\n"]
[1012.269099, "o", "        -------\r\n"]
[1012.303915, "o", "        IntervalIndex\r\n"]
[1012.338732, "o", "        \"\"\"\r\n"]
[1012.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1012.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1012.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1012.478, "o", "\r\n"]
[1012.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1012.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1012.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1012.617268, "o", "\r\n"]
[1012.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1012.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1012.721718, "o", "            if tup in other_tups:\r\n"]
[1012.756535, "o", "                mask[i] = True\r\n"]
[1012.791352, "o", "\r\n"]
[1012.826169, "o", "        return self[mask]\r\n"]
[1012.860986, "o", "\r\n"]
[1012.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1012.93062, "o", "\r\n"]
[1012.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1013.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1013.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1013.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1013.104704, "o", "        raise NotImplementedError(\r\n"]
[1013.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1013.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1013.209155, "o", "        )\r\n"]
[1013.243972, "o", "\r\n"]
[1013.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1013.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1013.348423, "o", "\r\n"]
[1013.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1013.418056, "o", "\r\n"]
[1013.452873, "o", "\r\n"]
[1013.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1013.522507, "o", "    \"\"\"\r\n"]
[1013.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1013.592141, "o", "    \"\"\"\r\n"]
[1013.626958, "o", "    return any(\r\n"]
[1013.661775, "o", "        [\r\n"]
[1013.696592, "o", "            is_number(endpoint),\r\n"]
[1013.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1013.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1013.801042, "o", "            endpoint is None,\r\n"]
[1013.835859, "o", "        ]\r\n"]
[1013.870676, "o", "    )\r\n"]
[1013.905493, "o", "\r\n"]
[1013.94031, "o", "\r\n"]
[1013.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1014.009944, "o", "    \"\"\"\r\n"]
[1014.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1014.079577, "o", "    \"\"\"\r\n"]
[1014.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1014.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1014.184028, "o", "    return (\r\n"]
[1014.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1014.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1014.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1014.323296, "o", "        or com.any_none(a, b)\r\n"]
[1014.358113, "o", "    )\r\n"]
[1014.39293, "o", "\r\n"]
[1014.427746, "o", "\r\n"]
[1014.462563, "o", "def interval_range(\r\n"]
[1014.49738, "o", "    start=None,\r\n"]
[1014.532197, "o", "    end=None,\r\n"]
[1014.567014, "o", "    periods=None,\r\n"]
[1014.601831, "o", "    freq=None,\r\n"]
[1014.636648, "o", "    name: Hashable = None,\r\n"]
[1014.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1014.706282, "o", ") -> IntervalIndex:\r\n"]
[1014.741099, "o", "    \"\"\"\r\n"]
[1014.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1014.810732, "o", "\r\n"]
[1014.845549, "o", "    Parameters\r\n"]
[1014.880366, "o", "    ----------\r\n"]
[1014.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1015.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1015.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1015.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1015.040817, "o", "\u001b[?2004l\r\n"]
[1015.075634, "o", "        Left bound for generating intervals.\r\n"]
[1015.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1015.145268, "o", "        Right bound for generating intervals.\r\n"]
[1015.180085, "o", "    periods : int, default None\r\n"]
[1015.214901, "o", "        Number of periods to generate.\r\n"]
[1015.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1015.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1015.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1015.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1015.388986, "o", "    name : str, default None\r\n"]
[1015.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1015.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1015.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1015.528254, "o", "        or neither.\r\n"]
[1015.56307, "o", "\r\n"]
[1015.597887, "o", "    Returns\r\n"]
[1015.632704, "o", "    -------\r\n"]
[1015.667521, "o", "    IntervalIndex\r\n"]
[1015.702338, "o", "\r\n"]
[1015.737155, "o", "    See Also\r\n"]
[1015.771972, "o", "    --------\r\n"]
[1015.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1015.841606, "o", "\r\n"]
[1015.876423, "o", "    Notes\r\n"]
[1015.911239, "o", "    -----\r\n"]
[1015.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1015.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1016.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1016.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1016.085324, "o", "\r\n"]
[1016.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1016.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1016.189775, "o", "\r\n"]
[1016.224592, "o", "    Examples\r\n"]
[1016.259408, "o", "    --------\r\n"]
[1016.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1016.329042, "o", "\r\n"]
[1016.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1016.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1016.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1016.46831, "o", "\r\n"]
[1016.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1016.537944, "o", "\r\n"]
[1016.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1016.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1016.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1016.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1016.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1016.746845, "o", "\r\n"]
[1016.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1016.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1016.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1016.886113, "o", "\r\n"]
[1016.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1016.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1016.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1017.02538, "o", "\r\n"]
[1017.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1017.095014, "o", "    convertible to a DateOffset.\r\n"]
[1017.129831, "o", "\r\n"]
[1017.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1017.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1017.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1017.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1017.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1017.338732, "o", "\r\n"]
[1017.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1017.408366, "o", "    automatically (linearly spaced).\r\n"]
[1017.443183, "o", "\r\n"]
[1017.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1017.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1017.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1017.582451, "o", "\r\n"]
[1017.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1017.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1017.686901, "o", "\r\n"]
[1017.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1017.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1017.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1017.826169, "o", "    \"\"\"\r\n"]
[1017.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1017.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1017.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1017.965437, "o", "\r\n"]
[1018.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1018.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1018.069887, "o", "\r\n"]
[1018.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1018.139521, "o", "        raise ValueError(\r\n"]
[1018.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1018.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1018.243972, "o", "        )\r\n"]
[1018.278789, "o", "\r\n"]
[1018.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1018.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1018.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1018.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1018.452873, "o", "\r\n"]
[1018.48769, "o", "    if is_float(periods):\r\n"]
[1018.522507, "o", "        periods = int(periods)\r\n"]
[1018.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1018.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1018.626958, "o", "\r\n"]
[1018.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1018.696592, "o", "        try:\r\n"]
[1018.731408, "o", "            freq = to_offset(freq)\r\n"]
[1018.766225, "o", "        except ValueError as err:\r\n"]
[1018.801042, "o", "            raise ValueError(\r\n"]
[1018.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1018.870676, "o", "            ) from err\r\n"]
[1018.905493, "o", "\r\n"]
[1018.94031, "o", "    # verify type compatibility\r\n"]
[1018.975127, "o", "    if not all(\r\n"]
[1019.009944, "o", "        [\r\n"]
[1019.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1019.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1019.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1019.149211, "o", "        ]\r\n"]
[1019.184028, "o", "    ):\r\n"]
[1019.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1019.253662, "o", "\r\n"]
[1019.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1019.323296, "o", "    if periods is not None:\r\n"]
[1019.358113, "o", "        periods += 1\r\n"]
[1019.39293, "o", "\r\n"]
[1019.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1019.462563, "o", "\r\n"]
[1019.49738, "o", "    if is_number(endpoint):\r\n"]
[1019.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1019.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1019.601831, "o", "            end -= (end - start) % freq\r\n"]
[1019.636648, "o", "\r\n"]
[1019.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1019.706282, "o", "        if periods is None:\r\n"]
[1019.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1019.775915, "o", "        elif start is None:\r\n"]
[1019.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1019.845549, "o", "        elif end is None:\r\n"]
[1019.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1019.915183, "o", "\r\n"]
[1020.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1020.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1020.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1020.030355, "o", "\u001b[?2004l\r\n"]
[1020.054709, "o", "import numpy as np\r\n"]
[1020.079064, "o", "import pytest\r\n"]
[1020.103419, "o", "\r\n"]
[1020.127773, "o", "from pandas import (\r\n"]
[1020.152128, "o", "    Index,\r\n"]
[1020.176483, "o", "    IntervalIndex,\r\n"]
[1020.200837, "o", "    Timestamp,\r\n"]
[1020.225192, "o", "    interval_range,\r\n"]
[1020.249547, "o", ")\r\n"]
[1020.273901, "o", "import pandas._testing as tm\r\n"]
[1020.298256, "o", "\r\n"]
[1020.322611, "o", "\r\n"]
[1020.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1020.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1020.395675, "o", "\r\n"]
[1020.42003, "o", "\r\n"]
[1020.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1020.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1020.493094, "o", "\r\n"]
[1020.517448, "o", "\r\n"]
[1020.541803, "o", "class TestIntervalIndex:\r\n"]
[1020.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1020.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1020.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1020.639222, "o", "\r\n"]
[1020.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1020.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1020.712286, "o", "        if sort is None:\r\n"]
[1020.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1020.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1020.78535, "o", "\r\n"]
[1020.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1020.834059, "o", "        if sort is None:\r\n"]
[1020.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1020.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1020.907123, "o", "\r\n"]
[1020.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1020.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1020.980187, "o", "\r\n"]
[1021.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1021.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1021.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1021.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1021.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1021.126315, "o", "\r\n"]
[1021.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1021.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1021.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1021.223734, "o", "        expected = other\r\n"]
[1021.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1021.272443, "o", "\r\n"]
[1021.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1021.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1021.345507, "o", "\r\n"]
[1021.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1021.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1021.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1021.442926, "o", "\r\n"]
[1021.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1021.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1021.51599, "o", "\r\n"]
[1021.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1021.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1021.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1021.613409, "o", "\r\n"]
[1021.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1021.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1021.686473, "o", "        if sort is None:\r\n"]
[1021.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1021.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1021.759537, "o", "\r\n"]
[1021.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1021.808246, "o", "        if sort is None:\r\n"]
[1021.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1021.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1021.88131, "o", "\r\n"]
[1021.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1021.93002, "o", "\r\n"]
[1021.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1021.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1022.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1022.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1022.051793, "o", "        result = index.intersection(other)\r\n"]
[1022.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1022.100502, "o", "\r\n"]
[1022.124857, "o", "        # GH 26225\r\n"]
[1022.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1022.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1022.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1022.222276, "o", "        result = index.intersection(other)\r\n"]
[1022.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1022.270985, "o", "\r\n"]
[1022.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1022.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1022.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1022.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1022.392759, "o", "        result = index.intersection(other)\r\n"]
[1022.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1022.441468, "o", "\r\n"]
[1022.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1022.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1022.514532, "o", "\r\n"]
[1022.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1022.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1022.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1022.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1022.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1022.66066, "o", "\r\n"]
[1022.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1022.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1022.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1022.758079, "o", "        expected = other[:0]\r\n"]
[1022.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1022.806788, "o", "\r\n"]
[1022.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1022.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1022.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1022.904207, "o", "\r\n"]
[1022.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1022.952916, "o", "        # GH#38743\r\n"]
[1022.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1023.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1023.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1023.050335, "o", "        result = index.intersection(other)\r\n"]
[1023.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1023.099044, "o", "\r\n"]
[1023.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1023.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1023.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1023.196463, "o", "        expected = index[1:]\r\n"]
[1023.220818, "o", "        if sort is None:\r\n"]
[1023.245172, "o", "            expected = expected.sort_values()\r\n"]
[1023.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1023.293882, "o", "\r\n"]
[1023.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1023.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1023.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1023.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1023.415655, "o", "\r\n"]
[1023.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1023.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1023.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1023.513074, "o", "        )\r\n"]
[1023.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1023.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1023.586138, "o", "\r\n"]
[1023.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1023.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1023.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1023.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1023.707911, "o", "        if sort is None:\r\n"]
[1023.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1023.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1023.780975, "o", "\r\n"]
[1023.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1023.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1023.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1023.878394, "o", "        if sort is None:\r\n"]
[1023.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1023.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1023.951458, "o", "\r\n"]
[1023.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1024.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1024.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1024.048877, "o", "        )\r\n"]
[1024.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1024.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1024.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1024.146296, "o", "\r\n"]
[1024.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1024.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1024.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1024.243714, "o", "    )\r\n"]
[1024.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1024.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1024.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1024.341133, "o", "\r\n"]
[1024.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1024.389842, "o", "        # non-IntervalIndex\r\n"]
[1024.414197, "o", "        if op_name == \"difference\":\r\n"]
[1024.438552, "o", "            expected = index\r\n"]
[1024.462906, "o", "        else:\r\n"]
[1024.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1024.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1024.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1024.560325, "o", "\r\n"]
[1024.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1024.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1024.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1024.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1024.682099, "o", "            if op_name == \"difference\":\r\n"]
[1024.706453, "o", "                expected = index\r\n"]
[1024.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1024.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1024.779517, "o", "\r\n"]
[1024.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1024.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1024.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1024.876936, "o", "        if op_name == \"difference\":\r\n"]
[1024.901291, "o", "            expected = index\r\n"]
[1024.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1025.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1025.002, "i", "cd asv_bench\r"]
[1025.004, "o", "cd asv_bench\r\n"]
[1025.006, "o", "\u001b[?2004l\r\n"]
[1030.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1030.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1030.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1035.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1035.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1035.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1035.418, "o", "\u001b[?2004l\r\n"]
[1035.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1036.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1036.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1037.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1037.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1037.89, "o", "              param1            \r\n"]
[1038.302, "o", "             -------- ----------\r\n"]
[1038.714, "o", "               1000    1.17\u00b10ms \r\n"]
[1039.126, "o", "              100000   73.1\u00b10ms \r\n"]
[1039.538, "o", "             ======== ==========\r\n"]
[1040.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1040.002, "i", "cd ..\r"]
[1040.004, "o", "cd ..\r\n"]
[1040.006, "o", "\u001b[?2004l\r\n"]
[1045.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1045.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1045.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1047.478, "o", "\u001b[?2004l\r\n"]
[1050.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1050.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[1050.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[1051.654, "o", "\u001b[?2004l\r\n"]
[1053.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[1055.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1055.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1055.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1055.040817, "o", "\u001b[?2004l\r\n"]
[1055.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1055.110451, "o", "\r\n"]
[1055.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1055.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1055.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1055.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1055.284535, "o", "\r\n"]
[1055.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1055.354169, "o", "    # Set Operations\r\n"]
[1055.388986, "o", "\r\n"]
[1055.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1055.45862, "o", "        \"\"\"\r\n"]
[1055.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1055.528254, "o", "        \"\"\"\r\n"]
[1055.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1055.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1055.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1055.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1055.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1055.737155, "o", "            # multiple NaNs\r\n"]
[1055.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1055.806789, "o", "        else:\r\n"]
[1055.841606, "o", "            # duplicates\r\n"]
[1055.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1055.911239, "o", "\r\n"]
[1055.946056, "o", "        if sort is None:\r\n"]
[1055.980873, "o", "            taken = taken.sort_values()\r\n"]
[1056.01569, "o", "\r\n"]
[1056.050507, "o", "        return taken\r\n"]
[1056.085324, "o", "\r\n"]
[1056.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1056.154958, "o", "        \"\"\"\r\n"]
[1056.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1056.224592, "o", "        no matter left or right.\r\n"]
[1056.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1056.294225, "o", "        Parameters\r\n"]
[1056.329042, "o", "        ----------\r\n"]
[1056.363859, "o", "        other : IntervalIndex\r\n"]
[1056.398676, "o", "        Returns\r\n"]
[1056.433493, "o", "        -------\r\n"]
[1056.46831, "o", "        IntervalIndex\r\n"]
[1056.503127, "o", "        \"\"\"\r\n"]
[1056.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1056.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1056.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1056.642394, "o", "\r\n"]
[1056.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1056.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1056.746845, "o", "        indexer = unique(indexer)\r\n"]
[1056.781662, "o", "\r\n"]
[1056.816479, "o", "        return self.take(indexer)\r\n"]
[1056.851296, "o", "\r\n"]
[1056.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1056.92093, "o", "        \"\"\"\r\n"]
[1056.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1056.990563, "o", "        on either sides.\r\n"]
[1057.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1057.060197, "o", "\r\n"]
[1057.095014, "o", "        Parameters\r\n"]
[1057.129831, "o", "        ----------\r\n"]
[1057.164648, "o", "        other : IntervalIndex\r\n"]
[1057.199465, "o", "\r\n"]
[1057.234282, "o", "        Returns\r\n"]
[1057.269099, "o", "        -------\r\n"]
[1057.303915, "o", "        IntervalIndex\r\n"]
[1057.338732, "o", "        \"\"\"\r\n"]
[1057.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1057.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1057.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1057.478, "o", "\r\n"]
[1057.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1057.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1057.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1057.617268, "o", "\r\n"]
[1057.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1057.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1057.721718, "o", "            if tup in other_tups:\r\n"]
[1057.756535, "o", "                mask[i] = True\r\n"]
[1057.791352, "o", "\r\n"]
[1057.826169, "o", "        return self[mask]\r\n"]
[1057.860986, "o", "\r\n"]
[1057.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1057.93062, "o", "\r\n"]
[1057.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1058.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1058.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1058.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1058.104704, "o", "        raise NotImplementedError(\r\n"]
[1058.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1058.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1058.209155, "o", "        )\r\n"]
[1058.243972, "o", "\r\n"]
[1058.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1058.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1058.348423, "o", "\r\n"]
[1058.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1058.418056, "o", "\r\n"]
[1058.452873, "o", "\r\n"]
[1058.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1058.522507, "o", "    \"\"\"\r\n"]
[1058.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1058.592141, "o", "    \"\"\"\r\n"]
[1058.626958, "o", "    return any(\r\n"]
[1058.661775, "o", "        [\r\n"]
[1058.696592, "o", "            is_number(endpoint),\r\n"]
[1058.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1058.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1058.801042, "o", "            endpoint is None,\r\n"]
[1058.835859, "o", "        ]\r\n"]
[1058.870676, "o", "    )\r\n"]
[1058.905493, "o", "\r\n"]
[1058.94031, "o", "\r\n"]
[1058.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1059.009944, "o", "    \"\"\"\r\n"]
[1059.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1059.079577, "o", "    \"\"\"\r\n"]
[1059.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1059.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1059.184028, "o", "    return (\r\n"]
[1059.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1059.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1059.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1059.323296, "o", "        or com.any_none(a, b)\r\n"]
[1059.358113, "o", "    )\r\n"]
[1059.39293, "o", "\r\n"]
[1059.427746, "o", "\r\n"]
[1059.462563, "o", "def interval_range(\r\n"]
[1059.49738, "o", "    start=None,\r\n"]
[1059.532197, "o", "    end=None,\r\n"]
[1059.567014, "o", "    periods=None,\r\n"]
[1059.601831, "o", "    freq=None,\r\n"]
[1059.636648, "o", "    name: Hashable = None,\r\n"]
[1059.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1059.706282, "o", ") -> IntervalIndex:\r\n"]
[1059.741099, "o", "    \"\"\"\r\n"]
[1059.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1059.810732, "o", "\r\n"]
[1059.845549, "o", "    Parameters\r\n"]
[1059.880366, "o", "    ----------\r\n"]
[1059.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1060.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1060.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1060.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1060.040817, "o", "\u001b[?2004l\r\n"]
[1060.075634, "o", "        Left bound for generating intervals.\r\n"]
[1060.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1060.145268, "o", "        Right bound for generating intervals.\r\n"]
[1060.180085, "o", "    periods : int, default None\r\n"]
[1060.214901, "o", "        Number of periods to generate.\r\n"]
[1060.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1060.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1060.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1060.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1060.388986, "o", "    name : str, default None\r\n"]
[1060.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1060.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1060.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1060.528254, "o", "        or neither.\r\n"]
[1060.56307, "o", "\r\n"]
[1060.597887, "o", "    Returns\r\n"]
[1060.632704, "o", "    -------\r\n"]
[1060.667521, "o", "    IntervalIndex\r\n"]
[1060.702338, "o", "\r\n"]
[1060.737155, "o", "    See Also\r\n"]
[1060.771972, "o", "    --------\r\n"]
[1060.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1060.841606, "o", "\r\n"]
[1060.876423, "o", "    Notes\r\n"]
[1060.911239, "o", "    -----\r\n"]
[1060.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1060.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1061.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1061.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1061.085324, "o", "\r\n"]
[1061.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1061.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1061.189775, "o", "\r\n"]
[1061.224592, "o", "    Examples\r\n"]
[1061.259408, "o", "    --------\r\n"]
[1061.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1061.329042, "o", "\r\n"]
[1061.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1061.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1061.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1061.46831, "o", "\r\n"]
[1061.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1061.537944, "o", "\r\n"]
[1061.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1061.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1061.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1061.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1061.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1061.746845, "o", "\r\n"]
[1061.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1061.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1061.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1061.886113, "o", "\r\n"]
[1061.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1061.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1061.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1062.02538, "o", "\r\n"]
[1062.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1062.095014, "o", "    convertible to a DateOffset.\r\n"]
[1062.129831, "o", "\r\n"]
[1062.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1062.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1062.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1062.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1062.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1062.338732, "o", "\r\n"]
[1062.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1062.408366, "o", "    automatically (linearly spaced).\r\n"]
[1062.443183, "o", "\r\n"]
[1062.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1062.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1062.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1062.582451, "o", "\r\n"]
[1062.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1062.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1062.686901, "o", "\r\n"]
[1062.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1062.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1062.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1062.826169, "o", "    \"\"\"\r\n"]
[1062.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1062.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1062.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1062.965437, "o", "\r\n"]
[1063.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1063.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1063.069887, "o", "\r\n"]
[1063.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1063.139521, "o", "        raise ValueError(\r\n"]
[1063.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1063.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1063.243972, "o", "        )\r\n"]
[1063.278789, "o", "\r\n"]
[1063.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1063.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1063.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1063.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1063.452873, "o", "\r\n"]
[1063.48769, "o", "    if is_float(periods):\r\n"]
[1063.522507, "o", "        periods = int(periods)\r\n"]
[1063.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1063.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1063.626958, "o", "\r\n"]
[1063.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1063.696592, "o", "        try:\r\n"]
[1063.731408, "o", "            freq = to_offset(freq)\r\n"]
[1063.766225, "o", "        except ValueError as err:\r\n"]
[1063.801042, "o", "            raise ValueError(\r\n"]
[1063.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1063.870676, "o", "            ) from err\r\n"]
[1063.905493, "o", "\r\n"]
[1063.94031, "o", "    # verify type compatibility\r\n"]
[1063.975127, "o", "    if not all(\r\n"]
[1064.009944, "o", "        [\r\n"]
[1064.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1064.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1064.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1064.149211, "o", "        ]\r\n"]
[1064.184028, "o", "    ):\r\n"]
[1064.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1064.253662, "o", "\r\n"]
[1064.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1064.323296, "o", "    if periods is not None:\r\n"]
[1064.358113, "o", "        periods += 1\r\n"]
[1064.39293, "o", "\r\n"]
[1064.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1064.462563, "o", "\r\n"]
[1064.49738, "o", "    if is_number(endpoint):\r\n"]
[1064.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1064.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1064.601831, "o", "            end -= (end - start) % freq\r\n"]
[1064.636648, "o", "\r\n"]
[1064.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1064.706282, "o", "        if periods is None:\r\n"]
[1064.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1064.775915, "o", "        elif start is None:\r\n"]
[1064.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1064.845549, "o", "        elif end is None:\r\n"]
[1064.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1064.915183, "o", "\r\n"]
[1065.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1065.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1065.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1065.030355, "o", "\u001b[?2004l\r\n"]
[1065.054709, "o", "import numpy as np\r\n"]
[1065.079064, "o", "import pytest\r\n"]
[1065.103419, "o", "\r\n"]
[1065.127773, "o", "from pandas import (\r\n"]
[1065.152128, "o", "    Index,\r\n"]
[1065.176483, "o", "    IntervalIndex,\r\n"]
[1065.200837, "o", "    Timestamp,\r\n"]
[1065.225192, "o", "    interval_range,\r\n"]
[1065.249547, "o", ")\r\n"]
[1065.273901, "o", "import pandas._testing as tm\r\n"]
[1065.298256, "o", "\r\n"]
[1065.322611, "o", "\r\n"]
[1065.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1065.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1065.395675, "o", "\r\n"]
[1065.42003, "o", "\r\n"]
[1065.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1065.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1065.493094, "o", "\r\n"]
[1065.517448, "o", "\r\n"]
[1065.541803, "o", "class TestIntervalIndex:\r\n"]
[1065.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1065.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1065.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1065.639222, "o", "\r\n"]
[1065.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1065.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1065.712286, "o", "        if sort is None:\r\n"]
[1065.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1065.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1065.78535, "o", "\r\n"]
[1065.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1065.834059, "o", "        if sort is None:\r\n"]
[1065.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1065.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1065.907123, "o", "\r\n"]
[1065.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1065.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1065.980187, "o", "\r\n"]
[1066.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1066.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1066.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1066.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1066.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1066.126315, "o", "\r\n"]
[1066.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1066.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1066.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1066.223734, "o", "        expected = other\r\n"]
[1066.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1066.272443, "o", "\r\n"]
[1066.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1066.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1066.345507, "o", "\r\n"]
[1066.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1066.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1066.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1066.442926, "o", "\r\n"]
[1066.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1066.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1066.51599, "o", "\r\n"]
[1066.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1066.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1066.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1066.613409, "o", "\r\n"]
[1066.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1066.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1066.686473, "o", "        if sort is None:\r\n"]
[1066.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1066.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1066.759537, "o", "\r\n"]
[1066.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1066.808246, "o", "        if sort is None:\r\n"]
[1066.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1066.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1066.88131, "o", "\r\n"]
[1066.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1066.93002, "o", "\r\n"]
[1066.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1066.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1067.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1067.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1067.051793, "o", "        result = index.intersection(other)\r\n"]
[1067.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1067.100502, "o", "\r\n"]
[1067.124857, "o", "        # GH 26225\r\n"]
[1067.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1067.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1067.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1067.222276, "o", "        result = index.intersection(other)\r\n"]
[1067.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1067.270985, "o", "\r\n"]
[1067.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1067.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1067.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1067.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1067.392759, "o", "        result = index.intersection(other)\r\n"]
[1067.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1067.441468, "o", "\r\n"]
[1067.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1067.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1067.514532, "o", "\r\n"]
[1067.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1067.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1067.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1067.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1067.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1067.66066, "o", "\r\n"]
[1067.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1067.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1067.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1067.758079, "o", "        expected = other[:0]\r\n"]
[1067.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1067.806788, "o", "\r\n"]
[1067.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1067.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1067.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1067.904207, "o", "\r\n"]
[1067.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1067.952916, "o", "        # GH#38743\r\n"]
[1067.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1068.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1068.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1068.050335, "o", "        result = index.intersection(other)\r\n"]
[1068.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1068.099044, "o", "\r\n"]
[1068.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1068.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1068.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1068.196463, "o", "        expected = index[1:]\r\n"]
[1068.220818, "o", "        if sort is None:\r\n"]
[1068.245172, "o", "            expected = expected.sort_values()\r\n"]
[1068.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1068.293882, "o", "\r\n"]
[1068.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1068.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1068.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1068.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1068.415655, "o", "\r\n"]
[1068.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1068.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1068.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1068.513074, "o", "        )\r\n"]
[1068.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1068.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1068.586138, "o", "\r\n"]
[1068.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1068.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1068.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1068.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1068.707911, "o", "        if sort is None:\r\n"]
[1068.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1068.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1068.780975, "o", "\r\n"]
[1068.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1068.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1068.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1068.878394, "o", "        if sort is None:\r\n"]
[1068.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1068.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1068.951458, "o", "\r\n"]
[1068.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1069.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1069.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1069.048877, "o", "        )\r\n"]
[1069.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1069.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1069.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1069.146296, "o", "\r\n"]
[1069.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1069.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1069.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1069.243714, "o", "    )\r\n"]
[1069.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1069.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1069.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1069.341133, "o", "\r\n"]
[1069.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1069.389842, "o", "        # non-IntervalIndex\r\n"]
[1069.414197, "o", "        if op_name == \"difference\":\r\n"]
[1069.438552, "o", "            expected = index\r\n"]
[1069.462906, "o", "        else:\r\n"]
[1069.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1069.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1069.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1069.560325, "o", "\r\n"]
[1069.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1069.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1069.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1069.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1069.682099, "o", "            if op_name == \"difference\":\r\n"]
[1069.706453, "o", "                expected = index\r\n"]
[1069.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1069.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1069.779517, "o", "\r\n"]
[1069.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1069.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1069.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1069.876936, "o", "        if op_name == \"difference\":\r\n"]
[1069.901291, "o", "            expected = index\r\n"]
[1069.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1070.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1070.002, "i", "cd asv_bench\r"]
[1070.004, "o", "cd asv_bench\r\n"]
[1070.006, "o", "\u001b[?2004l\r\n"]
[1075.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1075.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1075.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1080.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1080.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1080.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1080.418, "o", "\u001b[?2004l\r\n"]
[1080.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1081.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1081.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1082.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1082.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1082.89, "o", "              param1            \r\n"]
[1083.302, "o", "             -------- ----------\r\n"]
[1083.714, "o", "               1000    1.18\u00b10ms \r\n"]
[1084.126, "o", "              100000   76.0\u00b10ms \r\n"]
[1084.538, "o", "             ======== ==========\r\n"]
[1085.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1085.002, "i", "cd ..\r"]
[1085.004, "o", "cd ..\r\n"]
[1085.006, "o", "\u001b[?2004l\r\n"]
[1090.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1090.002, "i", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r"]
[1090.004, "o", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r\n"]
[1090.5004, "o", "\u001b[?2004l\r\n"]
[1090.9948, "o", "\u001b[32m\u001b[K850\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(self, other, sort):\r\n"]
[1091.4892, "o", "\u001b[32m\u001b[K856\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(other)\r\n"]
[1091.9836, "o", "\u001b[32m\u001b[K860\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = other.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self)\r\n"]
[1092.478, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(other)\r\n"]
[1092.9724, "o", "\u001b[32m\u001b[K870\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1093.4668, "o", "\u001b[32m\u001b[K882\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is much more performant than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[1093.9612, "o", "\u001b[32m\u001b[K892\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1094.4556, "o", "\u001b[32m\u001b[K906\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is about 3.25x faster than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[1095.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1095.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1095.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1095.040817, "o", "\u001b[?2004l\r\n"]
[1095.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1095.110451, "o", "\r\n"]
[1095.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1095.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1095.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1095.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1095.284535, "o", "\r\n"]
[1095.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1095.354169, "o", "    # Set Operations\r\n"]
[1095.388986, "o", "\r\n"]
[1095.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1095.45862, "o", "        \"\"\"\r\n"]
[1095.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1095.528254, "o", "        \"\"\"\r\n"]
[1095.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1095.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1095.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1095.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1095.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1095.737155, "o", "            # multiple NaNs\r\n"]
[1095.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1095.806789, "o", "        else:\r\n"]
[1095.841606, "o", "            # duplicates\r\n"]
[1095.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1095.911239, "o", "\r\n"]
[1095.946056, "o", "        if sort is None:\r\n"]
[1095.980873, "o", "            taken = taken.sort_values()\r\n"]
[1096.01569, "o", "\r\n"]
[1096.050507, "o", "        return taken\r\n"]
[1096.085324, "o", "\r\n"]
[1096.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1096.154958, "o", "        \"\"\"\r\n"]
[1096.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1096.224592, "o", "        no matter left or right.\r\n"]
[1096.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1096.294225, "o", "        Parameters\r\n"]
[1096.329042, "o", "        ----------\r\n"]
[1096.363859, "o", "        other : IntervalIndex\r\n"]
[1096.398676, "o", "        Returns\r\n"]
[1096.433493, "o", "        -------\r\n"]
[1096.46831, "o", "        IntervalIndex\r\n"]
[1096.503127, "o", "        \"\"\"\r\n"]
[1096.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1096.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1096.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1096.642394, "o", "\r\n"]
[1096.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1096.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1096.746845, "o", "        indexer = unique(indexer)\r\n"]
[1096.781662, "o", "\r\n"]
[1096.816479, "o", "        return self.take(indexer)\r\n"]
[1096.851296, "o", "\r\n"]
[1096.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1096.92093, "o", "        \"\"\"\r\n"]
[1096.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1096.990563, "o", "        on either sides.\r\n"]
[1097.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1097.060197, "o", "\r\n"]
[1097.095014, "o", "        Parameters\r\n"]
[1097.129831, "o", "        ----------\r\n"]
[1097.164648, "o", "        other : IntervalIndex\r\n"]
[1097.199465, "o", "\r\n"]
[1097.234282, "o", "        Returns\r\n"]
[1097.269099, "o", "        -------\r\n"]
[1097.303915, "o", "        IntervalIndex\r\n"]
[1097.338732, "o", "        \"\"\"\r\n"]
[1097.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1097.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1097.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1097.478, "o", "\r\n"]
[1097.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1097.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1097.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1097.617268, "o", "\r\n"]
[1097.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1097.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1097.721718, "o", "            if tup in other_tups:\r\n"]
[1097.756535, "o", "                mask[i] = True\r\n"]
[1097.791352, "o", "\r\n"]
[1097.826169, "o", "        return self[mask]\r\n"]
[1097.860986, "o", "\r\n"]
[1097.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1097.93062, "o", "\r\n"]
[1097.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1098.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1098.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1098.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1098.104704, "o", "        raise NotImplementedError(\r\n"]
[1098.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1098.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1098.209155, "o", "        )\r\n"]
[1098.243972, "o", "\r\n"]
[1098.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1098.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1098.348423, "o", "\r\n"]
[1098.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1098.418056, "o", "\r\n"]
[1098.452873, "o", "\r\n"]
[1098.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1098.522507, "o", "    \"\"\"\r\n"]
[1098.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1098.592141, "o", "    \"\"\"\r\n"]
[1098.626958, "o", "    return any(\r\n"]
[1098.661775, "o", "        [\r\n"]
[1098.696592, "o", "            is_number(endpoint),\r\n"]
[1098.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1098.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1098.801042, "o", "            endpoint is None,\r\n"]
[1098.835859, "o", "        ]\r\n"]
[1098.870676, "o", "    )\r\n"]
[1098.905493, "o", "\r\n"]
[1098.94031, "o", "\r\n"]
[1098.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1099.009944, "o", "    \"\"\"\r\n"]
[1099.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1099.079577, "o", "    \"\"\"\r\n"]
[1099.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1099.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1099.184028, "o", "    return (\r\n"]
[1099.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1099.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1099.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1099.323296, "o", "        or com.any_none(a, b)\r\n"]
[1099.358113, "o", "    )\r\n"]
[1099.39293, "o", "\r\n"]
[1099.427746, "o", "\r\n"]
[1099.462563, "o", "def interval_range(\r\n"]
[1099.49738, "o", "    start=None,\r\n"]
[1099.532197, "o", "    end=None,\r\n"]
[1099.567014, "o", "    periods=None,\r\n"]
[1099.601831, "o", "    freq=None,\r\n"]
[1099.636648, "o", "    name: Hashable = None,\r\n"]
[1099.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1099.706282, "o", ") -> IntervalIndex:\r\n"]
[1099.741099, "o", "    \"\"\"\r\n"]
[1099.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1099.810732, "o", "\r\n"]
[1099.845549, "o", "    Parameters\r\n"]
[1099.880366, "o", "    ----------\r\n"]
[1099.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1100.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1100.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1100.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1100.040817, "o", "\u001b[?2004l\r\n"]
[1100.075634, "o", "        Left bound for generating intervals.\r\n"]
[1100.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1100.145268, "o", "        Right bound for generating intervals.\r\n"]
[1100.180085, "o", "    periods : int, default None\r\n"]
[1100.214901, "o", "        Number of periods to generate.\r\n"]
[1100.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1100.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1100.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1100.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1100.388986, "o", "    name : str, default None\r\n"]
[1100.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1100.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1100.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1100.528254, "o", "        or neither.\r\n"]
[1100.56307, "o", "\r\n"]
[1100.597887, "o", "    Returns\r\n"]
[1100.632704, "o", "    -------\r\n"]
[1100.667521, "o", "    IntervalIndex\r\n"]
[1100.702338, "o", "\r\n"]
[1100.737155, "o", "    See Also\r\n"]
[1100.771972, "o", "    --------\r\n"]
[1100.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1100.841606, "o", "\r\n"]
[1100.876423, "o", "    Notes\r\n"]
[1100.911239, "o", "    -----\r\n"]
[1100.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1100.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1101.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1101.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1101.085324, "o", "\r\n"]
[1101.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1101.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1101.189775, "o", "\r\n"]
[1101.224592, "o", "    Examples\r\n"]
[1101.259408, "o", "    --------\r\n"]
[1101.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1101.329042, "o", "\r\n"]
[1101.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1101.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1101.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1101.46831, "o", "\r\n"]
[1101.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1101.537944, "o", "\r\n"]
[1101.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1101.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1101.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1101.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1101.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1101.746845, "o", "\r\n"]
[1101.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1101.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1101.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1101.886113, "o", "\r\n"]
[1101.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1101.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1101.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1102.02538, "o", "\r\n"]
[1102.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1102.095014, "o", "    convertible to a DateOffset.\r\n"]
[1102.129831, "o", "\r\n"]
[1102.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1102.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1102.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1102.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1102.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1102.338732, "o", "\r\n"]
[1102.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1102.408366, "o", "    automatically (linearly spaced).\r\n"]
[1102.443183, "o", "\r\n"]
[1102.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1102.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1102.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1102.582451, "o", "\r\n"]
[1102.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1102.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1102.686901, "o", "\r\n"]
[1102.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1102.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1102.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1102.826169, "o", "    \"\"\"\r\n"]
[1102.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1102.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1102.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1102.965437, "o", "\r\n"]
[1103.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1103.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1103.069887, "o", "\r\n"]
[1103.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1103.139521, "o", "        raise ValueError(\r\n"]
[1103.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1103.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1103.243972, "o", "        )\r\n"]
[1103.278789, "o", "\r\n"]
[1103.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1103.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1103.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1103.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1103.452873, "o", "\r\n"]
[1103.48769, "o", "    if is_float(periods):\r\n"]
[1103.522507, "o", "        periods = int(periods)\r\n"]
[1103.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1103.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1103.626958, "o", "\r\n"]
[1103.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1103.696592, "o", "        try:\r\n"]
[1103.731408, "o", "            freq = to_offset(freq)\r\n"]
[1103.766225, "o", "        except ValueError as err:\r\n"]
[1103.801042, "o", "            raise ValueError(\r\n"]
[1103.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1103.870676, "o", "            ) from err\r\n"]
[1103.905493, "o", "\r\n"]
[1103.94031, "o", "    # verify type compatibility\r\n"]
[1103.975127, "o", "    if not all(\r\n"]
[1104.009944, "o", "        [\r\n"]
[1104.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1104.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1104.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1104.149211, "o", "        ]\r\n"]
[1104.184028, "o", "    ):\r\n"]
[1104.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1104.253662, "o", "\r\n"]
[1104.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1104.323296, "o", "    if periods is not None:\r\n"]
[1104.358113, "o", "        periods += 1\r\n"]
[1104.39293, "o", "\r\n"]
[1104.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1104.462563, "o", "\r\n"]
[1104.49738, "o", "    if is_number(endpoint):\r\n"]
[1104.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1104.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1104.601831, "o", "            end -= (end - start) % freq\r\n"]
[1104.636648, "o", "\r\n"]
[1104.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1104.706282, "o", "        if periods is None:\r\n"]
[1104.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1104.775915, "o", "        elif start is None:\r\n"]
[1104.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1104.845549, "o", "        elif end is None:\r\n"]
[1104.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1104.915183, "o", "\r\n"]
[1105.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1105.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1105.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1105.030355, "o", "\u001b[?2004l\r\n"]
[1105.054709, "o", "import numpy as np\r\n"]
[1105.079064, "o", "import pytest\r\n"]
[1105.103419, "o", "\r\n"]
[1105.127773, "o", "from pandas import (\r\n"]
[1105.152128, "o", "    Index,\r\n"]
[1105.176483, "o", "    IntervalIndex,\r\n"]
[1105.200837, "o", "    Timestamp,\r\n"]
[1105.225192, "o", "    interval_range,\r\n"]
[1105.249547, "o", ")\r\n"]
[1105.273901, "o", "import pandas._testing as tm\r\n"]
[1105.298256, "o", "\r\n"]
[1105.322611, "o", "\r\n"]
[1105.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1105.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1105.395675, "o", "\r\n"]
[1105.42003, "o", "\r\n"]
[1105.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1105.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1105.493094, "o", "\r\n"]
[1105.517448, "o", "\r\n"]
[1105.541803, "o", "class TestIntervalIndex:\r\n"]
[1105.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1105.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1105.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1105.639222, "o", "\r\n"]
[1105.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1105.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1105.712286, "o", "        if sort is None:\r\n"]
[1105.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1105.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1105.78535, "o", "\r\n"]
[1105.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1105.834059, "o", "        if sort is None:\r\n"]
[1105.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1105.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1105.907123, "o", "\r\n"]
[1105.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1105.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1105.980187, "o", "\r\n"]
[1106.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1106.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1106.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1106.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1106.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1106.126315, "o", "\r\n"]
[1106.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1106.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1106.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1106.223734, "o", "        expected = other\r\n"]
[1106.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1106.272443, "o", "\r\n"]
[1106.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1106.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1106.345507, "o", "\r\n"]
[1106.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1106.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1106.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1106.442926, "o", "\r\n"]
[1106.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1106.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1106.51599, "o", "\r\n"]
[1106.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1106.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1106.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1106.613409, "o", "\r\n"]
[1106.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1106.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1106.686473, "o", "        if sort is None:\r\n"]
[1106.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1106.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1106.759537, "o", "\r\n"]
[1106.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1106.808246, "o", "        if sort is None:\r\n"]
[1106.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1106.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1106.88131, "o", "\r\n"]
[1106.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1106.93002, "o", "\r\n"]
[1106.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1106.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1107.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1107.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1107.051793, "o", "        result = index.intersection(other)\r\n"]
[1107.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1107.100502, "o", "\r\n"]
[1107.124857, "o", "        # GH 26225\r\n"]
[1107.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1107.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1107.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1107.222276, "o", "        result = index.intersection(other)\r\n"]
[1107.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1107.270985, "o", "\r\n"]
[1107.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1107.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1107.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1107.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1107.392759, "o", "        result = index.intersection(other)\r\n"]
[1107.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1107.441468, "o", "\r\n"]
[1107.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1107.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1107.514532, "o", "\r\n"]
[1107.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1107.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1107.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1107.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1107.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1107.66066, "o", "\r\n"]
[1107.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1107.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1107.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1107.758079, "o", "        expected = other[:0]\r\n"]
[1107.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1107.806788, "o", "\r\n"]
[1107.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1107.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1107.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1107.904207, "o", "\r\n"]
[1107.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1107.952916, "o", "        # GH#38743\r\n"]
[1107.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1108.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1108.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1108.050335, "o", "        result = index.intersection(other)\r\n"]
[1108.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1108.099044, "o", "\r\n"]
[1108.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1108.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1108.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1108.196463, "o", "        expected = index[1:]\r\n"]
[1108.220818, "o", "        if sort is None:\r\n"]
[1108.245172, "o", "            expected = expected.sort_values()\r\n"]
[1108.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1108.293882, "o", "\r\n"]
[1108.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1108.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1108.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1108.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1108.415655, "o", "\r\n"]
[1108.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1108.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1108.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1108.513074, "o", "        )\r\n"]
[1108.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1108.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1108.586138, "o", "\r\n"]
[1108.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1108.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1108.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1108.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1108.707911, "o", "        if sort is None:\r\n"]
[1108.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1108.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1108.780975, "o", "\r\n"]
[1108.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1108.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1108.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1108.878394, "o", "        if sort is None:\r\n"]
[1108.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1108.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1108.951458, "o", "\r\n"]
[1108.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1109.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1109.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1109.048877, "o", "        )\r\n"]
[1109.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1109.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1109.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1109.146296, "o", "\r\n"]
[1109.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1109.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1109.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1109.243714, "o", "    )\r\n"]
[1109.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1109.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1109.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1109.341133, "o", "\r\n"]
[1109.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1109.389842, "o", "        # non-IntervalIndex\r\n"]
[1109.414197, "o", "        if op_name == \"difference\":\r\n"]
[1109.438552, "o", "            expected = index\r\n"]
[1109.462906, "o", "        else:\r\n"]
[1109.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1109.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1109.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1109.560325, "o", "\r\n"]
[1109.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1109.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1109.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1109.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1109.682099, "o", "            if op_name == \"difference\":\r\n"]
[1109.706453, "o", "                expected = index\r\n"]
[1109.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1109.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1109.779517, "o", "\r\n"]
[1109.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1109.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1109.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1109.876936, "o", "        if op_name == \"difference\":\r\n"]
[1109.901291, "o", "            expected = index\r\n"]
[1109.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1110.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1110.002, "i", "cd asv_bench\r"]
[1110.004, "o", "cd asv_bench\r\n"]
[1110.006, "o", "\u001b[?2004l\r\n"]
[1115.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1115.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1115.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1120.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1120.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1120.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1120.418, "o", "\u001b[?2004l\r\n"]
[1120.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1121.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1121.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1122.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1122.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1122.89, "o", "              param1            \r\n"]
[1123.302, "o", "             -------- ----------\r\n"]
[1123.714, "o", "               1000    1.19\u00b10ms \r\n"]
[1124.126, "o", "              100000   74.6\u00b10ms \r\n"]
[1124.538, "o", "             ======== ==========\r\n"]
[1125.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1125.002, "i", "cd ..\r"]
[1125.004, "o", "cd ..\r\n"]
[1125.006, "o", "\u001b[?2004l\r\n"]
[1130.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1130.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1130.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1132.478, "o", "\u001b[?2004l\r\n"]
[1135.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1135.002, "i", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r"]
[1135.004, "o", "grep -n \"_intersection_non_unique\" pandas/core/indexes/interval.py || true\r\n"]
[1136.654, "o", "\u001b[?2004l\r\n"]
[1138.302, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection_non_unique\u001b[m\u001b[K(other)\r\n"]
[1140.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1140.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1140.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1140.040817, "o", "\u001b[?2004l\r\n"]
[1140.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1140.110451, "o", "\r\n"]
[1140.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1140.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1140.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1140.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1140.284535, "o", "\r\n"]
[1140.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1140.354169, "o", "    # Set Operations\r\n"]
[1140.388986, "o", "\r\n"]
[1140.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1140.45862, "o", "        \"\"\"\r\n"]
[1140.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1140.528254, "o", "        \"\"\"\r\n"]
[1140.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1140.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1140.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1140.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1140.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1140.737155, "o", "            # multiple NaNs\r\n"]
[1140.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1140.806789, "o", "        else:\r\n"]
[1140.841606, "o", "            # duplicates\r\n"]
[1140.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1140.911239, "o", "\r\n"]
[1140.946056, "o", "        if sort is None:\r\n"]
[1140.980873, "o", "            taken = taken.sort_values()\r\n"]
[1141.01569, "o", "\r\n"]
[1141.050507, "o", "        return taken\r\n"]
[1141.085324, "o", "\r\n"]
[1141.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1141.154958, "o", "        \"\"\"\r\n"]
[1141.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1141.224592, "o", "        no matter left or right.\r\n"]
[1141.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1141.294225, "o", "        Parameters\r\n"]
[1141.329042, "o", "        ----------\r\n"]
[1141.363859, "o", "        other : IntervalIndex\r\n"]
[1141.398676, "o", "        Returns\r\n"]
[1141.433493, "o", "        -------\r\n"]
[1141.46831, "o", "        IntervalIndex\r\n"]
[1141.503127, "o", "        \"\"\"\r\n"]
[1141.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1141.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1141.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1141.642394, "o", "\r\n"]
[1141.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1141.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1141.746845, "o", "        indexer = unique(indexer)\r\n"]
[1141.781662, "o", "\r\n"]
[1141.816479, "o", "        return self.take(indexer)\r\n"]
[1141.851296, "o", "\r\n"]
[1141.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1141.92093, "o", "        \"\"\"\r\n"]
[1141.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1141.990563, "o", "        on either sides.\r\n"]
[1142.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1142.060197, "o", "\r\n"]
[1142.095014, "o", "        Parameters\r\n"]
[1142.129831, "o", "        ----------\r\n"]
[1142.164648, "o", "        other : IntervalIndex\r\n"]
[1142.199465, "o", "\r\n"]
[1142.234282, "o", "        Returns\r\n"]
[1142.269099, "o", "        -------\r\n"]
[1142.303915, "o", "        IntervalIndex\r\n"]
[1142.338732, "o", "        \"\"\"\r\n"]
[1142.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1142.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1142.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1142.478, "o", "\r\n"]
[1142.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1142.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1142.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1142.617268, "o", "\r\n"]
[1142.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1142.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1142.721718, "o", "            if tup in other_tups:\r\n"]
[1142.756535, "o", "                mask[i] = True\r\n"]
[1142.791352, "o", "\r\n"]
[1142.826169, "o", "        return self[mask]\r\n"]
[1142.860986, "o", "\r\n"]
[1142.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1142.93062, "o", "\r\n"]
[1142.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1143.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1143.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1143.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1143.104704, "o", "        raise NotImplementedError(\r\n"]
[1143.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1143.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1143.209155, "o", "        )\r\n"]
[1143.243972, "o", "\r\n"]
[1143.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1143.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1143.348423, "o", "\r\n"]
[1143.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1143.418056, "o", "\r\n"]
[1143.452873, "o", "\r\n"]
[1143.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1143.522507, "o", "    \"\"\"\r\n"]
[1143.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1143.592141, "o", "    \"\"\"\r\n"]
[1143.626958, "o", "    return any(\r\n"]
[1143.661775, "o", "        [\r\n"]
[1143.696592, "o", "            is_number(endpoint),\r\n"]
[1143.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1143.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1143.801042, "o", "            endpoint is None,\r\n"]
[1143.835859, "o", "        ]\r\n"]
[1143.870676, "o", "    )\r\n"]
[1143.905493, "o", "\r\n"]
[1143.94031, "o", "\r\n"]
[1143.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1144.009944, "o", "    \"\"\"\r\n"]
[1144.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1144.079577, "o", "    \"\"\"\r\n"]
[1144.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1144.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1144.184028, "o", "    return (\r\n"]
[1144.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1144.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1144.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1144.323296, "o", "        or com.any_none(a, b)\r\n"]
[1144.358113, "o", "    )\r\n"]
[1144.39293, "o", "\r\n"]
[1144.427746, "o", "\r\n"]
[1144.462563, "o", "def interval_range(\r\n"]
[1144.49738, "o", "    start=None,\r\n"]
[1144.532197, "o", "    end=None,\r\n"]
[1144.567014, "o", "    periods=None,\r\n"]
[1144.601831, "o", "    freq=None,\r\n"]
[1144.636648, "o", "    name: Hashable = None,\r\n"]
[1144.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1144.706282, "o", ") -> IntervalIndex:\r\n"]
[1144.741099, "o", "    \"\"\"\r\n"]
[1144.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1144.810732, "o", "\r\n"]
[1144.845549, "o", "    Parameters\r\n"]
[1144.880366, "o", "    ----------\r\n"]
[1144.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1145.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1145.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1145.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1145.040817, "o", "\u001b[?2004l\r\n"]
[1145.075634, "o", "        Left bound for generating intervals.\r\n"]
[1145.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1145.145268, "o", "        Right bound for generating intervals.\r\n"]
[1145.180085, "o", "    periods : int, default None\r\n"]
[1145.214901, "o", "        Number of periods to generate.\r\n"]
[1145.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1145.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1145.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1145.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1145.388986, "o", "    name : str, default None\r\n"]
[1145.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1145.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1145.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1145.528254, "o", "        or neither.\r\n"]
[1145.56307, "o", "\r\n"]
[1145.597887, "o", "    Returns\r\n"]
[1145.632704, "o", "    -------\r\n"]
[1145.667521, "o", "    IntervalIndex\r\n"]
[1145.702338, "o", "\r\n"]
[1145.737155, "o", "    See Also\r\n"]
[1145.771972, "o", "    --------\r\n"]
[1145.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1145.841606, "o", "\r\n"]
[1145.876423, "o", "    Notes\r\n"]
[1145.911239, "o", "    -----\r\n"]
[1145.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1145.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1146.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1146.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1146.085324, "o", "\r\n"]
[1146.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1146.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1146.189775, "o", "\r\n"]
[1146.224592, "o", "    Examples\r\n"]
[1146.259408, "o", "    --------\r\n"]
[1146.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1146.329042, "o", "\r\n"]
[1146.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1146.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1146.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1146.46831, "o", "\r\n"]
[1146.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1146.537944, "o", "\r\n"]
[1146.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1146.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1146.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1146.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1146.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1146.746845, "o", "\r\n"]
[1146.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1146.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1146.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1146.886113, "o", "\r\n"]
[1146.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1146.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1146.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1147.02538, "o", "\r\n"]
[1147.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1147.095014, "o", "    convertible to a DateOffset.\r\n"]
[1147.129831, "o", "\r\n"]
[1147.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1147.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1147.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1147.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1147.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1147.338732, "o", "\r\n"]
[1147.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1147.408366, "o", "    automatically (linearly spaced).\r\n"]
[1147.443183, "o", "\r\n"]
[1147.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1147.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1147.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1147.582451, "o", "\r\n"]
[1147.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1147.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1147.686901, "o", "\r\n"]
[1147.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1147.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1147.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1147.826169, "o", "    \"\"\"\r\n"]
[1147.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1147.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1147.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1147.965437, "o", "\r\n"]
[1148.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1148.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1148.069887, "o", "\r\n"]
[1148.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1148.139521, "o", "        raise ValueError(\r\n"]
[1148.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1148.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1148.243972, "o", "        )\r\n"]
[1148.278789, "o", "\r\n"]
[1148.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1148.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1148.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1148.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1148.452873, "o", "\r\n"]
[1148.48769, "o", "    if is_float(periods):\r\n"]
[1148.522507, "o", "        periods = int(periods)\r\n"]
[1148.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1148.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1148.626958, "o", "\r\n"]
[1148.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1148.696592, "o", "        try:\r\n"]
[1148.731408, "o", "            freq = to_offset(freq)\r\n"]
[1148.766225, "o", "        except ValueError as err:\r\n"]
[1148.801042, "o", "            raise ValueError(\r\n"]
[1148.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1148.870676, "o", "            ) from err\r\n"]
[1148.905493, "o", "\r\n"]
[1148.94031, "o", "    # verify type compatibility\r\n"]
[1148.975127, "o", "    if not all(\r\n"]
[1149.009944, "o", "        [\r\n"]
[1149.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1149.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1149.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1149.149211, "o", "        ]\r\n"]
[1149.184028, "o", "    ):\r\n"]
[1149.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1149.253662, "o", "\r\n"]
[1149.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1149.323296, "o", "    if periods is not None:\r\n"]
[1149.358113, "o", "        periods += 1\r\n"]
[1149.39293, "o", "\r\n"]
[1149.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1149.462563, "o", "\r\n"]
[1149.49738, "o", "    if is_number(endpoint):\r\n"]
[1149.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1149.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1149.601831, "o", "            end -= (end - start) % freq\r\n"]
[1149.636648, "o", "\r\n"]
[1149.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1149.706282, "o", "        if periods is None:\r\n"]
[1149.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1149.775915, "o", "        elif start is None:\r\n"]
[1149.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1149.845549, "o", "        elif end is None:\r\n"]
[1149.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1149.915183, "o", "\r\n"]
[1150.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1150.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1150.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1150.030355, "o", "\u001b[?2004l\r\n"]
[1150.054709, "o", "import numpy as np\r\n"]
[1150.079064, "o", "import pytest\r\n"]
[1150.103419, "o", "\r\n"]
[1150.127773, "o", "from pandas import (\r\n"]
[1150.152128, "o", "    Index,\r\n"]
[1150.176483, "o", "    IntervalIndex,\r\n"]
[1150.200837, "o", "    Timestamp,\r\n"]
[1150.225192, "o", "    interval_range,\r\n"]
[1150.249547, "o", ")\r\n"]
[1150.273901, "o", "import pandas._testing as tm\r\n"]
[1150.298256, "o", "\r\n"]
[1150.322611, "o", "\r\n"]
[1150.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1150.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1150.395675, "o", "\r\n"]
[1150.42003, "o", "\r\n"]
[1150.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1150.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1150.493094, "o", "\r\n"]
[1150.517448, "o", "\r\n"]
[1150.541803, "o", "class TestIntervalIndex:\r\n"]
[1150.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1150.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1150.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1150.639222, "o", "\r\n"]
[1150.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1150.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1150.712286, "o", "        if sort is None:\r\n"]
[1150.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1150.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1150.78535, "o", "\r\n"]
[1150.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1150.834059, "o", "        if sort is None:\r\n"]
[1150.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1150.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1150.907123, "o", "\r\n"]
[1150.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1150.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1150.980187, "o", "\r\n"]
[1151.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1151.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1151.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1151.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1151.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1151.126315, "o", "\r\n"]
[1151.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1151.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1151.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1151.223734, "o", "        expected = other\r\n"]
[1151.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1151.272443, "o", "\r\n"]
[1151.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1151.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1151.345507, "o", "\r\n"]
[1151.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1151.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1151.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1151.442926, "o", "\r\n"]
[1151.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1151.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1151.51599, "o", "\r\n"]
[1151.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1151.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1151.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1151.613409, "o", "\r\n"]
[1151.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1151.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1151.686473, "o", "        if sort is None:\r\n"]
[1151.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1151.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1151.759537, "o", "\r\n"]
[1151.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1151.808246, "o", "        if sort is None:\r\n"]
[1151.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1151.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1151.88131, "o", "\r\n"]
[1151.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1151.93002, "o", "\r\n"]
[1151.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1151.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1152.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1152.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1152.051793, "o", "        result = index.intersection(other)\r\n"]
[1152.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1152.100502, "o", "\r\n"]
[1152.124857, "o", "        # GH 26225\r\n"]
[1152.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1152.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1152.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1152.222276, "o", "        result = index.intersection(other)\r\n"]
[1152.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1152.270985, "o", "\r\n"]
[1152.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1152.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1152.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1152.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1152.392759, "o", "        result = index.intersection(other)\r\n"]
[1152.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1152.441468, "o", "\r\n"]
[1152.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1152.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1152.514532, "o", "\r\n"]
[1152.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1152.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1152.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1152.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1152.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1152.66066, "o", "\r\n"]
[1152.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1152.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1152.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1152.758079, "o", "        expected = other[:0]\r\n"]
[1152.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1152.806788, "o", "\r\n"]
[1152.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1152.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1152.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1152.904207, "o", "\r\n"]
[1152.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1152.952916, "o", "        # GH#38743\r\n"]
[1152.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1153.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1153.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1153.050335, "o", "        result = index.intersection(other)\r\n"]
[1153.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1153.099044, "o", "\r\n"]
[1153.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1153.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1153.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1153.196463, "o", "        expected = index[1:]\r\n"]
[1153.220818, "o", "        if sort is None:\r\n"]
[1153.245172, "o", "            expected = expected.sort_values()\r\n"]
[1153.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1153.293882, "o", "\r\n"]
[1153.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1153.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1153.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1153.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1153.415655, "o", "\r\n"]
[1153.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1153.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1153.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1153.513074, "o", "        )\r\n"]
[1153.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1153.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1153.586138, "o", "\r\n"]
[1153.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1153.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1153.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1153.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1153.707911, "o", "        if sort is None:\r\n"]
[1153.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1153.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1153.780975, "o", "\r\n"]
[1153.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1153.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1153.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1153.878394, "o", "        if sort is None:\r\n"]
[1153.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1153.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1153.951458, "o", "\r\n"]
[1153.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1154.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1154.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1154.048877, "o", "        )\r\n"]
[1154.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1154.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1154.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1154.146296, "o", "\r\n"]
[1154.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1154.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1154.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1154.243714, "o", "    )\r\n"]
[1154.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1154.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1154.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1154.341133, "o", "\r\n"]
[1154.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1154.389842, "o", "        # non-IntervalIndex\r\n"]
[1154.414197, "o", "        if op_name == \"difference\":\r\n"]
[1154.438552, "o", "            expected = index\r\n"]
[1154.462906, "o", "        else:\r\n"]
[1154.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1154.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1154.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1154.560325, "o", "\r\n"]
[1154.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1154.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1154.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1154.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1154.682099, "o", "            if op_name == \"difference\":\r\n"]
[1154.706453, "o", "                expected = index\r\n"]
[1154.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1154.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1154.779517, "o", "\r\n"]
[1154.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1154.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1154.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1154.876936, "o", "        if op_name == \"difference\":\r\n"]
[1154.901291, "o", "            expected = index\r\n"]
[1154.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1155.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1155.002, "i", "cd asv_bench\r"]
[1155.004, "o", "cd asv_bench\r\n"]
[1155.006, "o", "\u001b[?2004l\r\n"]
[1160.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1160.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1160.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1165.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1165.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1165.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1165.418, "o", "\u001b[?2004l\r\n"]
[1165.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1166.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1166.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1167.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1167.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1167.89, "o", "              param1            \r\n"]
[1168.302, "o", "             -------- ----------\r\n"]
[1168.714, "o", "               1000    1.22\u00b10ms \r\n"]
[1169.126, "o", "              100000   76.1\u00b10ms \r\n"]
[1169.538, "o", "             ======== ==========\r\n"]
[1170.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1170.002, "i", "cd ..\r"]
[1170.004, "o", "cd ..\r\n"]
[1170.006, "o", "\u001b[?2004l\r\n"]
[1175.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1175.002, "i", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r"]
[1175.004, "o", "grep -n \"_intersection\" pandas/core/indexes/interval.py || true\r\n"]
[1175.5004, "o", "\u001b[?2004l\r\n"]
[1175.9948, "o", "\u001b[32m\u001b[K850\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(self, other, sort):\r\n"]
[1176.4892, "o", "\u001b[32m\u001b[K856\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(other)\r\n"]
[1176.9836, "o", "\u001b[32m\u001b[K860\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = other.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self)\r\n"]
[1177.478, "o", "\u001b[32m\u001b[K863\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K            taken = self.\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(other)\r\n"]
[1177.9724, "o", "\u001b[32m\u001b[K870\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1178.4668, "o", "\u001b[32m\u001b[K882\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is much more performant than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[1178.9612, "o", "\u001b[32m\u001b[K892\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K    def \u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1179.4556, "o", "\u001b[32m\u001b[K906\u001b[m\u001b[K\u001b[36m\u001b[K:\u001b[m\u001b[K        # Note: this is about 3.25x faster than super().\u001b[01;31m\u001b[K_intersection\u001b[m\u001b[K(other)\r\n"]
[1180.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1180.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1180.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1180.040817, "o", "\u001b[?2004l\r\n"]
[1180.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1180.110451, "o", "\r\n"]
[1180.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1180.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1180.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1180.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1180.284535, "o", "\r\n"]
[1180.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1180.354169, "o", "    # Set Operations\r\n"]
[1180.388986, "o", "\r\n"]
[1180.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1180.45862, "o", "        \"\"\"\r\n"]
[1180.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1180.528254, "o", "        \"\"\"\r\n"]
[1180.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1180.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1180.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1180.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1180.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1180.737155, "o", "            # multiple NaNs\r\n"]
[1180.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1180.806789, "o", "        else:\r\n"]
[1180.841606, "o", "            # duplicates\r\n"]
[1180.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1180.911239, "o", "\r\n"]
[1180.946056, "o", "        if sort is None:\r\n"]
[1180.980873, "o", "            taken = taken.sort_values()\r\n"]
[1181.01569, "o", "\r\n"]
[1181.050507, "o", "        return taken\r\n"]
[1181.085324, "o", "\r\n"]
[1181.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1181.154958, "o", "        \"\"\"\r\n"]
[1181.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1181.224592, "o", "        no matter left or right.\r\n"]
[1181.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1181.294225, "o", "        Parameters\r\n"]
[1181.329042, "o", "        ----------\r\n"]
[1181.363859, "o", "        other : IntervalIndex\r\n"]
[1181.398676, "o", "        Returns\r\n"]
[1181.433493, "o", "        -------\r\n"]
[1181.46831, "o", "        IntervalIndex\r\n"]
[1181.503127, "o", "        \"\"\"\r\n"]
[1181.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1181.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1181.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1181.642394, "o", "\r\n"]
[1181.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1181.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1181.746845, "o", "        indexer = unique(indexer)\r\n"]
[1181.781662, "o", "\r\n"]
[1181.816479, "o", "        return self.take(indexer)\r\n"]
[1181.851296, "o", "\r\n"]
[1181.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1181.92093, "o", "        \"\"\"\r\n"]
[1181.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1181.990563, "o", "        on either sides.\r\n"]
[1182.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1182.060197, "o", "\r\n"]
[1182.095014, "o", "        Parameters\r\n"]
[1182.129831, "o", "        ----------\r\n"]
[1182.164648, "o", "        other : IntervalIndex\r\n"]
[1182.199465, "o", "\r\n"]
[1182.234282, "o", "        Returns\r\n"]
[1182.269099, "o", "        -------\r\n"]
[1182.303915, "o", "        IntervalIndex\r\n"]
[1182.338732, "o", "        \"\"\"\r\n"]
[1182.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1182.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1182.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1182.478, "o", "\r\n"]
[1182.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1182.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1182.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1182.617268, "o", "\r\n"]
[1182.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1182.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1182.721718, "o", "            if tup in other_tups:\r\n"]
[1182.756535, "o", "                mask[i] = True\r\n"]
[1182.791352, "o", "\r\n"]
[1182.826169, "o", "        return self[mask]\r\n"]
[1182.860986, "o", "\r\n"]
[1182.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1182.93062, "o", "\r\n"]
[1182.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1183.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1183.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1183.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1183.104704, "o", "        raise NotImplementedError(\r\n"]
[1183.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1183.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1183.209155, "o", "        )\r\n"]
[1183.243972, "o", "\r\n"]
[1183.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1183.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1183.348423, "o", "\r\n"]
[1183.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1183.418056, "o", "\r\n"]
[1183.452873, "o", "\r\n"]
[1183.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1183.522507, "o", "    \"\"\"\r\n"]
[1183.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1183.592141, "o", "    \"\"\"\r\n"]
[1183.626958, "o", "    return any(\r\n"]
[1183.661775, "o", "        [\r\n"]
[1183.696592, "o", "            is_number(endpoint),\r\n"]
[1183.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1183.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1183.801042, "o", "            endpoint is None,\r\n"]
[1183.835859, "o", "        ]\r\n"]
[1183.870676, "o", "    )\r\n"]
[1183.905493, "o", "\r\n"]
[1183.94031, "o", "\r\n"]
[1183.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1184.009944, "o", "    \"\"\"\r\n"]
[1184.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1184.079577, "o", "    \"\"\"\r\n"]
[1184.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1184.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1184.184028, "o", "    return (\r\n"]
[1184.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1184.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1184.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1184.323296, "o", "        or com.any_none(a, b)\r\n"]
[1184.358113, "o", "    )\r\n"]
[1184.39293, "o", "\r\n"]
[1184.427746, "o", "\r\n"]
[1184.462563, "o", "def interval_range(\r\n"]
[1184.49738, "o", "    start=None,\r\n"]
[1184.532197, "o", "    end=None,\r\n"]
[1184.567014, "o", "    periods=None,\r\n"]
[1184.601831, "o", "    freq=None,\r\n"]
[1184.636648, "o", "    name: Hashable = None,\r\n"]
[1184.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1184.706282, "o", ") -> IntervalIndex:\r\n"]
[1184.741099, "o", "    \"\"\"\r\n"]
[1184.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1184.810732, "o", "\r\n"]
[1184.845549, "o", "    Parameters\r\n"]
[1184.880366, "o", "    ----------\r\n"]
[1184.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1185.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1185.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1185.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1185.040817, "o", "\u001b[?2004l\r\n"]
[1185.075634, "o", "        Left bound for generating intervals.\r\n"]
[1185.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1185.145268, "o", "        Right bound for generating intervals.\r\n"]
[1185.180085, "o", "    periods : int, default None\r\n"]
[1185.214901, "o", "        Number of periods to generate.\r\n"]
[1185.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1185.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1185.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1185.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1185.388986, "o", "    name : str, default None\r\n"]
[1185.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1185.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1185.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1185.528254, "o", "        or neither.\r\n"]
[1185.56307, "o", "\r\n"]
[1185.597887, "o", "    Returns\r\n"]
[1185.632704, "o", "    -------\r\n"]
[1185.667521, "o", "    IntervalIndex\r\n"]
[1185.702338, "o", "\r\n"]
[1185.737155, "o", "    See Also\r\n"]
[1185.771972, "o", "    --------\r\n"]
[1185.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1185.841606, "o", "\r\n"]
[1185.876423, "o", "    Notes\r\n"]
[1185.911239, "o", "    -----\r\n"]
[1185.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1185.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1186.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1186.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1186.085324, "o", "\r\n"]
[1186.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1186.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1186.189775, "o", "\r\n"]
[1186.224592, "o", "    Examples\r\n"]
[1186.259408, "o", "    --------\r\n"]
[1186.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1186.329042, "o", "\r\n"]
[1186.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1186.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1186.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1186.46831, "o", "\r\n"]
[1186.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1186.537944, "o", "\r\n"]
[1186.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1186.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1186.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1186.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1186.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1186.746845, "o", "\r\n"]
[1186.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1186.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1186.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1186.886113, "o", "\r\n"]
[1186.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1186.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1186.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1187.02538, "o", "\r\n"]
[1187.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1187.095014, "o", "    convertible to a DateOffset.\r\n"]
[1187.129831, "o", "\r\n"]
[1187.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1187.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1187.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1187.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1187.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1187.338732, "o", "\r\n"]
[1187.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1187.408366, "o", "    automatically (linearly spaced).\r\n"]
[1187.443183, "o", "\r\n"]
[1187.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1187.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1187.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1187.582451, "o", "\r\n"]
[1187.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1187.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1187.686901, "o", "\r\n"]
[1187.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1187.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1187.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1187.826169, "o", "    \"\"\"\r\n"]
[1187.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1187.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1187.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1187.965437, "o", "\r\n"]
[1188.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1188.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1188.069887, "o", "\r\n"]
[1188.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1188.139521, "o", "        raise ValueError(\r\n"]
[1188.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1188.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1188.243972, "o", "        )\r\n"]
[1188.278789, "o", "\r\n"]
[1188.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1188.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1188.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1188.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1188.452873, "o", "\r\n"]
[1188.48769, "o", "    if is_float(periods):\r\n"]
[1188.522507, "o", "        periods = int(periods)\r\n"]
[1188.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1188.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1188.626958, "o", "\r\n"]
[1188.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1188.696592, "o", "        try:\r\n"]
[1188.731408, "o", "            freq = to_offset(freq)\r\n"]
[1188.766225, "o", "        except ValueError as err:\r\n"]
[1188.801042, "o", "            raise ValueError(\r\n"]
[1188.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1188.870676, "o", "            ) from err\r\n"]
[1188.905493, "o", "\r\n"]
[1188.94031, "o", "    # verify type compatibility\r\n"]
[1188.975127, "o", "    if not all(\r\n"]
[1189.009944, "o", "        [\r\n"]
[1189.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1189.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1189.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1189.149211, "o", "        ]\r\n"]
[1189.184028, "o", "    ):\r\n"]
[1189.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1189.253662, "o", "\r\n"]
[1189.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1189.323296, "o", "    if periods is not None:\r\n"]
[1189.358113, "o", "        periods += 1\r\n"]
[1189.39293, "o", "\r\n"]
[1189.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1189.462563, "o", "\r\n"]
[1189.49738, "o", "    if is_number(endpoint):\r\n"]
[1189.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1189.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1189.601831, "o", "            end -= (end - start) % freq\r\n"]
[1189.636648, "o", "\r\n"]
[1189.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1189.706282, "o", "        if periods is None:\r\n"]
[1189.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1189.775915, "o", "        elif start is None:\r\n"]
[1189.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1189.845549, "o", "        elif end is None:\r\n"]
[1189.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1189.915183, "o", "\r\n"]
[1190.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1190.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1190.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1190.030355, "o", "\u001b[?2004l\r\n"]
[1190.054709, "o", "import numpy as np\r\n"]
[1190.079064, "o", "import pytest\r\n"]
[1190.103419, "o", "\r\n"]
[1190.127773, "o", "from pandas import (\r\n"]
[1190.152128, "o", "    Index,\r\n"]
[1190.176483, "o", "    IntervalIndex,\r\n"]
[1190.200837, "o", "    Timestamp,\r\n"]
[1190.225192, "o", "    interval_range,\r\n"]
[1190.249547, "o", ")\r\n"]
[1190.273901, "o", "import pandas._testing as tm\r\n"]
[1190.298256, "o", "\r\n"]
[1190.322611, "o", "\r\n"]
[1190.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1190.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1190.395675, "o", "\r\n"]
[1190.42003, "o", "\r\n"]
[1190.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1190.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1190.493094, "o", "\r\n"]
[1190.517448, "o", "\r\n"]
[1190.541803, "o", "class TestIntervalIndex:\r\n"]
[1190.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1190.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1190.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1190.639222, "o", "\r\n"]
[1190.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1190.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1190.712286, "o", "        if sort is None:\r\n"]
[1190.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1190.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1190.78535, "o", "\r\n"]
[1190.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1190.834059, "o", "        if sort is None:\r\n"]
[1190.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1190.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1190.907123, "o", "\r\n"]
[1190.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1190.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1190.980187, "o", "\r\n"]
[1191.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1191.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1191.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1191.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1191.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1191.126315, "o", "\r\n"]
[1191.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1191.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1191.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1191.223734, "o", "        expected = other\r\n"]
[1191.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1191.272443, "o", "\r\n"]
[1191.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1191.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1191.345507, "o", "\r\n"]
[1191.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1191.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1191.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1191.442926, "o", "\r\n"]
[1191.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1191.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1191.51599, "o", "\r\n"]
[1191.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1191.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1191.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1191.613409, "o", "\r\n"]
[1191.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1191.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1191.686473, "o", "        if sort is None:\r\n"]
[1191.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1191.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1191.759537, "o", "\r\n"]
[1191.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1191.808246, "o", "        if sort is None:\r\n"]
[1191.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1191.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1191.88131, "o", "\r\n"]
[1191.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1191.93002, "o", "\r\n"]
[1191.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1191.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1192.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1192.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1192.051793, "o", "        result = index.intersection(other)\r\n"]
[1192.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1192.100502, "o", "\r\n"]
[1192.124857, "o", "        # GH 26225\r\n"]
[1192.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1192.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1192.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1192.222276, "o", "        result = index.intersection(other)\r\n"]
[1192.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1192.270985, "o", "\r\n"]
[1192.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1192.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1192.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1192.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1192.392759, "o", "        result = index.intersection(other)\r\n"]
[1192.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1192.441468, "o", "\r\n"]
[1192.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1192.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1192.514532, "o", "\r\n"]
[1192.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1192.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1192.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1192.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1192.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1192.66066, "o", "\r\n"]
[1192.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1192.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1192.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1192.758079, "o", "        expected = other[:0]\r\n"]
[1192.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1192.806788, "o", "\r\n"]
[1192.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1192.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1192.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1192.904207, "o", "\r\n"]
[1192.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1192.952916, "o", "        # GH#38743\r\n"]
[1192.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1193.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1193.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1193.050335, "o", "        result = index.intersection(other)\r\n"]
[1193.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1193.099044, "o", "\r\n"]
[1193.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1193.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1193.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1193.196463, "o", "        expected = index[1:]\r\n"]
[1193.220818, "o", "        if sort is None:\r\n"]
[1193.245172, "o", "            expected = expected.sort_values()\r\n"]
[1193.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1193.293882, "o", "\r\n"]
[1193.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1193.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1193.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1193.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1193.415655, "o", "\r\n"]
[1193.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1193.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1193.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1193.513074, "o", "        )\r\n"]
[1193.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1193.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1193.586138, "o", "\r\n"]
[1193.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1193.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1193.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1193.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1193.707911, "o", "        if sort is None:\r\n"]
[1193.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1193.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1193.780975, "o", "\r\n"]
[1193.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1193.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1193.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1193.878394, "o", "        if sort is None:\r\n"]
[1193.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1193.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1193.951458, "o", "\r\n"]
[1193.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1194.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1194.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1194.048877, "o", "        )\r\n"]
[1194.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1194.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1194.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1194.146296, "o", "\r\n"]
[1194.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1194.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1194.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1194.243714, "o", "    )\r\n"]
[1194.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1194.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1194.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1194.341133, "o", "\r\n"]
[1194.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1194.389842, "o", "        # non-IntervalIndex\r\n"]
[1194.414197, "o", "        if op_name == \"difference\":\r\n"]
[1194.438552, "o", "            expected = index\r\n"]
[1194.462906, "o", "        else:\r\n"]
[1194.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1194.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1194.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1194.560325, "o", "\r\n"]
[1194.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1194.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1194.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1194.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1194.682099, "o", "            if op_name == \"difference\":\r\n"]
[1194.706453, "o", "                expected = index\r\n"]
[1194.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1194.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1194.779517, "o", "\r\n"]
[1194.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1194.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1194.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1194.876936, "o", "        if op_name == \"difference\":\r\n"]
[1194.901291, "o", "            expected = index\r\n"]
[1194.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1195.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1195.002, "i", "cd asv_bench\r"]
[1195.004, "o", "cd asv_bench\r\n"]
[1195.006, "o", "\u001b[?2004l\r\n"]
[1200.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1200.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1200.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1205.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1205.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1205.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1205.418, "o", "\u001b[?2004l\r\n"]
[1205.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1206.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1206.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1207.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1207.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1207.89, "o", "              param1            \r\n"]
[1208.302, "o", "             -------- ----------\r\n"]
[1208.714, "o", "               1000    1.16\u00b10ms \r\n"]
[1209.126, "o", "              100000   73.8\u00b10ms \r\n"]
[1209.538, "o", "             ======== ==========\r\n"]
[1210.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1210.002, "i", "cd ..\r"]
[1210.004, "o", "cd ..\r\n"]
[1210.006, "o", "\u001b[?2004l\r\n"]
[1215.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1215.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1215.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1217.478, "o", "\u001b[?2004l\r\n"]
[1220.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1220.002, "i", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r"]
[1220.004, "o", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1222.478, "o", "\u001b[?2004l\r\n"]
[1225.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1225.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1225.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1225.040817, "o", "\u001b[?2004l\r\n"]
[1225.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1225.110451, "o", "\r\n"]
[1225.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1225.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1225.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1225.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1225.284535, "o", "\r\n"]
[1225.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1225.354169, "o", "    # Set Operations\r\n"]
[1225.388986, "o", "\r\n"]
[1225.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1225.45862, "o", "        \"\"\"\r\n"]
[1225.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1225.528254, "o", "        \"\"\"\r\n"]
[1225.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1225.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1225.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1225.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1225.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1225.737155, "o", "            # multiple NaNs\r\n"]
[1225.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1225.806789, "o", "        else:\r\n"]
[1225.841606, "o", "            # duplicates\r\n"]
[1225.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1225.911239, "o", "\r\n"]
[1225.946056, "o", "        if sort is None:\r\n"]
[1225.980873, "o", "            taken = taken.sort_values()\r\n"]
[1226.01569, "o", "\r\n"]
[1226.050507, "o", "        return taken\r\n"]
[1226.085324, "o", "\r\n"]
[1226.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1226.154958, "o", "        \"\"\"\r\n"]
[1226.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1226.224592, "o", "        no matter left or right.\r\n"]
[1226.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1226.294225, "o", "        Parameters\r\n"]
[1226.329042, "o", "        ----------\r\n"]
[1226.363859, "o", "        other : IntervalIndex\r\n"]
[1226.398676, "o", "        Returns\r\n"]
[1226.433493, "o", "        -------\r\n"]
[1226.46831, "o", "        IntervalIndex\r\n"]
[1226.503127, "o", "        \"\"\"\r\n"]
[1226.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1226.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1226.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1226.642394, "o", "\r\n"]
[1226.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1226.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1226.746845, "o", "        indexer = unique(indexer)\r\n"]
[1226.781662, "o", "\r\n"]
[1226.816479, "o", "        return self.take(indexer)\r\n"]
[1226.851296, "o", "\r\n"]
[1226.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1226.92093, "o", "        \"\"\"\r\n"]
[1226.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1226.990563, "o", "        on either sides.\r\n"]
[1227.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1227.060197, "o", "\r\n"]
[1227.095014, "o", "        Parameters\r\n"]
[1227.129831, "o", "        ----------\r\n"]
[1227.164648, "o", "        other : IntervalIndex\r\n"]
[1227.199465, "o", "\r\n"]
[1227.234282, "o", "        Returns\r\n"]
[1227.269099, "o", "        -------\r\n"]
[1227.303915, "o", "        IntervalIndex\r\n"]
[1227.338732, "o", "        \"\"\"\r\n"]
[1227.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1227.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1227.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1227.478, "o", "\r\n"]
[1227.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1227.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1227.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1227.617268, "o", "\r\n"]
[1227.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1227.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1227.721718, "o", "            if tup in other_tups:\r\n"]
[1227.756535, "o", "                mask[i] = True\r\n"]
[1227.791352, "o", "\r\n"]
[1227.826169, "o", "        return self[mask]\r\n"]
[1227.860986, "o", "\r\n"]
[1227.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1227.93062, "o", "\r\n"]
[1227.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1228.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1228.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1228.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1228.104704, "o", "        raise NotImplementedError(\r\n"]
[1228.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1228.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1228.209155, "o", "        )\r\n"]
[1228.243972, "o", "\r\n"]
[1228.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1228.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1228.348423, "o", "\r\n"]
[1228.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1228.418056, "o", "\r\n"]
[1228.452873, "o", "\r\n"]
[1228.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1228.522507, "o", "    \"\"\"\r\n"]
[1228.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1228.592141, "o", "    \"\"\"\r\n"]
[1228.626958, "o", "    return any(\r\n"]
[1228.661775, "o", "        [\r\n"]
[1228.696592, "o", "            is_number(endpoint),\r\n"]
[1228.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1228.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1228.801042, "o", "            endpoint is None,\r\n"]
[1228.835859, "o", "        ]\r\n"]
[1228.870676, "o", "    )\r\n"]
[1228.905493, "o", "\r\n"]
[1228.94031, "o", "\r\n"]
[1228.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1229.009944, "o", "    \"\"\"\r\n"]
[1229.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1229.079577, "o", "    \"\"\"\r\n"]
[1229.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1229.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1229.184028, "o", "    return (\r\n"]
[1229.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1229.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1229.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1229.323296, "o", "        or com.any_none(a, b)\r\n"]
[1229.358113, "o", "    )\r\n"]
[1229.39293, "o", "\r\n"]
[1229.427746, "o", "\r\n"]
[1229.462563, "o", "def interval_range(\r\n"]
[1229.49738, "o", "    start=None,\r\n"]
[1229.532197, "o", "    end=None,\r\n"]
[1229.567014, "o", "    periods=None,\r\n"]
[1229.601831, "o", "    freq=None,\r\n"]
[1229.636648, "o", "    name: Hashable = None,\r\n"]
[1229.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1229.706282, "o", ") -> IntervalIndex:\r\n"]
[1229.741099, "o", "    \"\"\"\r\n"]
[1229.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1229.810732, "o", "\r\n"]
[1229.845549, "o", "    Parameters\r\n"]
[1229.880366, "o", "    ----------\r\n"]
[1229.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1230.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1230.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1230.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1230.040817, "o", "\u001b[?2004l\r\n"]
[1230.075634, "o", "        Left bound for generating intervals.\r\n"]
[1230.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1230.145268, "o", "        Right bound for generating intervals.\r\n"]
[1230.180085, "o", "    periods : int, default None\r\n"]
[1230.214901, "o", "        Number of periods to generate.\r\n"]
[1230.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1230.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1230.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1230.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1230.388986, "o", "    name : str, default None\r\n"]
[1230.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1230.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1230.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1230.528254, "o", "        or neither.\r\n"]
[1230.56307, "o", "\r\n"]
[1230.597887, "o", "    Returns\r\n"]
[1230.632704, "o", "    -------\r\n"]
[1230.667521, "o", "    IntervalIndex\r\n"]
[1230.702338, "o", "\r\n"]
[1230.737155, "o", "    See Also\r\n"]
[1230.771972, "o", "    --------\r\n"]
[1230.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1230.841606, "o", "\r\n"]
[1230.876423, "o", "    Notes\r\n"]
[1230.911239, "o", "    -----\r\n"]
[1230.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1230.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1231.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1231.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1231.085324, "o", "\r\n"]
[1231.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1231.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1231.189775, "o", "\r\n"]
[1231.224592, "o", "    Examples\r\n"]
[1231.259408, "o", "    --------\r\n"]
[1231.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1231.329042, "o", "\r\n"]
[1231.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1231.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1231.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1231.46831, "o", "\r\n"]
[1231.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1231.537944, "o", "\r\n"]
[1231.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1231.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1231.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1231.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1231.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1231.746845, "o", "\r\n"]
[1231.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1231.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1231.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1231.886113, "o", "\r\n"]
[1231.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1231.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1231.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1232.02538, "o", "\r\n"]
[1232.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1232.095014, "o", "    convertible to a DateOffset.\r\n"]
[1232.129831, "o", "\r\n"]
[1232.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1232.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1232.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1232.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1232.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1232.338732, "o", "\r\n"]
[1232.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1232.408366, "o", "    automatically (linearly spaced).\r\n"]
[1232.443183, "o", "\r\n"]
[1232.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1232.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1232.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1232.582451, "o", "\r\n"]
[1232.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1232.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1232.686901, "o", "\r\n"]
[1232.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1232.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1232.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1232.826169, "o", "    \"\"\"\r\n"]
[1232.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1232.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1232.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1232.965437, "o", "\r\n"]
[1233.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1233.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1233.069887, "o", "\r\n"]
[1233.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1233.139521, "o", "        raise ValueError(\r\n"]
[1233.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1233.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1233.243972, "o", "        )\r\n"]
[1233.278789, "o", "\r\n"]
[1233.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1233.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1233.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1233.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1233.452873, "o", "\r\n"]
[1233.48769, "o", "    if is_float(periods):\r\n"]
[1233.522507, "o", "        periods = int(periods)\r\n"]
[1233.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1233.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1233.626958, "o", "\r\n"]
[1233.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1233.696592, "o", "        try:\r\n"]
[1233.731408, "o", "            freq = to_offset(freq)\r\n"]
[1233.766225, "o", "        except ValueError as err:\r\n"]
[1233.801042, "o", "            raise ValueError(\r\n"]
[1233.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1233.870676, "o", "            ) from err\r\n"]
[1233.905493, "o", "\r\n"]
[1233.94031, "o", "    # verify type compatibility\r\n"]
[1233.975127, "o", "    if not all(\r\n"]
[1234.009944, "o", "        [\r\n"]
[1234.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1234.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1234.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1234.149211, "o", "        ]\r\n"]
[1234.184028, "o", "    ):\r\n"]
[1234.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1234.253662, "o", "\r\n"]
[1234.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1234.323296, "o", "    if periods is not None:\r\n"]
[1234.358113, "o", "        periods += 1\r\n"]
[1234.39293, "o", "\r\n"]
[1234.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1234.462563, "o", "\r\n"]
[1234.49738, "o", "    if is_number(endpoint):\r\n"]
[1234.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1234.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1234.601831, "o", "            end -= (end - start) % freq\r\n"]
[1234.636648, "o", "\r\n"]
[1234.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1234.706282, "o", "        if periods is None:\r\n"]
[1234.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1234.775915, "o", "        elif start is None:\r\n"]
[1234.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1234.845549, "o", "        elif end is None:\r\n"]
[1234.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1234.915183, "o", "\r\n"]
[1235.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1235.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1235.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1235.030355, "o", "\u001b[?2004l\r\n"]
[1235.054709, "o", "import numpy as np\r\n"]
[1235.079064, "o", "import pytest\r\n"]
[1235.103419, "o", "\r\n"]
[1235.127773, "o", "from pandas import (\r\n"]
[1235.152128, "o", "    Index,\r\n"]
[1235.176483, "o", "    IntervalIndex,\r\n"]
[1235.200837, "o", "    Timestamp,\r\n"]
[1235.225192, "o", "    interval_range,\r\n"]
[1235.249547, "o", ")\r\n"]
[1235.273901, "o", "import pandas._testing as tm\r\n"]
[1235.298256, "o", "\r\n"]
[1235.322611, "o", "\r\n"]
[1235.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1235.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1235.395675, "o", "\r\n"]
[1235.42003, "o", "\r\n"]
[1235.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1235.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1235.493094, "o", "\r\n"]
[1235.517448, "o", "\r\n"]
[1235.541803, "o", "class TestIntervalIndex:\r\n"]
[1235.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1235.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1235.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1235.639222, "o", "\r\n"]
[1235.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1235.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1235.712286, "o", "        if sort is None:\r\n"]
[1235.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1235.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1235.78535, "o", "\r\n"]
[1235.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1235.834059, "o", "        if sort is None:\r\n"]
[1235.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1235.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1235.907123, "o", "\r\n"]
[1235.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1235.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1235.980187, "o", "\r\n"]
[1236.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1236.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1236.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1236.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1236.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1236.126315, "o", "\r\n"]
[1236.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1236.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1236.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1236.223734, "o", "        expected = other\r\n"]
[1236.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1236.272443, "o", "\r\n"]
[1236.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1236.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1236.345507, "o", "\r\n"]
[1236.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1236.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1236.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1236.442926, "o", "\r\n"]
[1236.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1236.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1236.51599, "o", "\r\n"]
[1236.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1236.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1236.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1236.613409, "o", "\r\n"]
[1236.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1236.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1236.686473, "o", "        if sort is None:\r\n"]
[1236.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1236.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1236.759537, "o", "\r\n"]
[1236.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1236.808246, "o", "        if sort is None:\r\n"]
[1236.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1236.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1236.88131, "o", "\r\n"]
[1236.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1236.93002, "o", "\r\n"]
[1236.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1236.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1237.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1237.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1237.051793, "o", "        result = index.intersection(other)\r\n"]
[1237.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1237.100502, "o", "\r\n"]
[1237.124857, "o", "        # GH 26225\r\n"]
[1237.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1237.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1237.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1237.222276, "o", "        result = index.intersection(other)\r\n"]
[1237.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1237.270985, "o", "\r\n"]
[1237.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1237.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1237.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1237.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1237.392759, "o", "        result = index.intersection(other)\r\n"]
[1237.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1237.441468, "o", "\r\n"]
[1237.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1237.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1237.514532, "o", "\r\n"]
[1237.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1237.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1237.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1237.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1237.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1237.66066, "o", "\r\n"]
[1237.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1237.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1237.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1237.758079, "o", "        expected = other[:0]\r\n"]
[1237.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1237.806788, "o", "\r\n"]
[1237.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1237.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1237.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1237.904207, "o", "\r\n"]
[1237.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1237.952916, "o", "        # GH#38743\r\n"]
[1237.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1238.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1238.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1238.050335, "o", "        result = index.intersection(other)\r\n"]
[1238.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1238.099044, "o", "\r\n"]
[1238.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1238.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1238.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1238.196463, "o", "        expected = index[1:]\r\n"]
[1238.220818, "o", "        if sort is None:\r\n"]
[1238.245172, "o", "            expected = expected.sort_values()\r\n"]
[1238.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1238.293882, "o", "\r\n"]
[1238.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1238.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1238.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1238.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1238.415655, "o", "\r\n"]
[1238.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1238.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1238.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1238.513074, "o", "        )\r\n"]
[1238.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1238.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1238.586138, "o", "\r\n"]
[1238.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1238.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1238.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1238.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1238.707911, "o", "        if sort is None:\r\n"]
[1238.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1238.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1238.780975, "o", "\r\n"]
[1238.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1238.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1238.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1238.878394, "o", "        if sort is None:\r\n"]
[1238.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1238.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1238.951458, "o", "\r\n"]
[1238.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1239.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1239.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1239.048877, "o", "        )\r\n"]
[1239.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1239.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1239.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1239.146296, "o", "\r\n"]
[1239.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1239.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1239.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1239.243714, "o", "    )\r\n"]
[1239.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1239.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1239.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1239.341133, "o", "\r\n"]
[1239.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1239.389842, "o", "        # non-IntervalIndex\r\n"]
[1239.414197, "o", "        if op_name == \"difference\":\r\n"]
[1239.438552, "o", "            expected = index\r\n"]
[1239.462906, "o", "        else:\r\n"]
[1239.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1239.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1239.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1239.560325, "o", "\r\n"]
[1239.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1239.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1239.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1239.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1239.682099, "o", "            if op_name == \"difference\":\r\n"]
[1239.706453, "o", "                expected = index\r\n"]
[1239.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1239.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1239.779517, "o", "\r\n"]
[1239.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1239.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1239.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1239.876936, "o", "        if op_name == \"difference\":\r\n"]
[1239.901291, "o", "            expected = index\r\n"]
[1239.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1240.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1240.002, "i", "cd asv_bench\r"]
[1240.004, "o", "cd asv_bench\r\n"]
[1240.006, "o", "\u001b[?2004l\r\n"]
[1245.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1245.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1245.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1250.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1250.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1250.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1250.418, "o", "\u001b[?2004l\r\n"]
[1250.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1251.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1251.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1252.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1252.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1252.89, "o", "              param1            \r\n"]
[1253.302, "o", "             -------- ----------\r\n"]
[1253.714, "o", "               1000    1.18\u00b10ms \r\n"]
[1254.126, "o", "              100000   74.2\u00b10ms \r\n"]
[1254.538, "o", "             ======== ==========\r\n"]
[1255.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1255.002, "i", "cd ..\r"]
[1255.004, "o", "cd ..\r\n"]
[1255.006, "o", "\u001b[?2004l\r\n"]
[1260.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1260.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1260.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1262.478, "o", "\u001b[?2004l\r\n"]
[1265.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1265.002, "i", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r"]
[1265.004, "o", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1267.478, "o", "\u001b[?2004l\r\n"]
[1270.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1270.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1270.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1270.040817, "o", "\u001b[?2004l\r\n"]
[1270.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1270.110451, "o", "\r\n"]
[1270.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1270.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1270.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1270.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1270.284535, "o", "\r\n"]
[1270.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1270.354169, "o", "    # Set Operations\r\n"]
[1270.388986, "o", "\r\n"]
[1270.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1270.45862, "o", "        \"\"\"\r\n"]
[1270.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1270.528254, "o", "        \"\"\"\r\n"]
[1270.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1270.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1270.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1270.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1270.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1270.737155, "o", "            # multiple NaNs\r\n"]
[1270.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1270.806789, "o", "        else:\r\n"]
[1270.841606, "o", "            # duplicates\r\n"]
[1270.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1270.911239, "o", "\r\n"]
[1270.946056, "o", "        if sort is None:\r\n"]
[1270.980873, "o", "            taken = taken.sort_values()\r\n"]
[1271.01569, "o", "\r\n"]
[1271.050507, "o", "        return taken\r\n"]
[1271.085324, "o", "\r\n"]
[1271.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1271.154958, "o", "        \"\"\"\r\n"]
[1271.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1271.224592, "o", "        no matter left or right.\r\n"]
[1271.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1271.294225, "o", "        Parameters\r\n"]
[1271.329042, "o", "        ----------\r\n"]
[1271.363859, "o", "        other : IntervalIndex\r\n"]
[1271.398676, "o", "        Returns\r\n"]
[1271.433493, "o", "        -------\r\n"]
[1271.46831, "o", "        IntervalIndex\r\n"]
[1271.503127, "o", "        \"\"\"\r\n"]
[1271.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1271.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1271.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1271.642394, "o", "\r\n"]
[1271.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1271.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1271.746845, "o", "        indexer = unique(indexer)\r\n"]
[1271.781662, "o", "\r\n"]
[1271.816479, "o", "        return self.take(indexer)\r\n"]
[1271.851296, "o", "\r\n"]
[1271.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1271.92093, "o", "        \"\"\"\r\n"]
[1271.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1271.990563, "o", "        on either sides.\r\n"]
[1272.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1272.060197, "o", "\r\n"]
[1272.095014, "o", "        Parameters\r\n"]
[1272.129831, "o", "        ----------\r\n"]
[1272.164648, "o", "        other : IntervalIndex\r\n"]
[1272.199465, "o", "\r\n"]
[1272.234282, "o", "        Returns\r\n"]
[1272.269099, "o", "        -------\r\n"]
[1272.303915, "o", "        IntervalIndex\r\n"]
[1272.338732, "o", "        \"\"\"\r\n"]
[1272.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1272.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1272.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1272.478, "o", "\r\n"]
[1272.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1272.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1272.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1272.617268, "o", "\r\n"]
[1272.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1272.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1272.721718, "o", "            if tup in other_tups:\r\n"]
[1272.756535, "o", "                mask[i] = True\r\n"]
[1272.791352, "o", "\r\n"]
[1272.826169, "o", "        return self[mask]\r\n"]
[1272.860986, "o", "\r\n"]
[1272.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1272.93062, "o", "\r\n"]
[1272.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1273.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1273.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1273.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1273.104704, "o", "        raise NotImplementedError(\r\n"]
[1273.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1273.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1273.209155, "o", "        )\r\n"]
[1273.243972, "o", "\r\n"]
[1273.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1273.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1273.348423, "o", "\r\n"]
[1273.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1273.418056, "o", "\r\n"]
[1273.452873, "o", "\r\n"]
[1273.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1273.522507, "o", "    \"\"\"\r\n"]
[1273.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1273.592141, "o", "    \"\"\"\r\n"]
[1273.626958, "o", "    return any(\r\n"]
[1273.661775, "o", "        [\r\n"]
[1273.696592, "o", "            is_number(endpoint),\r\n"]
[1273.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1273.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1273.801042, "o", "            endpoint is None,\r\n"]
[1273.835859, "o", "        ]\r\n"]
[1273.870676, "o", "    )\r\n"]
[1273.905493, "o", "\r\n"]
[1273.94031, "o", "\r\n"]
[1273.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1274.009944, "o", "    \"\"\"\r\n"]
[1274.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1274.079577, "o", "    \"\"\"\r\n"]
[1274.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1274.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1274.184028, "o", "    return (\r\n"]
[1274.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1274.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1274.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1274.323296, "o", "        or com.any_none(a, b)\r\n"]
[1274.358113, "o", "    )\r\n"]
[1274.39293, "o", "\r\n"]
[1274.427746, "o", "\r\n"]
[1274.462563, "o", "def interval_range(\r\n"]
[1274.49738, "o", "    start=None,\r\n"]
[1274.532197, "o", "    end=None,\r\n"]
[1274.567014, "o", "    periods=None,\r\n"]
[1274.601831, "o", "    freq=None,\r\n"]
[1274.636648, "o", "    name: Hashable = None,\r\n"]
[1274.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1274.706282, "o", ") -> IntervalIndex:\r\n"]
[1274.741099, "o", "    \"\"\"\r\n"]
[1274.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1274.810732, "o", "\r\n"]
[1274.845549, "o", "    Parameters\r\n"]
[1274.880366, "o", "    ----------\r\n"]
[1274.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1275.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1275.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1275.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1275.040817, "o", "\u001b[?2004l\r\n"]
[1275.075634, "o", "        Left bound for generating intervals.\r\n"]
[1275.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1275.145268, "o", "        Right bound for generating intervals.\r\n"]
[1275.180085, "o", "    periods : int, default None\r\n"]
[1275.214901, "o", "        Number of periods to generate.\r\n"]
[1275.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1275.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1275.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1275.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1275.388986, "o", "    name : str, default None\r\n"]
[1275.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1275.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1275.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1275.528254, "o", "        or neither.\r\n"]
[1275.56307, "o", "\r\n"]
[1275.597887, "o", "    Returns\r\n"]
[1275.632704, "o", "    -------\r\n"]
[1275.667521, "o", "    IntervalIndex\r\n"]
[1275.702338, "o", "\r\n"]
[1275.737155, "o", "    See Also\r\n"]
[1275.771972, "o", "    --------\r\n"]
[1275.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1275.841606, "o", "\r\n"]
[1275.876423, "o", "    Notes\r\n"]
[1275.911239, "o", "    -----\r\n"]
[1275.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1275.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1276.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1276.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1276.085324, "o", "\r\n"]
[1276.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1276.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1276.189775, "o", "\r\n"]
[1276.224592, "o", "    Examples\r\n"]
[1276.259408, "o", "    --------\r\n"]
[1276.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1276.329042, "o", "\r\n"]
[1276.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1276.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1276.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1276.46831, "o", "\r\n"]
[1276.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1276.537944, "o", "\r\n"]
[1276.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1276.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1276.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1276.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1276.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1276.746845, "o", "\r\n"]
[1276.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1276.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1276.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1276.886113, "o", "\r\n"]
[1276.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1276.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1276.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1277.02538, "o", "\r\n"]
[1277.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1277.095014, "o", "    convertible to a DateOffset.\r\n"]
[1277.129831, "o", "\r\n"]
[1277.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1277.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1277.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1277.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1277.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1277.338732, "o", "\r\n"]
[1277.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1277.408366, "o", "    automatically (linearly spaced).\r\n"]
[1277.443183, "o", "\r\n"]
[1277.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1277.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1277.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1277.582451, "o", "\r\n"]
[1277.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1277.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1277.686901, "o", "\r\n"]
[1277.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1277.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1277.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1277.826169, "o", "    \"\"\"\r\n"]
[1277.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1277.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1277.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1277.965437, "o", "\r\n"]
[1278.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1278.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1278.069887, "o", "\r\n"]
[1278.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1278.139521, "o", "        raise ValueError(\r\n"]
[1278.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1278.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1278.243972, "o", "        )\r\n"]
[1278.278789, "o", "\r\n"]
[1278.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1278.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1278.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1278.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1278.452873, "o", "\r\n"]
[1278.48769, "o", "    if is_float(periods):\r\n"]
[1278.522507, "o", "        periods = int(periods)\r\n"]
[1278.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1278.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1278.626958, "o", "\r\n"]
[1278.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1278.696592, "o", "        try:\r\n"]
[1278.731408, "o", "            freq = to_offset(freq)\r\n"]
[1278.766225, "o", "        except ValueError as err:\r\n"]
[1278.801042, "o", "            raise ValueError(\r\n"]
[1278.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1278.870676, "o", "            ) from err\r\n"]
[1278.905493, "o", "\r\n"]
[1278.94031, "o", "    # verify type compatibility\r\n"]
[1278.975127, "o", "    if not all(\r\n"]
[1279.009944, "o", "        [\r\n"]
[1279.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1279.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1279.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1279.149211, "o", "        ]\r\n"]
[1279.184028, "o", "    ):\r\n"]
[1279.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1279.253662, "o", "\r\n"]
[1279.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1279.323296, "o", "    if periods is not None:\r\n"]
[1279.358113, "o", "        periods += 1\r\n"]
[1279.39293, "o", "\r\n"]
[1279.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1279.462563, "o", "\r\n"]
[1279.49738, "o", "    if is_number(endpoint):\r\n"]
[1279.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1279.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1279.601831, "o", "            end -= (end - start) % freq\r\n"]
[1279.636648, "o", "\r\n"]
[1279.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1279.706282, "o", "        if periods is None:\r\n"]
[1279.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1279.775915, "o", "        elif start is None:\r\n"]
[1279.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1279.845549, "o", "        elif end is None:\r\n"]
[1279.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1279.915183, "o", "\r\n"]
[1280.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1280.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1280.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1280.030355, "o", "\u001b[?2004l\r\n"]
[1280.054709, "o", "import numpy as np\r\n"]
[1280.079064, "o", "import pytest\r\n"]
[1280.103419, "o", "\r\n"]
[1280.127773, "o", "from pandas import (\r\n"]
[1280.152128, "o", "    Index,\r\n"]
[1280.176483, "o", "    IntervalIndex,\r\n"]
[1280.200837, "o", "    Timestamp,\r\n"]
[1280.225192, "o", "    interval_range,\r\n"]
[1280.249547, "o", ")\r\n"]
[1280.273901, "o", "import pandas._testing as tm\r\n"]
[1280.298256, "o", "\r\n"]
[1280.322611, "o", "\r\n"]
[1280.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1280.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1280.395675, "o", "\r\n"]
[1280.42003, "o", "\r\n"]
[1280.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1280.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1280.493094, "o", "\r\n"]
[1280.517448, "o", "\r\n"]
[1280.541803, "o", "class TestIntervalIndex:\r\n"]
[1280.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1280.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1280.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1280.639222, "o", "\r\n"]
[1280.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1280.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1280.712286, "o", "        if sort is None:\r\n"]
[1280.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1280.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1280.78535, "o", "\r\n"]
[1280.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1280.834059, "o", "        if sort is None:\r\n"]
[1280.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1280.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1280.907123, "o", "\r\n"]
[1280.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1280.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1280.980187, "o", "\r\n"]
[1281.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1281.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1281.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1281.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1281.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1281.126315, "o", "\r\n"]
[1281.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1281.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1281.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1281.223734, "o", "        expected = other\r\n"]
[1281.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1281.272443, "o", "\r\n"]
[1281.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1281.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1281.345507, "o", "\r\n"]
[1281.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1281.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1281.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1281.442926, "o", "\r\n"]
[1281.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1281.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1281.51599, "o", "\r\n"]
[1281.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1281.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1281.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1281.613409, "o", "\r\n"]
[1281.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1281.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1281.686473, "o", "        if sort is None:\r\n"]
[1281.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1281.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1281.759537, "o", "\r\n"]
[1281.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1281.808246, "o", "        if sort is None:\r\n"]
[1281.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1281.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1281.88131, "o", "\r\n"]
[1281.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1281.93002, "o", "\r\n"]
[1281.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1281.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1282.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1282.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1282.051793, "o", "        result = index.intersection(other)\r\n"]
[1282.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1282.100502, "o", "\r\n"]
[1282.124857, "o", "        # GH 26225\r\n"]
[1282.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1282.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1282.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1282.222276, "o", "        result = index.intersection(other)\r\n"]
[1282.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1282.270985, "o", "\r\n"]
[1282.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1282.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1282.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1282.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1282.392759, "o", "        result = index.intersection(other)\r\n"]
[1282.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1282.441468, "o", "\r\n"]
[1282.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1282.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1282.514532, "o", "\r\n"]
[1282.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1282.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1282.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1282.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1282.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1282.66066, "o", "\r\n"]
[1282.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1282.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1282.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1282.758079, "o", "        expected = other[:0]\r\n"]
[1282.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1282.806788, "o", "\r\n"]
[1282.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1282.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1282.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1282.904207, "o", "\r\n"]
[1282.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1282.952916, "o", "        # GH#38743\r\n"]
[1282.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1283.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1283.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1283.050335, "o", "        result = index.intersection(other)\r\n"]
[1283.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1283.099044, "o", "\r\n"]
[1283.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1283.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1283.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1283.196463, "o", "        expected = index[1:]\r\n"]
[1283.220818, "o", "        if sort is None:\r\n"]
[1283.245172, "o", "            expected = expected.sort_values()\r\n"]
[1283.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1283.293882, "o", "\r\n"]
[1283.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1283.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1283.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1283.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1283.415655, "o", "\r\n"]
[1283.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1283.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1283.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1283.513074, "o", "        )\r\n"]
[1283.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1283.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1283.586138, "o", "\r\n"]
[1283.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1283.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1283.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1283.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1283.707911, "o", "        if sort is None:\r\n"]
[1283.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1283.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1283.780975, "o", "\r\n"]
[1283.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1283.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1283.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1283.878394, "o", "        if sort is None:\r\n"]
[1283.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1283.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1283.951458, "o", "\r\n"]
[1283.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1284.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1284.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1284.048877, "o", "        )\r\n"]
[1284.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1284.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1284.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1284.146296, "o", "\r\n"]
[1284.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1284.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1284.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1284.243714, "o", "    )\r\n"]
[1284.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1284.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1284.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1284.341133, "o", "\r\n"]
[1284.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1284.389842, "o", "        # non-IntervalIndex\r\n"]
[1284.414197, "o", "        if op_name == \"difference\":\r\n"]
[1284.438552, "o", "            expected = index\r\n"]
[1284.462906, "o", "        else:\r\n"]
[1284.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1284.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1284.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1284.560325, "o", "\r\n"]
[1284.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1284.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1284.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1284.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1284.682099, "o", "            if op_name == \"difference\":\r\n"]
[1284.706453, "o", "                expected = index\r\n"]
[1284.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1284.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1284.779517, "o", "\r\n"]
[1284.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1284.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1284.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1284.876936, "o", "        if op_name == \"difference\":\r\n"]
[1284.901291, "o", "            expected = index\r\n"]
[1284.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1285.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1285.002, "i", "cd asv_bench\r"]
[1285.004, "o", "cd asv_bench\r\n"]
[1285.006, "o", "\u001b[?2004l\r\n"]
[1290.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1290.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1290.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1295.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1295.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1295.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1295.418, "o", "\u001b[?2004l\r\n"]
[1295.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1296.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1296.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1297.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1297.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1297.89, "o", "              param1            \r\n"]
[1298.302, "o", "             -------- ----------\r\n"]
[1298.714, "o", "               1000    1.22\u00b10ms \r\n"]
[1299.126, "o", "              100000   107\u00b10ms  \r\n"]
[1299.538, "o", "             ======== ==========\r\n"]
[1300.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1300.002, "i", "cd ..\r"]
[1300.004, "o", "cd ..\r\n"]
[1300.006, "o", "\u001b[?2004l\r\n"]
[1305.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1305.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1305.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1307.478, "o", "\u001b[?2004l\r\n"]
[1310.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1310.002, "i", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r"]
[1310.004, "o", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1312.478, "o", "\u001b[?2004l\r\n"]
[1315.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1315.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1315.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1315.040817, "o", "\u001b[?2004l\r\n"]
[1315.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1315.110451, "o", "\r\n"]
[1315.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1315.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1315.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1315.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1315.284535, "o", "\r\n"]
[1315.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1315.354169, "o", "    # Set Operations\r\n"]
[1315.388986, "o", "\r\n"]
[1315.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1315.45862, "o", "        \"\"\"\r\n"]
[1315.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1315.528254, "o", "        \"\"\"\r\n"]
[1315.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1315.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1315.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1315.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1315.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1315.737155, "o", "            # multiple NaNs\r\n"]
[1315.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1315.806789, "o", "        else:\r\n"]
[1315.841606, "o", "            # duplicates\r\n"]
[1315.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1315.911239, "o", "\r\n"]
[1315.946056, "o", "        if sort is None:\r\n"]
[1315.980873, "o", "            taken = taken.sort_values()\r\n"]
[1316.01569, "o", "\r\n"]
[1316.050507, "o", "        return taken\r\n"]
[1316.085324, "o", "\r\n"]
[1316.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1316.154958, "o", "        \"\"\"\r\n"]
[1316.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1316.224592, "o", "        no matter left or right.\r\n"]
[1316.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1316.294225, "o", "        Parameters\r\n"]
[1316.329042, "o", "        ----------\r\n"]
[1316.363859, "o", "        other : IntervalIndex\r\n"]
[1316.398676, "o", "        Returns\r\n"]
[1316.433493, "o", "        -------\r\n"]
[1316.46831, "o", "        IntervalIndex\r\n"]
[1316.503127, "o", "        \"\"\"\r\n"]
[1316.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1316.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1316.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1316.642394, "o", "\r\n"]
[1316.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1316.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1316.746845, "o", "        indexer = unique(indexer)\r\n"]
[1316.781662, "o", "\r\n"]
[1316.816479, "o", "        return self.take(indexer)\r\n"]
[1316.851296, "o", "\r\n"]
[1316.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1316.92093, "o", "        \"\"\"\r\n"]
[1316.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1316.990563, "o", "        on either sides.\r\n"]
[1317.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1317.060197, "o", "\r\n"]
[1317.095014, "o", "        Parameters\r\n"]
[1317.129831, "o", "        ----------\r\n"]
[1317.164648, "o", "        other : IntervalIndex\r\n"]
[1317.199465, "o", "\r\n"]
[1317.234282, "o", "        Returns\r\n"]
[1317.269099, "o", "        -------\r\n"]
[1317.303915, "o", "        IntervalIndex\r\n"]
[1317.338732, "o", "        \"\"\"\r\n"]
[1317.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1317.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1317.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1317.478, "o", "\r\n"]
[1317.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1317.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1317.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1317.617268, "o", "\r\n"]
[1317.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1317.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1317.721718, "o", "            if tup in other_tups:\r\n"]
[1317.756535, "o", "                mask[i] = True\r\n"]
[1317.791352, "o", "\r\n"]
[1317.826169, "o", "        return self[mask]\r\n"]
[1317.860986, "o", "\r\n"]
[1317.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1317.93062, "o", "\r\n"]
[1317.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1318.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1318.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1318.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1318.104704, "o", "        raise NotImplementedError(\r\n"]
[1318.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1318.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1318.209155, "o", "        )\r\n"]
[1318.243972, "o", "\r\n"]
[1318.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1318.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1318.348423, "o", "\r\n"]
[1318.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1318.418056, "o", "\r\n"]
[1318.452873, "o", "\r\n"]
[1318.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1318.522507, "o", "    \"\"\"\r\n"]
[1318.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1318.592141, "o", "    \"\"\"\r\n"]
[1318.626958, "o", "    return any(\r\n"]
[1318.661775, "o", "        [\r\n"]
[1318.696592, "o", "            is_number(endpoint),\r\n"]
[1318.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1318.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1318.801042, "o", "            endpoint is None,\r\n"]
[1318.835859, "o", "        ]\r\n"]
[1318.870676, "o", "    )\r\n"]
[1318.905493, "o", "\r\n"]
[1318.94031, "o", "\r\n"]
[1318.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1319.009944, "o", "    \"\"\"\r\n"]
[1319.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1319.079577, "o", "    \"\"\"\r\n"]
[1319.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1319.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1319.184028, "o", "    return (\r\n"]
[1319.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1319.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1319.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1319.323296, "o", "        or com.any_none(a, b)\r\n"]
[1319.358113, "o", "    )\r\n"]
[1319.39293, "o", "\r\n"]
[1319.427746, "o", "\r\n"]
[1319.462563, "o", "def interval_range(\r\n"]
[1319.49738, "o", "    start=None,\r\n"]
[1319.532197, "o", "    end=None,\r\n"]
[1319.567014, "o", "    periods=None,\r\n"]
[1319.601831, "o", "    freq=None,\r\n"]
[1319.636648, "o", "    name: Hashable = None,\r\n"]
[1319.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1319.706282, "o", ") -> IntervalIndex:\r\n"]
[1319.741099, "o", "    \"\"\"\r\n"]
[1319.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1319.810732, "o", "\r\n"]
[1319.845549, "o", "    Parameters\r\n"]
[1319.880366, "o", "    ----------\r\n"]
[1319.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1320.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1320.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1320.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1320.040817, "o", "\u001b[?2004l\r\n"]
[1320.075634, "o", "        Left bound for generating intervals.\r\n"]
[1320.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1320.145268, "o", "        Right bound for generating intervals.\r\n"]
[1320.180085, "o", "    periods : int, default None\r\n"]
[1320.214901, "o", "        Number of periods to generate.\r\n"]
[1320.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1320.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1320.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1320.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1320.388986, "o", "    name : str, default None\r\n"]
[1320.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1320.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1320.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1320.528254, "o", "        or neither.\r\n"]
[1320.56307, "o", "\r\n"]
[1320.597887, "o", "    Returns\r\n"]
[1320.632704, "o", "    -------\r\n"]
[1320.667521, "o", "    IntervalIndex\r\n"]
[1320.702338, "o", "\r\n"]
[1320.737155, "o", "    See Also\r\n"]
[1320.771972, "o", "    --------\r\n"]
[1320.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1320.841606, "o", "\r\n"]
[1320.876423, "o", "    Notes\r\n"]
[1320.911239, "o", "    -----\r\n"]
[1320.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1320.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1321.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1321.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1321.085324, "o", "\r\n"]
[1321.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1321.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1321.189775, "o", "\r\n"]
[1321.224592, "o", "    Examples\r\n"]
[1321.259408, "o", "    --------\r\n"]
[1321.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1321.329042, "o", "\r\n"]
[1321.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1321.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1321.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1321.46831, "o", "\r\n"]
[1321.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1321.537944, "o", "\r\n"]
[1321.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1321.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1321.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1321.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1321.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1321.746845, "o", "\r\n"]
[1321.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1321.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1321.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1321.886113, "o", "\r\n"]
[1321.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1321.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1321.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1322.02538, "o", "\r\n"]
[1322.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1322.095014, "o", "    convertible to a DateOffset.\r\n"]
[1322.129831, "o", "\r\n"]
[1322.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1322.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1322.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1322.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1322.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1322.338732, "o", "\r\n"]
[1322.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1322.408366, "o", "    automatically (linearly spaced).\r\n"]
[1322.443183, "o", "\r\n"]
[1322.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1322.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1322.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1322.582451, "o", "\r\n"]
[1322.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1322.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1322.686901, "o", "\r\n"]
[1322.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1322.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1322.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1322.826169, "o", "    \"\"\"\r\n"]
[1322.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1322.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1322.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1322.965437, "o", "\r\n"]
[1323.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1323.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1323.069887, "o", "\r\n"]
[1323.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1323.139521, "o", "        raise ValueError(\r\n"]
[1323.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1323.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1323.243972, "o", "        )\r\n"]
[1323.278789, "o", "\r\n"]
[1323.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1323.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1323.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1323.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1323.452873, "o", "\r\n"]
[1323.48769, "o", "    if is_float(periods):\r\n"]
[1323.522507, "o", "        periods = int(periods)\r\n"]
[1323.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1323.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1323.626958, "o", "\r\n"]
[1323.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1323.696592, "o", "        try:\r\n"]
[1323.731408, "o", "            freq = to_offset(freq)\r\n"]
[1323.766225, "o", "        except ValueError as err:\r\n"]
[1323.801042, "o", "            raise ValueError(\r\n"]
[1323.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1323.870676, "o", "            ) from err\r\n"]
[1323.905493, "o", "\r\n"]
[1323.94031, "o", "    # verify type compatibility\r\n"]
[1323.975127, "o", "    if not all(\r\n"]
[1324.009944, "o", "        [\r\n"]
[1324.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1324.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1324.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1324.149211, "o", "        ]\r\n"]
[1324.184028, "o", "    ):\r\n"]
[1324.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1324.253662, "o", "\r\n"]
[1324.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1324.323296, "o", "    if periods is not None:\r\n"]
[1324.358113, "o", "        periods += 1\r\n"]
[1324.39293, "o", "\r\n"]
[1324.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1324.462563, "o", "\r\n"]
[1324.49738, "o", "    if is_number(endpoint):\r\n"]
[1324.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1324.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1324.601831, "o", "            end -= (end - start) % freq\r\n"]
[1324.636648, "o", "\r\n"]
[1324.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1324.706282, "o", "        if periods is None:\r\n"]
[1324.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1324.775915, "o", "        elif start is None:\r\n"]
[1324.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1324.845549, "o", "        elif end is None:\r\n"]
[1324.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1324.915183, "o", "\r\n"]
[1325.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1325.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1325.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1325.030355, "o", "\u001b[?2004l\r\n"]
[1325.054709, "o", "import numpy as np\r\n"]
[1325.079064, "o", "import pytest\r\n"]
[1325.103419, "o", "\r\n"]
[1325.127773, "o", "from pandas import (\r\n"]
[1325.152128, "o", "    Index,\r\n"]
[1325.176483, "o", "    IntervalIndex,\r\n"]
[1325.200837, "o", "    Timestamp,\r\n"]
[1325.225192, "o", "    interval_range,\r\n"]
[1325.249547, "o", ")\r\n"]
[1325.273901, "o", "import pandas._testing as tm\r\n"]
[1325.298256, "o", "\r\n"]
[1325.322611, "o", "\r\n"]
[1325.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1325.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1325.395675, "o", "\r\n"]
[1325.42003, "o", "\r\n"]
[1325.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1325.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1325.493094, "o", "\r\n"]
[1325.517448, "o", "\r\n"]
[1325.541803, "o", "class TestIntervalIndex:\r\n"]
[1325.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1325.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1325.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1325.639222, "o", "\r\n"]
[1325.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1325.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1325.712286, "o", "        if sort is None:\r\n"]
[1325.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1325.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1325.78535, "o", "\r\n"]
[1325.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1325.834059, "o", "        if sort is None:\r\n"]
[1325.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1325.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1325.907123, "o", "\r\n"]
[1325.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1325.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1325.980187, "o", "\r\n"]
[1326.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1326.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1326.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1326.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1326.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1326.126315, "o", "\r\n"]
[1326.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1326.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1326.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1326.223734, "o", "        expected = other\r\n"]
[1326.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1326.272443, "o", "\r\n"]
[1326.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1326.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1326.345507, "o", "\r\n"]
[1326.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1326.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1326.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1326.442926, "o", "\r\n"]
[1326.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1326.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1326.51599, "o", "\r\n"]
[1326.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1326.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1326.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1326.613409, "o", "\r\n"]
[1326.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1326.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1326.686473, "o", "        if sort is None:\r\n"]
[1326.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1326.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1326.759537, "o", "\r\n"]
[1326.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1326.808246, "o", "        if sort is None:\r\n"]
[1326.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1326.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1326.88131, "o", "\r\n"]
[1326.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1326.93002, "o", "\r\n"]
[1326.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1326.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1327.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1327.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1327.051793, "o", "        result = index.intersection(other)\r\n"]
[1327.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1327.100502, "o", "\r\n"]
[1327.124857, "o", "        # GH 26225\r\n"]
[1327.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1327.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1327.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1327.222276, "o", "        result = index.intersection(other)\r\n"]
[1327.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1327.270985, "o", "\r\n"]
[1327.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1327.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1327.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1327.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1327.392759, "o", "        result = index.intersection(other)\r\n"]
[1327.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1327.441468, "o", "\r\n"]
[1327.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1327.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1327.514532, "o", "\r\n"]
[1327.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1327.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1327.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1327.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1327.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1327.66066, "o", "\r\n"]
[1327.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1327.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1327.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1327.758079, "o", "        expected = other[:0]\r\n"]
[1327.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1327.806788, "o", "\r\n"]
[1327.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1327.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1327.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1327.904207, "o", "\r\n"]
[1327.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1327.952916, "o", "        # GH#38743\r\n"]
[1327.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1328.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1328.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1328.050335, "o", "        result = index.intersection(other)\r\n"]
[1328.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1328.099044, "o", "\r\n"]
[1328.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1328.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1328.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1328.196463, "o", "        expected = index[1:]\r\n"]
[1328.220818, "o", "        if sort is None:\r\n"]
[1328.245172, "o", "            expected = expected.sort_values()\r\n"]
[1328.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1328.293882, "o", "\r\n"]
[1328.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1328.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1328.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1328.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1328.415655, "o", "\r\n"]
[1328.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1328.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1328.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1328.513074, "o", "        )\r\n"]
[1328.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1328.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1328.586138, "o", "\r\n"]
[1328.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1328.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1328.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1328.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1328.707911, "o", "        if sort is None:\r\n"]
[1328.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1328.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1328.780975, "o", "\r\n"]
[1328.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1328.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1328.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1328.878394, "o", "        if sort is None:\r\n"]
[1328.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1328.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1328.951458, "o", "\r\n"]
[1328.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1329.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1329.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1329.048877, "o", "        )\r\n"]
[1329.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1329.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1329.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1329.146296, "o", "\r\n"]
[1329.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1329.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1329.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1329.243714, "o", "    )\r\n"]
[1329.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1329.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1329.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1329.341133, "o", "\r\n"]
[1329.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1329.389842, "o", "        # non-IntervalIndex\r\n"]
[1329.414197, "o", "        if op_name == \"difference\":\r\n"]
[1329.438552, "o", "            expected = index\r\n"]
[1329.462906, "o", "        else:\r\n"]
[1329.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1329.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1329.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1329.560325, "o", "\r\n"]
[1329.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1329.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1329.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1329.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1329.682099, "o", "            if op_name == \"difference\":\r\n"]
[1329.706453, "o", "                expected = index\r\n"]
[1329.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1329.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1329.779517, "o", "\r\n"]
[1329.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1329.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1329.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1329.876936, "o", "        if op_name == \"difference\":\r\n"]
[1329.901291, "o", "            expected = index\r\n"]
[1329.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1330.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1330.002, "i", "cd asv_bench\r"]
[1330.004, "o", "cd asv_bench\r\n"]
[1330.006, "o", "\u001b[?2004l\r\n"]
[1335.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1335.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1335.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1340.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1340.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1340.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1340.418, "o", "\u001b[?2004l\r\n"]
[1340.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1341.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1341.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1342.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1342.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1342.89, "o", "              param1            \r\n"]
[1343.302, "o", "             -------- ----------\r\n"]
[1343.714, "o", "               1000    1.16\u00b10ms \r\n"]
[1344.126, "o", "              100000   80.8\u00b10ms \r\n"]
[1344.538, "o", "             ======== ==========\r\n"]
[1345.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1345.002, "i", "cd ..\r"]
[1345.004, "o", "cd ..\r\n"]
[1345.006, "o", "\u001b[?2004l\r\n"]
[1350.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1350.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1350.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1352.478, "o", "\u001b[?2004l\r\n"]
[1355.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1355.002, "i", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r"]
[1355.004, "o", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1357.478, "o", "\u001b[?2004l\r\n"]
[1360.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1360.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1360.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1360.040817, "o", "\u001b[?2004l\r\n"]
[1360.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1360.110451, "o", "\r\n"]
[1360.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1360.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1360.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1360.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1360.284535, "o", "\r\n"]
[1360.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1360.354169, "o", "    # Set Operations\r\n"]
[1360.388986, "o", "\r\n"]
[1360.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1360.45862, "o", "        \"\"\"\r\n"]
[1360.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1360.528254, "o", "        \"\"\"\r\n"]
[1360.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1360.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1360.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1360.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1360.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1360.737155, "o", "            # multiple NaNs\r\n"]
[1360.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1360.806789, "o", "        else:\r\n"]
[1360.841606, "o", "            # duplicates\r\n"]
[1360.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1360.911239, "o", "\r\n"]
[1360.946056, "o", "        if sort is None:\r\n"]
[1360.980873, "o", "            taken = taken.sort_values()\r\n"]
[1361.01569, "o", "\r\n"]
[1361.050507, "o", "        return taken\r\n"]
[1361.085324, "o", "\r\n"]
[1361.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1361.154958, "o", "        \"\"\"\r\n"]
[1361.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1361.224592, "o", "        no matter left or right.\r\n"]
[1361.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1361.294225, "o", "        Parameters\r\n"]
[1361.329042, "o", "        ----------\r\n"]
[1361.363859, "o", "        other : IntervalIndex\r\n"]
[1361.398676, "o", "        Returns\r\n"]
[1361.433493, "o", "        -------\r\n"]
[1361.46831, "o", "        IntervalIndex\r\n"]
[1361.503127, "o", "        \"\"\"\r\n"]
[1361.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1361.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1361.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1361.642394, "o", "\r\n"]
[1361.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1361.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1361.746845, "o", "        indexer = unique(indexer)\r\n"]
[1361.781662, "o", "\r\n"]
[1361.816479, "o", "        return self.take(indexer)\r\n"]
[1361.851296, "o", "\r\n"]
[1361.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1361.92093, "o", "        \"\"\"\r\n"]
[1361.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1361.990563, "o", "        on either sides.\r\n"]
[1362.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1362.060197, "o", "\r\n"]
[1362.095014, "o", "        Parameters\r\n"]
[1362.129831, "o", "        ----------\r\n"]
[1362.164648, "o", "        other : IntervalIndex\r\n"]
[1362.199465, "o", "\r\n"]
[1362.234282, "o", "        Returns\r\n"]
[1362.269099, "o", "        -------\r\n"]
[1362.303915, "o", "        IntervalIndex\r\n"]
[1362.338732, "o", "        \"\"\"\r\n"]
[1362.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1362.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1362.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1362.478, "o", "\r\n"]
[1362.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1362.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1362.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1362.617268, "o", "\r\n"]
[1362.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1362.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1362.721718, "o", "            if tup in other_tups:\r\n"]
[1362.756535, "o", "                mask[i] = True\r\n"]
[1362.791352, "o", "\r\n"]
[1362.826169, "o", "        return self[mask]\r\n"]
[1362.860986, "o", "\r\n"]
[1362.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1362.93062, "o", "\r\n"]
[1362.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1363.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1363.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1363.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1363.104704, "o", "        raise NotImplementedError(\r\n"]
[1363.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1363.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1363.209155, "o", "        )\r\n"]
[1363.243972, "o", "\r\n"]
[1363.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1363.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1363.348423, "o", "\r\n"]
[1363.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1363.418056, "o", "\r\n"]
[1363.452873, "o", "\r\n"]
[1363.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1363.522507, "o", "    \"\"\"\r\n"]
[1363.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1363.592141, "o", "    \"\"\"\r\n"]
[1363.626958, "o", "    return any(\r\n"]
[1363.661775, "o", "        [\r\n"]
[1363.696592, "o", "            is_number(endpoint),\r\n"]
[1363.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1363.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1363.801042, "o", "            endpoint is None,\r\n"]
[1363.835859, "o", "        ]\r\n"]
[1363.870676, "o", "    )\r\n"]
[1363.905493, "o", "\r\n"]
[1363.94031, "o", "\r\n"]
[1363.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1364.009944, "o", "    \"\"\"\r\n"]
[1364.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1364.079577, "o", "    \"\"\"\r\n"]
[1364.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1364.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1364.184028, "o", "    return (\r\n"]
[1364.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1364.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1364.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1364.323296, "o", "        or com.any_none(a, b)\r\n"]
[1364.358113, "o", "    )\r\n"]
[1364.39293, "o", "\r\n"]
[1364.427746, "o", "\r\n"]
[1364.462563, "o", "def interval_range(\r\n"]
[1364.49738, "o", "    start=None,\r\n"]
[1364.532197, "o", "    end=None,\r\n"]
[1364.567014, "o", "    periods=None,\r\n"]
[1364.601831, "o", "    freq=None,\r\n"]
[1364.636648, "o", "    name: Hashable = None,\r\n"]
[1364.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1364.706282, "o", ") -> IntervalIndex:\r\n"]
[1364.741099, "o", "    \"\"\"\r\n"]
[1364.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1364.810732, "o", "\r\n"]
[1364.845549, "o", "    Parameters\r\n"]
[1364.880366, "o", "    ----------\r\n"]
[1364.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1365.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1365.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1365.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1365.040817, "o", "\u001b[?2004l\r\n"]
[1365.075634, "o", "        Left bound for generating intervals.\r\n"]
[1365.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1365.145268, "o", "        Right bound for generating intervals.\r\n"]
[1365.180085, "o", "    periods : int, default None\r\n"]
[1365.214901, "o", "        Number of periods to generate.\r\n"]
[1365.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1365.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1365.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1365.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1365.388986, "o", "    name : str, default None\r\n"]
[1365.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1365.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1365.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1365.528254, "o", "        or neither.\r\n"]
[1365.56307, "o", "\r\n"]
[1365.597887, "o", "    Returns\r\n"]
[1365.632704, "o", "    -------\r\n"]
[1365.667521, "o", "    IntervalIndex\r\n"]
[1365.702338, "o", "\r\n"]
[1365.737155, "o", "    See Also\r\n"]
[1365.771972, "o", "    --------\r\n"]
[1365.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1365.841606, "o", "\r\n"]
[1365.876423, "o", "    Notes\r\n"]
[1365.911239, "o", "    -----\r\n"]
[1365.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1365.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1366.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1366.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1366.085324, "o", "\r\n"]
[1366.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1366.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1366.189775, "o", "\r\n"]
[1366.224592, "o", "    Examples\r\n"]
[1366.259408, "o", "    --------\r\n"]
[1366.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1366.329042, "o", "\r\n"]
[1366.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1366.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1366.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1366.46831, "o", "\r\n"]
[1366.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1366.537944, "o", "\r\n"]
[1366.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1366.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1366.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1366.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1366.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1366.746845, "o", "\r\n"]
[1366.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1366.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1366.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1366.886113, "o", "\r\n"]
[1366.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1366.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1366.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1367.02538, "o", "\r\n"]
[1367.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1367.095014, "o", "    convertible to a DateOffset.\r\n"]
[1367.129831, "o", "\r\n"]
[1367.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1367.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1367.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1367.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1367.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1367.338732, "o", "\r\n"]
[1367.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1367.408366, "o", "    automatically (linearly spaced).\r\n"]
[1367.443183, "o", "\r\n"]
[1367.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1367.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1367.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1367.582451, "o", "\r\n"]
[1367.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1367.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1367.686901, "o", "\r\n"]
[1367.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1367.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1367.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1367.826169, "o", "    \"\"\"\r\n"]
[1367.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1367.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1367.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1367.965437, "o", "\r\n"]
[1368.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1368.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1368.069887, "o", "\r\n"]
[1368.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1368.139521, "o", "        raise ValueError(\r\n"]
[1368.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1368.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1368.243972, "o", "        )\r\n"]
[1368.278789, "o", "\r\n"]
[1368.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1368.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1368.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1368.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1368.452873, "o", "\r\n"]
[1368.48769, "o", "    if is_float(periods):\r\n"]
[1368.522507, "o", "        periods = int(periods)\r\n"]
[1368.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1368.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1368.626958, "o", "\r\n"]
[1368.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1368.696592, "o", "        try:\r\n"]
[1368.731408, "o", "            freq = to_offset(freq)\r\n"]
[1368.766225, "o", "        except ValueError as err:\r\n"]
[1368.801042, "o", "            raise ValueError(\r\n"]
[1368.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1368.870676, "o", "            ) from err\r\n"]
[1368.905493, "o", "\r\n"]
[1368.94031, "o", "    # verify type compatibility\r\n"]
[1368.975127, "o", "    if not all(\r\n"]
[1369.009944, "o", "        [\r\n"]
[1369.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1369.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1369.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1369.149211, "o", "        ]\r\n"]
[1369.184028, "o", "    ):\r\n"]
[1369.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1369.253662, "o", "\r\n"]
[1369.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1369.323296, "o", "    if periods is not None:\r\n"]
[1369.358113, "o", "        periods += 1\r\n"]
[1369.39293, "o", "\r\n"]
[1369.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1369.462563, "o", "\r\n"]
[1369.49738, "o", "    if is_number(endpoint):\r\n"]
[1369.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1369.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1369.601831, "o", "            end -= (end - start) % freq\r\n"]
[1369.636648, "o", "\r\n"]
[1369.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1369.706282, "o", "        if periods is None:\r\n"]
[1369.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1369.775915, "o", "        elif start is None:\r\n"]
[1369.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1369.845549, "o", "        elif end is None:\r\n"]
[1369.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1369.915183, "o", "\r\n"]
[1370.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1370.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1370.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1370.030355, "o", "\u001b[?2004l\r\n"]
[1370.054709, "o", "import numpy as np\r\n"]
[1370.079064, "o", "import pytest\r\n"]
[1370.103419, "o", "\r\n"]
[1370.127773, "o", "from pandas import (\r\n"]
[1370.152128, "o", "    Index,\r\n"]
[1370.176483, "o", "    IntervalIndex,\r\n"]
[1370.200837, "o", "    Timestamp,\r\n"]
[1370.225192, "o", "    interval_range,\r\n"]
[1370.249547, "o", ")\r\n"]
[1370.273901, "o", "import pandas._testing as tm\r\n"]
[1370.298256, "o", "\r\n"]
[1370.322611, "o", "\r\n"]
[1370.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1370.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1370.395675, "o", "\r\n"]
[1370.42003, "o", "\r\n"]
[1370.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1370.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1370.493094, "o", "\r\n"]
[1370.517448, "o", "\r\n"]
[1370.541803, "o", "class TestIntervalIndex:\r\n"]
[1370.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1370.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1370.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1370.639222, "o", "\r\n"]
[1370.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1370.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1370.712286, "o", "        if sort is None:\r\n"]
[1370.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1370.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1370.78535, "o", "\r\n"]
[1370.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1370.834059, "o", "        if sort is None:\r\n"]
[1370.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1370.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1370.907123, "o", "\r\n"]
[1370.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1370.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1370.980187, "o", "\r\n"]
[1371.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1371.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1371.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1371.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1371.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1371.126315, "o", "\r\n"]
[1371.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1371.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1371.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1371.223734, "o", "        expected = other\r\n"]
[1371.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1371.272443, "o", "\r\n"]
[1371.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1371.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1371.345507, "o", "\r\n"]
[1371.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1371.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1371.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1371.442926, "o", "\r\n"]
[1371.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1371.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1371.51599, "o", "\r\n"]
[1371.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1371.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1371.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1371.613409, "o", "\r\n"]
[1371.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1371.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1371.686473, "o", "        if sort is None:\r\n"]
[1371.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1371.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1371.759537, "o", "\r\n"]
[1371.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1371.808246, "o", "        if sort is None:\r\n"]
[1371.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1371.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1371.88131, "o", "\r\n"]
[1371.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1371.93002, "o", "\r\n"]
[1371.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1371.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1372.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1372.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1372.051793, "o", "        result = index.intersection(other)\r\n"]
[1372.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1372.100502, "o", "\r\n"]
[1372.124857, "o", "        # GH 26225\r\n"]
[1372.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1372.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1372.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1372.222276, "o", "        result = index.intersection(other)\r\n"]
[1372.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1372.270985, "o", "\r\n"]
[1372.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1372.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1372.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1372.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1372.392759, "o", "        result = index.intersection(other)\r\n"]
[1372.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1372.441468, "o", "\r\n"]
[1372.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1372.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1372.514532, "o", "\r\n"]
[1372.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1372.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1372.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1372.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1372.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1372.66066, "o", "\r\n"]
[1372.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1372.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1372.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1372.758079, "o", "        expected = other[:0]\r\n"]
[1372.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1372.806788, "o", "\r\n"]
[1372.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1372.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1372.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1372.904207, "o", "\r\n"]
[1372.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1372.952916, "o", "        # GH#38743\r\n"]
[1372.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1373.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1373.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1373.050335, "o", "        result = index.intersection(other)\r\n"]
[1373.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1373.099044, "o", "\r\n"]
[1373.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1373.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1373.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1373.196463, "o", "        expected = index[1:]\r\n"]
[1373.220818, "o", "        if sort is None:\r\n"]
[1373.245172, "o", "            expected = expected.sort_values()\r\n"]
[1373.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1373.293882, "o", "\r\n"]
[1373.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1373.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1373.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1373.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1373.415655, "o", "\r\n"]
[1373.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1373.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1373.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1373.513074, "o", "        )\r\n"]
[1373.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1373.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1373.586138, "o", "\r\n"]
[1373.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1373.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1373.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1373.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1373.707911, "o", "        if sort is None:\r\n"]
[1373.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1373.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1373.780975, "o", "\r\n"]
[1373.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1373.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1373.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1373.878394, "o", "        if sort is None:\r\n"]
[1373.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1373.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1373.951458, "o", "\r\n"]
[1373.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1374.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1374.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1374.048877, "o", "        )\r\n"]
[1374.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1374.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1374.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1374.146296, "o", "\r\n"]
[1374.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1374.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1374.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1374.243714, "o", "    )\r\n"]
[1374.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1374.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1374.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1374.341133, "o", "\r\n"]
[1374.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1374.389842, "o", "        # non-IntervalIndex\r\n"]
[1374.414197, "o", "        if op_name == \"difference\":\r\n"]
[1374.438552, "o", "            expected = index\r\n"]
[1374.462906, "o", "        else:\r\n"]
[1374.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1374.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1374.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1374.560325, "o", "\r\n"]
[1374.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1374.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1374.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1374.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1374.682099, "o", "            if op_name == \"difference\":\r\n"]
[1374.706453, "o", "                expected = index\r\n"]
[1374.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1374.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1374.779517, "o", "\r\n"]
[1374.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1374.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1374.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1374.876936, "o", "        if op_name == \"difference\":\r\n"]
[1374.901291, "o", "            expected = index\r\n"]
[1374.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1375.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1375.002, "i", "cd asv_bench\r"]
[1375.004, "o", "cd asv_bench\r\n"]
[1375.006, "o", "\u001b[?2004l\r\n"]
[1380.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1380.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1380.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1385.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1385.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1385.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1385.418, "o", "\u001b[?2004l\r\n"]
[1385.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1386.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1386.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1387.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1387.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1387.89, "o", "              param1            \r\n"]
[1388.302, "o", "             -------- ----------\r\n"]
[1388.714, "o", "               1000    1.21\u00b10ms \r\n"]
[1389.126, "o", "              100000   80.3\u00b10ms \r\n"]
[1389.538, "o", "             ======== ==========\r\n"]
[1390.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1390.002, "i", "cd ..\r"]
[1390.004, "o", "cd ..\r\n"]
[1390.006, "o", "\u001b[?2004l\r\n"]
[1395.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1395.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1395.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1397.478, "o", "\u001b[?2004l\r\n"]
[1400.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1400.002, "i", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r"]
[1400.004, "o", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1402.478, "o", "\u001b[?2004l\r\n"]
[1405.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1405.002, "i", "sed -n '840,980p' pandas/core/indexes/interval.py\r"]
[1405.004, "o", "sed -n '840,980p' pandas/core/indexes/interval.py\r\n"]
[1405.040817, "o", "\u001b[?2004l\r\n"]
[1405.075634, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1405.110451, "o", "\r\n"]
[1405.145268, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1405.180085, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1405.214901, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1405.249718, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1405.284535, "o", "\r\n"]
[1405.319352, "o", "    # --------------------------------------------------------------------\r\n"]
[1405.354169, "o", "    # Set Operations\r\n"]
[1405.388986, "o", "\r\n"]
[1405.423803, "o", "    def _intersection(self, other, sort):\r\n"]
[1405.45862, "o", "        \"\"\"\r\n"]
[1405.493437, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1405.528254, "o", "        \"\"\"\r\n"]
[1405.56307, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1405.597887, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1405.632704, "o", "            taken = self._intersection_unique(other)\r\n"]
[1405.667521, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1405.702338, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1405.737155, "o", "            # multiple NaNs\r\n"]
[1405.771972, "o", "            taken = other._intersection_unique(self)\r\n"]
[1405.806789, "o", "        else:\r\n"]
[1405.841606, "o", "            # duplicates\r\n"]
[1405.876423, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1405.911239, "o", "\r\n"]
[1405.946056, "o", "        if sort is None:\r\n"]
[1405.980873, "o", "            taken = taken.sort_values()\r\n"]
[1406.01569, "o", "\r\n"]
[1406.050507, "o", "        return taken\r\n"]
[1406.085324, "o", "\r\n"]
[1406.120141, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1406.154958, "o", "        \"\"\"\r\n"]
[1406.189775, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1406.224592, "o", "        no matter left or right.\r\n"]
[1406.259408, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1406.294225, "o", "        Parameters\r\n"]
[1406.329042, "o", "        ----------\r\n"]
[1406.363859, "o", "        other : IntervalIndex\r\n"]
[1406.398676, "o", "        Returns\r\n"]
[1406.433493, "o", "        -------\r\n"]
[1406.46831, "o", "        IntervalIndex\r\n"]
[1406.503127, "o", "        \"\"\"\r\n"]
[1406.537944, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1406.572761, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1406.607577, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1406.642394, "o", "\r\n"]
[1406.677211, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1406.712028, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1406.746845, "o", "        indexer = unique(indexer)\r\n"]
[1406.781662, "o", "\r\n"]
[1406.816479, "o", "        return self.take(indexer)\r\n"]
[1406.851296, "o", "\r\n"]
[1406.886113, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1406.92093, "o", "        \"\"\"\r\n"]
[1406.955746, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1406.990563, "o", "        on either sides.\r\n"]
[1407.02538, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1407.060197, "o", "\r\n"]
[1407.095014, "o", "        Parameters\r\n"]
[1407.129831, "o", "        ----------\r\n"]
[1407.164648, "o", "        other : IntervalIndex\r\n"]
[1407.199465, "o", "\r\n"]
[1407.234282, "o", "        Returns\r\n"]
[1407.269099, "o", "        -------\r\n"]
[1407.303915, "o", "        IntervalIndex\r\n"]
[1407.338732, "o", "        \"\"\"\r\n"]
[1407.373549, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1407.408366, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1407.443183, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1407.478, "o", "\r\n"]
[1407.512817, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1407.547634, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1407.582451, "o", "            mask[first_nan_loc] = True\r\n"]
[1407.617268, "o", "\r\n"]
[1407.652085, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1407.686901, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1407.721718, "o", "            if tup in other_tups:\r\n"]
[1407.756535, "o", "                mask[i] = True\r\n"]
[1407.791352, "o", "\r\n"]
[1407.826169, "o", "        return self[mask]\r\n"]
[1407.860986, "o", "\r\n"]
[1407.895803, "o", "    # --------------------------------------------------------------------\r\n"]
[1407.93062, "o", "\r\n"]
[1407.965437, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1408.000254, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1408.03507, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1408.069887, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1408.104704, "o", "        raise NotImplementedError(\r\n"]
[1408.139521, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1408.174338, "o", "            \"IndexEngine objects\"\r\n"]
[1408.209155, "o", "        )\r\n"]
[1408.243972, "o", "\r\n"]
[1408.278789, "o", "    def _from_join_target(self, result):\r\n"]
[1408.313606, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1408.348423, "o", "\r\n"]
[1408.383239, "o", "    # TODO: arithmetic operations\r\n"]
[1408.418056, "o", "\r\n"]
[1408.452873, "o", "\r\n"]
[1408.48769, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1408.522507, "o", "    \"\"\"\r\n"]
[1408.557324, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1408.592141, "o", "    \"\"\"\r\n"]
[1408.626958, "o", "    return any(\r\n"]
[1408.661775, "o", "        [\r\n"]
[1408.696592, "o", "            is_number(endpoint),\r\n"]
[1408.731408, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1408.766225, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1408.801042, "o", "            endpoint is None,\r\n"]
[1408.835859, "o", "        ]\r\n"]
[1408.870676, "o", "    )\r\n"]
[1408.905493, "o", "\r\n"]
[1408.94031, "o", "\r\n"]
[1408.975127, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1409.009944, "o", "    \"\"\"\r\n"]
[1409.044761, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1409.079577, "o", "    \"\"\"\r\n"]
[1409.114394, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1409.149211, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1409.184028, "o", "    return (\r\n"]
[1409.218845, "o", "        (is_number(a) and is_number(b))\r\n"]
[1409.253662, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1409.288479, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1409.323296, "o", "        or com.any_none(a, b)\r\n"]
[1409.358113, "o", "    )\r\n"]
[1409.39293, "o", "\r\n"]
[1409.427746, "o", "\r\n"]
[1409.462563, "o", "def interval_range(\r\n"]
[1409.49738, "o", "    start=None,\r\n"]
[1409.532197, "o", "    end=None,\r\n"]
[1409.567014, "o", "    periods=None,\r\n"]
[1409.601831, "o", "    freq=None,\r\n"]
[1409.636648, "o", "    name: Hashable = None,\r\n"]
[1409.671465, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1409.706282, "o", ") -> IntervalIndex:\r\n"]
[1409.741099, "o", "    \"\"\"\r\n"]
[1409.775915, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1409.810732, "o", "\r\n"]
[1409.845549, "o", "    Parameters\r\n"]
[1409.880366, "o", "    ----------\r\n"]
[1409.915183, "o", "    start : numeric or datetime-like, default None\r\n"]
[1410.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1410.002, "i", "sed -n '980,1120p' pandas/core/indexes/interval.py\r"]
[1410.004, "o", "sed -n '980,1120p' pandas/core/indexes/interval.py\r\n"]
[1410.040817, "o", "\u001b[?2004l\r\n"]
[1410.075634, "o", "        Left bound for generating intervals.\r\n"]
[1410.110451, "o", "    end : numeric or datetime-like, default None\r\n"]
[1410.145268, "o", "        Right bound for generating intervals.\r\n"]
[1410.180085, "o", "    periods : int, default None\r\n"]
[1410.214901, "o", "        Number of periods to generate.\r\n"]
[1410.249718, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1410.284535, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1410.319352, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1410.354169, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1410.388986, "o", "    name : str, default None\r\n"]
[1410.423803, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1410.45862, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1410.493437, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1410.528254, "o", "        or neither.\r\n"]
[1410.56307, "o", "\r\n"]
[1410.597887, "o", "    Returns\r\n"]
[1410.632704, "o", "    -------\r\n"]
[1410.667521, "o", "    IntervalIndex\r\n"]
[1410.702338, "o", "\r\n"]
[1410.737155, "o", "    See Also\r\n"]
[1410.771972, "o", "    --------\r\n"]
[1410.806789, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1410.841606, "o", "\r\n"]
[1410.876423, "o", "    Notes\r\n"]
[1410.911239, "o", "    -----\r\n"]
[1410.946056, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1410.980873, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1411.01569, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1411.050507, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1411.085324, "o", "\r\n"]
[1411.120141, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1411.154958, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1411.189775, "o", "\r\n"]
[1411.224592, "o", "    Examples\r\n"]
[1411.259408, "o", "    --------\r\n"]
[1411.294225, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1411.329042, "o", "\r\n"]
[1411.363859, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1411.398676, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1411.433493, "o", "                  dtype='interval[int64, right]')\r\n"]
[1411.46831, "o", "\r\n"]
[1411.503127, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1411.537944, "o", "\r\n"]
[1411.572761, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1411.607577, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1411.642394, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1411.677211, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1411.712028, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1411.746845, "o", "\r\n"]
[1411.781662, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1411.816479, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1411.851296, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1411.886113, "o", "\r\n"]
[1411.92093, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1411.955746, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1411.990563, "o", "                  dtype='interval[float64, right]')\r\n"]
[1412.02538, "o", "\r\n"]
[1412.060197, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1412.095014, "o", "    convertible to a DateOffset.\r\n"]
[1412.129831, "o", "\r\n"]
[1412.164648, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1412.199465, "o", "    ...                   periods=3, freq='MS')\r\n"]
[1412.234282, "o", "    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\r\n"]
[1412.269099, "o", "                   (2017-03-01, 2017-04-01]],\r\n"]
[1412.303915, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1412.338732, "o", "\r\n"]
[1412.373549, "o", "    Specify ``start``, ``end``, and ``periods``; the frequency is generated\r\n"]
[1412.408366, "o", "    automatically (linearly spaced).\r\n"]
[1412.443183, "o", "\r\n"]
[1412.478, "o", "    >>> pd.interval_range(start=0, end=6, periods=4)\r\n"]
[1412.512817, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1412.547634, "o", "              dtype='interval[float64, right]')\r\n"]
[1412.582451, "o", "\r\n"]
[1412.617268, "o", "    The ``closed`` parameter specifies which endpoints of the individual\r\n"]
[1412.652085, "o", "    intervals within the ``IntervalIndex`` are closed.\r\n"]
[1412.686901, "o", "\r\n"]
[1412.721718, "o", "    >>> pd.interval_range(end=5, periods=4, closed='both')\r\n"]
[1412.756535, "o", "    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\r\n"]
[1412.791352, "o", "                  dtype='interval[int64, both]')\r\n"]
[1412.826169, "o", "    \"\"\"\r\n"]
[1412.860986, "o", "    start = maybe_box_datetimelike(start)\r\n"]
[1412.895803, "o", "    end = maybe_box_datetimelike(end)\r\n"]
[1412.93062, "o", "    endpoint = start if start is not None else end\r\n"]
[1412.965437, "o", "\r\n"]
[1413.000254, "o", "    if freq is None and com.any_none(periods, start, end):\r\n"]
[1413.03507, "o", "        freq = 1 if is_number(endpoint) else \"D\"\r\n"]
[1413.069887, "o", "\r\n"]
[1413.104704, "o", "    if com.count_not_none(start, end, periods, freq) != 3:\r\n"]
[1413.139521, "o", "        raise ValueError(\r\n"]
[1413.174338, "o", "            \"Of the four parameters: start, end, periods, and \"\r\n"]
[1413.209155, "o", "            \"freq, exactly three must be specified\"\r\n"]
[1413.243972, "o", "        )\r\n"]
[1413.278789, "o", "\r\n"]
[1413.313606, "o", "    if not _is_valid_endpoint(start):\r\n"]
[1413.348423, "o", "        raise ValueError(f\"start must be numeric or datetime-like, got {start}\")\r\n"]
[1413.383239, "o", "    if not _is_valid_endpoint(end):\r\n"]
[1413.418056, "o", "        raise ValueError(f\"end must be numeric or datetime-like, got {end}\")\r\n"]
[1413.452873, "o", "\r\n"]
[1413.48769, "o", "    if is_float(periods):\r\n"]
[1413.522507, "o", "        periods = int(periods)\r\n"]
[1413.557324, "o", "    elif not is_integer(periods) and periods is not None:\r\n"]
[1413.592141, "o", "        raise TypeError(f\"periods must be a number, got {periods}\")\r\n"]
[1413.626958, "o", "\r\n"]
[1413.661775, "o", "    if freq is not None and not is_number(freq):\r\n"]
[1413.696592, "o", "        try:\r\n"]
[1413.731408, "o", "            freq = to_offset(freq)\r\n"]
[1413.766225, "o", "        except ValueError as err:\r\n"]
[1413.801042, "o", "            raise ValueError(\r\n"]
[1413.835859, "o", "                f\"freq must be numeric or convertible to DateOffset, got {freq}\"\r\n"]
[1413.870676, "o", "            ) from err\r\n"]
[1413.905493, "o", "\r\n"]
[1413.94031, "o", "    # verify type compatibility\r\n"]
[1413.975127, "o", "    if not all(\r\n"]
[1414.009944, "o", "        [\r\n"]
[1414.044761, "o", "            _is_type_compatible(start, end),\r\n"]
[1414.079577, "o", "            _is_type_compatible(start, freq),\r\n"]
[1414.114394, "o", "            _is_type_compatible(end, freq),\r\n"]
[1414.149211, "o", "        ]\r\n"]
[1414.184028, "o", "    ):\r\n"]
[1414.218845, "o", "        raise TypeError(\"start, end, freq need to be type compatible\")\r\n"]
[1414.253662, "o", "\r\n"]
[1414.288479, "o", "    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\r\n"]
[1414.323296, "o", "    if periods is not None:\r\n"]
[1414.358113, "o", "        periods += 1\r\n"]
[1414.39293, "o", "\r\n"]
[1414.427746, "o", "    breaks: np.ndarray | TimedeltaIndex | DatetimeIndex\r\n"]
[1414.462563, "o", "\r\n"]
[1414.49738, "o", "    if is_number(endpoint):\r\n"]
[1414.532197, "o", "        # force consistency between start/end/freq (lower end if freq skips it)\r\n"]
[1414.567014, "o", "        if com.all_not_none(start, end, freq):\r\n"]
[1414.601831, "o", "            end -= (end - start) % freq\r\n"]
[1414.636648, "o", "\r\n"]
[1414.671465, "o", "        # compute the period/start/end if unspecified (at most one)\r\n"]
[1414.706282, "o", "        if periods is None:\r\n"]
[1414.741099, "o", "            periods = int((end - start) // freq) + 1\r\n"]
[1414.775915, "o", "        elif start is None:\r\n"]
[1414.810732, "o", "            start = end - (periods - 1) * freq\r\n"]
[1414.845549, "o", "        elif end is None:\r\n"]
[1414.880366, "o", "            end = start + (periods - 1) * freq\r\n"]
[1414.915183, "o", "\r\n"]
[1415.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1415.002, "i", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r"]
[1415.004, "o", "sed -n '1,320p' pandas/tests/indexes/interval/test_setops.py\r\n"]
[1415.030355, "o", "\u001b[?2004l\r\n"]
[1415.054709, "o", "import numpy as np\r\n"]
[1415.079064, "o", "import pytest\r\n"]
[1415.103419, "o", "\r\n"]
[1415.127773, "o", "from pandas import (\r\n"]
[1415.152128, "o", "    Index,\r\n"]
[1415.176483, "o", "    IntervalIndex,\r\n"]
[1415.200837, "o", "    Timestamp,\r\n"]
[1415.225192, "o", "    interval_range,\r\n"]
[1415.249547, "o", ")\r\n"]
[1415.273901, "o", "import pandas._testing as tm\r\n"]
[1415.298256, "o", "\r\n"]
[1415.322611, "o", "\r\n"]
[1415.346966, "o", "def monotonic_index(start, end, dtype=\"int64\", closed=\"right\"):\r\n"]
[1415.37132, "o", "    return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)\r\n"]
[1415.395675, "o", "\r\n"]
[1415.42003, "o", "\r\n"]
[1415.444384, "o", "def empty_index(dtype=\"int64\", closed=\"right\"):\r\n"]
[1415.468739, "o", "    return IntervalIndex(np.array([], dtype=dtype), closed=closed)\r\n"]
[1415.493094, "o", "\r\n"]
[1415.517448, "o", "\r\n"]
[1415.541803, "o", "class TestIntervalIndex:\r\n"]
[1415.566158, "o", "    def test_union(self, closed, sort):\r\n"]
[1415.590512, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1415.614867, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1415.639222, "o", "\r\n"]
[1415.663576, "o", "        expected = monotonic_index(0, 13, closed=closed)\r\n"]
[1415.687931, "o", "        result = index[::-1].union(other, sort=sort)\r\n"]
[1415.712286, "o", "        if sort is None:\r\n"]
[1415.73664, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1415.760995, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1415.78535, "o", "\r\n"]
[1415.809704, "o", "        result = other[::-1].union(index, sort=sort)\r\n"]
[1415.834059, "o", "        if sort is None:\r\n"]
[1415.858414, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1415.882768, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1415.907123, "o", "\r\n"]
[1415.931478, "o", "        tm.assert_index_equal(index.union(index, sort=sort), index)\r\n"]
[1415.955833, "o", "        tm.assert_index_equal(index.union(index[:1], sort=sort), index)\r\n"]
[1415.980187, "o", "\r\n"]
[1416.004542, "o", "    def test_union_empty_result(self, closed, sort):\r\n"]
[1416.028897, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1416.053251, "o", "        index = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1416.077606, "o", "        result = index.union(index, sort=sort)\r\n"]
[1416.101961, "o", "        tm.assert_index_equal(result, index)\r\n"]
[1416.126315, "o", "\r\n"]
[1416.15067, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is f8\r\n"]
[1416.175025, "o", "        other = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1416.199379, "o", "        result = index.union(other, sort=sort)\r\n"]
[1416.223734, "o", "        expected = other\r\n"]
[1416.248089, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1416.272443, "o", "\r\n"]
[1416.296798, "o", "        other = index.union(index, sort=sort)\r\n"]
[1416.321153, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1416.345507, "o", "\r\n"]
[1416.369862, "o", "        other = empty_index(dtype=\"uint64\", closed=closed)\r\n"]
[1416.394217, "o", "        result = index.union(other, sort=sort)\r\n"]
[1416.418571, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1416.442926, "o", "\r\n"]
[1416.467281, "o", "        result = other.union(index, sort=sort)\r\n"]
[1416.491635, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1416.51599, "o", "\r\n"]
[1416.540345, "o", "    def test_intersection(self, closed, sort):\r\n"]
[1416.5647, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1416.589054, "o", "        other = monotonic_index(5, 13, closed=closed)\r\n"]
[1416.613409, "o", "\r\n"]
[1416.637764, "o", "        expected = monotonic_index(5, 11, closed=closed)\r\n"]
[1416.662118, "o", "        result = index[::-1].intersection(other, sort=sort)\r\n"]
[1416.686473, "o", "        if sort is None:\r\n"]
[1416.710828, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1416.735182, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1416.759537, "o", "\r\n"]
[1416.783892, "o", "        result = other[::-1].intersection(index, sort=sort)\r\n"]
[1416.808246, "o", "        if sort is None:\r\n"]
[1416.832601, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1416.856956, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1416.88131, "o", "\r\n"]
[1416.905665, "o", "        tm.assert_index_equal(index.intersection(index, sort=sort), index)\r\n"]
[1416.93002, "o", "\r\n"]
[1416.954374, "o", "        # GH 26225: nested intervals\r\n"]
[1416.978729, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])\r\n"]
[1417.003084, "o", "        other = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1417.027438, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])\r\n"]
[1417.051793, "o", "        result = index.intersection(other)\r\n"]
[1417.076148, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1417.100502, "o", "\r\n"]
[1417.124857, "o", "        # GH 26225\r\n"]
[1417.149212, "o", "        index = IntervalIndex.from_tuples([(0, 3), (0, 2)])\r\n"]
[1417.173567, "o", "        other = IntervalIndex.from_tuples([(0, 2), (1, 3)])\r\n"]
[1417.197921, "o", "        expected = IntervalIndex.from_tuples([(0, 2)])\r\n"]
[1417.222276, "o", "        result = index.intersection(other)\r\n"]
[1417.246631, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1417.270985, "o", "\r\n"]
[1417.29534, "o", "        # GH 26225: duplicate nan element\r\n"]
[1417.319695, "o", "        index = IntervalIndex([np.nan, np.nan])\r\n"]
[1417.344049, "o", "        other = IntervalIndex([np.nan])\r\n"]
[1417.368404, "o", "        expected = IntervalIndex([np.nan])\r\n"]
[1417.392759, "o", "        result = index.intersection(other)\r\n"]
[1417.417113, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1417.441468, "o", "\r\n"]
[1417.465823, "o", "    def test_intersection_empty_result(self, closed, sort):\r\n"]
[1417.490177, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1417.514532, "o", "\r\n"]
[1417.538887, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1417.563241, "o", "        other = monotonic_index(300, 314, closed=closed)\r\n"]
[1417.587596, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1417.611951, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1417.636305, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1417.66066, "o", "\r\n"]
[1417.685015, "o", "        # GH 19101: empty result, different numeric dtypes -> common dtype is float64\r\n"]
[1417.709369, "o", "        other = monotonic_index(300, 314, dtype=\"float64\", closed=closed)\r\n"]
[1417.733724, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1417.758079, "o", "        expected = other[:0]\r\n"]
[1417.782433, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1417.806788, "o", "\r\n"]
[1417.831143, "o", "        other = monotonic_index(300, 314, dtype=\"uint64\", closed=closed)\r\n"]
[1417.855498, "o", "        result = index.intersection(other, sort=sort)\r\n"]
[1417.879852, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1417.904207, "o", "\r\n"]
[1417.928562, "o", "    def test_intersection_duplicates(self):\r\n"]
[1417.952916, "o", "        # GH#38743\r\n"]
[1417.977271, "o", "        index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])\r\n"]
[1418.001626, "o", "        other = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1418.02598, "o", "        expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])\r\n"]
[1418.050335, "o", "        result = index.intersection(other)\r\n"]
[1418.07469, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1418.099044, "o", "\r\n"]
[1418.123399, "o", "    def test_difference(self, closed, sort):\r\n"]
[1418.147754, "o", "        index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)\r\n"]
[1418.172108, "o", "        result = index.difference(index[:1], sort=sort)\r\n"]
[1418.196463, "o", "        expected = index[1:]\r\n"]
[1418.220818, "o", "        if sort is None:\r\n"]
[1418.245172, "o", "            expected = expected.sort_values()\r\n"]
[1418.269527, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1418.293882, "o", "\r\n"]
[1418.318236, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1418.342591, "o", "        result = index.difference(index, sort=sort)\r\n"]
[1418.366946, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1418.3913, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1418.415655, "o", "\r\n"]
[1418.44001, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1418.464365, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1418.488719, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1418.513074, "o", "        )\r\n"]
[1418.537429, "o", "        result = index.difference(other, sort=sort)\r\n"]
[1418.561783, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1418.586138, "o", "\r\n"]
[1418.610493, "o", "    def test_symmetric_difference(self, closed, sort):\r\n"]
[1418.634847, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1418.659202, "o", "        result = index[1:].symmetric_difference(index[:-1], sort=sort)\r\n"]
[1418.683557, "o", "        expected = IntervalIndex([index[0], index[-1]])\r\n"]
[1418.707911, "o", "        if sort is None:\r\n"]
[1418.732266, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1418.756621, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1418.780975, "o", "\r\n"]
[1418.80533, "o", "        # GH 19101: empty result, same dtype\r\n"]
[1418.829685, "o", "        result = index.symmetric_difference(index, sort=sort)\r\n"]
[1418.854039, "o", "        expected = empty_index(dtype=\"int64\", closed=closed)\r\n"]
[1418.878394, "o", "        if sort is None:\r\n"]
[1418.902749, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1418.927103, "o", "        assert tm.equalContents(result, expected)\r\n"]
[1418.951458, "o", "\r\n"]
[1418.975813, "o", "        # GH 19101: empty result, different dtypes\r\n"]
[1419.000167, "o", "        other = IntervalIndex.from_arrays(\r\n"]
[1419.024522, "o", "            index.left.astype(\"float64\"), index.right, closed=closed\r\n"]
[1419.048877, "o", "        )\r\n"]
[1419.073232, "o", "        result = index.symmetric_difference(other, sort=sort)\r\n"]
[1419.097586, "o", "        expected = empty_index(dtype=\"float64\", closed=closed)\r\n"]
[1419.121941, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1419.146296, "o", "\r\n"]
[1419.17065, "o", "    @pytest.mark.filterwarnings(\"ignore:'<' not supported between:RuntimeWarning\")\r\n"]
[1419.195005, "o", "    @pytest.mark.parametrize(\r\n"]
[1419.21936, "o", "        \"op_name\", [\"union\", \"intersection\", \"difference\", \"symmetric_difference\"]\r\n"]
[1419.243714, "o", "    )\r\n"]
[1419.268069, "o", "    def test_set_incompatible_types(self, closed, op_name, sort):\r\n"]
[1419.292424, "o", "        index = monotonic_index(0, 11, closed=closed)\r\n"]
[1419.316778, "o", "        set_op = getattr(index, op_name)\r\n"]
[1419.341133, "o", "\r\n"]
[1419.365488, "o", "        # TODO: standardize return type of non-union setops type(self vs other)\r\n"]
[1419.389842, "o", "        # non-IntervalIndex\r\n"]
[1419.414197, "o", "        if op_name == \"difference\":\r\n"]
[1419.438552, "o", "            expected = index\r\n"]
[1419.462906, "o", "        else:\r\n"]
[1419.487261, "o", "            expected = getattr(index.astype(\"O\"), op_name)(Index([1, 2, 3]))\r\n"]
[1419.511616, "o", "        result = set_op(Index([1, 2, 3]), sort=sort)\r\n"]
[1419.53597, "o", "        tm.assert_index_equal(result, expected)\r\n"]
[1419.560325, "o", "\r\n"]
[1419.58468, "o", "        # mixed closed -> cast to object\r\n"]
[1419.609034, "o", "        for other_closed in {\"right\", \"left\", \"both\", \"neither\"} - {closed}:\r\n"]
[1419.633389, "o", "            other = monotonic_index(0, 11, closed=other_closed)\r\n"]
[1419.657744, "o", "            expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1419.682099, "o", "            if op_name == \"difference\":\r\n"]
[1419.706453, "o", "                expected = index\r\n"]
[1419.730808, "o", "            result = set_op(other, sort=sort)\r\n"]
[1419.755163, "o", "            tm.assert_index_equal(result, expected)\r\n"]
[1419.779517, "o", "\r\n"]
[1419.803872, "o", "        # GH 19016: incompatible dtypes -> cast to object\r\n"]
[1419.828227, "o", "        other = interval_range(Timestamp(\"20180101\"), periods=9, closed=closed)\r\n"]
[1419.852581, "o", "        expected = getattr(index.astype(object), op_name)(other, sort=sort)\r\n"]
[1419.876936, "o", "        if op_name == \"difference\":\r\n"]
[1419.901291, "o", "            expected = index\r\n"]
[1419.925645, "o", "        result = set_op(other, sort=sort)\r\n"]
[1420.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1420.002, "i", "cd asv_bench\r"]
[1420.004, "o", "cd asv_bench\r\n"]
[1420.006, "o", "\u001b[?2004l\r\n"]
[1425.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1425.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1425.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1430.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1430.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1430.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1430.418, "o", "\u001b[?2004l\r\n"]
[1430.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1431.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1431.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1432.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1432.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1432.89, "o", "              param1            \r\n"]
[1433.302, "o", "             -------- ----------\r\n"]
[1433.714, "o", "               1000    1.26\u00b10ms \r\n"]
[1434.126, "o", "              100000   85.1\u00b10ms \r\n"]
[1434.538, "o", "             ======== ==========\r\n"]
[1435.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1435.002, "i", "cd ..\r"]
[1435.004, "o", "cd ..\r\n"]
[1435.006, "o", "\u001b[?2004l\r\n"]
[1440.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1440.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1440.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1442.478, "o", "\u001b[?2004l\r\n"]
[1445.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1445.002, "i", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r"]
[1445.004, "o", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1447.478, "o", "\u001b[?2004l\r\n"]
[1450.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1450.002, "i", "sed -n '840,1040p' pandas/core/indexes/interval.py\r"]
[1450.004, "o", "sed -n '840,1040p' pandas/core/indexes/interval.py\r\n"]
[1450.030475, "o", "\u001b[?2004l\r\n"]
[1450.05495, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1450.079426, "o", "\r\n"]
[1450.103901, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1450.128376, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1450.152851, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1450.177327, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1450.201802, "o", "\r\n"]
[1450.226277, "o", "    # --------------------------------------------------------------------\r\n"]
[1450.250752, "o", "    # Set Operations\r\n"]
[1450.275228, "o", "\r\n"]
[1450.299703, "o", "    def _intersection(self, other, sort):\r\n"]
[1450.324178, "o", "        \"\"\"\r\n"]
[1450.348653, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1450.373129, "o", "        \"\"\"\r\n"]
[1450.397604, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1450.422079, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1450.446554, "o", "            taken = self._intersection_unique(other)\r\n"]
[1450.47103, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1450.495505, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1450.51998, "o", "            # multiple NaNs\r\n"]
[1450.544455, "o", "            taken = other._intersection_unique(self)\r\n"]
[1450.568931, "o", "        else:\r\n"]
[1450.593406, "o", "            # duplicates\r\n"]
[1450.617881, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1450.642356, "o", "\r\n"]
[1450.666832, "o", "        if sort is None:\r\n"]
[1450.691307, "o", "            taken = taken.sort_values()\r\n"]
[1450.715782, "o", "\r\n"]
[1450.740257, "o", "        return taken\r\n"]
[1450.764733, "o", "\r\n"]
[1450.789208, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1450.813683, "o", "        \"\"\"\r\n"]
[1450.838158, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1450.862634, "o", "        no matter left or right.\r\n"]
[1450.887109, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1450.911584, "o", "        Parameters\r\n"]
[1450.936059, "o", "        ----------\r\n"]
[1450.960535, "o", "        other : IntervalIndex\r\n"]
[1450.98501, "o", "        Returns\r\n"]
[1451.009485, "o", "        -------\r\n"]
[1451.03396, "o", "        IntervalIndex\r\n"]
[1451.058436, "o", "        \"\"\"\r\n"]
[1451.082911, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1451.107386, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1451.131861, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1451.156337, "o", "\r\n"]
[1451.180812, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1451.205287, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1451.229762, "o", "        indexer = unique(indexer)\r\n"]
[1451.254238, "o", "\r\n"]
[1451.278713, "o", "        return self.take(indexer)\r\n"]
[1451.303188, "o", "\r\n"]
[1451.327663, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1451.352139, "o", "        \"\"\"\r\n"]
[1451.376614, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1451.401089, "o", "        on either sides.\r\n"]
[1451.425564, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1451.45004, "o", "\r\n"]
[1451.474515, "o", "        Parameters\r\n"]
[1451.49899, "o", "        ----------\r\n"]
[1451.523465, "o", "        other : IntervalIndex\r\n"]
[1451.547941, "o", "\r\n"]
[1451.572416, "o", "        Returns\r\n"]
[1451.596891, "o", "        -------\r\n"]
[1451.621366, "o", "        IntervalIndex\r\n"]
[1451.645842, "o", "        \"\"\"\r\n"]
[1451.670317, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1451.694792, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1451.719267, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1451.743743, "o", "\r\n"]
[1451.768218, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1451.792693, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1451.817168, "o", "            mask[first_nan_loc] = True\r\n"]
[1451.841644, "o", "\r\n"]
[1451.866119, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1451.890594, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1451.915069, "o", "            if tup in other_tups:\r\n"]
[1451.939545, "o", "                mask[i] = True\r\n"]
[1451.96402, "o", "\r\n"]
[1451.988495, "o", "        return self[mask]\r\n"]
[1452.01297, "o", "\r\n"]
[1452.037446, "o", "    # --------------------------------------------------------------------\r\n"]
[1452.061921, "o", "\r\n"]
[1452.086396, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1452.110871, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1452.135347, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1452.159822, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1452.184297, "o", "        raise NotImplementedError(\r\n"]
[1452.208772, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1452.233248, "o", "            \"IndexEngine objects\"\r\n"]
[1452.257723, "o", "        )\r\n"]
[1452.282198, "o", "\r\n"]
[1452.306673, "o", "    def _from_join_target(self, result):\r\n"]
[1452.331149, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1452.355624, "o", "\r\n"]
[1452.380099, "o", "    # TODO: arithmetic operations\r\n"]
[1452.404574, "o", "\r\n"]
[1452.42905, "o", "\r\n"]
[1452.453525, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1452.478, "o", "    \"\"\"\r\n"]
[1452.502475, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1452.52695, "o", "    \"\"\"\r\n"]
[1452.551426, "o", "    return any(\r\n"]
[1452.575901, "o", "        [\r\n"]
[1452.600376, "o", "            is_number(endpoint),\r\n"]
[1452.624851, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1452.649327, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1452.673802, "o", "            endpoint is None,\r\n"]
[1452.698277, "o", "        ]\r\n"]
[1452.722752, "o", "    )\r\n"]
[1452.747228, "o", "\r\n"]
[1452.771703, "o", "\r\n"]
[1452.796178, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1452.820653, "o", "    \"\"\"\r\n"]
[1452.845129, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1452.869604, "o", "    \"\"\"\r\n"]
[1452.894079, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1452.918554, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1452.94303, "o", "    return (\r\n"]
[1452.967505, "o", "        (is_number(a) and is_number(b))\r\n"]
[1452.99198, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1453.016455, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1453.040931, "o", "        or com.any_none(a, b)\r\n"]
[1453.065406, "o", "    )\r\n"]
[1453.089881, "o", "\r\n"]
[1453.114356, "o", "\r\n"]
[1453.138832, "o", "def interval_range(\r\n"]
[1453.163307, "o", "    start=None,\r\n"]
[1453.187782, "o", "    end=None,\r\n"]
[1453.212257, "o", "    periods=None,\r\n"]
[1453.236733, "o", "    freq=None,\r\n"]
[1453.261208, "o", "    name: Hashable = None,\r\n"]
[1453.285683, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1453.310158, "o", ") -> IntervalIndex:\r\n"]
[1453.334634, "o", "    \"\"\"\r\n"]
[1453.359109, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1453.383584, "o", "\r\n"]
[1453.408059, "o", "    Parameters\r\n"]
[1453.432535, "o", "    ----------\r\n"]
[1453.45701, "o", "    start : numeric or datetime-like, default None\r\n"]
[1453.481485, "o", "        Left bound for generating intervals.\r\n"]
[1453.50596, "o", "    end : numeric or datetime-like, default None\r\n"]
[1453.530436, "o", "        Right bound for generating intervals.\r\n"]
[1453.554911, "o", "    periods : int, default None\r\n"]
[1453.579386, "o", "        Number of periods to generate.\r\n"]
[1453.603861, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1453.628337, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1453.652812, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1453.677287, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1453.701762, "o", "    name : str, default None\r\n"]
[1453.726238, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1453.750713, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1453.775188, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1453.799663, "o", "        or neither.\r\n"]
[1453.824139, "o", "\r\n"]
[1453.848614, "o", "    Returns\r\n"]
[1453.873089, "o", "    -------\r\n"]
[1453.897564, "o", "    IntervalIndex\r\n"]
[1453.92204, "o", "\r\n"]
[1453.946515, "o", "    See Also\r\n"]
[1453.97099, "o", "    --------\r\n"]
[1453.995465, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1454.019941, "o", "\r\n"]
[1454.044416, "o", "    Notes\r\n"]
[1454.068891, "o", "    -----\r\n"]
[1454.093366, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1454.117842, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1454.142317, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1454.166792, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1454.191267, "o", "\r\n"]
[1454.215743, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1454.240218, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1454.264693, "o", "\r\n"]
[1454.289168, "o", "    Examples\r\n"]
[1454.313644, "o", "    --------\r\n"]
[1454.338119, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1454.362594, "o", "\r\n"]
[1454.387069, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1454.411545, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1454.43602, "o", "                  dtype='interval[int64, right]')\r\n"]
[1454.460495, "o", "\r\n"]
[1454.48497, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1454.509446, "o", "\r\n"]
[1454.533921, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1454.558396, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1454.582871, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1454.607347, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1454.631822, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1454.656297, "o", "\r\n"]
[1454.680772, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1454.705248, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1454.729723, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1454.754198, "o", "\r\n"]
[1454.778673, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1454.803149, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1454.827624, "o", "                  dtype='interval[float64, right]')\r\n"]
[1454.852099, "o", "\r\n"]
[1454.876574, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1454.90105, "o", "    convertible to a DateOffset.\r\n"]
[1454.925525, "o", "\r\n"]
[1455.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1455.002, "i", "python - << 'PY'\r"]
[1455.004, "o", "python - << 'PY'\r\n"]
[1455.099283, "o", "\u001b[?2004l\r\n"]
[1455.192566, "o", "\u001b[?2004h> import numpy as np\r\n"]
[1455.285849, "o", "\u001b[?2004l\r\n"]
[1455.379132, "o", "\u001b[?2004h> import time\r\n"]
[1455.472415, "o", "\u001b[?2004l\r\n"]
[1455.565698, "o", "\u001b[?2004h> from pandas.core.indexes.interval import IntervalIndex\r\n"]
[1455.658981, "o", "\u001b[?2004l\r\n"]
[1455.752264, "o", "\u001b[?2004h> from pandas import MultiIndex\r\n"]
[1455.845547, "o", "\u001b[?2004l\r\n"]
[1455.93883, "o", "\u001b[?2004h> \r\n"]
[1456.032113, "o", "\u001b[?2004l\r\n"]
[1456.125396, "o", "\u001b[?2004h> N = 100_000\r\n"]
[1456.218679, "o", "\u001b[?2004l\r\n"]
[1456.311962, "o", "\u001b[?2004h> left = np.append(np.arange(N), np.array(0))\r\n"]
[1456.405245, "o", "\u001b[?2004l\r\n"]
[1456.498528, "o", "\u001b[?2004h> right = np.append(np.arange(1, N + 1), np.array(1))\r\n"]
[1456.591811, "o", "\u001b[?2004l\r\n"]
[1456.685094, "o", "\u001b[?2004h> intv = IntervalIndex.from_arrays(left, right)\r\n"]
[1456.778377, "o", "\u001b[?2004l\r\n"]
[1456.87166, "o", "\u001b[?2004h> intv._engine\r\n"]
[1456.964943, "o", "\u001b[?2004l\r\n"]
[1457.058226, "o", "\u001b[?2004h> intv2 = IntervalIndex.from_arrays(left + 1, right + 1)\r\n"]
[1457.151509, "o", "\u001b[?2004l\r\n"]
[1457.244792, "o", "\u001b[?2004h> intv2._engine\r\n"]
[1457.338075, "o", "\u001b[?2004l\r\n"]
[1457.431358, "o", "\u001b[?2004h> \r\n"]
[1457.524642, "o", "\u001b[?2004l\r\n"]
[1457.617925, "o", "\u001b[?2004h> # Baseline via current method\r\n"]
[1457.711208, "o", "\u001b[?2004l\r\n"]
[1457.804491, "o", "\u001b[?2004h> s = time.time(); res1 = intv.intersection(intv2); t1 = time.time()-s\r\n"]
[1457.897774, "o", "\u001b[?2004l\r\n"]
[1457.991057, "o", "\u001b[?2004h> \r\n"]
[1458.08434, "o", "\u001b[?2004l\r\n"]
[1458.177623, "o", "\u001b[?2004h> # Prototype using MultiIndex intersection\r\n"]
[1458.270906, "o", "\u001b[?2004l\r\n"]
[1458.364189, "o", "\u001b[?2004h> mi1 = MultiIndex.from_arrays([intv.left.values, intv.right.values])\r\n"]
[1458.457472, "o", "\u001b[?2004l\r\n"]
[1458.550755, "o", "\u001b[?2004h> mi2 = MultiIndex.from_arrays([intv2.left.values, intv2.right.values])\r\n"]
[1458.644038, "o", "\u001b[?2004l\r\n"]
[1458.737321, "o", "\u001b[?2004h> s = time.time(); mi_res = mi1.intersection(mi2, sort=False); t2 = time.time()-s\r\n"]
[1458.830604, "o", "\u001b[?2004l\r\n"]
[1458.923887, "o", "\u001b[?2004h> # reconstruct IntervalIndex\r\n"]
[1459.01717, "o", "\u001b[?2004l\r\n"]
[1459.110453, "o", "\u001b[?2004h> re = IntervalIndex.from_arrays(mi_res.get_level_values(0).values, mi_res.get_level_values(1).values, closed=intv.closed)\r\n"]
[1459.203736, "o", "\u001b[?2004l\r\n"]
[1459.297019, "o", "\u001b[?2004h> print('baseline_len', len(res1), 'mi_len', len(re), 'equal', list(res1[:10])==list(re[:10]))\r\n"]
[1459.390302, "o", "\u001b[?2004l\r\n"]
[1459.483585, "o", "\u001b[?2004h> print('times: baseline:', round(t1*1000,2),'ms  mi:', round(t2*1000,2),'ms')\r\n"]
[1459.576868, "o", "\u001b[?2004l\r\n"]
[1459.670151, "o", "\u001b[?2004h> PY\r\n"]
[1459.763434, "o", "\u001b[?2004l\r\n"]
[1459.856717, "o", "baseline_len 99999 mi_len 99999 equal True\r\n"]
[1460.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1460.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1460.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1462.478, "o", "\u001b[?2004l\r\n"]
[1465.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1465.002, "i", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r"]
[1465.004, "o", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1467.478, "o", "\u001b[?2004l\r\n"]
[1470.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1470.002, "i", "sed -n '820,1040p' pandas/core/indexes/interval.py\r"]
[1470.004, "o", "sed -n '820,1040p' pandas/core/indexes/interval.py\r\n"]
[1470.02827, "o", "\u001b[?2004l\r\n"]
[1470.050541, "o", "    @cache_readonly\r\n"]
[1470.072811, "o", "    def mid(self) -> Index:\r\n"]
[1470.095081, "o", "        return Index(self._data.mid, copy=False)\r\n"]
[1470.117351, "o", "\r\n"]
[1470.139622, "o", "    @property\r\n"]
[1470.161892, "o", "    def length(self) -> Index:\r\n"]
[1470.184162, "o", "        return Index(self._data.length, copy=False)\r\n"]
[1470.206432, "o", "\r\n"]
[1470.228703, "o", "    # --------------------------------------------------------------------\r\n"]
[1470.250973, "o", "    # Rendering Methods\r\n"]
[1470.273243, "o", "    # __repr__ associated methods are based on MultiIndex\r\n"]
[1470.295514, "o", "\r\n"]
[1470.317784, "o", "    def _format_with_header(self, header: list[str], na_rep: str) -> list[str]:\r\n"]
[1470.340054, "o", "        # matches base class except for whitespace padding\r\n"]
[1470.362324, "o", "        return header + list(self._format_native_types(na_rep=na_rep))\r\n"]
[1470.384595, "o", "\r\n"]
[1470.406865, "o", "    def _format_native_types(\r\n"]
[1470.429135, "o", "        self, *, na_rep: str = \"NaN\", quoting=None, **kwargs\r\n"]
[1470.451405, "o", "    ) -> npt.NDArray[np.object_]:\r\n"]
[1470.473676, "o", "        # GH 28210: use base method but with different default na_rep\r\n"]
[1470.495946, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1470.518216, "o", "\r\n"]
[1470.540486, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1470.562757, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1470.585027, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1470.607297, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1470.629568, "o", "\r\n"]
[1470.651838, "o", "    # --------------------------------------------------------------------\r\n"]
[1470.674108, "o", "    # Set Operations\r\n"]
[1470.696378, "o", "\r\n"]
[1470.718649, "o", "    def _intersection(self, other, sort):\r\n"]
[1470.740919, "o", "        \"\"\"\r\n"]
[1470.763189, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1470.785459, "o", "        \"\"\"\r\n"]
[1470.80773, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1470.83, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1470.85227, "o", "            taken = self._intersection_unique(other)\r\n"]
[1470.874541, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1470.896811, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1470.919081, "o", "            # multiple NaNs\r\n"]
[1470.941351, "o", "            taken = other._intersection_unique(self)\r\n"]
[1470.963622, "o", "        else:\r\n"]
[1470.985892, "o", "            # duplicates\r\n"]
[1471.008162, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1471.030432, "o", "\r\n"]
[1471.052703, "o", "        if sort is None:\r\n"]
[1471.074973, "o", "            taken = taken.sort_values()\r\n"]
[1471.097243, "o", "\r\n"]
[1471.119514, "o", "        return taken\r\n"]
[1471.141784, "o", "\r\n"]
[1471.164054, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1471.186324, "o", "        \"\"\"\r\n"]
[1471.208595, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1471.230865, "o", "        no matter left or right.\r\n"]
[1471.253135, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1471.275405, "o", "        Parameters\r\n"]
[1471.297676, "o", "        ----------\r\n"]
[1471.319946, "o", "        other : IntervalIndex\r\n"]
[1471.342216, "o", "        Returns\r\n"]
[1471.364486, "o", "        -------\r\n"]
[1471.386757, "o", "        IntervalIndex\r\n"]
[1471.409027, "o", "        \"\"\"\r\n"]
[1471.431297, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1471.453568, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1471.475838, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1471.498108, "o", "\r\n"]
[1471.520378, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1471.542649, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1471.564919, "o", "        indexer = unique(indexer)\r\n"]
[1471.587189, "o", "\r\n"]
[1471.609459, "o", "        return self.take(indexer)\r\n"]
[1471.63173, "o", "\r\n"]
[1471.654, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1471.67627, "o", "        \"\"\"\r\n"]
[1471.698541, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1471.720811, "o", "        on either sides.\r\n"]
[1471.743081, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1471.765351, "o", "\r\n"]
[1471.787622, "o", "        Parameters\r\n"]
[1471.809892, "o", "        ----------\r\n"]
[1471.832162, "o", "        other : IntervalIndex\r\n"]
[1471.854432, "o", "\r\n"]
[1471.876703, "o", "        Returns\r\n"]
[1471.898973, "o", "        -------\r\n"]
[1471.921243, "o", "        IntervalIndex\r\n"]
[1471.943514, "o", "        \"\"\"\r\n"]
[1471.965784, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1471.988054, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1472.010324, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1472.032595, "o", "\r\n"]
[1472.054865, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1472.077135, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1472.099405, "o", "            mask[first_nan_loc] = True\r\n"]
[1472.121676, "o", "\r\n"]
[1472.143946, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1472.166216, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1472.188486, "o", "            if tup in other_tups:\r\n"]
[1472.210757, "o", "                mask[i] = True\r\n"]
[1472.233027, "o", "\r\n"]
[1472.255297, "o", "        return self[mask]\r\n"]
[1472.277568, "o", "\r\n"]
[1472.299838, "o", "    # --------------------------------------------------------------------\r\n"]
[1472.322108, "o", "\r\n"]
[1472.344378, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1472.366649, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1472.388919, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1472.411189, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1472.433459, "o", "        raise NotImplementedError(\r\n"]
[1472.45573, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1472.478, "o", "            \"IndexEngine objects\"\r\n"]
[1472.50027, "o", "        )\r\n"]
[1472.522541, "o", "\r\n"]
[1472.544811, "o", "    def _from_join_target(self, result):\r\n"]
[1472.567081, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1472.589351, "o", "\r\n"]
[1472.611622, "o", "    # TODO: arithmetic operations\r\n"]
[1472.633892, "o", "\r\n"]
[1472.656162, "o", "\r\n"]
[1472.678432, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1472.700703, "o", "    \"\"\"\r\n"]
[1472.722973, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1472.745243, "o", "    \"\"\"\r\n"]
[1472.767514, "o", "    return any(\r\n"]
[1472.789784, "o", "        [\r\n"]
[1472.812054, "o", "            is_number(endpoint),\r\n"]
[1472.834324, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1472.856595, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1472.878865, "o", "            endpoint is None,\r\n"]
[1472.901135, "o", "        ]\r\n"]
[1472.923405, "o", "    )\r\n"]
[1472.945676, "o", "\r\n"]
[1472.967946, "o", "\r\n"]
[1472.990216, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1473.012486, "o", "    \"\"\"\r\n"]
[1473.034757, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1473.057027, "o", "    \"\"\"\r\n"]
[1473.079297, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1473.101568, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1473.123838, "o", "    return (\r\n"]
[1473.146108, "o", "        (is_number(a) and is_number(b))\r\n"]
[1473.168378, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1473.190649, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1473.212919, "o", "        or com.any_none(a, b)\r\n"]
[1473.235189, "o", "    )\r\n"]
[1473.257459, "o", "\r\n"]
[1473.27973, "o", "\r\n"]
[1473.302, "o", "def interval_range(\r\n"]
[1473.32427, "o", "    start=None,\r\n"]
[1473.346541, "o", "    end=None,\r\n"]
[1473.368811, "o", "    periods=None,\r\n"]
[1473.391081, "o", "    freq=None,\r\n"]
[1473.413351, "o", "    name: Hashable = None,\r\n"]
[1473.435622, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1473.457892, "o", ") -> IntervalIndex:\r\n"]
[1473.480162, "o", "    \"\"\"\r\n"]
[1473.502432, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1473.524703, "o", "\r\n"]
[1473.546973, "o", "    Parameters\r\n"]
[1473.569243, "o", "    ----------\r\n"]
[1473.591514, "o", "    start : numeric or datetime-like, default None\r\n"]
[1473.613784, "o", "        Left bound for generating intervals.\r\n"]
[1473.636054, "o", "    end : numeric or datetime-like, default None\r\n"]
[1473.658324, "o", "        Right bound for generating intervals.\r\n"]
[1473.680595, "o", "    periods : int, default None\r\n"]
[1473.702865, "o", "        Number of periods to generate.\r\n"]
[1473.725135, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1473.747405, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1473.769676, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1473.791946, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1473.814216, "o", "    name : str, default None\r\n"]
[1473.836486, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1473.858757, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1473.881027, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1473.903297, "o", "        or neither.\r\n"]
[1473.925568, "o", "\r\n"]
[1473.947838, "o", "    Returns\r\n"]
[1473.970108, "o", "    -------\r\n"]
[1473.992378, "o", "    IntervalIndex\r\n"]
[1474.014649, "o", "\r\n"]
[1474.036919, "o", "    See Also\r\n"]
[1474.059189, "o", "    --------\r\n"]
[1474.081459, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1474.10373, "o", "\r\n"]
[1474.126, "o", "    Notes\r\n"]
[1474.14827, "o", "    -----\r\n"]
[1474.170541, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1474.192811, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1474.215081, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1474.237351, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1474.259622, "o", "\r\n"]
[1474.281892, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1474.304162, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1474.326432, "o", "\r\n"]
[1474.348703, "o", "    Examples\r\n"]
[1474.370973, "o", "    --------\r\n"]
[1474.393243, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1474.415514, "o", "\r\n"]
[1474.437784, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1474.460054, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1474.482324, "o", "                  dtype='interval[int64, right]')\r\n"]
[1474.504595, "o", "\r\n"]
[1474.526865, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1474.549135, "o", "\r\n"]
[1474.571405, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1474.593676, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1474.615946, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1474.638216, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1474.660486, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1474.682757, "o", "\r\n"]
[1474.705027, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1474.727297, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1474.749568, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1474.771838, "o", "\r\n"]
[1474.794108, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1474.816378, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1474.838649, "o", "                  dtype='interval[float64, right]')\r\n"]
[1474.860919, "o", "\r\n"]
[1474.883189, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1474.905459, "o", "    convertible to a DateOffset.\r\n"]
[1474.92773, "o", "\r\n"]
[1475.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1475.002, "i", "python - << 'PY'\r"]
[1475.004, "o", "python - << 'PY'\r\n"]
[1475.115867, "o", "\u001b[?2004l\r\n"]
[1475.225733, "o", "\u001b[?2004h> from pathlib import Path\r\n"]
[1475.3356, "o", "\u001b[?2004l\r\n"]
[1475.445467, "o", "\u001b[?2004h> p = Path('pandas/core/indexes/interval.py')\r\n"]
[1475.555333, "o", "\u001b[?2004l\r\n"]
[1475.6652, "o", "\u001b[?2004h> s = p.read_text()\r\n"]
[1475.775067, "o", "\u001b[?2004l\r\n"]
[1475.884933, "o", "\u001b[?2004h> start = s.find('def _intersection_non_unique')\r\n"]
[1475.9948, "o", "\u001b[?2004l\r\n"]
[1476.104667, "o", "\u001b[?2004h> end = s.find('\\ndef ', start+1)\r\n"]
[1476.214533, "o", "\u001b[?2004l\r\n"]
[1476.3244, "o", "\u001b[?2004h> print('start:', start, 'end:', end)\r\n"]
[1476.434267, "o", "\u001b[?2004l\r\n"]
[1476.544133, "o", "\u001b[?2004h> print(s[start-200:start+600])\r\n"]
[1476.654, "o", "\u001b[?2004l\r\n"]
[1476.763867, "o", "\u001b[?2004h> PY\r\n"]
[1476.873733, "o", "\u001b[?2004l\r\n"]
[1476.9836, "o", "start: 29367 end: 30966\r\n"]
[1477.093467, "o", "r(other.right)\r\n"]
[1477.203333, "o", "\r\n"]
[1477.3132, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1477.423067, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1477.532933, "o", "        indexer = unique(indexer)\r\n"]
[1477.6428, "o", "\r\n"]
[1477.752667, "o", "        return self.take(indexer)\r\n"]
[1477.862533, "o", "\r\n"]
[1477.9724, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1478.082267, "o", "        \"\"\"\r\n"]
[1478.192133, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1478.302, "o", "        on either sides.\r\n"]
[1478.411867, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1478.521733, "o", "\r\n"]
[1478.6316, "o", "        Parameters\r\n"]
[1478.741467, "o", "        ----------\r\n"]
[1478.851333, "o", "        other : IntervalIndex\r\n"]
[1478.9612, "o", "\r\n"]
[1479.071067, "o", "        Returns\r\n"]
[1479.180933, "o", "        -------\r\n"]
[1479.2908, "o", "        IntervalIndex\r\n"]
[1479.400667, "o", "        \"\"\"\r\n"]
[1479.510533, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1479.6204, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1479.730267, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1479.840133, "o", "\r\n"]
[1480.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1480.002, "i", "applypatch << 'PATCH'\r"]
[1480.004, "o", "applypatch << 'PATCH'\r\n"]
[1480.059739, "o", "\u001b[?2004l\r\n"]
[1480.113478, "o", "\u001b[?2004h> *** Begin Patch\r\n"]
[1480.167217, "o", "\u001b[?2004l\r\n"]
[1480.220957, "o", "\u001b[?2004h> *** Update File: pandas/core/indexes/interval.py\r\n"]
[1480.274696, "o", "\u001b[?2004l\r\n"]
[1480.328435, "o", "\u001b[?2004h> @@\r\n"]
[1480.382174, "o", "\u001b[?2004l\r\n"]
[1480.435913, "o", "\u001b[?2004h>  def _intersection_non_unique(self, other, sort):\r\n"]
[1480.489652, "o", "\u001b[?2004l\r\n"]
[1480.543391, "o", "\u001b[?2004h> -    # existing implementation handles non-unique cases\r\n"]
[1480.59713, "o", "\u001b[?2004l\r\n"]
[1480.65087, "o", "\u001b[?2004h> -    # fall back to base behavior\r\n"]
[1480.704609, "o", "\u001b[?2004l\r\n"]
[1480.758348, "o", "\u001b[?2004h> -    return Index._intersection(self, other, sort=sort)\r\n"]
[1480.812087, "o", "\u001b[?2004l\r\n"]
[1480.865826, "o", "\u001b[?2004h> +    # Fastpath for non-unique IntervalIndex intersection:\r\n"]
[1480.919565, "o", "\u001b[?2004l\r\n"]
[1480.973304, "o", "\u001b[?2004h> +    # If both IntervalIndexes share the same dtype and 'closed' attribute,\r\n"]
[1481.027043, "o", "\u001b[?2004l\r\n"]
[1481.080783, "o", "\u001b[?2004h> +    # we can intersect pairs of (left, right) endpoints using a MultiIndex\r\n"]
[1481.134522, "o", "\u001b[?2004l\r\n"]
[1481.188261, "o", "\u001b[?2004h> +    # and then reconstruct an IntervalIndex. This avoids expensive Python-level\r\n"]
[1481.242, "o", "\u001b[?2004l\r\n"]
[1481.295739, "o", "\u001b[?2004h> +    # handling and leverages optimized index setops. Semantics (order and\r\n"]
[1481.349478, "o", "\u001b[?2004l\r\n"]
[1481.403217, "o", "\u001b[?2004h> +    # duplicate handling) follow Index.intersection with sort=False.\r\n"]
[1481.456957, "o", "\u001b[?2004l\r\n"]
[1481.510696, "o", "\u001b[?2004h> +    try:\r\n"]
[1481.564435, "o", "\u001b[?2004l\r\n"]
[1481.618174, "o", "\u001b[?2004h> +        if isinstance(other, IntervalIndex) and self.closed == other.closed:\r\n"]
[1481.671913, "o", "\u001b[?2004l\r\n"]
[1481.725652, "o", "\u001b[?2004h> +            # Ensure comparable endpoint dtypes and avoid object dtype\r\n"]
[1481.779391, "o", "\u001b[?2004l\r\n"]
[1481.83313, "o", "\u001b[?2004h> +            left1 = self.left.values\r\n"]
[1481.88687, "o", "\u001b[?2004l\r\n"]
[1481.940609, "o", "\u001b[?2004h> +            right1 = self.right.values\r\n"]
[1481.994348, "o", "\u001b[?2004l\r\n"]
[1482.048087, "o", "\u001b[?2004h> +            left2 = other.left.values\r\n"]
[1482.101826, "o", "\u001b[?2004l\r\n"]
[1482.155565, "o", "\u001b[?2004h> +            right2 = other.right.values\r\n"]
[1482.209304, "o", "\u001b[?2004l\r\n"]
[1482.263043, "o", "\u001b[?2004h> +\r\n"]
[1482.316783, "o", "\u001b[?2004l\r\n"]
[1482.370522, "o", "\u001b[?2004h> +            if (\r\n"]
[1482.424261, "o", "\u001b[?2004l\r\n"]
[1482.478, "o", "\u001b[?2004h> +                left1.dtype == left2.dtype\r\n"]
[1482.531739, "o", "\u001b[?2004l\r\n"]
[1482.585478, "o", "\u001b[?2004h> +                and right1.dtype == right2.dtype\r\n"]
[1482.639217, "o", "\u001b[?2004l\r\n"]
[1482.692957, "o", "\u001b[?2004h> +                and left1.dtype != object\r\n"]
[1482.746696, "o", "\u001b[?2004l\r\n"]
[1482.800435, "o", "\u001b[?2004h> +                and right1.dtype != object\r\n"]
[1482.854174, "o", "\u001b[?2004l\r\n"]
[1482.907913, "o", "\u001b[?2004h> +            ):\r\n"]
[1482.961652, "o", "\u001b[?2004l\r\n"]
[1483.015391, "o", "\u001b[?2004h> +                from pandas import MultiIndex\r\n"]
[1483.06913, "o", "\u001b[?2004l\r\n"]
[1483.12287, "o", "\u001b[?2004h> +                mi1 = MultiIndex.from_arrays([left1, right1])\r\n"]
[1483.176609, "o", "\u001b[?2004l\r\n"]
[1483.230348, "o", "\u001b[?2004h> +                mi2 = MultiIndex.from_arrays([left2, right2])\r\n"]
[1483.284087, "o", "\u001b[?2004l\r\n"]
[1483.337826, "o", "\u001b[?2004h> +                mi_res = mi1.intersection(mi2, sort=False)\r\n"]
[1483.391565, "o", "\u001b[?2004l\r\n"]
[1483.445304, "o", "\u001b[?2004h> +                if len(mi_res) == 0:\r\n"]
[1483.499043, "o", "\u001b[?2004l\r\n"]
[1483.552783, "o", "\u001b[?2004h> +                    return self[:0]\r\n"]
[1483.606522, "o", "\u001b[?2004l\r\n"]
[1483.660261, "o", "\u001b[?2004h> +                res_left = mi_res.get_level_values(0).values\r\n"]
[1483.714, "o", "\u001b[?2004l\r\n"]
[1483.767739, "o", "\u001b[?2004h> +                res_right = mi_res.get_level_values(1).values\r\n"]
[1483.821478, "o", "\u001b[?2004l\r\n"]
[1483.875217, "o", "\u001b[?2004h> +                # Reconstruct IntervalIndex; keep closed from self.\r\n"]
[1483.928957, "o", "\u001b[?2004l\r\n"]
[1483.982696, "o", "\u001b[?2004h> +                return IntervalIndex.from_arrays(res_left, res_right, closed=self.closed)\r\n"]
[1484.036435, "o", "\u001b[?2004l\r\n"]
[1484.090174, "o", "\u001b[?2004h> +    except Exception:\r\n"]
[1484.143913, "o", "\u001b[?2004l\r\n"]
[1484.197652, "o", "\u001b[?2004h> +        # Fall back to existing implementation on any issue\r\n"]
[1484.251391, "o", "\u001b[?2004l\r\n"]
[1484.30513, "o", "\u001b[?2004h> +        pass\r\n"]
[1484.35887, "o", "\u001b[?2004l\r\n"]
[1484.412609, "o", "\u001b[?2004h> +\r\n"]
[1484.466348, "o", "\u001b[?2004l\r\n"]
[1484.520087, "o", "\u001b[?2004h> +    # Fallback to base behavior\r\n"]
[1484.573826, "o", "\u001b[?2004l\r\n"]
[1484.627565, "o", "\u001b[?2004h> +    return Index._intersection(self, other, sort=sort)\r\n"]
[1484.681304, "o", "\u001b[?2004l\r\n"]
[1484.735043, "o", "\u001b[?2004h> *** End Patch\r\n"]
[1484.788783, "o", "\u001b[?2004l\r\n"]
[1484.842522, "o", "\u001b[?2004h> PATCH\r\n"]
[1484.896261, "o", "\u001b[?2004l\r\n"]
[1485.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1485.002, "i", "python -m pyflakes pandas/core/indexes/interval.py 2>/dev/null || true\r"]
[1485.004, "o", "python -m pyflakes pandas/core/indexes/interval.py 2>/dev/null || true\r\n"]
[1485.006, "o", "\u001b[?2004l\r\n"]
[1490.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1490.002, "i", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r"]
[1490.004, "o", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r\n"]
[1490.359143, "o", "ue\r\n"]
[1490.712286, "o", "\u001b[?2004l\r\n"]
[1491.065429, "o", "cd asv_bench\r\n"]
[1491.418571, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\"\r\n"]
[1491.771714, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection\" \r\n"]
[1492.124857, "o", "\r\n"]
[1492.478, "o", "\u001b[33m======================================================================= warnings summary =======================================================================\u001b[0m\r\n"]
[1492.831143, "o", "pandas/core/construction.py:335\r\n"]
[1493.184286, "o", "  /workspace/repo/pandas/core/construction.py:335: UserWarning: pyarrow requires pandas 1.0.0 or above, pandas 0+untagged.31506.g5f584bd is installed. Therefore, pandas-specific integration is not used.\r\n"]
[1493.537429, "o", "    return cls._from_sequence(data, dtype=dtype, copy=copy)\r\n"]
[1493.890571, "o", "\r\n"]
[1494.243714, "o", "-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\r\n"]
[1494.596857, "o", "------------------------------------------------------ generated xml file: /workspace/repo/test-data.xml -------------------------------------------------------\r\n"]
[1495.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1495.002, "i", "cd asv_bench\r"]
[1495.004, "o", "cd asv_bench\r\n"]
[1495.006, "o", "\u001b[?2004l\r\n"]
[1500.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1500.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1500.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1505.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1505.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1505.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1505.418, "o", "\u001b[?2004l\r\n"]
[1505.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1506.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1506.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1507.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1507.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1507.89, "o", "              param1            \r\n"]
[1508.302, "o", "             -------- ----------\r\n"]
[1508.714, "o", "               1000    1.33\u00b10ms \r\n"]
[1509.126, "o", "              100000   86.0\u00b10ms \r\n"]
[1509.538, "o", "             ======== ==========\r\n"]
[1510.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1510.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection\" \r"]
[1510.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection\" \r\n"]
[1510.182571, "o", "\u001b[?2004l\r\n"]
[1510.359143, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1510.535714, "o", "\u00b7 \u001b[0;32mRunning 3 total benchmarks (1 commits * 1 environments * 3 benchmarks)\u001b[0m\r\n"]
[1510.712286, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1510.888857, "o", "[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection\u001b[0m                                                                                              ok\r\n"]
[1511.065429, "o", "[16.67%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1511.242, "o", "              param1            \r\n"]
[1511.418571, "o", "             -------- ----------\r\n"]
[1511.595143, "o", "               1000    1.01\u00b10ms \r\n"]
[1511.771714, "o", "              100000   8.90\u00b10ms \r\n"]
[1511.948286, "o", "             ======== ==========\r\n"]
[1512.124857, "o", "\r\n"]
[1512.301429, "o", "[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1512.478, "o", "[33.33%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1512.654571, "o", "              param1            \r\n"]
[1512.831143, "o", "             -------- ----------\r\n"]
[1513.007714, "o", "               1000    1.25\u00b10ms \r\n"]
[1513.184286, "o", "              100000   93.8\u00b10ms \r\n"]
[1513.360857, "o", "             ======== ==========\r\n"]
[1513.537429, "o", "\r\n"]
[1513.714, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_one_duplicate\u001b[0m                                                                                ok\r\n"]
[1513.890571, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1514.067143, "o", "              param1            \r\n"]
[1514.243714, "o", "             -------- ----------\r\n"]
[1514.420286, "o", "               1000    828\u00b10\u03bcs  \r\n"]
[1514.596857, "o", "              100000   8.27\u00b10ms \r\n"]
[1514.773429, "o", "             ======== ==========\r\n"]
[1515.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1515.002, "i", "cd ..\r"]
[1515.004, "o", "cd ..\r\n"]
[1515.006, "o", "\u001b[?2004l\r\n"]
[1520.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1520.002, "i", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r"]
[1520.004, "o", "grep -n \"def _intersection\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1522.478, "o", "\u001b[?2004l\r\n"]
[1525.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1525.002, "i", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r"]
[1525.004, "o", "grep -n \"def _intersection_non_unique\\(\" pandas/core/indexes/interval.py || true\r\n"]
[1527.478, "o", "\u001b[?2004l\r\n"]
[1530.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1530.002, "i", "sed -n '840,1040p' pandas/core/indexes/interval.py\r"]
[1530.004, "o", "sed -n '840,1040p' pandas/core/indexes/interval.py\r\n"]
[1530.030475, "o", "\u001b[?2004l\r\n"]
[1530.05495, "o", "        return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)\r\n"]
[1530.079426, "o", "\r\n"]
[1530.103901, "o", "    def _format_data(self, name=None) -> str:\r\n"]
[1530.128376, "o", "        # TODO: integrate with categorical and make generic\r\n"]
[1530.152851, "o", "        # name argument is unused here; just for compat with base / categorical\r\n"]
[1530.177327, "o", "        return f\"{self._data._format_data()},{self._format_space()}\"\r\n"]
[1530.201802, "o", "\r\n"]
[1530.226277, "o", "    # --------------------------------------------------------------------\r\n"]
[1530.250752, "o", "    # Set Operations\r\n"]
[1530.275228, "o", "\r\n"]
[1530.299703, "o", "    def _intersection(self, other, sort):\r\n"]
[1530.324178, "o", "        \"\"\"\r\n"]
[1530.348653, "o", "        intersection specialized to the case with matching dtypes.\r\n"]
[1530.373129, "o", "        \"\"\"\r\n"]
[1530.397604, "o", "        # For IntervalIndex we also know other.closed == self.closed\r\n"]
[1530.422079, "o", "        if self.left.is_unique and self.right.is_unique:\r\n"]
[1530.446554, "o", "            taken = self._intersection_unique(other)\r\n"]
[1530.47103, "o", "        elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\r\n"]
[1530.495505, "o", "            # Swap other/self if other is unique and self does not have\r\n"]
[1530.51998, "o", "            # multiple NaNs\r\n"]
[1530.544455, "o", "            taken = other._intersection_unique(self)\r\n"]
[1530.568931, "o", "        else:\r\n"]
[1530.593406, "o", "            # duplicates\r\n"]
[1530.617881, "o", "            taken = self._intersection_non_unique(other)\r\n"]
[1530.642356, "o", "\r\n"]
[1530.666832, "o", "        if sort is None:\r\n"]
[1530.691307, "o", "            taken = taken.sort_values()\r\n"]
[1530.715782, "o", "\r\n"]
[1530.740257, "o", "        return taken\r\n"]
[1530.764733, "o", "\r\n"]
[1530.789208, "o", "    def _intersection_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1530.813683, "o", "        \"\"\"\r\n"]
[1530.838158, "o", "        Used when the IntervalIndex does not have any common endpoint,\r\n"]
[1530.862634, "o", "        no matter left or right.\r\n"]
[1530.887109, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1530.911584, "o", "        Parameters\r\n"]
[1530.936059, "o", "        ----------\r\n"]
[1530.960535, "o", "        other : IntervalIndex\r\n"]
[1530.98501, "o", "        Returns\r\n"]
[1531.009485, "o", "        -------\r\n"]
[1531.03396, "o", "        IntervalIndex\r\n"]
[1531.058436, "o", "        \"\"\"\r\n"]
[1531.082911, "o", "        # Note: this is much more performant than super()._intersection(other)\r\n"]
[1531.107386, "o", "        lindexer = self.left.get_indexer(other.left)\r\n"]
[1531.131861, "o", "        rindexer = self.right.get_indexer(other.right)\r\n"]
[1531.156337, "o", "\r\n"]
[1531.180812, "o", "        match = (lindexer == rindexer) & (lindexer != -1)\r\n"]
[1531.205287, "o", "        indexer = lindexer.take(match.nonzero()[0])\r\n"]
[1531.229762, "o", "        indexer = unique(indexer)\r\n"]
[1531.254238, "o", "\r\n"]
[1531.278713, "o", "        return self.take(indexer)\r\n"]
[1531.303188, "o", "\r\n"]
[1531.327663, "o", "    def _intersection_non_unique(self, other: IntervalIndex) -> IntervalIndex:\r\n"]
[1531.352139, "o", "        \"\"\"\r\n"]
[1531.376614, "o", "        Used when the IntervalIndex does have some common endpoints,\r\n"]
[1531.401089, "o", "        on either sides.\r\n"]
[1531.425564, "o", "        Return the intersection with another IntervalIndex.\r\n"]
[1531.45004, "o", "\r\n"]
[1531.474515, "o", "        Parameters\r\n"]
[1531.49899, "o", "        ----------\r\n"]
[1531.523465, "o", "        other : IntervalIndex\r\n"]
[1531.547941, "o", "\r\n"]
[1531.572416, "o", "        Returns\r\n"]
[1531.596891, "o", "        -------\r\n"]
[1531.621366, "o", "        IntervalIndex\r\n"]
[1531.645842, "o", "        \"\"\"\r\n"]
[1531.670317, "o", "        # Note: this is about 3.25x faster than super()._intersection(other)\r\n"]
[1531.694792, "o", "        #  in IntervalIndexMethod.time_intersection_both_duplicate(1000)\r\n"]
[1531.719267, "o", "        mask = np.zeros(len(self), dtype=bool)\r\n"]
[1531.743743, "o", "\r\n"]
[1531.768218, "o", "        if self.hasnans and other.hasnans:\r\n"]
[1531.792693, "o", "            first_nan_loc = np.arange(len(self))[self.isna()][0]\r\n"]
[1531.817168, "o", "            mask[first_nan_loc] = True\r\n"]
[1531.841644, "o", "\r\n"]
[1531.866119, "o", "        other_tups = set(zip(other.left, other.right))\r\n"]
[1531.890594, "o", "        for i, tup in enumerate(zip(self.left, self.right)):\r\n"]
[1531.915069, "o", "            if tup in other_tups:\r\n"]
[1531.939545, "o", "                mask[i] = True\r\n"]
[1531.96402, "o", "\r\n"]
[1531.988495, "o", "        return self[mask]\r\n"]
[1532.01297, "o", "\r\n"]
[1532.037446, "o", "    # --------------------------------------------------------------------\r\n"]
[1532.061921, "o", "\r\n"]
[1532.086396, "o", "    def _get_engine_target(self) -> np.ndarray:\r\n"]
[1532.110871, "o", "        # Note: we _could_ use libjoin functions by either casting to object\r\n"]
[1532.135347, "o", "        #  dtype or constructing tuples (faster than constructing Intervals)\r\n"]
[1532.159822, "o", "        #  but the libjoin fastpaths are no longer fast in these cases.\r\n"]
[1532.184297, "o", "        raise NotImplementedError(\r\n"]
[1532.208772, "o", "            \"IntervalIndex does not use libjoin fastpaths or pass values to \"\r\n"]
[1532.233248, "o", "            \"IndexEngine objects\"\r\n"]
[1532.257723, "o", "        )\r\n"]
[1532.282198, "o", "\r\n"]
[1532.306673, "o", "    def _from_join_target(self, result):\r\n"]
[1532.331149, "o", "        raise NotImplementedError(\"IntervalIndex does not use libjoin fastpaths\")\r\n"]
[1532.355624, "o", "\r\n"]
[1532.380099, "o", "    # TODO: arithmetic operations\r\n"]
[1532.404574, "o", "\r\n"]
[1532.42905, "o", "\r\n"]
[1532.453525, "o", "def _is_valid_endpoint(endpoint) -> bool:\r\n"]
[1532.478, "o", "    \"\"\"\r\n"]
[1532.502475, "o", "    Helper for interval_range to check if start/end are valid types.\r\n"]
[1532.52695, "o", "    \"\"\"\r\n"]
[1532.551426, "o", "    return any(\r\n"]
[1532.575901, "o", "        [\r\n"]
[1532.600376, "o", "            is_number(endpoint),\r\n"]
[1532.624851, "o", "            isinstance(endpoint, Timestamp),\r\n"]
[1532.649327, "o", "            isinstance(endpoint, Timedelta),\r\n"]
[1532.673802, "o", "            endpoint is None,\r\n"]
[1532.698277, "o", "        ]\r\n"]
[1532.722752, "o", "    )\r\n"]
[1532.747228, "o", "\r\n"]
[1532.771703, "o", "\r\n"]
[1532.796178, "o", "def _is_type_compatible(a, b) -> bool:\r\n"]
[1532.820653, "o", "    \"\"\"\r\n"]
[1532.845129, "o", "    Helper for interval_range to check type compat of start/end/freq.\r\n"]
[1532.869604, "o", "    \"\"\"\r\n"]
[1532.894079, "o", "    is_ts_compat = lambda x: isinstance(x, (Timestamp, BaseOffset))\r\n"]
[1532.918554, "o", "    is_td_compat = lambda x: isinstance(x, (Timedelta, BaseOffset))\r\n"]
[1532.94303, "o", "    return (\r\n"]
[1532.967505, "o", "        (is_number(a) and is_number(b))\r\n"]
[1532.99198, "o", "        or (is_ts_compat(a) and is_ts_compat(b))\r\n"]
[1533.016455, "o", "        or (is_td_compat(a) and is_td_compat(b))\r\n"]
[1533.040931, "o", "        or com.any_none(a, b)\r\n"]
[1533.065406, "o", "    )\r\n"]
[1533.089881, "o", "\r\n"]
[1533.114356, "o", "\r\n"]
[1533.138832, "o", "def interval_range(\r\n"]
[1533.163307, "o", "    start=None,\r\n"]
[1533.187782, "o", "    end=None,\r\n"]
[1533.212257, "o", "    periods=None,\r\n"]
[1533.236733, "o", "    freq=None,\r\n"]
[1533.261208, "o", "    name: Hashable = None,\r\n"]
[1533.285683, "o", "    closed: IntervalClosedType = \"right\",\r\n"]
[1533.310158, "o", ") -> IntervalIndex:\r\n"]
[1533.334634, "o", "    \"\"\"\r\n"]
[1533.359109, "o", "    Return a fixed frequency IntervalIndex.\r\n"]
[1533.383584, "o", "\r\n"]
[1533.408059, "o", "    Parameters\r\n"]
[1533.432535, "o", "    ----------\r\n"]
[1533.45701, "o", "    start : numeric or datetime-like, default None\r\n"]
[1533.481485, "o", "        Left bound for generating intervals.\r\n"]
[1533.50596, "o", "    end : numeric or datetime-like, default None\r\n"]
[1533.530436, "o", "        Right bound for generating intervals.\r\n"]
[1533.554911, "o", "    periods : int, default None\r\n"]
[1533.579386, "o", "        Number of periods to generate.\r\n"]
[1533.603861, "o", "    freq : numeric, str, datetime.timedelta, or DateOffset, default None\r\n"]
[1533.628337, "o", "        The length of each interval. Must be consistent with the type of start\r\n"]
[1533.652812, "o", "        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\r\n"]
[1533.677287, "o", "        for numeric and 'D' for datetime-like.\r\n"]
[1533.701762, "o", "    name : str, default None\r\n"]
[1533.726238, "o", "        Name of the resulting IntervalIndex.\r\n"]
[1533.750713, "o", "    closed : {'left', 'right', 'both', 'neither'}, default 'right'\r\n"]
[1533.775188, "o", "        Whether the intervals are closed on the left-side, right-side, both\r\n"]
[1533.799663, "o", "        or neither.\r\n"]
[1533.824139, "o", "\r\n"]
[1533.848614, "o", "    Returns\r\n"]
[1533.873089, "o", "    -------\r\n"]
[1533.897564, "o", "    IntervalIndex\r\n"]
[1533.92204, "o", "\r\n"]
[1533.946515, "o", "    See Also\r\n"]
[1533.97099, "o", "    --------\r\n"]
[1533.995465, "o", "    IntervalIndex : An Index of intervals that are all closed on the same side.\r\n"]
[1534.019941, "o", "\r\n"]
[1534.044416, "o", "    Notes\r\n"]
[1534.068891, "o", "    -----\r\n"]
[1534.093366, "o", "    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\r\n"]
[1534.117842, "o", "    exactly three must be specified. If ``freq`` is omitted, the resulting\r\n"]
[1534.142317, "o", "    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\r\n"]
[1534.166792, "o", "    ``start`` and ``end``, inclusively.\r\n"]
[1534.191267, "o", "\r\n"]
[1534.215743, "o", "    To learn more about datetime-like frequency strings, please see `this link\r\n"]
[1534.240218, "o", "    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\r\n"]
[1534.264693, "o", "\r\n"]
[1534.289168, "o", "    Examples\r\n"]
[1534.313644, "o", "    --------\r\n"]
[1534.338119, "o", "    Numeric ``start`` and  ``end`` is supported.\r\n"]
[1534.362594, "o", "\r\n"]
[1534.387069, "o", "    >>> pd.interval_range(start=0, end=5)\r\n"]
[1534.411545, "o", "    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\r\n"]
[1534.43602, "o", "                  dtype='interval[int64, right]')\r\n"]
[1534.460495, "o", "\r\n"]
[1534.48497, "o", "    Additionally, datetime-like input is also supported.\r\n"]
[1534.509446, "o", "\r\n"]
[1534.533921, "o", "    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\r\n"]
[1534.558396, "o", "    ...                   end=pd.Timestamp('2017-01-04'))\r\n"]
[1534.582871, "o", "    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\r\n"]
[1534.607347, "o", "                   (2017-01-03, 2017-01-04]],\r\n"]
[1534.631822, "o", "                  dtype='interval[datetime64[ns], right]')\r\n"]
[1534.656297, "o", "\r\n"]
[1534.680772, "o", "    The ``freq`` parameter specifies the frequency between the left and right.\r\n"]
[1534.705248, "o", "    endpoints of the individual intervals within the ``IntervalIndex``.  For\r\n"]
[1534.729723, "o", "    numeric ``start`` and ``end``, the frequency must also be numeric.\r\n"]
[1534.754198, "o", "\r\n"]
[1534.778673, "o", "    >>> pd.interval_range(start=0, periods=4, freq=1.5)\r\n"]
[1534.803149, "o", "    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\r\n"]
[1534.827624, "o", "                  dtype='interval[float64, right]')\r\n"]
[1534.852099, "o", "\r\n"]
[1534.876574, "o", "    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\r\n"]
[1534.90105, "o", "    convertible to a DateOffset.\r\n"]
[1534.925525, "o", "\r\n"]
[1535.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1535.002, "i", "applypatch << 'PATCH'\r"]
[1535.004, "o", "applypatch << 'PATCH'\r\n"]
[1535.10488, "o", "\u001b[?2004l\r\n"]
[1535.20376, "o", "\u001b[?2004h> *** Begin Patch\r\n"]
[1535.30264, "o", "\u001b[?2004l\r\n"]
[1535.40152, "o", "\u001b[?2004h> *** Update File: pandas/core/indexes/interval.py\r\n"]
[1535.5004, "o", "\u001b[?2004l\r\n"]
[1535.59928, "o", "\u001b[?2004h> @@\r\n"]
[1535.69816, "o", "\u001b[?2004l\r\n"]
[1535.79704, "o", "\u001b[?2004h> -    try:\r\n"]
[1535.89592, "o", "\u001b[?2004l\r\n"]
[1535.9948, "o", "\u001b[?2004h> -        if isinstance(other, IntervalIndex) and self.closed == other.closed:\r\n"]
[1536.09368, "o", "\u001b[?2004l\r\n"]
[1536.19256, "o", "\u001b[?2004h> +    try:\r\n"]
[1536.29144, "o", "\u001b[?2004l\r\n"]
[1536.39032, "o", "\u001b[?2004h> +        # Only fastpath when we don't request sorting (preserve existing order)\r\n"]
[1536.4892, "o", "\u001b[?2004l\r\n"]
[1536.58808, "o", "\u001b[?2004h> +        if sort is not True and isinstance(other, IntervalIndex) and self.closed == other.closed:\r\n"]
[1536.68696, "o", "\u001b[?2004l\r\n"]
[1536.78584, "o", "\u001b[?2004h> @@\r\n"]
[1536.88472, "o", "\u001b[?2004l\r\n"]
[1536.9836, "o", "\u001b[?2004h> -                mi_res = mi1.intersection(mi2, sort=False)\r\n"]
[1537.08248, "o", "\u001b[?2004l\r\n"]
[1537.18136, "o", "\u001b[?2004h> +                # preserve order semantics of default intersection (sort=False)\r\n"]
[1537.28024, "o", "\u001b[?2004l\r\n"]
[1537.37912, "o", "\u001b[?2004h> +                mi_res = mi1.intersection(mi2, sort=False)\r\n"]
[1537.478, "o", "\u001b[?2004l\r\n"]
[1537.57688, "o", "\u001b[?2004h>                  if len(mi_res) == 0:\r\n"]
[1537.67576, "o", "\u001b[?2004l\r\n"]
[1537.77464, "o", "\u001b[?2004h>                      return self[:0]\r\n"]
[1537.87352, "o", "\u001b[?2004l\r\n"]
[1537.9724, "o", "\u001b[?2004h>                  res_left = mi_res.get_level_values(0).values\r\n"]
[1538.07128, "o", "\u001b[?2004l\r\n"]
[1538.17016, "o", "\u001b[?2004h>                  res_right = mi_res.get_level_values(1).values\r\n"]
[1538.26904, "o", "\u001b[?2004l\r\n"]
[1538.36792, "o", "\u001b[?2004h> -                # Reconstruct IntervalIndex; keep closed from self.\r\n"]
[1538.4668, "o", "\u001b[?2004l\r\n"]
[1538.56568, "o", "\u001b[?2004h> -                return IntervalIndex.from_arrays(res_left, res_right, closed=self.closed)\r\n"]
[1538.66456, "o", "\u001b[?2004l\r\n"]
[1538.76344, "o", "\u001b[?2004h> +                # Reconstruct IntervalIndex; keep closed from self and set name\r\n"]
[1538.86232, "o", "\u001b[?2004l\r\n"]
[1538.9612, "o", "\u001b[?2004h> +                # consistently with Index.intersection semantics: common name only.\r\n"]
[1539.06008, "o", "\u001b[?2004l\r\n"]
[1539.15896, "o", "\u001b[?2004h> +                name = self.name if self.name == other.name else None\r\n"]
[1539.25784, "o", "\u001b[?2004l\r\n"]
[1539.35672, "o", "\u001b[?2004h> +                return IntervalIndex.from_arrays(res_left, res_right, closed=self.closed, name=name)\r\n"]
[1539.4556, "o", "\u001b[?2004l\r\n"]
[1539.55448, "o", "\u001b[?2004h> *** End Patch\r\n"]
[1539.65336, "o", "\u001b[?2004l\r\n"]
[1539.75224, "o", "\u001b[?2004h> PATCH\r\n"]
[1539.85112, "o", "\u001b[?2004l\r\n"]
[1540.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1540.002, "i", "python -m pyflakes pandas/core/indexes/interval.py 2>/dev/null || true\r"]
[1540.004, "o", "python -m pyflakes pandas/core/indexes/interval.py 2>/dev/null || true\r\n"]
[1540.006, "o", "\u001b[?2004l\r\n"]
[1545.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1545.002, "i", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r"]
[1545.004, "o", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r\n"]
[1545.359143, "o", "ue\r\n"]
[1545.712286, "o", "\u001b[?2004l\r\n"]
[1546.065429, "o", "cd asv_bench\r\n"]
[1546.418571, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\"\r\n"]
[1546.771714, "o", "\r\n"]
[1547.124857, "o", "\u001b[33m======================================================================= warnings summary =======================================================================\u001b[0m\r\n"]
[1547.478, "o", "pandas/core/construction.py:335\r\n"]
[1547.831143, "o", "  /workspace/repo/pandas/core/construction.py:335: UserWarning: pyarrow requires pandas 1.0.0 or above, pandas 0+untagged.31506.g5f584bd is installed. Therefore, pandas-specific integration is not used.\r\n"]
[1548.184286, "o", "    return cls._from_sequence(data, dtype=dtype, copy=copy)\r\n"]
[1548.537429, "o", "\r\n"]
[1548.890571, "o", "-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\r\n"]
[1549.243714, "o", "------------------------------------------------------ generated xml file: /workspace/repo/test-data.xml -------------------------------------------------------\r\n"]
[1549.596857, "o", "\u001b[33m\u001b[33m\u001b[1m1 skipped\u001b[0m, \u001b[33m\u001b[1m214465 deselected\u001b[0m, \u001b[33m\u001b[1m1 warning\u001b[0m\u001b[33m in 97.02s (0:01:37)\u001b[0m\u001b[0m\r\n"]
[1550.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1550.002, "i", "cd asv_bench\r"]
[1550.004, "o", "cd asv_bench\r\n"]
[1550.006, "o", "\u001b[?2004l\r\n"]
[1555.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1555.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1555.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1560.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1560.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1560.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1560.418, "o", "\u001b[?2004l\r\n"]
[1560.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1561.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1561.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1562.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1562.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1562.89, "o", "              param1            \r\n"]
[1563.302, "o", "             -------- ----------\r\n"]
[1563.714, "o", "               1000    1.22\u00b10ms \r\n"]
[1564.126, "o", "              100000   87.5\u00b10ms \r\n"]
[1564.538, "o", "             ======== ==========\r\n"]
[1565.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1565.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1565.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1570.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1570.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1570.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1570.418, "o", "\u001b[?2004l\r\n"]
[1570.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1571.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1571.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1572.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1572.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1572.89, "o", "              param1            \r\n"]
[1573.302, "o", "             -------- ----------\r\n"]
[1573.714, "o", "               1000    1.19\u00b10ms \r\n"]
[1574.126, "o", "              100000   76.3\u00b10ms \r\n"]
[1574.538, "o", "             ======== ==========\r\n"]
[1575.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1575.002, "i", "cd ..\r"]
[1575.004, "o", "cd ..\r\n"]
[1575.006, "o", "\u001b[?2004l\r\n"]
[1580.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1580.002, "i", "grep -n \"from pandas import MultiIndex\" pandas/core/indexes/interval.py || true\r"]
[1580.004, "o", "grep -n \"from pandas import MultiIndex\" pandas/core/indexes/interval.py || true\r\n"]
[1580.006, "o", "\u001b[?2004l\r\n"]
[1585.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1585.002, "i", "applypatch << 'PATCH'\r"]
[1585.004, "o", "applypatch << 'PATCH'\r\n"]
[1585.212, "o", "\u001b[?2004l\r\n"]
[1585.418, "o", "\u001b[?2004h> *** Begin Patch\r\n"]
[1585.624, "o", "\u001b[?2004l\r\n"]
[1585.83, "o", "\u001b[?2004h> *** Update File: pandas/core/indexes/interval.py\r\n"]
[1586.036, "o", "\u001b[?2004l\r\n"]
[1586.242, "o", "\u001b[?2004h> @@\r\n"]
[1586.448, "o", "\u001b[?2004l\r\n"]
[1586.654, "o", "\u001b[?2004h> -                from pandas import MultiIndex\r\n"]
[1586.86, "o", "\u001b[?2004l\r\n"]
[1587.066, "o", "\u001b[?2004h> -                mi1 = MultiIndex.from_arrays([left1, right1])\r\n"]
[1587.272, "o", "\u001b[?2004l\r\n"]
[1587.478, "o", "\u001b[?2004h> -                mi2 = MultiIndex.from_arrays([left2, right2])\r\n"]
[1587.684, "o", "\u001b[?2004l\r\n"]
[1587.89, "o", "\u001b[?2004h> +                # Use already-imported MultiIndex to avoid heavy top-level imports\r\n"]
[1588.096, "o", "\u001b[?2004l\r\n"]
[1588.302, "o", "\u001b[?2004h> +                mi1 = MultiIndex.from_arrays([left1, right1])\r\n"]
[1588.508, "o", "\u001b[?2004l\r\n"]
[1588.714, "o", "\u001b[?2004h> +                mi2 = MultiIndex.from_arrays([left2, right2])\r\n"]
[1588.92, "o", "\u001b[?2004l\r\n"]
[1589.126, "o", "\u001b[?2004h> *** End Patch\r\n"]
[1589.332, "o", "\u001b[?2004l\r\n"]
[1589.538, "o", "\u001b[?2004h> PATCH\r\n"]
[1589.744, "o", "\u001b[?2004l\r\n"]
[1590.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1590.002, "i", "python -m pyflakes pandas/core/indexes/interval.py 2>/dev/null || true\r"]
[1590.004, "o", "python -m pyflakes pandas/core/indexes/interval.py 2>/dev/null || true\r\n"]
[1590.006, "o", "\u001b[?2004l\r\n"]
[1595.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1595.002, "i", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r"]
[1595.004, "o", "pytest -q -k \"pandas/tests/indexes/interval/test_setops.py::TestIntervalIndex::test_intersection\" 2>/dev/null || tru\r\n"]
[1595.359143, "o", "ue\r\n"]
[1595.712286, "o", "\u001b[?2004l\r\n"]
[1596.065429, "o", "cd asv_bench\r\n"]
[1596.418571, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\"\r\n"]
[1596.771714, "o", "\r\n"]
[1597.124857, "o", "\u001b[33m======================================================================= warnings summary =======================================================================\u001b[0m\r\n"]
[1597.478, "o", "pandas/core/construction.py:335\r\n"]
[1597.831143, "o", "  /workspace/repo/pandas/core/construction.py:335: UserWarning: pyarrow requires pandas 1.0.0 or above, pandas 0+untagged.31506.g5f584bd is installed. Therefore, pandas-specific integration is not used.\r\n"]
[1598.184286, "o", "    return cls._from_sequence(data, dtype=dtype, copy=copy)\r\n"]
[1598.537429, "o", "\r\n"]
[1598.890571, "o", "-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\r\n"]
[1599.243714, "o", "------------------------------------------------------ generated xml file: /workspace/repo/test-data.xml -------------------------------------------------------\r\n"]
[1599.596857, "o", "\u001b[33m\u001b[33m\u001b[1m1 skipped\u001b[0m, \u001b[33m\u001b[1m214465 deselected\u001b[0m, \u001b[33m\u001b[1m1 warning\u001b[0m\u001b[33m in 102.10s (0:01:42)\u001b[0m\u001b[0m\r\n"]
[1600.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo# "]
[1600.002, "i", "cd asv_bench\r"]
[1600.004, "o", "cd asv_bench\r\n"]
[1600.006, "o", "\u001b[?2004l\r\n"]
[1605.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1605.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r"]
[1605.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\" \r\n"]
[1610.0, "o", "\u001bM(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1610.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r"]
[1610.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[K\"\r\n"]
[1610.418, "o", "\u001b[?2004l\r\n"]
[1610.83, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1611.242, "o", "\u00b7 \u001b[0;32mRunning 1 total benchmarks (1 commits * 1 environments * 1 benchmarks)\u001b[0m\r\n"]
[1611.654, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1612.066, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1612.478, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1612.89, "o", "              param1            \r\n"]
[1613.302, "o", "             -------- ----------\r\n"]
[1613.714, "o", "               1000    1.20\u00b10ms \r\n"]
[1614.126, "o", "              100000   80.3\u00b10ms \r\n"]
[1614.538, "o", "             ======== ==========\r\n"]
[1615.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1615.002, "i", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.*\"\r"]
[1615.004, "o", "asv run --python=same --quick --bench=\"index_object.IntervalIndexMethod.*\"\r\n"]
[1615.118364, "o", "\u001b[?2004l\r\n"]
[1615.230727, "o", "\u00b7 \u001b[0;32mDiscovering benchmarks\u001b[0m\r\n"]
[1615.343091, "o", "\u00b7 \u001b[0;32mRunning 5 total benchmarks (1 commits * 1 environments * 5 benchmarks)\u001b[0m\r\n"]
[1615.455455, "o", "[ 0.00%] \u00b7\u00b7 \u001b[0;34mBenchmarking existing-py_opt_conda_envs_asv_3.8_bin_python\u001b[0m\r\n"]
[1615.567818, "o", "[10.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection\u001b[0m                                                                                              ok\r\n"]
[1615.680182, "o", "[10.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1615.792545, "o", "              param1            \r\n"]
[1615.904909, "o", "             -------- ----------\r\n"]
[1616.017273, "o", "               1000    909\u00b10\u03bcs  \r\n"]
[1616.129636, "o", "              100000   7.73\u00b10ms \r\n"]
[1616.242, "o", "             ======== ==========\r\n"]
[1616.354364, "o", "\r\n"]
[1616.466727, "o", "[20.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_both_duplicate\u001b[0m                                                                               ok\r\n"]
[1616.579091, "o", "[20.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1616.691455, "o", "              param1            \r\n"]
[1616.803818, "o", "             -------- ----------\r\n"]
[1616.916182, "o", "               1000    1.15\u00b10ms \r\n"]
[1617.028545, "o", "              100000   82.2\u00b10ms \r\n"]
[1617.140909, "o", "             ======== ==========\r\n"]
[1617.253273, "o", "\r\n"]
[1617.365636, "o", "[30.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_intersection_one_duplicate\u001b[0m                                                                                ok\r\n"]
[1617.478, "o", "[30.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1617.590364, "o", "              param1            \r\n"]
[1617.702727, "o", "             -------- ----------\r\n"]
[1617.815091, "o", "               1000    786\u00b10\u03bcs  \r\n"]
[1617.927455, "o", "              100000   8.10\u00b10ms \r\n"]
[1618.039818, "o", "             ======== ==========\r\n"]
[1618.152182, "o", "\r\n"]
[1618.264545, "o", "[40.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_is_unique\u001b[0m                                                                                                 ok\r\n"]
[1618.376909, "o", "[40.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1618.489273, "o", "              param1            \r\n"]
[1618.601636, "o", "             -------- ----------\r\n"]
[1618.714, "o", "               1000    261\u00b10\u03bcs  \r\n"]
[1618.826364, "o", "              100000   4.08\u00b10ms \r\n"]
[1618.938727, "o", "             ======== ==========\r\n"]
[1619.051091, "o", "\r\n"]
[1619.163455, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39mindex_object.IntervalIndexMethod.time_monotonic_inc\u001b[0m                                                                                             ok\r\n"]
[1619.275818, "o", "[50.00%] \u00b7\u00b7\u00b7 \u001b[0;39m======== ==========\u001b[0m\r\n"]
[1619.388182, "o", "              param1            \r\n"]
[1619.500545, "o", "             -------- ----------\r\n"]
[1619.612909, "o", "               1000    63.9\u00b10\u03bcs \r\n"]
[1619.725273, "o", "              100000   364\u00b10\u03bcs  \r\n"]
[1619.837636, "o", "             ======== ==========\r\n"]
[1620.0, "o", "(asv_3.8) root@4dad128a768f:/workspace/repo/asv_bench# "]
[1620.002, "i", "\u001b[?2004l\r"]
[1620.004, "o", "\u001b[?2004l\r\n"]
[1622.478, "o", "\r\n"]
